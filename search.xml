<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ OOP</title>
    <url>/2022/09/29/C-OOP/</url>
    <content><![CDATA[<h1 id="C-OOP"><a href="#C-OOP" class="headerlink" title="C++ OOP"></a>C++ OOP</h1><h2 id="C-的类"><a href="#C-的类" class="headerlink" title="C++ 的类"></a>C++ 的类</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。</p>
<p>在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用</p>
<p><strong>this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。</strong></p>
<h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层<code>const</code>的的this指针。</p>
<p>由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。</p>
<p>为了解决这个问题，我们可以将成员函数声明成<code>const</code> </p>
<p>例如，像下面这样，在参数列表后添加上<code>const</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，这个this指针，既是顶层<code>const</code> (this指针所固有的属性)，又是底层<code>const</code> （我们声明的结果）</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>P241, P250，P545</p>
</blockquote>
<p>想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部</p>
<p>由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置</p>
<p>可以将一个类声明成另一个类的友元</p>
<blockquote>
<p> 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员</p>
</blockquote>
<p>可以将一个类的成员函数声明成另一个类的友元函数</p>
<p>友元声明是单向的，友元声明不具有传递性</p>
<p>关于友元的作用域：P252</p>
<p>友元关系是不能继承的</p>
<ul>
<li>基类的友元在访问派生类时没有特殊性。</li>
<li>派生类的友元也不能访问基类的私有成员</li>
</ul>
<h3 id="类的类型成员"><a href="#类的类型成员" class="headerlink" title="类的类型成员"></a>类的类型成员</h3><p>类的成员不只可以有变量和函数，还可以有类型</p>
<p>类内定义的类型也有访问权限的限制</p>
<p>用来定义类型的成员必须先定义再使用</p>
<blockquote>
<p>原因：// TODO</p>
</blockquote>
<h3 id="类的内联函数"><a href="#类的内联函数" class="headerlink" title="类的内联函数"></a>类的内联函数</h3><blockquote>
<p>内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销</p>
<p>内联函数会在编译时，被编译器展开</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>max(), min() 之类的函数特别适合被定义为内联函数</p>
</blockquote>
<ul>
<li>定义在类内部的成员函数，它们默认是内联函数</li>
<li>可以在类内声明时使用<code>inline</code>，同时在类外定义函数时也同时使用<code>inline</code> ，但最好是只在类外部定义函数时使用<code>inline</code> 声明。</li>
</ul>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><blockquote>
<p>from effective c++</p>
<p>编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为<code>mutable</code> </p>
</blockquote>
<p>如果在定义类的成员时，使用<code>mutable</code> 关键字，那么，即使这个对象被声明成<code>const</code> ，我们依然可以改变这个成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">     public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">inc</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">    private:</span><br><span class="line">    mutable <span class="type">size_t</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">A::inc</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回-this-左值"><a href="#返回-this-左值" class="headerlink" title="返回*this 左值"></a>返回*this 左值</h3><p>当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值</p>
<p>我们可以根据this指针是否具有底层<code>const</code> 来对函数进行重载</p>
<blockquote>
<p>底层const的重载见：P206</p>
<p>P247</p>
</blockquote>
<h3 id="类的前向声明"><a href="#类的前向声明" class="headerlink" title="类的前向声明"></a>类的前向声明</h3><p>可以使用类似这种形式声明类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。</p>
<p>前向声明可以放在类的头文件中，从而减少依赖。</p>
<h3 id="类的名字查找"><a href="#类的名字查找" class="headerlink" title="类的名字查找"></a>类的名字查找</h3><ul>
<li><p>我们可以在成员函数的任意地方使用类的成员</p>
<blockquote>
<p>原因在于编译器如何处理类：</p>
<ol>
<li>编译所有的成员声明</li>
<li>编译函数体</li>
</ol>
</blockquote>
</li>
<li><p>如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。</p>
</li>
<li><p>在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用<code>typedef</code> 或使用<code>using symbol = type</code>）不能再类中重定义。</p>
</li>
<li><p>成员函数的名字查找规则</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在成员函数内查找名字（成员函数体定义的名字，形参的名字）</span><br><span class="line"><span class="bullet">2.</span> 在类作用域内查找名字</span><br><span class="line"><span class="bullet">3.</span> 在成员函数定义之前的作用域内继续查找</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。</p>
</li>
</ul>
<h3 id="类的隐式类型转换"><a href="#类的隐式类型转换" class="headerlink" title="类的隐式类型转换"></a>类的隐式类型转换</h3><blockquote>
<p>P263 隐式的类类型转换 P514 重载类型转换运算符</p>
</blockquote>
<ul>
<li><p>如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换</p>
<p>这种类型转换只允许一步类型转换</p>
</li>
<li><p>一直类的隐式类型转换：</p>
<p>使用关键字<code>explicit</code> </p>
<p>该关键字只能在类内声明中使用，不能在类外重复</p>
<p>该关键字只能用于接受一个值的构造函数前面</p>
</li>
</ul>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0</p>
<p>类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的</p>
<p>由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似</p>
<ul>
<li>在<code>.h</code> 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理</li>
<li>我们可以使用类的静态成员作为成员函数的默认实参</li>
</ul>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><blockquote>
<p>类的初始化、对象拷贝、移动、销毁</p>
<p>由以下六个函数决定：</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
<p>后五个称为类的拷贝控制操作</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>C++ Primer P235、P257、P551、P689</p>
</blockquote>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下</p>
<ol>
<li>如果存在类内的初始值，用它来初始化成员</li>
<li>否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数）</li>
</ol>
<p>如果出现以下情况，编译器无法为类构造合成的默认构造函数</p>
<ol>
<li><p>类有定义一个构造函数</p>
<blockquote>
<p>遇到这种情况，可以使用 <code>类名() = defalut</code> 来给予类一个默认的构造函数</p>
</blockquote>
</li>
<li><p>类存在一个成员，这个成员没有默认的构造函数</p>
</li>
</ol>
<h4 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">BookNo</span>(s) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</p>
<p>（重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化</p>
<p>由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 没有默认构造函数</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> num) : elem(num) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> elem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    B(<span class="type">int</span> num) : elem_int(num) &#123;&#125;  <span class="comment">// 错误，因为A没有默认构造函数，所以必须对它进行列表初始化</span></span><br><span class="line">private:</span><br><span class="line">    A elem_A;</span><br><span class="line">    <span class="type">int</span> elem_int;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。</p>
<p>（重要）列表初始化的初始化顺序</p>
<p>列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非委托构造函数要使用的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price) : </span><br><span class="line">          <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt * price) &#123;&#125;</span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) : <span class="built_in">Sales_data</span>() &#123;<span class="built_in">read</span>(is, *<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体</p>
<h4 id="默认构造函数被调用的时机"><a href="#默认构造函数被调用的时机" class="headerlink" title="默认构造函数被调用的时机"></a>默认构造函数被调用的时机</h4><blockquote>
<p>C++ Primer P262</p>
</blockquote>
<p>默认初始化</p>
<ol>
<li>在块作用域内不适用任何初始值定义一个非静态变量</li>
<li>一个类类型本身含有类成员，并且使用合成的默认构造函数时</li>
<li>没有在列表初始化中被显示初始化时</li>
</ol>
<p>值初始化</p>
<ol>
<li>数组初始化时，提供的值小于数组的大小</li>
<li>不适用初始值定义一个局部静态变量</li>
<li>使用<code>T()</code> 这种表达式来显示请求值初始化</li>
</ol>
<h4 id="继承体系中的合成的默认构造函数"><a href="#继承体系中的合成的默认构造函数" class="headerlink" title="继承体系中的合成的默认构造函数"></a>继承体系中的合成的默认构造函数</h4><ul>
<li><p>派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。</p>
</li>
<li><p>继承直接基类的构造函数，使用<code>using</code> 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数</p>
</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。</p>
<blockquote>
<p>拷贝构造函数的形式通常是 <code>ClassType(const ClassType &amp;)</code> </p>
<p>拷贝构造函数通常不应该是explicit的</p>
</blockquote>
<h4 id="合成的拷贝构造函数"><a href="#合成的拷贝构造函数" class="headerlink" title="合成的拷贝构造函数"></a>合成的拷贝构造函数</h4><p>如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数</p>
<p>对于内置类型，合成的拷贝构造函数会直接拷贝</p>
<p>对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数</p>
<p>对于数组，合成的拷贝构造函数会逐个拷贝它的元素</p>
<blockquote>
<p> <strong>一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别：</strong></p>
<blockquote>
<p>几种初始化的区别：<a href="https://blog.csdn.net/qq_38231713/article/details/106291397">https://blog.csdn.net/qq_38231713/article/details/106291397</a></p>
</blockquote>
<p> 默认初始化：对象可能产生未定义的值，出现场景：</p>
<ol>
<li>块作用域内不使用任何初始值定义一个非静态变量；</li>
<li><p>类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员</p>
<ul>
<li>如果存在类内初始值，用它来初始化成员</li>
<li>否则，默认初始化该成员</li>
</ul>
<p>值初始化：对象的值是确定（预设）的，出现场景：</p>
</li>
<li><p>数组初始化时，初始值数量小于数组的长度。</p>
</li>
<li><p>不使用初始值定义一个静态变量（带有初始值0）</p>
</li>
<li><p>使用类似<code>classType()</code> 形式表达式显示请求值初始化</p>
</li>
<li><p>只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化</p>
<p><code>vector&lt;int&gt; vec(10);</code> 值初始化为0 </p>
<p>直接初始化：使用<code>classType()</code> 初始化对象</p>
<p>拷贝初始化：使用<code>classType foo = classType()</code> 初始化对象</p>
</li>
</ol>
<ul>
<li>不光在使用 = 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化<ol>
<li>将参数作为实参传递给非引用类型的形参</li>
<li>从返回类型为非引用的函数返回一个对象</li>
<li>使用花括号列表初始化数组或聚合类</li>
<li>初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数）</li>
</ol>
</li>
</ul>
<p> <strong>二、不同的初始化方式会调用那种构造函数</strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/sksukai/article/details/104741675/">https://blog.csdn.net/sksukai/article/details/104741675/</a></p>
</blockquote>
<p> 当定义类时，会有直接初始化和拷贝初始化两种区别</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">foo var1;      <span class="comment">// 直接初始化，使用默认构造函数</span></span><br><span class="line"><span class="function">foo <span class="title">var2</span><span class="params">(<span class="number">1</span>)</span></span>;    <span class="comment">// 直接初始化，使用一个参数的构造函数</span></span><br><span class="line">foo var3 = <span class="number">50</span>;    <span class="comment">// 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3</span></span><br><span class="line">foo var4 = <span class="built_in">foo</span>(<span class="number">50</span>); <span class="comment">// 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数</span></span><br><span class="line">foo var5 = var3;  <span class="comment">// 拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="继承体系中的拷贝构造函数"><a href="#继承体系中的拷贝构造函数" class="headerlink" title="继承体系中的拷贝构造函数"></a>继承体系中的拷贝构造函数</h4><p>我们需要使用基类的拷贝构造函数显示的初始化基类的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">derived</span>(<span class="type">const</span> derived &amp;d) : <span class="built_in">base</span>(d)    <span class="comment">// 显式的使用基类的拷贝构造函数+</span></span><br><span class="line">    &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>可能会误以为拷贝初始化<code>classType obj = ori;</code> 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数</p>
<p>当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符</p>
<p>此外我们还可以定义两种赋值运算符</p>
<ol>
<li>移动赋值运算符</li>
<li>其他类型到此类型的赋值运算符</li>
</ol>
<p>但这个运算符是最常用的运算符</p>
</blockquote>
<p>拷贝赋值运算符的形式通常是<code>classType operator=(const classType &amp;)</code> 因为他是一个成员函数，因此它的左侧成员自动绑定</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝</p>
<h4 id="继承体系中的拷贝赋值运算符"><a href="#继承体系中的拷贝赋值运算符" class="headerlink" title="继承体系中的拷贝赋值运算符"></a>继承体系中的拷贝赋值运算符</h4><p>派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classType &amp; classType::<span class="keyword">operator</span>=(<span class="type">const</span> classType &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);  <span class="comment">// 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    派生类成员的赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>释放对象使用的资源，销毁对象的非static成员</p>
<p>析构函数的形式是<code>~classType()</code> 没有返回值，不接受参数</p>
<p>不能被重载，对于任意一个类有且只有一个析构函数</p>
<blockquote>
<p>析构函数不能是删除的</p>
</blockquote>
<p>析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员</p>
<ul>
<li><p>继承体系中的析构函数</p>
<p>派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。</p>
<p>对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。</p>
</li>
</ul>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h3 id="类的拷贝控制成员被默认定义为删除的"><a href="#类的拷贝控制成员被默认定义为删除的" class="headerlink" title="类的拷贝控制成员被默认定义为删除的"></a>类的拷贝控制成员被默认定义为删除的</h3><blockquote>
<p>P450、P476、P553、P751</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><p>类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符，</p>
<blockquote>
<p>派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见</p>
</blockquote>
</li>
<li><p>动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定</p>
<blockquote>
<p>基类通过在成员函数前加上<code>virtual</code> 关键字使得函数执行运行时动态绑定。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数</p>
<p>关键字<code>virtual</code> 只能出现在类内声明语句中，而不能出现在定义语句中</p>
<p>没有用<code>virtual</code> 声明的函数，其解析发生在编译时，而非运行时</p>
</blockquote>
</li>
<li><p>访问控制：</p>
<p>如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为<code>protected</code> </p>
</li>
</ul>
<ul>
<li><p>派生类的构造函数</p>
<p>派生类必须使用基类的构造函数初始化其基类的部分</p>
</li>
<li><p>防止继承 定义类的时候使用<code>final</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123;<span class="comment">/* ... */</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><ul>
<li><p>纯虚函数</p>
<p>通过在函数声明的分号前添加 = 0 即可声明这个函数为纯虚函数</p>
<p>纯虚函数只是提供了一个接口，无需定义纯虚函数</p>
</li>
<li><p>含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象</p>
</li>
</ul>
<h3 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h3><ul>
<li>派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员</li>
<li>基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响<ol>
<li>若基类的访问说明符</li>
<li>派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高）</li>
</ol>
</li>
<li>对于派生类成员来说，它可以访问基类的<code>public</code> 和<code>private</code> 部分</li>
</ul>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以在派生类中使用<code>using</code> 声明改变它继承自基类的成员的可访问性</p>
<p>但<code>using</code>声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。</p>
<h3 id="struct-和-class的区别"><a href="#struct-和-class的区别" class="headerlink" title="struct 和 class的区别"></a>struct 和 class的区别</h3><ol>
<li>struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数</li>
<li>在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数</li>
<li>他们的可访问性：<ol>
<li>struct的默认成员都是public，class的默认成员都是private</li>
<li>struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承</li>
</ol>
</li>
</ol>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul>
<li><p>每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。</p>
<p>当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。</p>
</li>
</ul>
<ul>
<li><p>一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。</p>
<p>如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。</p>
<p>与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。</p>
<blockquote>
<p>编译器解析类的函数调用的过程：</p>
<p>例如<code>obj.func()</code></p>
<ol>
<li><p>确定obj的静态类型，去对应的类的作用域内查找该名称</p>
</li>
<li><p>如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。</p>
</li>
<li><p>如果找到了该名子，编译器进行类型检查，看这次调用是否合法。</p>
</li>
<li><p>如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。</p>
<p>否则直接进行函数调用。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li>声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。</li>
<li><p>因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。</p>
</li>
<li><p>成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。</p>
<p>如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用<code>using</code> 声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">char</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> base::func;</span><br><span class="line">    <span class="comment">// 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span>) <span class="keyword">override</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>BallMove:基于Qt的GUI小项目</title>
    <url>/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="BallMove-基于Qt的GUI小项目"><a href="#BallMove-基于Qt的GUI小项目" class="headerlink" title="BallMove:基于Qt的GUI小项目"></a>BallMove:基于Qt的GUI小项目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在暑假学科目二的时候，看着 <a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/">Qt学习之路2</a> 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。</p>
<p>今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。</p>
<p>这个项目基于<code>QGraphicsScene + QGraphicsItem + QGraphicsView</code>， 模拟了一个小球在现实世界中的运动。</p>
<p>项目地址：<a href="https://github.com/cfla1638/BallMove">cfla1638/BallMove</a> </p>
<h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p><strong>功能</strong>：实现了实心球的运动。</p>
<p>考虑的因素有：</p>
<ol>
<li>用户给予的加速度</li>
<li>重力</li>
<li>摩擦力</li>
<li>空气阻力</li>
</ol>
<p><strong>细节：</strong></p>
<p>该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg / m^3^ 。</p>
<p>重力加速度为 9.8 m/s^2^ 。</p>
<p>静摩擦系数为 0.3。</p>
<p>空气阻力使用公式：F = 1/2 <em> CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 </em> 0.04^2^ 。</p>
<p>尺寸换算：1m = 250px。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>Qt的绘制系统由<code>QGraphicsScene + QGraphicsItem + QGraphicsView</code> 相互配合使用。</p>
<p><code>QGraphicsScene</code> 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。</p>
<p><code>QGraphicsItem</code> 是在<code>QGraphicsScene</code> 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到<code>QGraphicsScene</code>，进行显示和管理。</p>
<p><code>QGraphicsView</code> 提供了一个观察的视角，配合<code>QGraphicsScene</code> 进行显示。这个类可以被设为<code>QMainWindow</code> 的<code>CentralWidget</code>。</p>
</li>
<li><p>只有<code>QObject</code> 的子类可以使用信号槽的机制</p>
</li>
<li><p><code>QTimer</code>类提供计时器功能，使用<code>timer.start(sec)</code> 功能开始计时，这里timer是一个<code>QTimer</code>类的一个对象，每经过sec时间后，timer就会发出一个<code>timeout()</code> 信号。</p>
</li>
<li><p>想要实现物体的运动，就要让物体的位置在每一帧里进行改变/刷新（本程序的帧率是120），而<code>QGraphicsScene</code> 提供一个<code>advance()</code> 函数，该函数会调用所有在场景里的<code>QGraphicsItem</code> 对象的<code>advance()</code> 函数，因此我们只要每经过 1000 / 120 毫秒 就调用一次<code>QGraphicsScene::advance()</code> 函数，就可以进行场景刷新，从而实现物体的运动。</p>
</li>
<li><p>每个<code>QGraphicsItem::advance(int phase)</code> 都会被一个<code>QGraphicsScene::advance()</code> 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase = 0。第二次<code>QGraphicsScene::advance()</code> 将phase  = 1 传入函数并调用。</p>
<p>基于此，我们只需要在phase = 1是进行处理，phase = 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。</p>
</li>
<li><p>Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在<code>QGraphicsScene</code> 中的全局坐标系，它记录了每个<code>QGraphicsItem</code> 的位置。第二个是每个<code>QGraphicsItem</code> 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。</p>
</li>
<li><p>每个继承了<code>QGraphicsItem</code> 的类都要重载以下四个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(<span class="type">int</span> phase)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>boundingRect()</code> 返回一个包裹住<code>QGraphicsItem</code>  对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。</p>
<p><code>shape()</code> 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。</p>
<p><code>void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr)</code> </p>
<p>该函数一般由<code>QGraphicsScene</code> 自动调用，绘制该项目。</p>
<p>这个函数一般这样写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();    <span class="comment">// 保存画笔状态</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置新的画笔状态</span></span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);     <span class="comment">// 设置反走线（抗锯齿）</span></span><br><span class="line">    painter-&gt;<span class="built_in">fillPath</span>(<span class="built_in">shape</span>(), Qt::blue);  <span class="comment">// 绘制图型</span></span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();    <span class="comment">// 还原画笔状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。</p>
<p><code>painter-&gt;fillPath(shape(), Qt::blue);</code> 这一行绘制我们在<code>shape()</code> 中返回的图型，在此之前我们可以设置画笔的状态。</p>
</li>
<li><p>编写头文件的建议</p>
<p>如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。</p>
<p>为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。</p>
<p>即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。</p>
</li>
</ol>
<h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><p>首先来看一下运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208220742986.png" alt="image-20220822074244433"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象</span><br><span class="line">另外，这棵树也为我们展示了本项目的设计思路。</span><br><span class="line">└─MainWindow</span><br><span class="line">    ├─Controller</span><br><span class="line">    │  ├─Ball</span><br><span class="line">    │  ├─Balldata</span><br><span class="line">    │  ├─Ground</span><br><span class="line">    │  └─QGraphicsScene - Reference</span><br><span class="line">    ├─QGraphicsScene</span><br><span class="line">    └─QGraphicsView</span><br></pre></td></tr></table></figure>
<p>自下而上，首先来看Controller下的三个类，</p>
<p>Controller下有三个类，分别是Ball, Balldata, Ground，他们都是<code>QGraphicsItem</code> 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。</p>
<p>这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。</p>
<p>值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。</p>
<p>接着是Controller类。</p>
<p>顾名思义，Controller类是我们程序的控制器。</p>
<p>Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。</p>
<p>最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。</p>
<p>当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的<code>QMainWindow::show()</code> 和 <code>QApplication :: exec()</code> 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。</p>
<h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>首先看一下我们的文件结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BallMove</span><br><span class="line">     - BallMove.pro</span><br><span class="line">    Headers</span><br><span class="line">     - ball.h</span><br><span class="line">     - balldata.h</span><br><span class="line">     - constants.h</span><br><span class="line">     - controller.h</span><br><span class="line">     - ground.h</span><br><span class="line">     - mainwindow.h</span><br><span class="line">    Sources</span><br><span class="line">     - ball.cpp</span><br><span class="line">     - balldata.cpp</span><br><span class="line">     - controller.cpp</span><br><span class="line">     - ground.cpp</span><br><span class="line">     - main.cpp</span><br><span class="line">     - mainwindow.cpp</span><br></pre></td></tr></table></figure>
<h3 id="Ball类的实现"><a href="#Ball类的实现" class="headerlink" title="Ball类的实现"></a>Ball类的实现</h3><p>首先看一下ball类的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> : <span class="keyword">public</span> QGraphicsItem</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ball</span>(qreal x, qreal y);</span><br><span class="line"></span><br><span class="line">    <span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(<span class="type">int</span> phase)</span></span>;</span><br><span class="line">    <span class="function">QPointF <span class="title">getPos</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">pos</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> forceCount = <span class="number">4</span>;</span><br><span class="line">    qreal a[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">    qreal vx = <span class="number">0</span>;</span><br><span class="line">    qreal vy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先我们来看Ball类的私有变量：</p>
<p>由于我们运动的平面是二维的，因此我们使用一个二维数组<code>qreal a[2][4]</code> 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即<code>a[xAxis][AirResistance]</code> 。如果想要引用y方向的重力加速度，就使用<code>a[yAxis][Gravity]</code> 。</p>
<p><code>qreal vx, vy</code> 即小球的x方向速度，和y方向的速度。</p>
<p><code>int forceCount</code> 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。</p>
<p>接着我们来看一下Ball类中声明的函数:</p>
<p>第一个函数<code>getPos()</code>很好理解，即返回小球在全局坐标系中的坐标。</p>
<p>接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：<code>paint() shape() advance()</code></p>
<p><code>boundingRect()</code> </p>
<p><code>boundingRect</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRectF <span class="title">Ball::boundingRect</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QRectF</span>(-BALL_SIZE * <span class="number">2</span>, -BALL_SIZE * <span class="number">2</span>, BALL_SIZE * <span class="number">4</span>, BALL_SIZE * <span class="number">4</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。</p>
<p><code>BALL_SIZE</code> 定义在constants.h 代表小球的直径。</p>
<p><code>shape()</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPainterPath <span class="title">Ball::shape</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.<span class="built_in">addEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), BALL_SIZE / <span class="number">2</span>, BALL_SIZE / <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。</p>
<p><code>paint()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);     <span class="comment">// 设置反走线（抗锯齿）</span></span><br><span class="line">    painter-&gt;<span class="built_in">fillPath</span>(<span class="built_in">shape</span>(), Qt::blue);</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。</p>
<p><code>advance()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::advance</span><span class="params">(<span class="type">int</span> phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有phase为1时进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!phase) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算合力</span></span><br><span class="line">    qreal sumAx = <span class="number">0</span>, sumAy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; forceCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumAx += a[xAxis][i];</span><br><span class="line">        sumAy += a[yAxis][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sumAx) vx += (sumAx / FRAME_RATE);</span><br><span class="line">    <span class="keyword">if</span> (sumAy) vy += (sumAy / FRAME_RATE);</span><br><span class="line"></span><br><span class="line">    qreal x = <span class="built_in">fmod</span>(<span class="built_in">pos</span>().<span class="built_in">rx</span>() + vx / FRAME_RATE, <span class="number">1000</span>), y = <span class="built_in">fmod</span>(<span class="built_in">pos</span>().<span class="built_in">ry</span>() + vy / FRAME_RATE, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理小球越界</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; BALL_SIZE / <span class="number">2</span>) y = BALL_SIZE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新位置</span></span><br><span class="line">    <span class="built_in">setPos</span>(<span class="built_in">QPointF</span>(x, y));</span><br><span class="line">    <span class="built_in">update</span>();       <span class="comment">// 更新显示小球</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。</p>
<p>在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。</p>
<p>需要注意，一、因为我们的速度、加速度定义为m/s和m/s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。</p>
<p>二、在设置了小球的位置之后，需要使用<code>update()</code> 函数更新小球的位置。</p>
<h3 id="constants-h-参数存储文件"><a href="#constants-h-参数存储文件" class="headerlink" title="constants.h 参数存储文件"></a>constants.h 参数存储文件</h3><p>constants.h 文件中存放了项目的各种参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME_RATE = <span class="number">120</span>;         <span class="comment">// 帧率：120帧  帧率过低时碰撞会穿透地面</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BALL_SIZE = <span class="number">20</span>;           <span class="comment">// 球的直径：20px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 400 对应 112 重力</span></span><br><span class="line"><span class="comment">// 3000 对应 2450 重力</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> X_SPEED = <span class="number">1500</span>;           <span class="comment">// 左右键给球的加速度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Y_SPEED = <span class="number">3000</span>;           <span class="comment">// 上下键给球的加速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRICTION = <span class="number">735</span>;           <span class="comment">// 摩擦力大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRICTION_SENSITIVITY = <span class="number">2</span>;         <span class="comment">// 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 112 对应1.75 米的人</span></span><br><span class="line"><span class="comment">// 2450 对应 8cm 的实心球</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GRAVITY = <span class="number">2450</span>;           <span class="comment">// 重力大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> M = <span class="number">2.1038</span>;            <span class="comment">// 小球质量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Directions</span>&#123;xAxis, yAxis&#125;;      <span class="comment">// x, y轴方向</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Force</span>&#123;User, Gravity, Friction, AirResistance&#125;;         <span class="comment">// 力的四个维度，用户给出的力，重力，摩擦力，空气阻力</span></span><br></pre></td></tr></table></figure>
<p>需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。</p>
<h3 id="Balldata-amp-ground"><a href="#Balldata-amp-ground" class="headerlink" title="Balldata &amp; ground"></a>Balldata &amp; ground</h3><p>这两个类都继承了<code>QGraphicsItem</code> 和Ball类类似，因此我们不在赘述。</p>
<h3 id="Controller类"><a href="#Controller类" class="headerlink" title="Controller类"></a>Controller类</h3><p>首先看一下Controller类的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span> : QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Controller</span>(QGraphicsScene &amp; scene, QObject * parent = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gravity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawLineOfTrack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *atched, QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleKeyPressed</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleKeyReleased</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line"></span><br><span class="line">    QTimer timer;</span><br><span class="line">    Ball * ball;</span><br><span class="line">    QGraphicsScene &amp; scene;</span><br><span class="line">    Ground * ground;</span><br><span class="line">    ballData * data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Controller类有以下几点功能：</p>
<ul>
<li><p>处理键盘事件：如上下左右移动，打开/关闭 轨迹显示，清屏。</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *atched, QEvent *event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleKeyPressed</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleKeyReleased</span><span class="params">(QKeyEvent * event)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制程序的开始与结束</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制程序的一步步地推进，即让小球动起来。</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他功能</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gravity</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLineOfTrack</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里我们只介绍<code>advance()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Controller::advance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scene.<span class="built_in">advance</span>();                        <span class="comment">// 首先调用场景的advance()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取碰撞信息</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> lastStatus = <span class="literal">false</span>;         <span class="comment">// 上一帧是否碰撞</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> nowStatus = <span class="literal">false</span>;          <span class="comment">// 当前是否处于碰撞</span></span><br><span class="line">    nowStatus = ball-&gt;<span class="built_in">collidesWithItem</span>(ground);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (nowStatus == <span class="literal">true</span> &amp;&amp; lastStatus == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ball-&gt;a[yAxis][Gravity] = <span class="number">0</span>;        <span class="comment">// 碰撞时重力与支持力抵消</span></span><br><span class="line">        ball-&gt;vy = -(ball-&gt;vy * <span class="number">0.667</span>);     <span class="comment">// 回弹 2/3 的速度</span></span><br><span class="line">        ball-&gt;a[yAxis][User] = <span class="number">0</span>;           <span class="comment">// 竖直方向速度为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理摩擦力</span></span><br><span class="line">    <span class="keyword">if</span> (nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[xAxis][Friction] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有碰撞的时候</span></span><br><span class="line">    <span class="keyword">if</span> (!nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 摩擦力置零</span></span><br><span class="line">        ball-&gt;a[xAxis][Friction] = <span class="number">0</span>;</span><br><span class="line">        ball-&gt;a[yAxis][Gravity] = GRAVITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理空气阻力</span></span><br><span class="line">    qreal sumV = <span class="built_in">pow</span>(ball-&gt;vx, <span class="number">2</span>) + <span class="built_in">pow</span>(ball-&gt;vy, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(sumV) &gt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qreal airSum = <span class="number">0.0009744</span> * sumV / <span class="number">250</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumV == <span class="number">0</span>) sumV = <span class="number">1</span>;</span><br><span class="line">        ball-&gt;a[xAxis][AirResistance] = (<span class="built_in">fabs</span>(ball-&gt;vx) / (<span class="built_in">sqrt</span>(sumV))) * airSum;</span><br><span class="line">        ball-&gt;a[yAxis][AirResistance] = (<span class="built_in">fabs</span>(ball-&gt;vy) / (<span class="built_in">sqrt</span>(sumV))) * airSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将力换算成加速度</span></span><br><span class="line">        ball-&gt;a[xAxis][AirResistance] /= M;</span><br><span class="line">        ball-&gt;a[yAxis][AirResistance] /= M;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vx &gt; <span class="number">5</span>) ball-&gt;a[xAxis][AirResistance] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball -&gt; vx &lt; <span class="number">10</span>) ;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[xAxis][AirResistance] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vy &gt; <span class="number">5</span>) ball-&gt;a[yAxis][AirResistance] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball -&gt; vy &lt; <span class="number">10</span>) ;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[yAxis][AirResistance] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lastStatus = nowStatus;</span><br><span class="line">    data-&gt;<span class="built_in">update</span>();                         <span class="comment">// 更新数据显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。</p>
<p>等运动结束之后，我们使用Qt地碰撞检测函数<code>collidesWithItem()</code>看小球是否接触地面。</p>
<p>接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。</p>
<p>其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。</p>
<h3 id="MainWindow-类"><a href="#MainWindow-类" class="headerlink" title="MainWindow 类"></a>MainWindow 类</h3><p>MainWindow类的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjustViewSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initScene</span><span class="params">()</span></span>;</span><br><span class="line">    QGraphicsView * view;</span><br><span class="line">    QGraphicsScene * scene;</span><br><span class="line">    Controller * controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">      <span class="built_in">scene</span>(<span class="keyword">new</span> <span class="built_in">QGraphicsScene</span>(<span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">view</span>(<span class="keyword">new</span> <span class="built_in">QGraphicsView</span>(scene, <span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">controller</span>(<span class="keyword">new</span> <span class="built_in">Controller</span>(*scene, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(view);</span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">750</span>, <span class="number">750</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initScene</span>();</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">0</span>, <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">adjustViewSize</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的<code>centralWidget</code> 并调整了窗口大小。</p>
<p>在倒数第二步，调用<code>initScene</code> 对scene进行调整。</p>
<p>以上的这些步骤都不会有什么问题，只有最后一步令人困惑：</p>
<p><code>QTimer::singleShot(0, this, SLOT(adjustViewSize()));</code> </p>
<p>首先解释<code>singleShot()</code> 函数，这个函数的声明如下</p>
<p><code>void QTimer::singleShot(int msec, const QObject *receiver, const char *member)</code> </p>
<p>它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。</p>
<p>那么为什么要使用这个功能呢？</p>
<p>这里有两个解释</p>
<blockquote>
<p>那么，<code>QTimer::signleShot(0, ...)</code>意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在<code>paintEvent()</code>事件中），因此我们需要在下一次事件循环中调用<code>adjustViewSize()</code>函数。这就是为什么我们需要用<code>QTimer</code>而不是直接调用<code>adjustViewSize()</code>。如果熟悉 flash，这相当于 flash 里面的<code>callLater()</code>函数。</p>
</blockquote>
<p>这个解释来自<a href="https://www.devbean.net/2012/12/qt-study-road-2-snake-1/">《Qt学习之路2》</a> 但我并不清楚这里的 “下一次事件循环” 的意思。</p>
<p>依我的理解，应该是这个意思：某个<code>QObject</code> 发出 <code>paintEvent()</code> 事件，但对这个事件的处理比较耗时，如果此时直接调用<code>adjustViewSize()</code> ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用<code>adjustViewSize()</code> ，我们会发现视图小小的挤在屏幕的中间。</p>
<p>后来我又在网上发现了这篇博客：<a href="https://blog.csdn.net/cutemypig/article/details/122131997">QTimer::singleShot(0, this, slot函数)；</a>  ，意思和我理解的大概相似。 </p>
<p>但还是挖个坑，等我以后学精了一定回来解释清楚。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/K346K346/article/details/50568472">C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范</a> </p>
<p><a href="https://www.devbean.net/2012/12/qt-study-road-2-snake-1/">Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World</a> </p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP 读后感</title>
    <url>/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h1 id="CS-APP-读后感"><a href="#CS-APP-读后感" class="headerlink" title="CS:APP 读后感"></a>CS:APP 读后感</h1><p>这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的）</p>
<p>接下来会陆续更新各章的详细笔记 … </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目录：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第1章    计算机系统漫游</span><br><span class="line">--- 程序结构和执行</span><br><span class="line">第2章    信息的表示和处理</span><br><span class="line">第3章    程序的机械级表示</span><br><span class="line">第4章    处理器体系结构</span><br><span class="line">第5章    优化程序性能</span><br><span class="line">第6章    存储器的层次结构</span><br><span class="line">--- 在系统上运行程序</span><br><span class="line">第7章    链接</span><br><span class="line">第8章    异常控制流</span><br><span class="line">第9章    虚拟内存</span><br><span class="line">--- 程序间的交互和通信</span><br><span class="line">第10章  系统及I/O</span><br><span class="line">第11章  网络编程</span><br><span class="line">第12章  并发编程</span><br></pre></td></tr></table></figure>
<p>本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。</p>
<p>剩下的十一章是本书的正式部分，我认为本书的核心在第 7~9 章，2~6章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。</p>
<h2 id="分章介绍"><a href="#分章介绍" class="headerlink" title="分章介绍"></a>分章介绍</h2><h3 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h3><blockquote>
<p>这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。</p>
</blockquote>
<p><strong>2.1.3 寻址和字节顺序</strong>： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。</p>
<p><strong>2.16 布尔代数介绍</strong> ： 可以使用位向量来表示有限集合。</p>
<p><strong>2.2 整数表示</strong> ： 介绍了整数原码和补码的表示，以及他们之间的转换。</p>
<p><strong>2.3 整数运算</strong> ： 介绍了整数运算可能出现的错误，以及来源。</p>
<p><strong>2.4</strong> ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。</p>
<h3 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h3><blockquote>
<p>相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。</p>
<p>这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。</p>
<p>从这一张开始到最后，才是一口气看完的。</p>
</blockquote>
<p>3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了<code>objdump</code> 的使用</p>
<p>3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。</p>
<p>3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。</p>
<p>3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法</p>
<h3 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h3><blockquote>
<p>这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。</p>
</blockquote>
<h3 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h3><blockquote>
<p>呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。</p>
</blockquote>
<p>客观一点就是 普通人日常写代码小技巧</p>
<h3 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h3><blockquote>
<p>没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。</p>
</blockquote>
<h3 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h3><blockquote>
<p>含金量高的来了</p>
<p>这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld</p>
<p>7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位</p>
<p>7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表</p>
<p>7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接</p>
<p>7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方</p>
<p>动态链接：与加载的时候链接的类型</p>
<p>库打桩机制</p>
<h3 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h3><blockquote>
<p>最重要的一章之一，介绍了并发编程的基础——异常控制流</p>
<p>介绍了进程，简单带领读者入门了并发编程</p>
<p>讲了信号，有助于以后学习事件驱动的GUI编程</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>8.2 异常</p>
<p>8.3 进程</p>
<p>8.4 用C语言操作进程：fork execve</p>
<p>8.5 信号  SIGINT … </p>
<h3 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h3><blockquote>
<p>最重要的一章之一</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>本章可以分为三部分</p>
<p>第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的</p>
<p>第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve</p>
<p>第三部分介绍了一个内存分配器的实现( malloc() )</p>
<h3 id="第十章-系统级-I-O"><a href="#第十章-系统级-I-O" class="headerlink" title="第十章 系统级 I/O"></a>第十章 系统级 I/O</h3><blockquote>
<p>这一章读起来很简单，没有什么要理解的东西</p>
</blockquote>
<p>首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。</p>
<p>然后着介绍了RIO包，即包装后的IO函数。</p>
<p>本章完</p>
<h3 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h3><blockquote>
<p>这一章需要理解的地方不多，只有介绍网络编程的部分</p>
<p>第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。</p>
</blockquote>
<p>首先介绍了网络编程</p>
<p>接着介绍了Linux的套接字函数</p>
<p>最后实现了一个小web服务器</p>
<p>11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议</p>
<h3 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h3><blockquote>
<p>和上一章差不多的感觉</p>
</blockquote>
<p>本章也分为三部分</p>
<p>首先介绍了实现并发编程的三种方法</p>
<ol>
<li>进程</li>
<li>IO多路复用</li>
<li>线程</li>
</ol>
<p>之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。</p>
<p>最后介绍了并发编程容易出现的问题：死锁、访问共享变量 … </p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 用法</title>
    <url>/2023/03/09/Visual-Studio%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="引入第三方库-（以OpenCV为例）"><a href="#引入第三方库-（以OpenCV为例）" class="headerlink" title="引入第三方库 （以OpenCV为例）"></a>引入第三方库 （以OpenCV为例）</h3><p>在右侧导航栏项目名称上右键，点击属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931479.png" alt="image-20230309191119122"> </p>
<p>在VC++页面中，找到包含目录和库目录，将要引用的第三方库的<code>include</code>目录和二进制库文件分别添加到里面去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931480.png" alt="image-20230309191325578"> </p>
<p>具体地，以OpenCV 4.7为例，需要包含的目录有:</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931481.png" alt="image-20230309192108457"> </p>
<p>最后在【链接器 → 输入】里面，指定具体需要用到的库</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931482.png" alt="image-20230309191425790"> </p>
<h3 id="汇编语言环境-（MASM）"><a href="#汇编语言环境-（MASM）" class="headerlink" title="汇编语言环境 （MASM）"></a>汇编语言环境 （MASM）</h3><ul>
<li><p>配置汇编项目</p>
<blockquote>
<p>1.创建一个 <strong>Visual C++</strong> <strong>空工程</strong> (Empty Project), 此时先不要添加汇编源文件。</p>
<p>2.在 “解决方案浏览器” 视图中, 在项目名称上右击 —-&gt; 选择 “<strong>生成自定义</strong>“ —-&gt; 在弹出的 “Visual C++ 生成自定义项文件” 窗口中, 勾选 <code>masm(.targets, .props)</code> 项。</p>
<p>​    <img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20230319212518753.png" alt="image-20230319212518753"> </p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20230319212601616.png" alt="image-20230319212601616"> </p>
<p>3.在 “解决方案浏览器” 视图中, 在项目名称上右击 —-&gt; 选择 “属性” —-&gt; 在左侧 “配置属性” 导航中 —-&gt; 选择 “链接器” —-&gt; “系统” —-&gt; 在 “<strong>子系统</strong>“ 右侧下拉菜单中选择 “控制台(/SUBSYSTEM:CONSOLE)” (注：VS2022已自动配置)</p>
<p>4.添加汇编源代码 file.asm (添加 C++ 文件, 然后将后缀修改为 <code>.asm</code>), (这一步要放在最后, 否则可能会报错) 。</p>
<p>5.如果是64位则要在项目属性→链接器→高级→程序入口点 里填上程序入口点，一般是main</p>
</blockquote>
</li>
<li><p>引入依赖库</p>
<blockquote>
<p>1.链接器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “链接器” —-&gt; “常规” —-&gt; “附加库目录” —-&gt; “c:\Irvine”.</p>
<p>2.链接器中添加 “附加依赖项”. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “链接器” —-&gt; “输入” —-&gt; “附加依赖项” —-&gt; 主要包含库: user32.lib, Irvine32.lib, kernel32.Lib .</p>
<p>3.汇编器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “Microsoft Macro Assembler” —-&gt; “General” —-&gt; “Include Paths” —-&gt; 添加库目录, 如 “c:\Irvine” (注意：此选项在添加 <code>.asm</code> 源文件后才出现).</p>
</blockquote>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>注意到，参考文献 2 中 还提到了一些其他的引入第三方库的方法。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Visual Studio 下配置第三方C/C++库的方法 : <a href="https://blog.csdn.net/yangfchn/article/details/85162934">https://blog.csdn.net/yangfchn/article/details/85162934</a></p>
<p>[2] VS配置OpenCV教程（超详细） : <a href="https://blog.csdn.net/mars_xiaolei/article/details/78759041">https://blog.csdn.net/mars_xiaolei/article/details/78759041</a></p>
<p>[3] Getting Started with MASM and Visual Studio 2022 : <a href="http://www.asmirvine.com/gettingStartedVS2022/index.htm">http://www.asmirvine.com/gettingStartedVS2022/index.htm</a></p>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake学习之路</title>
    <url>/2022/10/22/cmake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="cmake-学习之路"><a href="#cmake-学习之路" class="headerlink" title="cmake 学习之路"></a>cmake 学习之路</h1><blockquote>
<p>参考链接</p>
<p><a href="https://www.zhihu.com/question/58949190/answer/999701073">CMake 如何入门？ - 知乎 (zhihu.com)</a> </p>
<p><a href="https://github.com/ttroy50/cmake-examples">ttroy50/cmake-examples: Useful CMake Examples (github.com)</a> </p>
<p><a href="https://blog.csdn.net/Kprogram/article/details/126010833">超详细的cmake入门教程【转载】_Korpse的博客-CSDN博客_cmake 教程</a> </p>
</blockquote>
<h2 id="01-basic"><a href="#01-basic" class="headerlink" title="01-basic"></a>01-basic</h2><h3 id="A-hello-cmake"><a href="#A-hello-cmake" class="headerlink" title="A-hello cmake"></a>A-hello cmake</h3><p>概念：</p>
<blockquote>
<p><code>CMakeLists.txt</code> : 存储cmake命令，当在一个文件夹中运行cmake时，cmake会寻找这个文件，如果找不到会报错。</p>
</blockquote>
<p>三个命令：</p>
<blockquote>
<p><code>cmake_minimum_required(VERSION 3.5)</code> 最小的cmake版本</p>
<p><code>project()</code> 指定项目的名称，cmake可以通过include一个项目名称来引用另一个项目，这对多项目是很方便的。另外这个命令也会创建一个名为 <code>$&#123;PROJECT_NAME&#125;</code> 的变量，它的内容就是我们指定的项目名称。</p>
<p><code>add_executable(hello_cmake hello_cmake.cpp)</code> 第一个参数是我们生成可执行文件的名称，第二个参数以后则是为了生成这个可执行文件需要的源文件列表</p>
</blockquote>
<p>两种构建方式</p>
<ol>
<li><p>In-Place Build</p>
<p>将生成的二进制文件和源文件放在一起，这样构建会比较混乱</p>
<p>在Linux上的方法是 </p>
<p><code>cmake .</code> 参数代表CMakeLists.txt 所在的位置</p>
<p><code>make</code></p>
<blockquote>
<p>注意，在window上，默认的生成器是nmake</p>
<p>要使用mingw的make应当这样：</p>
<p><code>cmake -G &quot;MinGW Makefiles&quot; .</code> 注意字符串大小写严格</p>
<p><code>cmake .</code></p>
<p><code>make</code></p>
</blockquote>
</li>
<li><p>Out-of-Source Build</p>
<p>将生成的二进制文件单独放在一个文件夹中，这样比较整洁</p>
<p>具体的方法是（Linux） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>在 window上的方法是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="B-hello-headers"><a href="#B-hello-headers" class="headerlink" title="B hello headers"></a>B hello headers</h3><p>将头文件和源文件分离编译</p>
<p>我们有一个include目录和一个src目录</p>
<p>CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="comment"># To find the cmake version run</span></span><br><span class="line"><span class="comment"># $ cmake --version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the project name</span></span><br><span class="line"><span class="keyword">project</span> (hello_headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a sources variable with a link to all cpp files to compile</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable with the above sources</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_headers <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the directories that should be included in the build command for this target</span></span><br><span class="line"><span class="comment"># when running g++ these will be included as -I/directory/path/</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_headers</span><br><span class="line">    PRIVATE </span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 有两个需要注意的点：</p>
<ol>
<li><p>首先我们使用了set函数，将源文件甚至为了其内容，<code>add_executable()</code> 函数的第二个参数也使用该变量。</p>
</li>
<li><p>使用了<code>target_include_directories</code> 函数，这个函数的文档<a href="[target_include_directories — CMake 3.0.2 Documentation](https://cmake.org/cmake/help/v3.0/command/target_include_directories.html">在这里</a>) ，需要注意的是，这个函数必须在我们已经添加了源文件或库之后才能使用。否则会构建失败。</p>
<p>详见文档</p>
<blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>
<p>Specify include directories or targets to use when compiling a given target. The named <code>&lt;target&gt;</code> must have been created by a command such as <a href="https://cmake.org/cmake/help/v3.0/command/add_executable.html#command:add_executable"><code>add_executable()</code></a> or <a href="https://cmake.org/cmake/help/v3.0/command/add_library.html#command:add_library"><code>add_library()</code></a> and must not be an <a href="https://cmake.org/cmake/help/v3.0/prop_tgt/IMPORTED.html#prop_tgt:IMPORTED"><code>IMPORTED</code></a> target.</p>
</blockquote>
</li>
</ol>
<p>附：cmake 预先定义的一些变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Variable</th>
<th style="text-align:left">Info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMAKE_SOURCE_DIR</td>
<td style="text-align:left">The root source directory</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_SOURCE_DIR</td>
<td style="text-align:left">The current source directory if using sub-projects and directories.</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_SOURCE_DIR</td>
<td style="text-align:left">The source directory of the current cmake project.</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_BINARY_DIR</td>
<td style="text-align:left">The root binary / build directory. This is the directory where you ran the cmake command.</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_BINARY_DIR</td>
<td style="text-align:left">The build directory you are currently in.</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_BINARY_DIR</td>
<td style="text-align:left">The build directory for the current project.</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 constexpr 的详解和区别</title>
    <url>/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="const和constexpr"><a href="#const和constexpr" class="headerlink" title="const和constexpr"></a><code>const</code>和<code>constexpr</code></h1><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p>常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式</p>
<p>常量表达式是由</p>
<ul>
<li>数据类型</li>
<li>数据初始值</li>
</ul>
<p>决定的。</p>
<p><code>int a = 1</code> a 不是一个常量表达式，因为它的数据类型不是常量</p>
<p><code>const int b = get_val()</code> b不是一个常量表达式，因为它的初始值不是常量</p>
<p>由于使用<code>const</code> 不能确定一个表达式是不是常量，因此C++11使用<code>constexpr</code> 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。</p>
<p>下面这个程序是不正确的，因为a虽然被<code>const</code> 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> i = a;</span><br><span class="line">    <span class="type">int</span> arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而只要将<code>a = b</code> 改为 <code>a = 1</code> 程序就不会报错了，因为此时a的确是一个常量表达式</p>
<h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h3><p>普通的函数不是常量表达式，但我们可以定义<code>constexpr</code> 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定</p>
<h3 id="constexpr-指针-amp-引用"><a href="#constexpr-指针-amp-引用" class="headerlink" title="constexpr 指针 &amp; 引用"></a><code>constexpr</code> 指针 &amp; 引用</h3><p><code>constexpr</code> 指向的位置必须是全局变量，静态变量，或者字面值等放在<code>.bss</code> 节<code>.data</code> 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><p><code>const</code>用来修饰变量，根据<code>const</code> 出现的位置，可以分为两种<code>const</code> ：顶层<code>const</code> 和底层<code>const</code> </p>
<p>顶层<code>const</code> 可以表示任意的对象是常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;    <span class="comment">// a不能改变，是顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;    <span class="comment">// p不能改变指向，是顶层const</span></span><br></pre></td></tr></table></figure>
<p>低层<code>const</code> 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;    <span class="comment">// 指向a的指针，不能通过这个指针修改a的值，是底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = a;    <span class="comment">// a的引用，不能通过这种方式修改a, 是底层const</span></span><br></pre></td></tr></table></figure>
<h3 id="const-与参数传递"><a href="#const-与参数传递" class="headerlink" title="const 与参数传递"></a><code>const</code> 与参数传递</h3><ul>
<li><p>在参数传递时，顶层<code>const</code>会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层<code>const</code> 后没有区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用非常量初始化底层<code>const</code> ，但不能使用常量去初始化非底层<code>const</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_1 = a;  <span class="comment">// 可以， 可以使用非常量初始化底层const</span></span><br><span class="line"><span class="type">int</span> &amp;ret_2 = b;      <span class="comment">// 不可以， 不能使用常量去初始化非底层const</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非常量的引用必须是左值，常量的引用可以是左值，也可以是右值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">1</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> &amp;b = <span class="number">2</span>;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>因此<strong>尽量将不会改变形参的函数的形参定义成底层<code>const</code></strong> ，因为这样定义我们可以使用字面量（rvalue）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>placement new</title>
    <url>/2022/12/17/placement-new/</url>
    <content><![CDATA[<h1 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h1><p>最典型的<code>placement new</code> 的签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span> * pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>placement new</code> 就得名于这个最典型的new。</p>
<p>下面这个程序将展示这种<code>placement new</code> 的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">obj</span>() &#123;num = <span class="number">233</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; num &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    obj * p = (obj *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (obj));</span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    obj * t = <span class="built_in">new</span>(p) <span class="built_in">obj</span>();       <span class="comment">// placement new : 在一片已分配但未使用的区域调用构造函数</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t;        <span class="comment">// p 和 t的值相同，说明placement new 的返回值就是p</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">411689296</span></span><br><span class="line"><span class="number">233</span></span><br><span class="line"><span class="number">0xb25fb0</span> <span class="number">0xb25fb0</span></span><br></pre></td></tr></table></figure>
<p>当最初使用malloc时，<code>obj</code>的构造函数并没有被调用，因此<code>num</code>的值是垃圾值，当使用<code>placement new</code>之后，在原位置调用了构造函数，因此<code>num</code>的值变为了233，而这个<code>placement new</code>的返回值也就是我们传入的那个<code>rawMemory</code></p>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 配置</title>
    <url>/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ubuntu-配置"><a href="#ubuntu-配置" class="headerlink" title="ubuntu 配置"></a>ubuntu 配置</h1><p>2022/9/1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。</p>
<h2 id="VScode-下载和配置"><a href="#VScode-下载和配置" class="headerlink" title="VScode 下载和配置"></a>VScode 下载和配置</h2><p>下载的方法见官网，配置C/C++的方法网上的博客也很好搜到</p>
<p><a href="https://blog.csdn.net/qq_42911863/article/details/125619397">Linux系统VsCode 配置C/C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境</a>  </p>
<p>接下来使将<code>Open With Code</code> 添加到右键菜单</p>
<blockquote>
<p>这部分参考</p>
<p><a href="https://www.cnblogs.com/hongdoudou/p/12708510.html">ubuntu中为vscode添加右键菜单—网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com)</a></p>
<p>其中修改了一点命令，将visual-studio-code 改成了code</p>
</blockquote>
<p>去<code>$HOME/.local/share/nautilus/script/</code> 目录下新建一个文件，文件名就是显示在右键菜单上的名字。</p>
<p>接着将以下内容复制到新建的文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script opens a gnome-terminal in the directory you select.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Distributed under the terms of GNU GPL version 2 or later</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts</span></span><br><span class="line"><span class="comment"># You need to be running Nautilus 1.0.3+ to use scripts.</span></span><br><span class="line"><span class="comment"># When a directory is selected, go there. Otherwise go to current</span></span><br><span class="line"><span class="comment"># directory. If more than one directory is selected, show error.</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">destination=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="comment"># Go to file&#x27;s directory if it&#x27;s a file</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$destination</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">destination=<span class="string">&quot;`dirname &quot;</span><span class="variable">$destination</span><span class="string">&quot;`&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">zenity --error --title=<span class="string">&quot;Error - Open terminal here&quot;</span> /</span><br><span class="line">--text=<span class="string">&quot;You can only select one directory.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">destination=<span class="string">&quot;`echo &quot;</span><span class="variable">$NAUTILUS_SCRIPT_CURRENT_URI</span><span class="string">&quot; | sed &#x27;s/^file://////&#x27;`&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># It&#x27;s only possible to go to local directories</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;`echo &quot;</span><span class="variable">$destination</span><span class="string">&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">zenity --error --title=<span class="string">&quot;Error - Open terminal here&quot;</span> /</span><br><span class="line">--text=<span class="string">&quot;Only local directories can be used.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$destination</span>&quot;</span></span><br><span class="line"><span class="built_in">exec</span> code <span class="string">&quot;<span class="variable">$destination</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后运行命令<code>chmod +x  刚才创建的文件名</code> </p>
<p>对文件或文件夹右键就可以看到刚才添加的右键菜单了。</p>
<h2 id="下拉式终端Yakuka"><a href="#下拉式终端Yakuka" class="headerlink" title="下拉式终端Yakuka"></a>下拉式终端Yakuka</h2><p>在<a href="https://snapcraft.io/yakuake">这里</a> 找到 <a href="https://snapcraft.io/install/yakuake/ubuntu">Ubuntu</a> 根据提示安装。</p>
<p>如果安装失败可能要换清华源，如下：</p>
<h2 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_49700990/article/details/122005001">https://blog.csdn.net/weixin_49700990/article/details/122005001</a></p>
</blockquote>
<p>首先使用<code>lsb_release -a</code> 查看自己的Ubuntu版本</p>
<p>我们要更改的文件是 /etc/apt/sources.list，</p>
<p>首先使用命令对这个文件进行备份 </p>
<p><code>sudo cp /etc/apt/sources.list /etc/apt/sources_save.list</code></p>
<p>接着 进入<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华源网站</a> ，找到<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">Ubuntu的源</a> ，选择合适的版本，根据提示手动替换即可。</p>
<h2 id="设置应用开机启动"><a href="#设置应用开机启动" class="headerlink" title="设置应用开机启动"></a>设置应用开机启动</h2><p>在Ubuntu自带的 “启动应用程序” 里配置</p>
<h2 id="更改磁盘大小"><a href="#更改磁盘大小" class="headerlink" title="更改磁盘大小"></a>更改磁盘大小</h2><blockquote>
<p>参考 <a href="https://blog.csdn.net/Shine_Su/article/details/124630751">https://blog.csdn.net/Shine_Su/article/details/124630751</a></p>
</blockquote>
<p>首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。</p>
<h2 id="将虚拟机的内容复制到虚拟机外"><a href="#将虚拟机的内容复制到虚拟机外" class="headerlink" title="将虚拟机的内容复制到虚拟机外"></a>将虚拟机的内容复制到虚拟机外</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/u013554213/article/details/124061526">https://blog.csdn.net/u013554213/article/details/124061526</a></p>
</blockquote>
<p>依次执行以下命令，最后重启Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除原来安装过的文件</span></span><br><span class="line">sudo apt autoremove open-vm-tools</span><br><span class="line"><span class="comment"># 输入安装命令：</span></span><br><span class="line">sudo apt install open-vm-tools</span><br><span class="line">sudo apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>
<h2 id="截图软件"><a href="#截图软件" class="headerlink" title="截图软件"></a>截图软件</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/415011610">https://zhuanlan.zhihu.com/p/415011610</a></p>
</blockquote>
<p><code>sudo apt install flameshot</code></p>
<p>查看安装路径</p>
<p><code>which flameshot</code></p>
<p>在设置中，添加键盘快捷键</p>
<p>命令是<code>/usr/bin/flameshot gui</code></p>
]]></content>
      <categories>
        <category>使用教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是启蒙运动？</title>
    <url>/2022/12/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%AF%E8%92%99%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="康德-什么是启蒙运动？"><a href="#康德-什么是启蒙运动？" class="headerlink" title="康德|什么是启蒙运动？"></a>康德|什么是启蒙运动？</h3><ul>
<li>启蒙运动就是人类脱离自己所加之于自己的不成熟状态，不成熟状态就是不经别人的引导，就对运用自己的理智无能为力。当其原因不在于缺乏理智，而在于不经别人的引导就缺乏勇气与决心去加以运用时，那么这种不成熟状态就是自己所加之于自己的了。Sapere Aude！要有勇气运用你自己的理智！这就是启蒙运动的口号。</li>
<li>懒惰和怯懦乃是何以有如此大量的人，当大自然早己把他们从外界的引导之下释放出来以后（naturalitermaiorennes）时，却仍然愿意终身处于不成熟状态之中，以及别人何以那么轻而易举地就俨然以他们的保护人自居的原因所在。处于不成熟状态是那么安逸。如果我有一部书能替我有理解，有一位牧师能替我有良心，有一位医生能替我规定食谱，等等；那么我自己就用不着操心了。只要能对我合算，我就无需去思想：自有别人会替我去做这类伤脑筋的事。</li>
<li>绝大部分的人（其中包括全部的女性）都把步入成熟状态认为除了是非常之艰辛而外并且还是非常之危险的；这一点老早就被每一个一片好心在从事监护他们的保护人关注到了。保护人首先是使他们的牲口愚蠢，并且小心提防着这些温驯的畜牲不要竟敢冒险从锁着他们的摇车里面迈出一步；然后就向他们指出他们企图单独行走时会威胁他们的那种危险。可是这种危险实际上并不那么大，因为他们跌过几交之后就终于能学会走路的；然而只要有过一次这类事例，就会使人心惊胆战并且往往吓得完全不敢再去尝试了。</li>
<li>任何一个个人要从几乎已经成为自己天性的那种不成熟状态之中奋斗出来，都是很艰难的。他甚至于已经爱好它了，并且确实暂时还不能运用他自己的理智，因为人们从来都不允许他去做这种尝试。条例和公式这类他那天分的合理运用、或者不如说误用的机械产物，就是对终古长存的不成熟状态的一副脚梏。谁要是抛开它，也就不过是在极狭窄的沟渠上做了一次不可靠的跳跃而己，因为他并不习惯于这类自由的运动。因此就只有很少数的人才能通过自己精神的奋斗而摆脱不成熟的状态，并且从而迈出切实的步伐来。</li>
<li>然而公众要启蒙自己，却是很可能的；只要允许他们自由，这还确实几乎是无可避免的。因为哪怕是在为广大人群所设立的保护者们中间，也总会发见一些有独立思想的人；他们自己在抛却了不成熟状态的羁绊之后，就会传播合理地估计自己的价值以及每个人的本分就在于思想其自身的那种精神。这里面特别值得注意的是：公众本来是被他们套上了这种羁绊的，但当他们的保护者（其本身是不可能有任何启蒙的）中竟有一些人鼓动他们的时候，此后却强迫保护者们自身也处于其中了；种下偏见是那么有害，因为他们终于报复了本来是他们的教唆者或者是他们教唆者的先行者的那些人。因而公众只能是很缓慢地获得启蒙。通过一场革命或许很可以实现推翻个人专制以及贪婪心和权势欲的压迫，但却绝不能实现思想方式的真正改革；而新的偏见也正如旧的一样，将会成为驾驭缺少思想的广大人群的圈套。</li>
<li>然而，这一启蒙运动除了自由而外并不需要任何别的东西，而且还确乎是一切可以称之为自由的东西之中最无害的东西，那就是在一切事情上都有公开运用自己理性的自由。可是我却听到从四面八方都发出这样的叫喊：不许争辩！军官说：不许争辩，只许操练！税吏说：不许争辩，只许纳税。神甫说：不许争辩，只许信仰。（举世只有一位君主说：可以争辩，随便争多少，随便争什么，但是要听话！君主指普鲁士腓德烈大王）到处都有对自由的限制。</li>
<li>然则，哪些限制是有碍启蒙的，哪些不是，反而是足以促进它的呢？—我回答说：必须永远有公开运用自己理性的自由，并且唯有它才能带来人类的启蒙。私下运用自己的理性往往会被限制得很狭隘，虽则不致因此而特别妨碍启蒙运动的进步。而我所理解的对自己理性的公开运用，则是指任何人作为学者在全部听众面前所能做的那种运用。一个人在其所受任的一定公职岗位或者职务上所能运用的自己的理性，我就称之为私下的运用。</li>
<li>就涉及共同体利益的许多事物而言，则我们必须有一定的机器，共同体的一些成员必须靠它来保持纯粹的消极态度，以便他们由于一种人为的一致性而由政府引向公共的目的，或者至少也是防止破坏这一目的。在这上面确实是不容许有争辩的；而是人们必须服从。但是就该机器的这一部分同时也作为整个共同体的，乃至于作为世界公民社会的成员而论，从而也就是以一个学者的资格通过写作面向严格意义上的公众时，则他是绝对可以争辩的，而不致因此就有损于他作为一个消极的成员所从事的那种事业。因此，一个服役的军官在接受他的上级交下某项命令肘，竟抗声争辩这项命令的合目的性或者有用性，那就会非常坏事；他必须服从。但是他作为学者而对军事业务上的错误进行评论并把它提交给公众来作判断时，就不能公开地加以禁止了。公民不能拒绝缴纳规定于他的税额；对所加给他的这类赋税惹事生非地擅行责难，甚至可以当作诽谤（这可能引起普遍的反抗）而加以惩处。然而这同一个人作为一个学者公开发表自己的见解，抗议这种课税的不适宜与不正当不一样，他的行动并没有违背公民的义务。同样地，一个牧师也有义务按照他所服务的那个教会的教义向他的教义问答班上的学生们和他的会众们作报告，因为他是根据这一条件才被批准的。但是作为一个学者，他却有充分自由、甚至于有责任，把他经过深思熟虑有关那种教义的缺点的全部善意的意见以及关于更好地组织宗教团体和教会团体的建议传达给公众。这里面并没有任何可以给他的良心增添负担的东西。因为他把作为一个教会工作者由于自己职务的关系而讲授的东西，当作是某种他自己并没有自由的权力可以按照自己的心意进行讲授的东西；他是受命根据别人的指示并以别人的名义选行讲述的。他将要说：我们的教会教导这些或那些；这里就是他们所引用的论据。于是，他就从他自己不会以完全的信服而赞同、虽则他很可以使自己负责进行宣讲的那些条文中—因为并非是完全不可能其中也隐藏着真理，而且无论如何至少其中不会发见有任何与内心宗教相违背的东西，—为他的听众引绎出全部的实用价值来。因为如果他相信其中可以发见任何与内心宗教相违背的东西，那么他就不能根据良心而尽自己的职务了，他就必须辞职。一个就任的宣教师之向他的会众运用自己的理性，纯粹是一种私下的运用；因为那往往只是一种家庭式的聚会，不管是多大的聚会；而在这方面他作为一个牧师是并不自由的，而且也不能是自由的，因为他是在传达别人的委托。反之，作为一个学者通过自己的著作而向真正的公众亦即向全世界讲话时，则牧师在公开运用他的理性上便享有无限的自由可以使用他自己的理性，并以他自己本人的名义发言。因为人民（在精神事务上）的保护者而其本身居然也不成熟，那便可以归结为一种荒谬性，一种永世长存的荒谬性了。</li>
<li>然则一种牧师团体、一种教会会议或者一种可敬的教门法院（就象他们在荷兰人中间所自称的那样），是不是有权宣誓他们自己之间对某种不变的教义负有义务，以便对其每一个成员并且由此也就是对全体人民进行永不中辍的监护，甚至于使之永恒化呢？我要说：这是完全不可能的。这样一项向人类永远封锁住了任何进一步启蒙的契约乃是绝对无效的，哪怕它被最高权力、被国会和最庄严的和平条约所确认。一个时代决不能使自己负有义务并从而发誓，要把后来的时代置于一种决没有可能扩大自己的（尤其是十分迫切的）认识、清除错误以及一般地在启蒙中继续进步的状态之中。这会是一种违反人性的犯罪行为，人性本来的天职恰好就在于这种进步；因此后世就完全有权拒绝这种以毫无根据而且是犯罪的方式所采取的规定。</li>
<li>凡是一个民族可以总结为法律的任何东西，其试金石都在于这样一个问题：一个民族是不是可以把这样一种法律加之于其自身？它可能在一个有限的短时期之内就好像是在期待着另一种更好的似的，为的是好实行一种制度，使得每一个公民而尤其是牧师都能有自由以学者的身份公开地，也就是通过著作，对现行组织的缺点发表自己的言论。这种新实行的制度将要一直延续下去，直到对这类事情性质的洞见已经是那么公开地到来并且得到了证实，以致于通过他们联合（即使是并不一致）的呼声而可以向王位提出建议，以便对这一依据他们更好的洞见的概念而结合成另一种已经改变了的宗教组织加以保护，而又不致于妨碍那些仍愿保留在旧组织之中的人们。但是统一成一个固定不变的、没有人能够（哪怕在一个人的整个一生中）公开加以怀疑的宗教体制，从而也就犹如消灭了人类朝着改善前进的整整一个时代那样，并由此给后代造成损害，使得他们毫无收获，—这却是绝对不能容许的。一个人确实可以为了他本人并且也只是在一段时间之内，推迟对自己有义务加以认识的事物的启蒙；然而迳行放弃它，那就无论是对他本人，而更其是对于后代，都可以说是违反而且践踏人类的神圣权利了。</li>
<li>而人民对于他们本身都不能规定的事，一个君主就更加不可以对他的人民规定了；因为他的立法威望全靠他把全体人民的意志结合为他自己的意志。只要他注意使一切真正的或号称的改善都与公民秩序结合在一起，那么此外他就可以把他的臣民发觉对自己灵魂得教所必须做的事情留给他们自己去做；这与他无关，虽则他必须防范任何人以强力妨碍别人根据自己的全部才能去做出这种决定并促进这种得救。如果他干预这种事，要以政府的监督来评判他的臣民借以亮明他们自己的见识的那些作品；以及如他凭自己的最高观点来这样做，而使自己受到Caesarnon estt supragrammaticos（凯撒并不高于文法学家）的这种责难；那就会有损于他的威严。如果他把自己的最高权力降低到竟至去支持自己国内的一些暴君对他其余的臣民实行精神专制主义的时候，那就更加每况愈下了。</li>
<li>如果现在有人问：我们目前是不是生活在一个启蒙了的时代？那么回答就是：并不是，但确实是在一个启蒙运动的时代。目前的情形是，要说人类总的说来已经处于，或者是仅仅说已经被置于，一种不需别人引导就能够在宗教的事情上确切地而又很好地使用自己的理智的状态了，则那里面还缺乏许多东西。可是现在领域已经对他们开放了，他们可以自由地在这上面工作了，而且对普遍启蒙的、或者说对摆脱自己所加给自己的不成熟状态的障碍也逐渐地减少了；关于这些我们都有着明确的信号。就这方面考虑，这个时代乃是启蒙的时代，或者说乃是腓德烈的世纪。</li>
<li>一个不以如下说法为与自己不相称的国君：他认为自己的义务就是要在宗教事务方面决不对人们加以任何规定，而是让他们有充分的自由，但他又甚至谢绝宽容这个高傲的名称；这位国君本人就是启蒙了的，并且配得上被天下后世满怀感激之忱尊之为率先使得人类，至少从政权方面而言，脱离了不成熟状态，并使每个人在任何有关良心的事务上都能自由地运用自身所固有的理性。在他的治下，可敬的牧师们可以以学者的身份自由地并且公开地把自己在这里或那里偏离了既定教义的各种判断和见解都提供给全世界来检验，而又无损于自己的职责：至于另外那些不受任何职责约束的人，那就更加是如此了。这种自由精神也要向外扩展，甚至于扩展到必然会和误解了其自身的那种政权这一外部阻碍发生冲突的地步。因为它对这种政权树立了一个范例，即自由并不是一点也不关怀公共的安宁和共同体的团结一致的。只有当人们不再有意地想方设法要把人类保持在野蛮状态的时候，人类才会由于自己的努力而使自己从其中慢慢地走出来。</li>
<li>我把启蒙运动的重点，亦即人类摆脱他们所加之于其自身的不成熟状态，主要是放在宗教事务方面，因为我们的统治者在艺术和科学方面并没有向他们的臣民尽监护之责的兴趣；何况这一不成熟状态既是一切之中最有害的而又是最可耻的一种。但是，一个庇护艺术与科学的国家首领，他的思想方式就要更进一步了，他洞察到：即使是在他的立法方面，容许他的臣民公开运用他们自身的理性，公开向世上提出他们对于更好地编篡法律、甚至于是直言无讳地批评现行法律的各种见解，那也不会有危险的。在这方面，我们有着一个光辉的典范，我们所尊敬的这位君主（指普鲁士腓德烈大王）就是没有别的君主能够超越的。</li>
<li>但是只有那位其本身是启蒙了的、不怕幽灵的而同时手中又掌握着训练精良的大量军队可以保障公共安宁的君主，才能够说出一个自由国家所不敢说的这种话：可以争辩，随便争多少，随便争什么；但是必须听话。这就标志着人间事务的一种可惊异的、不能意料的进程；正犹如当我们对它从整体上加以观察时，其中就几乎一切都是悖论那样。程度更大的公民自由仿佛是有利于人民精神的自由似的，然而它却设下了不可逾越的限度；反之，程度较小的公民自由却为每个人发挥自己的才能开辟了余地。因为当大自然在这种坚硬的外壳之下打开了为她所极为精心照料着的幼芽时，也就是要求思想自由的倾向与任务时，它也就要逐步地反作用于人民的心灵面貌（从而他们慢慢地就能掌握自由）；并且终于还会反作用于政权原则，使之发见按照人的尊严—人并不仅仅是机器而已—去看待人，也是有利于政权本身的。</li>
<li>1784年9月30日，于普鲁士哥尼斯堡（刘伟录自《历史理性批判文集》）</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数组,二维数组,指针</title>
    <url>/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="动态数组、二维数组、指针"><a href="#动态数组、二维数组、指针" class="headerlink" title="动态数组、二维数组、指针"></a>动态数组、二维数组、指针</h1><p>本文会讲：</p>
<ul>
<li>二维数组的存储形式</li>
<li>数组类型为什么会退化？</li>
<li>二维数组的动态分配</li>
</ul>
<h2 id="1-二维数组的存储形式"><a href="#1-二维数组的存储形式" class="headerlink" title="1 二维数组的存储形式"></a>1 二维数组的存储形式</h2><p>以下这个程序可以很好的说明二维数组的存储形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = i * <span class="number">10</span> + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的运行结果是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">32</span>      </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DD0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">000000000064F</span>DD0</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">000000000064F</span>DD8</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">000000000064F</span>DE0</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DD4</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DDC</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DE4</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE8</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DEC</span><br></pre></td></tr></table></figure>
<p>可以看出，二维数组是连续储存的，有<code>&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0]</code> ，以此类推。</p>
<p>我们可以这样表示二维数组</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-数组类型为什么会退化？"><a href="#2-数组类型为什么会退化？" class="headerlink" title="2 数组类型为什么会退化？"></a>2 数组类型为什么会退化？</h2><p>有的时候会出现这种情况：</p>
<p>在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？</p>
<p>详见：<a href="https://www.zhihu.com/question/464844221/answer/1940453834">https://www.zhihu.com/question/464844221/answer/1940453834</a></p>
<h2 id="3-动态分配二维数组"><a href="#3-动态分配二维数组" class="headerlink" title="3 动态分配二维数组"></a>3 动态分配二维数组</h2><h3 id="3-1-第一种方法"><a href="#3-1-第一种方法" class="headerlink" title="3.1 第一种方法"></a>3.1 第一种方法</h3><p>先申请一维数组，在将该一维数组强制转换成二维数组</p>
<p>前置知识：</p>
<p>一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息</p>
<p>二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型，</p>
<p>即<code>int q[][4]</code> 和<code>int (*q)[4]</code> 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于<code>q += 2 * 4 * sizeof(int)</code></p>
<p>直接贴代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="type">int</span> (*b)[<span class="number">4</span>] = (<span class="type">int</span> (*)[<span class="number">4</span>])a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。</p>
<p>我们用<code>int (*b)[4]</code> 声明了一个指向 四个元素的数组 的指针。</p>
<p>然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。</p>
<p>这样动态分配的指针和直接<code>int b[2][4]</code> 是一样的。</p>
<p>下面我们使用 1 中的方法对这个数组进行仔细检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        b[i] = i;</span><br><span class="line">    <span class="type">int</span> (*a)[<span class="number">2</span>] = (<span class="type">int</span> (*)[<span class="number">2</span>])b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span>       </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span>      </span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span>      </span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">02</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">03</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">04</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">05</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">06</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">07</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">00000000009</span>C1420</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">00000000009</span>C1428</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">00000000009</span>C1430</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">2</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">4</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1424</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C142C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1434</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1438</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C143C</span><br></pre></td></tr></table></figure>
<p>可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。</p>
<p>这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 </p>
<h3 id="3-2-第二种方法："><a href="#3-2-第二种方法：" class="headerlink" title="3.2 第二种方法："></a>3.2 第二种方法：</h3><blockquote>
<p>参考: <a href="https://blog.csdn.net/morewindows/article/details/7664479#">https://blog.csdn.net/morewindows/article/details/7664479#</a> 我这里将原文的int 替换成了size_t</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C语言中动态的申请二维数组 malloc free</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//动态申请二维数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T** <span class="title">malloc_Array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="built_in">sizeof</span>(T);</span><br><span class="line">  <span class="type">int</span> point_size = <span class="built_in">sizeof</span>(T*);</span><br><span class="line">  <span class="comment">//先申请内存，其中point_size * row表示存放row个行指针</span></span><br><span class="line">  T **arr = (T **) <span class="built_in">malloc</span>(point_size * row + size * row * col);</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;	</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, point_size * row + size * row * col);</span><br><span class="line">    T *head = (T*)((<span class="type">size_t</span>)arr + point_size * row);    <span class="comment">// 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好</span></span><br><span class="line">    <span class="keyword">while</span> (row--)</span><br><span class="line">      arr[row] = (T*)((<span class="type">size_t</span>)head + row * col * size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T**)arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_Aarray2D</span><span class="params">(<span class="type">void</span> **arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  C语言中动态的申请二维数组 malloc free\n&quot;</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入行列(以空格分开): &quot;</span>);</span><br><span class="line">  <span class="type">int</span> nRow, nCol;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;nRow, &amp;nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//动态申请连续的二维数组</span></span><br><span class="line">  <span class="type">int</span> **p = <span class="built_in">malloc_Array2D</span>&lt;<span class="type">int</span>&gt;(nRow, nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//为二维数组赋值	</span></span><br><span class="line">  <span class="type">int</span> i, j;	</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      p[i][j] = i + j;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//输出二维数组	</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p[i][j]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free_Aarray2D</span>((<span class="type">void</span>**)p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，原作者对指针的操作让我叹为观止。</p>
<p>但是，用这种方法创作出来的二维数组和直接<code>int b[2][4]</code> 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-3-第三种方法"><a href="#3-3-第三种方法" class="headerlink" title="3.3 第三种方法"></a>3.3 第三种方法</h3><blockquote>
<p>参考：<a href="https://blog.csdn.net/houqd2012/article/details/8146070">https://blog.csdn.net/houqd2012/article/details/8146070</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。</p>
<p>我们使用 1 中的程序对这个数组进行详细的检查。代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span></span><br><span class="line"></span><br><span class="line">a:      <span class="number">0000000000701420</span></span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">0000000000701450</span></span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">0000000000701458</span></span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">0000000000701460</span></span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">0000000000701468</span></span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">0000000000701420</span></span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">0000000000701428</span></span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">0000000000701430</span></span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">0000000000701438</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">0000000000701450</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">0000000000701454</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">0000000000701458</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000070145</span>C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">0000000000701460</span></span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">0000000000701464</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">0000000000701468</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000070146</span>C</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接<code>int b[2][4]</code> 得到的二维数组，还是不一样的。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-4-总结-：-下标运算符"><a href="#3-4-总结-：-下标运算符" class="headerlink" title="3.4 总结 ： 下标运算符"></a>3.4 总结 ： 下标运算符</h3><p>首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。</p>
<p>下标运算符是左结合的，我们引用二维数组，通常是这样的    <code>arr[i][j]</code> 但其实也可以这样 <code>(arr[i])[j]</code> 这两种形式是等价的。</p>
<p>下面我们详细地描述下标运算符 </p>
<p><code>ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType))</code></p>
<p>可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型<code>int **</code>, 也可以是数组类型 <code>int (*)[]</code>，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。</p>
<p>首先我们来看内置的数组类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<p>一个内置数组类型表示为<code>int a[5][5]</code> ，但拎出来a，他的类型是 <code>int (*)[5]</code> 所以<code>arr[1]</code> 其实是指<code>a[1][0]</code> 这个位置。<code>a[1]</code> 的类型是<code>int *</code> 所以<code>(a[1])[1]</code> 的类型就是<code>int</code></p>
<p>接下来我们看动态分配二维数组的第一种方法：</p>
<p>这种方法一开始申请了一个一维数组<code>int *a = (int *)malloc(2 * 4 * sizeof(int))</code> a的类型是<code>int *</code></p>
<p>接下来我们使用强制类型转换，将a由<code>int *</code> 转换为<code>int (*)[4]</code> ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。</p>
<p>接下类我们看动态分配二维数组的第二种方法：</p>
<p>首先我们将这种方法分配的图画出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209061948605.png" alt="image-20220906194800829">  </p>
<p>设行数为row，列数为col，假设二维数组存储的类型为 int</p>
<p>第二种方法申请了 <code>row * sizeof(int *) + row * col * sizeof(int)</code> 字节的空间。</p>
<p>这个表达式的前一项<code>row * sizeof(int *)</code> 代表a[0] a[1] a[2] 的空间，后一项<code>row * col * sizeof(int)</code> 指的是连续的二维数组的存储空间。</p>
<p>这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。</p>
<p>需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是<code>int **</code> 而不是<code>int (*)[col]</code> ，也决不能是<code>int (*)[col]</code> 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？</p>
<p>首先a的类型时<code>int **</code> ，a[1]，代表a之后一个指针大小位置的内容，即</p>
<p><code>*((size_t)a + 1 * sizeof(int *))</code>，就是a[1] [0]的地址，而<code>(a[1])[0]</code> 就是a[1] [0]的内容。</p>
<p>为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是<code>int **</code> </p>
<p>第三种二维数组的分析与第二种类似，这里我们给出它的表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209062002932.png" alt="image-20220906200208361"> </p>
<h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><p>我们使用一个程序来展示 <code>int (*)[col]</code> 类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> a[][<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_3</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>])</span>  <span class="comment">// 指向数组的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*a)[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> q[<span class="number">4</span>][<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      q[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">  func_1(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  func_2(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> p[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  func_3(&amp;p);		<span class="comment">// 因为是指向数组的指针，p必须要取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一篇文章 ：<a href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></p>
<p>这篇文章里对指针类型的分析很好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line">Int (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于英文论文作者名称中逗号与句号的使用</title>
    <url>/2023/03/06/%E5%85%B3%E4%BA%8E%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E5%90%8D%E7%A7%B0%E4%B8%AD%E9%80%97%E5%8F%B7%E4%B8%8E%E5%8F%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Q : 论文作者名称中句号和逗号的意义是什么</p>
<p>A : </p>
<blockquote>
<p>你好，这是必应。😊</p>
<p><a href="https://www.zhihu.com/question/456669273">论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。一般来说，句号用于分隔作者的名和姓，逗号用于分隔多个作者</a><a href="https://www.zhihu.com/question/456669273">1</a>。例如：</p>
<p>张三.李四,王五.赵六.</p>
<p>表示有两个作者，分别是张三和王五，他们的名字是李四和赵六。</p>
<p><a href="https://www.xiegelunwen.com/article/chachong/05f0411947871274.html">如果你想了解更多关于参考文献著录规则的信息，你可以查看GB/T 7714—2015《信息与文献：参考文献著录规则》</a><a href="https://www.xiegelunwen.com/article/chachong/05f0411947871274.html">2</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/98524815">论文中作者顺序也有一定的含义，通常反映了作者对论文的贡献大小</a><a href="https://zhuanlan.zhihu.com/p/98524815">3</a>。例如：</p>
<p>张三.李四,王五.赵六*,刘七.钱八.</p>
<p>表示第一个作者是张三，最后一个作者是刘七，通讯作者（负责联系编辑和审稿人）是王五。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 我指的是英文，例如 Howard, J., Hyman, A.A.: ‘Dynamics and mechanics of the microtubule plus end’Nature, 2003, 422, (6933), pp. 753–758.</p>
<p>A : </p>
<blockquote>
<p>原来如此，你是指英文论文的作者名称。😊</p>
<p><a href="https://zhuanlan.zhihu.com/p/272715312">英文论文的作者名称中句号和逗号的意义也可能因不同的引用格式而有所不同。一般来说，句号用于缩写作者的名字，逗号用于分隔多个作者</a><a href="https://zhuanlan.zhihu.com/p/272715312">1</a>。例如：</p>
<p>Howard, J., Hyman, A.A.</p>
<p>表示有两个作者，分别是Howard和Hyman，他们的名字缩写为J和A.A.</p>
<p><a href="https://zhuanlan.zhihu.com/p/272715312">不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者</a><a href="https://zhuanlan.zhihu.com/p/272715312">1</a><a href="https://zhuanlan.zhihu.com/p/349018810">2</a><a href="https://zhuanlan.zhihu.com/p/129904989">3</a>。例如：</p>
<p>Howard, J., Hyman, A.A., &amp; Smith, P.</p>
<p>表示有三个作者，分别是Howard、Hyman和Smith。</p>
<p>Howard, J., et al.</p>
<p>表示有多个作者，只列出了第一个作者Howard。</p>
<p>你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。</p>
</blockquote>
<p>Q : Howard, J 代表一个人，为什么它的名字中间还有逗号呢？</p>
<p>A : </p>
<blockquote>
<p>Howard, J 代表一个人，但是它的名字是由两部分组成的，姓和名。在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。例如：</p>
<p>Howard, J.</p>
<p>表示作者的姓是Howard，名是J开头的单词，比如John或James。</p>
<p>你明白了吗？</p>
</blockquote>
<p>Q : 所以姓和名之间要用逗号分隔，此外，多个人名中间也需要使用逗号分隔，我理解的正确吗</p>
<p>A : </p>
<blockquote>
<p>是的，你理解的正确。😊</p>
<p>姓和名之间要用逗号分隔，多个人名中间也需要使用逗号分隔。这样做可以清楚地表达作者的身份和数量。例如：</p>
<p>Howard, J., Hyman, A.A., Smith, P.</p>
<p>表示有三个作者，分别是Howard、Hyman和Smith。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 请问 Smith, P. 这个名字，他最后的句号代表什么呢？</p>
<p>A : </p>
<blockquote>
<p>Smith, P. 这个名字，最后的句号是用来表示作者的名字是缩写的。如果作者的名字不是缩写的，就不需要最后的句号。例如：</p>
<p>Smith, Peter</p>
<p>表示作者的名字是Peter，不是缩写的。</p>
<p>Smith, P.</p>
<p>表示作者的名字是P开头的单词，比如Paul或Patrick，是缩写的。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 你可以总结一下我们这次的对话，最好有所有的细节，我想保存这次对话，以便于下次查阅，谢谢！</p>
<p>A : </p>
<blockquote>
<p>好的，我很乐意为你总结我们这次的对话。😊</p>
<p>我们这次的对话主要是关于论文作者名称中句号和逗号的意义。以下是我们讨论的要点：</p>
<ul>
<li>论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。</li>
<li>一般来说，句号用于分隔或缩写作者的名和姓，逗号用于分隔多个作者。</li>
<li>不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者。</li>
<li>你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。</li>
<li>在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。</li>
<li>如果没有下一个作者，就不需要最后一个逗号。如果作者的名字不是缩写的，就不需要最后一个句号。</li>
</ul>
<p>我希望这次总结能够帮助你更好地理解论文作者名称中句号和逗号的意义。如果你还有其他问题，请随时提出。🙏</p>
</blockquote>
<p>关于复姓</p>
<p>Q : 对于复姓的中国作者，他们的名称应该怎样书写呢，例如欧阳 洪，其中欧阳是姓氏，洪是名称。读音是Ouyang Hong</p>
<p>A：</p>
<blockquote>
<p><a href="https://www.wikiwand.com/en/Chinese_compound_surname">对于复姓的中国作者，他们的名称应该按照复姓的拼音和名称的首字母写出，复姓用连字符连接。例如，欧阳 洪的引文格式应该是 Ouyang-H., 或者 Ouyang-Hong</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
  </entry>
  <entry>
    <title>在vscode配置cmake</title>
    <url>/2022/11/14/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEcmake/</url>
    <content><![CDATA[<h1 id="在vscode中配置cmake"><a href="#在vscode中配置cmake" class="headerlink" title="在vscode中配置cmake"></a>在vscode中配置cmake</h1><h2 id="配置includePath"><a href="#配置includePath" class="headerlink" title="配置includePath"></a>配置includePath</h2><p>vscode的静态语法检查是 intellisense 完成的，想要使它能搜寻到指定的includePath需要这要做：</p>
<ol>
<li>ctrl p，输入c/c++ edit configurations(JSON)，这会在本地的<code>./vscode/</code>下创建<code>c_cpp_properties.json</code> 在includePath里面添加上自己的include path即可</li>
</ol>
<h2 id="配置generator"><a href="#配置generator" class="headerlink" title="配置generator"></a>配置generator</h2><p>首先 ctrl+p，输入settings.json，点击 “首选项：打开工作区设置(JSON)”。</p>
<p>此操作会创建 <code>./vscode/settings.json</code> 在此文件中加入<code>&quot;cmake.generator&quot; : &quot;MinGW Makefiles&quot;</code> 根据不同的系统，配置不同的generator。</p>
<h2 id="配置debugger"><a href="#配置debugger" class="headerlink" title="配置debugger"></a>配置debugger</h2><p>在侧边栏 调试 中点击创建 “launch.json” 或直接创建launch.json 只要是带有调试信息的可执行文件，都可以调试</p>
]]></content>
  </entry>
  <entry>
    <title>存储器层次结构 - CS:APP 第六章</title>
    <url>/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="存储器层次结构-CS-APP-第六章"><a href="#存储器层次结构-CS-APP-第六章" class="headerlink" title="存储器层次结构 - CS:APP 第六章"></a>存储器层次结构 - CS:APP 第六章</h1><p>本章的主要内容有四：</p>
<ol>
<li>介绍存储技术 </li>
<li>介绍存储器的层次结构思想</li>
<li>特别介绍高速缓存的原理和细节</li>
<li>使用局部性优化程序的性能</li>
</ol>
<p>本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。</p>
<h2 id="1-存储器的层次结构"><a href="#1-存储器的层次结构" class="headerlink" title="1 存储器的层次结构"></a>1 存储器的层次结构</h2><p>根据我们的经验观察，读取速度越快的存储器/存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。</p>
<p>因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。</p>
<p>但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。</p>
<blockquote>
<p>存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">L0  寄存器</span><br><span class="line">L1  L1高速缓存 SRAM</span><br><span class="line">L2  L2高速缓存 SRAM</span><br><span class="line">L3  L3高速缓存 SRAM</span><br><span class="line">L4  主存 DRAM</span><br><span class="line">L5  本地二级存储（本地磁盘）</span><br><span class="line">L6  远程二级缓存（分布式文件系统、二级服务器）</span><br></pre></td></tr></table></figure>
<p>下面我们介绍它们的存在基础，存储技术。</p>
<h2 id="2-存储技术"><a href="#2-存储技术" class="headerlink" title="2 存储技术"></a>2 存储技术</h2><p>我们要介绍的存储技术如下</p>
<ul>
<li>随机存储器RAM<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>非易失性存储器 ROM<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
<li>SSD （基于闪存，固态硬盘就是使用SSD技术）</li>
</ul>
</li>
<li>磁盘</li>
</ul>
<h3 id="2-1-随机访问存储器"><a href="#2-1-随机访问存储器" class="headerlink" title="2.1 随机访问存储器"></a>2.1 随机访问存储器</h3><p>随机存储器分为两种材类：SRAM和DRAM</p>
<p>SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。</p>
<p>DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。</p>
<h4 id="2-1-1-DRAM-内存的工作原理"><a href="#2-1-1-DRAM-内存的工作原理" class="headerlink" title="2.1.1 DRAM / 内存的工作原理"></a>2.1.1 DRAM / 内存的工作原理</h4><p>内存由若干个DRAM芯片构成，被称作内存模块(memory module)</p>
<p>每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。</p>
<p>每个超单元内存储若干个位，一般是一字节八位。　</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">内存/主存</span><br><span class="line">|</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br></pre></td></tr></table></figure>
<p>首先介绍DRAM 芯片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041151521.png" alt="image-20220904115118409"> </p>
<p>DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c = d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。</p>
<p>我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。</p>
<p>接下来看一下工作流程：</p>
<p>首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。</p>
<p>接着介绍内存模块：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041158562.png" alt="image-20220904115757187"> </p>
<p>一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 </p>
<h3 id="2-2-磁盘-amp-ROM"><a href="#2-2-磁盘-amp-ROM" class="headerlink" title="2.2 磁盘 &amp; ROM"></a>2.2 磁盘 &amp; ROM</h3><p>ROM可分为</p>
<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
</ul>
<p>我们不多介绍，只需要知道他们的名字和依赖关系即可</p>
<p>磁盘：通常指的是机械硬盘，也不过多介绍。</p>
<h2 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3 高速缓存"></a>3 高速缓存</h2><p>首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍：</p>
<blockquote>
<ul>
<li><p>对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。</p>
</li>
<li><p>而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。</p>
</li>
<li>数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。</li>
</ul>
</blockquote>
<p>以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。</p>
<p>令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。</p>
<p>这句话暂且悬置。</p>
<p>当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。</p>
<p>但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。</p>
<h3 id="3-1-高速缓存的结构"><a href="#3-1-高速缓存的结构" class="headerlink" title="3.1 高速缓存的结构"></a>3.1 高速缓存的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042138819.png" alt="image-20220904213832532"> </p>
<p>一个计算机存储器的地址有m位，他被分为三部分：</p>
<ul>
<li>高t位是标记位</li>
<li>中间s位是组索引位</li>
<li>低b位是组偏移位。</li>
</ul>
<p>高速缓存被组织为这样的结构：</p>
<ul>
<li><p>高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1</p>
</li>
<li><p>每个组中最多有2^t^ 个高速缓存行</p>
</li>
<li>每个高速缓存行也由三部分组成<ul>
<li>一位有效位，标记着这个高速缓存行是否有效</li>
<li>t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行</li>
<li>2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用</li>
</ul>
</li>
</ul>
<h3 id="3-2-高速缓存的工作原理"><a href="#3-2-高速缓存的工作原理" class="headerlink" title="3.2 高速缓存的工作原理"></a>3.2 高速缓存的工作原理</h3><p>当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。</p>
<p>确定是否命中有三个步骤：</p>
<ol>
<li>组选择</li>
<li>行匹配</li>
<li>字抽取</li>
</ol>
<ol>
<li><p>组选择</p>
<p>回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。</p>
</li>
<li><p>行匹配</p>
<p>如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。</p>
<p>如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。</p>
</li>
</ol>
<p>   补充 : </p>
<p>   我们先回忆一下地址的构成</p>
<p>   标记位 t + 索引位 s + 偏移位b</p>
<p>   假设有一个四位的地址，t = 1，s = 2，b = 1</p>
<p>   这四位地址的所有组合如下：</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042239062.png" alt="image-20220904223950779"> </p>
<p>   我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。</p>
<p>   我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。</p>
<p>   这样我们较低层的 0、4 映射到了较高层的0组，</p>
<p>   1、5映射到了1，</p>
<p>   2、6映射到了2，</p>
<p>   3、7映射到了3</p>
<p>   一个组中可以有最多2^t^ 行，如果我们一组中只有一行。</p>
<p>   如果我们首先引用了块0，那么块0每放在较高层的组0，</p>
<p>   接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。</p>
<p>   通过上面的例子，我想说明两点</p>
<p>   一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。</p>
<p>   二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？</p>
<p>   注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。</p>
<p>   其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。</p>
<ol>
<li>字抽取</li>
</ol>
<p>只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。</p>
<h2 id="4-虚拟内存"><a href="#4-虚拟内存" class="headerlink" title="4 虚拟内存"></a>4 虚拟内存</h2><p>从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。</p>
<blockquote>
<p>虚拟内存提供三个重要的能力：</p>
<ol>
<li>它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。</li>
<li>它位每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol>
</blockquote>
<p>从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。</p>
<p>虚拟内存的存在基础：</p>
<p>同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。</p>
<h3 id="4-1-虚拟内存原理"><a href="#4-1-虚拟内存原理" class="headerlink" title="4.1 虚拟内存原理"></a>4.1 虚拟内存原理</h3><p>首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: </p>
<blockquote>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
</blockquote>
<p>真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。</p>
<p>我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。</p>
<h3 id="4-2-虚拟内存的结构"><a href="#4-2-虚拟内存的结构" class="headerlink" title="4.2 虚拟内存的结构"></a>4.2 虚拟内存的结构</h3><p>在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。</p>
<p>页表：每个进程都有一个页表，页表将虚拟页映射到物理页。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209051937453.png" alt="image-20220905193713696"> </p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>
<h3 id="4-3-虚拟内存的地址翻译"><a href="#4-3-虚拟内存的地址翻译" class="headerlink" title="4.3 虚拟内存的地址翻译"></a>4.3 虚拟内存的地址翻译</h3><p>下面简单概括以下虚拟内存的地址翻译：</p>
<ol>
<li>处理器产生一个虚拟地址，并将它传送给MMU</li>
<li>MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3</li>
<li>由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4</li>
<li>现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。</li>
</ol>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220905200451112.png" alt="image-20220905200451112"> </p>
<p>下面我们介绍虚拟地址翻译中的一些细节：</p>
<ol>
<li><p>什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？</p>
<p>要解答这个问题，首先我们要介绍虚拟地址的格式。</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。</p>
</li>
<li><p>PTE 是什么，它的结构是什么？</p>
<p>PTE 是页表条目，他的结构是这样的</p>
<p>| SUP 有效位 | READ 有效位 | WRITE 有效位 | PPN 物理页号 (Physical Page Number) |<br>| ————— | —————- | —————— | —————————————————- |</p>
<p>前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。</p>
<p>PPN 物理页号是什么呢？</p>
<p>让我们回忆以下我们在介绍高速缓存时用到的物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052139387.png" alt="image-20220905213937545"> </p>
<p>如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。</p>
<p>而标记位和组索引合起来就是PPN。</p>
<p>而块偏移和虚拟地址的虚拟页偏移VPO是一样的</p>
<p>因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052144414.png" alt="image-20220905214401855"> </p>
<ol>
<li><p>快表TLB的工作原理是什么？</p>
<p>快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址：</p>
<p>虚拟地址由VPN和VPO组成</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>而虚拟页号VPN又可以分为两部分：</p>
<p>| VPN           | VPN           | VPO  |<br>| ——————- | ——————- | —— |<br>| TLB标记(TLBT) | TLB索引(TLBI) | VPO  |</p>
<p>TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。</p>
<p>接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-高速缓存系统和虚拟内存系统的对比"><a href="#5-高速缓存系统和虚拟内存系统的对比" class="headerlink" title="5 高速缓存系统和虚拟内存系统的对比"></a>5 高速缓存系统和虚拟内存系统的对比</h2><p>高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统</p>
<p>虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统</p>
<p>存储在某个存储层，在存储层之间传输的单元叫做块(block)</p>
<p>在高速缓存SRAM中，它叫做高速缓存行，或者行</p>
<p>在主存DRAM中，它叫做块(block)</p>
<p>在虚拟内存系统中，它叫做页(page)</p>
<p>调度策略</p>
<p>高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小</p>
<p>DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大</p>
<h2 id="6-技术总结"><a href="#6-技术总结" class="headerlink" title="6 技术总结"></a>6 技术总结</h2><p>在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。</p>
<p>有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。</p>
<p>我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052218205.png" alt="image-20220905221756883"> </p>
<p>B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n = m + o。</p>
<p>现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052220108.png" alt="image-20220905222017878"> </p>
<p>由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？</p>
<p>我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t = m - i 位来作为标记，区分一组中的不同块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052224081.png" alt="image-20220905222457743"></p>
<p>通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 </p>
<p>为什么使用中间位作为索引？</p>
<p>如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。</p>
<p>接下来我们概括一下内存系统：</p>
<p>一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。</p>
<p>如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。</p>
<h2 id="7-术语索引"><a href="#7-术语索引" class="headerlink" title="7 术语索引"></a>7 术语索引</h2><p>主存储器(main memory 主存) : 即通常理解的使用DRAM内存。</p>
<p>块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)</p>
<p>VM (Virtual Memory) 虚拟内存</p>
<p>VA(Virtual Address) 虚拟地址</p>
<p>MMU(Memory Management Unit)：内存管理单元，一种硬件</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>页表 ：一个数据类型位PTE的数组</p>
<p>PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型</p>
<p>页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging)</p>
<p>缺页：DRAM缓存不命中称为page fault</p>
<p>内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566</p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程 - CS:APP 第十二章</title>
    <url>/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="并发编程-CS-APP-第十二章"><a href="#并发编程-CS-APP-第十二章" class="headerlink" title="并发编程 - CS:APP 第十二章"></a>并发编程 - CS:APP 第十二章</h1><p>本章主要内容：</p>
<ul>
<li>实现并发程序的三种方法：<ol>
<li>fork() 进程</li>
<li>I/O 多路复用</li>
<li>使用线程</li>
</ol>
</li>
<li>使用信号量同步线程</li>
<li>线程安全问题</li>
</ul>
<h2 id="使用进程进行并发编程"><a href="#使用进程进行并发编程" class="headerlink" title="使用进程进行并发编程"></a>使用进程进行并发编程</h2><p><code>fork()</code> &amp; <code>execve</code> </p>
<p>优点：进程模型清晰，有独立的地址空间</p>
<p>缺点：不方便进程之间共享信息</p>
<p>基于进程的并发echo服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;args error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d connected\n&quot;</span>, getpid());</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            echo(connfd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d close connection\n&quot;</span>, getpid());</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>可以使用<code>select()</code> 函数显示等待一个进程有一个IO事件发生。</p>
<p>例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。</p>
<p>只要有一个IO事件发生，程序的逻辑流就会改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果fdset中的描述符准备好读或者写，就返回</span></span><br><span class="line"><span class="comment">返回值：返回已准备好的描述符数目，若出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset);</span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    fd_set read_set;</span><br><span class="line">    fd_set ready_set;</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="type">int</span> maxi;</span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];</span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE];</span><br><span class="line">&#125;pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pool.nready);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(connfd &gt; p-&gt;maxfd)</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi) </span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：编码特别复杂</p>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程是运行在进程上下文中的逻辑流</p>
<p>运行在同一个进程里的线程共享</p>
<ul>
<li>虚拟地址空间</li>
</ul>
<p>有自己独立的</p>
<ul>
<li>栈、栈指针、PC、通用目的寄存器和条件码</li>
</ul>
<p>线程之间是对等的，没有和进程一样有父子之分</p>
<p>进程有两种状态：可结合的和分离的</p>
<ul>
<li>可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收</li>
<li>分离的：不能被其他线程杀死，内存资源结束时由系统自动释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> * attr, func *f, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自己的tid</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止 tid</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞，等待tid终止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当这个线程第一次被调用时，执行 init_routine()，用于初始化</span></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误</p>
<blockquote>
<p>对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。</p>
</blockquote>
<p>想要实现互斥的访问，我们可以使用信号量机制</p>
<p>信号量：</p>
<p>信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它：</p>
<ul>
<li>P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。</li>
<li>V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。</li>
</ul>
<p>P中测试和加一的操作是不可分割的</p>
<p>V中测试和加以的操作也是不可分割的</p>
<p>如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。</p>
<p>互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。</p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><blockquote>
<p>生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。</p>
<p>因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。</p>
</blockquote>
<p>基于生产者消费者的sbuf包：</p>
<p><code>sbuf.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">int</span> n;    <span class="comment">// 缓冲区长度</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队列头</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;  <span class="comment">// 对缓冲区的互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> slots;  <span class="comment">// 控制生产者的信号量</span></span><br><span class="line">    <span class="type">sem_t</span> items;  <span class="comment">// 控制消费者的信号量</span></span><br><span class="line">&#125;<span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>sbuf.c</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放缓冲区空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区插入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);  <span class="comment">// 如果缓冲区已满，想要插入的线程会阻塞在这里</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁加锁</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;    <span class="comment">// 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);  <span class="comment">// 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);  <span class="comment">// 如果缓冲区为空，想要取出的线程会阻塞</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n];    <span class="comment">// 因为信号量的机制，我们不用担心从空缓冲区里取出数据</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);</span><br><span class="line">    V(&amp;sp-&gt;slots);  <span class="comment">// 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于预线程化的并发服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt;</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        echo_cnt(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="四个种不安全的函数"><a href="#四个种不安全的函数" class="headerlink" title="四个种不安全的函数"></a>四个种不安全的函数</h3><ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数（依赖前次调用结果的函数）</li>
<li>返回指向静态变量指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入的函数"><a href="#可重入的函数" class="headerlink" title="可重入的函数"></a>可重入的函数</h3><p>通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集</p>
<p>定义：当它被多个线程使用时，不会引用任何共享数据</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件</p>
<p>给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>异常控制流 - CS:APP 第8章</title>
    <url>/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="异常控制流-CS-APP-第8章"><a href="#异常控制流-CS-APP-第8章" class="headerlink" title="异常控制流 - CS:APP 第8章"></a>异常控制流 - CS:APP 第8章</h1><blockquote>
<p>这一章更多的是实践，理论的部分实在不多</p>
</blockquote>
<p>本文将介绍：</p>
<ol>
<li>常见的异常</li>
<li>(Linux)部分并发编程</li>
</ol>
<p>一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。</p>
<h2 id="异常及其分类"><a href="#异常及其分类" class="headerlink" title="异常及其分类"></a>异常及其分类</h2><ol>
<li><p>中断 (interrupt) : 异步发生，是来自处理器外部I/O设备的信号的结果</p>
</li>
<li><p>陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过<code>syscall</code> 指令，造成一个到异常处理程序的陷阱。</p>
<p>系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式</p>
</li>
<li><p>故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页</p>
</li>
<li><p>终止 (abort)：不可恢复的错误。</p>
</li>
</ol>
<h2 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h2><p>进程的定义：一个执行中的程序实例</p>
<p>进程提供给程序两个抽象的概念：</p>
<ol>
<li>一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。</li>
</ol>
<p>区分并发和并行：</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>获取进程id</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在linux上，pid_t 被定义为 int</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程pid</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 获得父进程pid</span></span><br></pre></td></tr></table></figure>
<p>进程只有三种状态：</p>
<ol>
<li>运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。</li>
<li>暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。)</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：<ol>
<li>收到一个信号，该信号的默认行为是终止进程</li>
<li>从主程序返回</li>
<li>调用exit函数。</li>
</ol>
</li>
</ol>
<p>创建进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）</span></span><br><span class="line"><span class="comment">子进程与父进程的虚拟地址空间相同，文件描述符相同</span></span><br><span class="line"><span class="comment">该函数返回两次：</span></span><br><span class="line"><span class="comment">在父进程中返回创建子进程的pid</span></span><br><span class="line"><span class="comment">在子进程中返回0</span></span><br><span class="line"><span class="comment">可以依此区分两个进程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>回收僵死进程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pid 等待集合</span></span><br><span class="line"><span class="comment">  pid &gt; 0 一个单独的子进程</span></span><br><span class="line"><span class="comment">  pid = -1 父进程的所有子进程</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">statusp 导致返回的状态信息</span></span><br><span class="line"><span class="comment">options 选项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return :</span></span><br><span class="line"><span class="comment">成功回收：回收进程的pid</span></span><br><span class="line"><span class="comment">WNOHANG 返回0</span></span><br><span class="line"><span class="comment">其他错误 -1 (例如没有子进程)：</span></span><br><span class="line"><span class="comment">如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD</span></span><br><span class="line"><span class="comment">如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">典型用法：waitpid(-1, NULL, 0);</span></span><br><span class="line"><span class="comment">挂起该进程，等待该进程的子进程终止，回收该僵死进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">// 等价于waitpid(-1, &amp;statusp, 0);</span></span><br></pre></td></tr></table></figure>
<p>让进程休眠：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">// 挂起进程secs秒，如果因为信号中断则会提前返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// 挂起进程，因为进程中断会提前返回</span></span><br></pre></td></tr></table></figure>
<p>加载并运行程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename 可执行文件路径，argv参数列表，envp环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">execve调用一次，从不返回，除非找不到可执行文件文件</span></span><br><span class="line"><span class="comment">argv/envp 指向以NULL结尾的指针数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特别强调：</span></span><br><span class="line"><span class="comment">通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种软件层次的异常</p>
<p>发送信号的两个原因：</p>
<ol>
<li>内核检测到一个系统事件，如子进程终止，发送SIGCHLD</li>
<li>一个进程显式地调用了kill函数，向某个进程发送了信号</li>
</ol>
<p>一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此：</p>
<blockquote>
<p>当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。</p>
</blockquote>
<p>为了能方便向大量进程发送信号，Linux提供了进程组这个概念。</p>
<p>进程组相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;    <span class="comment">// 设置pid的进程组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果pid为0，则设置当前的进程</span></span><br><span class="line"><span class="comment">如果pgid为0，则用pid指定的PID作为进程组id</span></span><br><span class="line"><span class="comment">setpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>发送信号</p>
<ol>
<li><p><code>/bin/kill</code> 程序可以手动发送信号</p>
</li>
<li><p>在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。</p>
</li>
<li>kill函数</li>
<li>alarm函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// secs秒后，发送一个SIGALRM信号给调用进程</span></span><br></pre></td></tr></table></figure>
<p>接受处理信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, sighandler handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：</span></span><br><span class="line"><span class="comment">1. 如果handler是SG_IGN,那么忽略类型为signum的信号。</span></span><br><span class="line"><span class="comment">2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。</span></span><br><span class="line"><span class="comment">3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>阻塞 &amp; 解除阻塞信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, sigset *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于sigprocmask的how，有三个选项：</span></span><br><span class="line"><span class="comment">SIG_BLOCK    将set中的信号添加到阻塞集合</span></span><br><span class="line"><span class="comment">SIG_UNBLOCK    将set中的信号从阻塞信号中删除</span></span><br><span class="line"><span class="comment">SIG_SETMASK    将block = set</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>非本地跳转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retrval)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="附：Linux-配置CSAPP库"><a href="#附：Linux-配置CSAPP库" class="headerlink" title="附：Linux 配置CSAPP库"></a>附：Linux 配置CSAPP库</h2><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435">https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/76930507">https://zhuanlan.zhihu.com/p/76930507</a></p>
<p><a href="https://blog.csdn.net/jakejohn/article/details/79825086">https://blog.csdn.net/jakejohn/article/details/79825086</a></p>
<p>第三版CSAPP库 代码下载：<a href="http://csapp.cs.cmu.edu/3e/code.html">http://csapp.cs.cmu.edu/3e/code.html</a></p>
</blockquote>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到     <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>抢占(preempted) 暂时挂起</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>挂起(suspended) </p>
<p>阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>数字在计算机中的表示</title>
    <url>/2023/03/10/%E6%95%B0%E5%AD%97%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><h3 id="无符号数的原码"><a href="#无符号数的原码" class="headerlink" title="无符号数的原码"></a>无符号数的原码</h3><p>即无符号数的二进制表示。</p>
<p>无符号数原码表示的范围从0到2^n^ -1，即{0，1}^w^ → {0，1，…，2^w^ -1}</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>定义</strong></p>
<p>最高有效位权重被解释为负权，其他有效位权重为正权，对于向量$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$ </p>
<p>函数B2T~w~ (Binary to Two’s-complement)为</p>
<p>$B2T_w = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p><strong>补码快速求相反数的方法及证明</strong></p>
<p>所有位全为1的补码的值为-1</p>
<blockquote>
<p>已知 $2^0+2^1+2^2+…+2^n=2^{n+1}-1$ </p>
<p>故$-2^{w-1}+\sum_{i=0}^{w-2}x_i2^i=-2^{w-1}+2^{w-1}-1=-1$ </p>
</blockquote>
<p>推论 快速求一个以补码表示的二进制数的相反数 </p>
<blockquote>
<p>$\bar{x}$ 为一个二进制数的反码</p>
<p>因为 x 与$\bar{x}$ 相加是一个所有位全为1的补码</p>
<p>故，$x+\bar{x}=-1$ </p>
<p>故，$-x=\bar{x}+1$ </p>
<p>结论：要快速求一个补码二进制数的相反数，只需求这个二进制数的反码（包括符号位，或者说补码并没有符号位一说），再加一</p>
</blockquote>
<p><strong>w位补码能表示的范围</strong></p>
<p>一个w位二进制补码的范围：$[-2^{w-1},2^{w-1}-1]$ </p>
<p>以一字节为例，最小的数是 1000 0000 = -128，最大的数是 0111 1111 = 127</p>
<p>最小的负数的相反数是它本身：</p>
<p>$-(-128) = -(1000 0000)=(0111 1111)+1 = (1000 0000)= -128$ </p>
<p><strong>符号扩展</strong></p>
<p>对于一个4位补码， 1001 ，其值为 -7，如果将其扩展到8为，应使用符号扩展：</p>
<p>即 1111 1001 其值为 -7</p>
<blockquote>
<p>符号扩展不改变补码值的证明</p>
<p>对于正数显然成立，对于负数</p>
<p>w位补码为其值为$2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p>符号扩展k位后，w+k位补码的值为</p>
<p>$-2^{w+k-1}+\sum_{i=w}^{w+k-2}2^i+2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p>$=-2^{w+k-1}+\sum_{i=w}^{w+k-2}2^i+2\times 2^{w-1}-2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$</p>
<p>$=2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$</p>
</blockquote>
<h3 id="原码和补码的相互转换"><a href="#原码和补码的相互转换" class="headerlink" title="原码和补码的相互转换"></a>原码和补码的相互转换</h3><ul>
<li>原码转换成补码<br>正数原码转补码：正数的补码，与原码相同，例如，10的原码为00001010，补码也是00001010<br>负数原码转补码：负数的补码：符号位不变，其余各位按位取反，取反后整体加1<br>例如：-10的原码为10001010，符号位不变：1  0001010，其余位按位取反：1  1110101，取反后整体加1：11110101 + 1 = 11110110</li>
<li>补码转换成原码<br>正数补码转原码：补码的符号位为0，表示该补码的原码是一个正数，所以补码就是该数的原码，例如：补码为00001010，它的符号位是0，代表它是一个正数的补码，正数的原码就是补码，反正也成立，所以它的原码是00001010<br>负数原码转补码：补码的符号位为1，表示该补码的原码是一个负数，所以可以这样求负数的原码，符号位不变，其余各位按位取反，然后再整体加1，例如：补码：11110110，符号位不变：1 1110110，其余位按位取反：1 0001001，取反后整体加1：10001001 + 1 = 10001010</li>
</ul>
<h2 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h2><h3 id="浮点数的一般表示"><a href="#浮点数的一般表示" class="headerlink" title="浮点数的一般表示"></a>浮点数的一般表示</h3><blockquote>
<p>参考：</p>
<p><a href="https://baike.baidu.com/item/纯小数补码/6480944">纯小数补码_百度百科 (baidu.com)</a> </p>
<p><a href="https://blog.csdn.net/weixin_44069475/article/details/122560674">纯小数补码学习_小数的补码_月老吃面包的博客-CSDN博客</a> </p>
<p><a href="https://www.jianshu.com/p/4f8a1dc94e4f">浮点数的一般表示 - 简书 (jianshu.com)</a> </p>
<p>一般会用补码表示浮点数的尾数，但网络上关于纯小数补码表示的讲解甚少。上课的时候老师也讲的不是很明白，因此花了好长时间查找资料。（百度还是比Bing能搜出来更有用的东西的！）</p>
</blockquote>
<p>浮点数一般表示方法如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>阶码和尾数既可以用原码也可以用补码表示。</p>
<blockquote>
<p>补充：有符号定点小数的表示</p>
<p>有符号定点小数有一个符号位，小数点隐含在符号位之后，小数点之后的数叫做尾数。有符号定点小数既可以用原码表示，也可以用补码表示。原码情况下，通常表示为<code>s.010101...</code> 其中s为符号位，010101…为尾数。</p>
<hr>
<p>至于有符号定点小数的补码表示，首先要介绍补码的原理与作用，才能更好地理解有符号定点小数的补码表示。下面首先讨论有符号整数的补码表示</p>
<p>在介绍补码概念之前，先介绍一下“模”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+12-2(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。若用一般公式可表示为：a-b=a-b+mod=a+mod-b。对“模”而言，2和10互为补数。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性，共同的特点是两者相加等于模。</p>
<p>补码的作用是化减法为加法：对于任何一个有模（mod）的计量系统，都可以化减法为加法。例如，将处在6点的钟表时针向后拨2点（减二），也可以将它向前拨10点（加十）。之所以可以这么做，就是因为-2与10关于12同余。对于一个n为二进制的计量系统，它的模（mod）为 2^n^ 。</p>
<p>补码的原理是数学上的同余关系，若 (a - b) / m能够得到一个整数，或者说 (a - b) 能够被 m 整除，就说 a 与 b关于m同余，记作<code>a≡b(mod m)</code>。对于n 位定点整数（以n = 4为例），负数的原码关于其补码关于2^n^ 同余，例如原码<code>1011</code> (十进制下为-3)，其补码<code>1101</code> （按照原码的解释方法，其真值为13），它们关于 2^4^ 同余（<code>13-(-3)=16</code>,16可以被2^4^ 整除）。</p>
<p>这也是为什么要取一个负数的补码，需要对它除了符号位以外的数按位取反再加1。（为什么补码的取法是按位取反再加一，以四位二进制数为例，四位二进制数的模为16，即<code>1111 + 0001</code>，<code>-0011</code> 表示-3。根据同余的定义，<code>(a-b)/m</code> 是一个整数，我们假设它为1，则有<code>a-b=m</code> ，则有<code>xxxx - (-0011)= 1111 + 0001</code>） 即，<code>xxxx = 1111-0011 + 0001</code> 而<code>1111-0011</code>的作用就是按位取反，因此补码的计算方法为对符号位意外的数按位取反再加一。补码的计算方法也可以简述为进制能表示的最大的数减去原码再加一）</p>
<hr>
<p>以上的讨论都是基于定点整数，下面我们来讨论有符号定点小数的补码表示</p>
<hr>
<p>定点纯小数计量系统的模为1，因此对于一个负数-x以及它的补码xc，有<code>xc - (-x) = mod, xc = mod - x = 1 - x</code> ，因此要求一个负小数的补码，可以将这个数在十进制下加一，再转换成二进制原码。例如-7/8，加1为1/8，1/8 转换成二进制得到 1001。</p>
<p>另一种更直接的获得负小数补码的方式是，将除符号位以外的位，按位取反，再加上 “1”。这里的“1”，并不是数值上的1，而是在最低位加1。例如，要求<code>-7/8</code>的补码，首先将其转化为原码表示，即<code>1111</code> (或写成<code>1.111</code>，有符号定点小数的小数点隐含在符号位之后) 。要求其补码，将处符号位以外的数按位取反，得到<code>1000</code> （或写成<code>1.000</code>）,再在最低为加1，得到<code>1001</code>(或写成<code>1.001</code>) </p>
<hr>
<p>对于一个负小数的补码  $sd_1d_2d_3…d_i$  或写成 $s.d_1d_2d_3…d_i$，它的每一个位可以这样解释，符号位解释为 s×-2^0^ （即s×1），数值位解释为 $d_i\times 2^{-i} (i=1,2,3,…) $。</p>
<p>它的真值为  $s\times (-2^0) + \sum_{i=1}^{n}d_i\times2^{-i} $ </p>
<hr>
<p>对于n+1位有符号定点小数（n=8）</p>
<p>原码表示的最大和最小定点小数</p>
<p>最大正数<code>0.1111 1111</code> ：1-2^-n^ </p>
<p>最小正数<code>0.0000 0000</code> : 0</p>
<p>最大负数<code>1.0000 0000</code> : 0</p>
<p>最小负数<code>1.1111 1111</code> ：-(1-2^-n^ ) </p>
<p>补码表示的最大和最小顶点小数</p>
<p>最大正数<code>0.1111 1111</code> ：1-2^-n^ </p>
<p>最小正数<code>0.0000 0000</code> : 0</p>
<p>最大负数<code>1.1111 1111</code>：-(1-2^-n^)  </p>
<p>最小负数<code>1.0000 0000</code> ：-1 </p>
</blockquote>
<p>浮点数的阶码和尾数，既可以使用原码表示，也可以使用补码表示。</p>
<p>例如，浮点数 <code>25.125</code>，其原码的二进制表示为$11001.001 = 1.1001001 × 2^4$ </p>
<p>如果用16位来表示这个浮点数，它的存储方式如下（阶码、尾数均为原码表示）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符（1bit）</th>
<th>阶码 (5bit)</th>
<th>数符(1bit)</th>
<th>尾数(9bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0 0100</td>
<td>1</td>
<td>1 0010 0100</td>
</tr>
</tbody>
</table>
</div>
<p>为了提高精度，充分利用尾数的每一位，规格化浮点数应运而生。规格化浮点数的特点是尾数位最高有效位应为1。这样可以提高数据表示的精度，避免尾数位的浪费。</p>
<p>例如，对于原码表示的浮点数，<code>1.100</code>为规格化浮点数，因为其尾数位最高位为1。</p>
<p>对于补码表示的浮点数，<code>0.100</code>，它为规格化浮点数，因为其尾数位最高位为1。</p>
<p>但对于用补码表示的负小数，情况则不同。例如<code>1.110</code>它就不是规格化浮点数，其最高位虽然是1，但负数从原码转换成补码中，有一个按位取反的操作，在按位取反时，0变成了1。因此，对于补码<code>1.110</code>其转换成原码为<code>1.010</code> 显然它不是规格化浮点数。综上，对于用补码表示的负小数，其尾数为的最高有效位应该为0。</p>
<p>对上面的规则进行归纳，可得到对于规格化浮点数的如下规则：</p>
<blockquote>
<p>当尾数为原码时，最高有效位必须为1</p>
<p>当尾数为补码时，尾数的最高位必须与符号位相反。即对于正数，最高有效位必须为1，对于负数，最高有效位必须为0。因为在负数的补码中，数值位的0相当于原码的1的作用。</p>
</blockquote>
<p>获得规格化浮点数的方法：</p>
<ul>
<li>左规，尾数左移一位，阶码-1</li>
<li>右规，尾数右移一位，阶码+1</li>
</ul>
<p>例如，浮点数 <code>25.125 = 1.1001001 × 2^4</code> 将其右规后，得到<code>0.11001001 × 2^5</code> </p>
<p>表示为（阶码、尾数均为原码表示）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符（1bit）</th>
<th>阶码 (5bit)</th>
<th>数符(1bit)</th>
<th>尾数(9bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0 0101</td>
<td>0</td>
<td>1 1001 0010</td>
</tr>
</tbody>
</table>
</div>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><blockquote>
<p>IEEE 读作 eye-triple-ee</p>
</blockquote>
<p>IEEE 754是一种表示浮点数的标准，它以这种格式表示浮点数</p>
<p>$V=(-1)^s\times M\times 2^E$ </p>
<p>其中s表示符号位</p>
<p>M，表示尾数；E表示阶码。</p>
<p>在IEEE 754中，有三种浮点数，分别是32位的单精度浮点数 float，和64位双精度浮点数double，以及80位浮点数，这里只介绍float 和double。</p>
<p>float 有1位符号位，8位阶码，23位尾数，</p>
<p>double 有1位符号位，11位阶码，52位尾数。</p>
<p>IEEE 754 有三种浮点数 它们分别是：规格化数，非规格化数和特殊值。</p>
<h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><blockquote>
<p>规格化数的定义是浮点数的一种表示方式，使得尾数的最高有效位总是1。这样可以省略这一位，增加尾数的精度。规格化数有一个隐含的整数位1，所以尾数的范围是[1, 2)。</p>
</blockquote>
<p>在规格化数中，阶码不能全为0，也不能全为1。例如，有4位阶码，那么最小的阶码位0001，最大的阶码为1110。</p>
<p>指数 E的计算方式如下，在规格化数中，E = e - Bias，其中 e 是阶码的值，Bias是偏置值，对于一个k位长度的阶码，Bias的大小等于$2^{k-1}-1$。</p>
<p>M的大小位1 + 尾数表示的值。通过省略前置的1，可以多获得一个位来表示尾数，这个被省略的1也叫做隐含的1。 </p>
<p>对于一个32位浮点数</p>
<p>绝对值最小的规格化数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>阶码</th>
<th>尾数</th>
<th>val</th>
</tr>
</thead>
<tbody>
<tr>
<td>绝对值最小的规格化数</td>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000</td>
<td>$2^{1-127}\times1.0=2^{-126}$</td>
</tr>
<tr>
<td>绝对值最大的规格化数</td>
<td>0</td>
<td>1111 1110</td>
<td>1111 1111 1111 1111 1111 111</td>
<td>$2^{254-127}\times1.9999 = 2^{127}\times 1.9999$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><blockquote>
<p>根据我从网络上找到的信息，非规格化数是一种特殊的浮点数，它的指数位全为0，尾数位前没有隐含的1。非规格化数用于表示0和非常靠近0的数²³。</p>
</blockquote>
<p>非规格化数的阶码全为0，此时 E = 1 - Bias, M = 尾数表示的二进制数</p>
<p>非规格化数的左右有2：</p>
<ol>
<li>表示0，规格化数的M处于 1~2之间，无法表示 0，而非规格化数只要令尾数为0，就可以表示0了。注意，非规格化数有+0.0与-0.0。</li>
<li>非规格化数可以相对均匀地表示十分接近于0的数。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>阶码</th>
<th>尾数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>绝对值最小的非规格化数</td>
<td>0</td>
<td>0000 0000</td>
<td>0000 0000 0000 0000 0000 000</td>
<td>0</td>
</tr>
<tr>
<td>绝对值最大的非规格化数</td>
<td>0</td>
<td>0000 0000</td>
<td>1111 1111 1111 1111 1111 111</td>
<td>$2^{1-127}\times0.9999=2^{-126}\times0.9999$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><h4 id="关于增长的均匀"><a href="#关于增长的均匀" class="headerlink" title="关于增长的均匀"></a>关于增长的均匀</h4><p>对于规格化数，其尾数每增长1，尾数绝对值增长<code>(0.0000 0000 0000 0000 0000 001)B</code> 而当尾数到达1，则会进位。实际的值的大小 = 尾数乘以2^E^ ，随着E的增长，浮点数的值的增长速度也会变快，但E不变时，浮点数的增长就是均匀的。  </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="C-语言中的右移操作"><a href="#C-语言中的右移操作" class="headerlink" title="C 语言中的右移操作"></a>C 语言中的右移操作</h3><p><code>x &gt;&gt; k</code> 右移，分为逻辑右移和算数右移，</p>
<p>逻辑右移在高有效位端补k个0，用于无符号数；</p>
<p>算数右移在最高有效位端补k个最高有效位的值，用于有符号数。</p>
<h3 id="New-Bing-关于纯小数的补码表示"><a href="#New-Bing-关于纯小数的补码表示" class="headerlink" title="New Bing 关于纯小数的补码表示"></a>New Bing 关于纯小数的补码表示</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303121314551.png" alt="image-20230312131442881"> </p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>数字逻辑课程</title>
    <url>/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数字逻辑"><a href="#数字逻辑" class="headerlink" title="数字逻辑"></a>数字逻辑</h1><h2 id="第一章-逻辑代数基础"><a href="#第一章-逻辑代数基础" class="headerlink" title="第一章 逻辑代数基础"></a>第一章 逻辑代数基础</h2><h3 id="1-1-布尔代数"><a href="#1-1-布尔代数" class="headerlink" title="1.1 布尔代数"></a>1.1 布尔代数</h3><p>也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。</p>
<p>· + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。</p>
<blockquote>
<p>虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。</p>
</blockquote>
<p>· 即合取，可以像乘号一样省略。</p>
<p>逻辑代数公理：</p>
<ol>
<li><p>0 - 1 律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + 0 = A</span><br><span class="line">A + 1 = 1</span><br><span class="line">A · 0 = 0</span><br><span class="line">A · 1 = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>重叠律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + A = A</span><br><span class="line">A · A = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>互补律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + ┐A = 1</span><br><span class="line">A · ┐A = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对合律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">┐┐A = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>交换律</p>
</li>
<li><p>结合律</p>
</li>
<li><p>分配律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A · (B + C) = AB + AC  与对或的分配</span><br><span class="line">A + BC = (A + B)(A + C) 或对与的分配</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1-2-逻辑函数"><a href="#1-2-逻辑函数" class="headerlink" title="1.2 逻辑函数"></a>1.2 逻辑函数</h3><p><strong>定义:</strong> 从n个逻辑变量到01的映射。记为F = f(A1, A2, A3 … )</p>
<p>逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式）</p>
<h4 id="1-2-1-三种表示法："><a href="#1-2-1-三种表示法：" class="headerlink" title="1.2.1 三种表示法："></a>1.2.1 三种表示法：</h4><ol>
<li><p>逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成</p>
</li>
<li><p>真值表</p>
</li>
<li><p>卡诺图</p>
<p>用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。</p>
<blockquote>
<p>挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-2-两种标准形式"><a href="#1-2-2-两种标准形式" class="headerlink" title="1.2.2 两种标准形式"></a>1.2.2 两种标准形式</h4><p><strong>最小项表达式：</strong>也叫积之和范式 或 主析取范式</p>
<p>最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。</p>
<p>最小项的表示：</p>
<p>对于n个变量而言，可以构成2的n次方个最小项。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。</p>
<blockquote>
<p>对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 m~i~ 来表示这个最小项表达式。</p>
<p>Q：为什么要使用1代表原变量，用0代表反变量？</p>
<p>A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi = 1，而且这是唯一的。</p>
<p>例如m6 = AB┐C，其顺序为110B = 6D，令对应的逻辑变量为1或0，则m6 = 1 · 1 · (┐0) = 1</p>
</blockquote>
<p>例如，最小项表达式 AB, 转换成二进制即11，表示为m3。</p>
<p>最小项表达式A┐B，转换成二进制即10，表示为m2。</p>
<p>最小项的性质：</p>
<ul>
<li>对于任意一个最小项，只有一组变量取值可以使其值为1</li>
<li>任意两个最小项之积为0</li>
<li>n个变量的所有2^n^ 个最小项之和为1</li>
</ul>
<p>将任意表达式转换为最小项表达式：</p>
<p>利用公式<code>A = A(B + ┐B)</code> </p>
<p>最小项表达式的性质：</p>
<ul>
<li>性质1：若m~i~是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi=1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。</li>
<li>性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F=F1+F2 将包括 F1 和 F2 中的所有最小项， G=F1·F2 将包括 F1 和 F2 中的公有最小项。 </li>
<li>性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成</li>
</ul>
<blockquote>
<p>思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式</p>
<p>使用归谬法证明</p>
</blockquote>
<p><code>第一次课到此结束</code> </p>
<p><strong>最大项表达式：</strong> 也叫和之积范式或主合取范式</p>
<p>定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。</p>
<p>举例：</p>
<p>二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B)</p>
<p>三变量最大项表达式：</p>
<p>最大项表达式的三条性质类似最小项表达式的三条性质：</p>
<ol>
<li>对于任意一个最大项，只有一组变量取值可使其值为0。</li>
<li>任意两个最大项 Mi 和 Mj 之和必为1。</li>
<li>n 变量的所有2^n^ 个最大项之积必为0。</li>
</ol>
<p>最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。</p>
<p>任意逻辑表达式转换成最大项表达式：</p>
<p>先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。</p>
<blockquote>
<p>类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。</p>
<p>AB + A┐B, 而这种表达式被称为 “与 - 或”表达式</p>
</blockquote>
<p>最大项表达式的性质也与最小项表达式类似：</p>
<ul>
<li>性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi=0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 </li>
<li>性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F=F1+F2将包括F1和F2中的公有最大项， G=F1·F2将包括F1和F2中的所有最大项。 </li>
<li>性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。</li>
</ul>
<h4 id="1-2-3-逻辑函数的三种表示法的关系"><a href="#1-2-3-逻辑函数的三种表示法的关系" class="headerlink" title="1.2.3 逻辑函数的三种表示法的关系"></a>1.2.3 逻辑函数的三种表示法的关系</h4><p>用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。</p>
<p>同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。</p>
<p>从上一节的学习，我们知道逻辑函数有三种表示法：</p>
<blockquote>
<ol>
<li><p>逻辑表达式</p>
</li>
<li><p>真值表</p>
</li>
<li><p>卡诺图</p>
</li>
</ol>
</blockquote>
<p>首先，逻辑表达式形式都可以化成标准形式。</p>
<p>接着我们来看真值表与逻辑表达式的关系（最大/小项表达式也是逻辑表达式）：</p>
<p>还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。</p>
<p>最大项表达式与最小项表达式恰恰相反：</p>
<p>最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。</p>
<p>最后我们来看一下卡诺图与真值表的关系：</p>
<p>卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">——————————————</span><br><span class="line">A  B	|	F</span><br><span class="line">——————————————</span><br><span class="line">0  0	|	0</span><br><span class="line">0  1	|	1</span><br><span class="line">1  0	|	1</span><br><span class="line">1  1	|	0</span><br><span class="line">——————————————</span><br></pre></td></tr></table></figure>
<p>它是一维的 线性的。</p>
<p>而卡诺图则二维的：</p>
<p>将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241752070.png" alt="image-20220824175139560"> </p>
<p>将项的组合换成数字的组合，我们得到卡诺图的简化形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241752221.png" alt="image-20220824175241939"> </p>
<p>需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。</p>
<p>下面给出一个逻辑函数的卡诺图表示的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241754925.png" alt="image-20220824175443316"> </p>
<blockquote>
<p>补充：格雷码</p>
<p><a href="https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858">https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858</a></p>
<p>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。</p>
<p><strong>递归生成码表</strong></p>
<p>这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造：</p>
<ol>
<li>1位格雷码有两个码字</li>
<li>(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0</li>
<li>(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] </li>
<li>n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>2位格雷码</th>
<th>3位格雷码</th>
<th>4位格雷码</th>
<th>4位自然二进制码</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>000</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>01</td>
<td>001</td>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>11</td>
<td>011</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>10</td>
<td>010</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td></td>
<td>110</td>
<td>0110</td>
<td>0100</td>
</tr>
<tr>
<td></td>
<td>111</td>
<td>0111</td>
<td>0101</td>
</tr>
<tr>
<td></td>
<td>101</td>
<td>0101</td>
<td>0110</td>
</tr>
<tr>
<td></td>
<td>100</td>
<td>0100</td>
<td>0111</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1100</td>
<td>1000</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1101</td>
<td>1001</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1111</td>
<td>1010</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1110</td>
<td>1011</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1010</td>
<td>1100</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1011</td>
<td>1101</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1001</td>
<td>1110</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1000</td>
<td>1111</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p><code>第二次课结束</code> </p>
<h3 id="1-3-主要定理-amp-常用公式"><a href="#1-3-主要定理-amp-常用公式" class="headerlink" title="1.3 主要定理 &amp; 常用公式"></a>1.3 主要定理 &amp; 常用公式</h3><h4 id="1-3-1个主要定理"><a href="#1-3-1个主要定理" class="headerlink" title="1.3.1个主要定理"></a>1.3.1个主要定理</h4><p><strong>德摩根律：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282109984.png" alt="image-20220828210855685"> </p>
<ul>
<li>当变量个数较少的时候，可以使用真值表法证明。</li>
<li>当变量较多的时候，使用数学归纳法证明。</li>
</ul>
<p><strong>香农定理：</strong> 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220828211532973.png" alt="image-20220828211532973"> </p>
<p>注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。</p>
<p><strong>对偶定理:</strong> </p>
<p>对偶函数的定义：</p>
<blockquote>
<p>将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数</p>
<p>设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) </p>
<p>则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) = f (x1, x2, … , xn, 1, 0, ·, 1) </p>
</blockquote>
<p>对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282126050.png" alt="image-20220828212559479"> </p>
<p>两个推论：</p>
<ol>
<li>原函数与其对偶函数互为对偶函数。</li>
<li>两个相等的函数（f = g）的对偶函数必定相等（f ‘ = g ‘）</li>
</ol>
<p>自对偶函数：一个函数的对偶函数等于它自己。</p>
<p><strong>展开定理：</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282130528.png" alt="image-20220828213000128"></p>
<p>两个推理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282130610.png" alt="image-20220828213053195"> </p>
<p>展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16</p>
<h4 id="1-3-2-5个常用公式"><a href="#1-3-2-5个常用公式" class="headerlink" title="1.3.2 5个常用公式"></a>1.3.2 5个常用公式</h4><ol>
<li><p>AB + A┐B = A</p>
<p>在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。</p>
</li>
<li><p>A + AB = A</p>
<p>在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。</p>
<p>还可以写成ABC + ABCDE = ABC</p>
</li>
<li><p>A + ┐AB = A + B</p>
<p>在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。</p>
<p>┐C + CE = ┐C + E</p>
</li>
<li><p>AB + ┐AC + BC = AB + ┐AC</p>
<p>包含律</p>
<p>在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。</p>
<p>AB + ┐AC + BCDE = AB + ┐AC</p>
</li>
<li><p>┐(A┐B + ┐AB) = ┐A┐B + AB</p>
<p>两个变量的异或的反   是  两个变量的同或</p>
</li>
</ol>
<p>上面5个公式的对偶形式也是成立的</p>
<h4 id="1-3-3-异或的性质"><a href="#1-3-3-异或的性质" class="headerlink" title="1.3.3 异或的性质"></a>1.3.3 异或的性质</h4><p>A ⊕A = 0</p>
<p>A⊕┐A = 1</p>
<p>A⊕0 = A</p>
<p>A⊕1 = ┐ A   重要</p>
<p>A⊕┐ B = A ⊙ B = A⊕B⊕1</p>
<p>A⊕B = B⊕A 交换律</p>
<p>A⊕(B⊕C) = （A⊕B) ⊕C 结合律</p>
<p>A(B⊕C) = AB⊕AC  分配律</p>
<p><code>第三次课到此结束</code></p>
<h4 id="1-3-4-应用"><a href="#1-3-4-应用" class="headerlink" title="1.3.4 应用"></a>1.3.4 应用</h4><p>一、转化称其他形式（详见P20）</p>
<ol>
<li><p>“与或” 表达式转 “或与”表达式</p>
<p>法一：分配律</p>
<p>法二：展开定理</p>
</li>
<li><p>“与或” 表达式 转 “与非 - 与非” 表达式</p>
<blockquote>
<p>“与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式</p>
</blockquote>
<p>或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可</p>
<p>因此我们的步骤是：两次取反，内层非用德摩根律断开</p>
</li>
<li><p>“与或” 表达式 转 “或非 - 或非” 表达式</p>
<blockquote>
<p> “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式</p>
</blockquote>
<p>首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开</p>
</li>
</ol>
<p>二、最大项表达式和最小项表达式的关系</p>
<p>┐mi = Mi 或 mi = ┐Mi</p>
<p>mi’ = Mj，且i + j = 2 ** n - 1</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208292300304.png" alt="image-20220829230044488"> </p>
<p>原函数</p>
<p>​    — 变换 —&gt;</p>
<p>最小项表达式</p>
<p>​    — 一次取反 —&gt;</p>
<p>符号错开，但保持最小项表达式，反函数的最小项表达式</p>
<p>或</p>
<p>或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式</p>
<p>​    — 二次取反 —&gt;</p>
<p>原函数的最大项表达式（和原函数最小项表达式符号错开）</p>
<p>将最大项表达式或最小项表达式变成对偶函数：</p>
<p>首先将最大项变成最小项，或最小项变成最大项</p>
<p>其次将序号变成互补的序号</p>
<h3 id="1-4-逻辑函数的化简"><a href="#1-4-逻辑函数的化简" class="headerlink" title="1.4 逻辑函数的化简"></a>1.4 逻辑函数的化简</h3><blockquote>
<p>逻辑函数最简式的定义：</p>
<ol>
<li>该式中乘积项最少</li>
<li>该式中的乘积项不能再用变量更少的乘积项代替</li>
</ol>
</blockquote>
<p>化简方法:</p>
<ol>
<li>代数方法</li>
<li>卡诺图法</li>
<li>列表化简法</li>
</ol>
<h4 id="1-4-1-卡诺图法"><a href="#1-4-1-卡诺图法" class="headerlink" title="1.4.1 卡诺图法"></a>1.4.1 卡诺图法</h4><p><code>第四次课到此结束</code> </p>
<p>基本原理：ABC + ┐ABC = (A + ┐A)BC = BC</p>
<p>反映在卡诺图上，就是相邻的两个格可以构成一个圈。</p>
<blockquote>
<p>n变量的卡诺图，任何2^m^ 个标1的相邻单元可以形成一个圈，改圈所代表的乘积项由n-m个变量组成，可以消去m个变量。</p>
</blockquote>
<p>名词解释：</p>
<p>蕴含项：最小项，以及2^m^ 个相邻单元所形成的圈组成的项。</p>
<p>素项：不是其他蕴含项子集的蕴含项。</p>
<p>实质素项：包含某一最小项，该最小项只被该素项包含。</p>
<p>化简方法：</p>
<ol>
<li><p>作出卡诺图，找出全部素项</p>
</li>
<li><p>找出全部实质素项</p>
</li>
<li><p>若有未被覆盖的最小项，找出一个可以包含该最小项的蕴含项，将其添加到实质素项集合中。</p>
<p>得到的集合，写成代数形式，即是化简结果。</p>
</li>
</ol>
<h2 id="第二章-组合电路的分析"><a href="#第二章-组合电路的分析" class="headerlink" title="第二章 组合电路的分析"></a>第二章 组合电路的分析</h2><h3 id="2-1-各种门电路"><a href="#2-1-各种门电路" class="headerlink" title="2.1 各种门电路"></a>2.1 各种门电路</h3><p>或门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201250943.png" alt="image-20220920125054365"> </p>
<p>与门<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251279.png" alt="image-20220920125108982"></p>
<p>非门<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251712.png" alt="image-20220920125121515"></p>
<p>与非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251840.png" alt="image-20220920125145303"></p>
<p>或非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201252721.png" alt="image-20220920125247085"></p>
<p>与或非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201252761.png" alt="image-20220920125206325"></p>
<p>异或门</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220920125225775.png" alt="image-20220920125225775"></p>
<p>三态门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201254104.png" alt="image-20220920125344236"></p>
<p>三态门真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
<th>A</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>任意</td>
<td>高阻抗</td>
</tr>
</tbody>
</table>
</div>
<p><code>第五次课结束</code></p>
<h3 id="2-2-门电路的主要参数以及组合电路的分析方法"><a href="#2-2-门电路的主要参数以及组合电路的分析方法" class="headerlink" title="2.2 门电路的主要参数以及组合电路的分析方法"></a>2.2 门电路的主要参数以及组合电路的分析方法</h3><p>门电路的主要参数：</p>
<ul>
<li><p>标称逻辑电平：表示逻辑值01的理想电平</p>
</li>
<li><p>扇入系数：门电路允许的输入端数目</p>
<p>若使用的输入端数目比扇入系数小，则多余的输入端再不改变电路逻辑功能的情况下接高电平或低电平</p>
</li>
<li><p>扇出系数：一个门电路输出端所连接的下一级输入端的个数</p>
</li>
<li><p>平均时延</p>
</li>
</ul>
<p>组合电路的分析方法：</p>
<ol>
<li>给定组合线路</li>
<li>列写逻辑表达式</li>
<li>列真值表</li>
<li>指出线路的逻辑功能</li>
<li>对线路进行评价和改进</li>
</ol>
<h3 id="2-3-全加器"><a href="#2-3-全加器" class="headerlink" title="2.3 全加器"></a>2.3 全加器</h3><p>符号表示：</p>
<ul>
<li>A 被加数</li>
<li>B 加数</li>
<li>C~i-1~ 低位向高位的进位</li>
<li>S 和</li>
</ul>
<p>全加器的逻辑符号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201303019.png" alt="image-20220920130348535"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201304218.png" alt="image-20220920130415100"></p>
<p>S = A⊕B⊕C~i-1~</p>
<p>​    = ∑(1, 2, 4, 7)</p>
<p>C = AB+(A⊕B)C~i-1~<br>    = AB+(A+B)C~i-1~ </p>
<p>​    = ∑(3, 5, 6, 7)</p>
<h3 id="2-4-译码器"><a href="#2-4-译码器" class="headerlink" title="2.4 译码器"></a>2.4 译码器</h3><p>几种常见的十进制数在二进制下的编码：</p>
<ul>
<li><p>8421码：顾名思义，就是十进制数转直接转换成二进制数（范围是0000-1001）</p>
</li>
<li><p>格雷码：相邻的格雷码只有一个位不同</p>
<p>8421转格雷码：G~i~=B⊕B~i+1~ (i &lt;= n-1);  G~i~ = B~i~ (i = n)</p>
</li>
<li><p>余三码：8421码+3得到余三码（范围是0011-1100）</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>十进制数</th>
<th>8421</th>
<th>格雷码</th>
<th>余三码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
<td>0011</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
<td>0100</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0011</td>
<td>0101</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0010</td>
<td>0110</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>0111</td>
<td>1000</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>0101</td>
<td>1001</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>0100</td>
<td>1010</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1100</td>
<td>1011</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1101</td>
<td>1100</td>
</tr>
</tbody>
</table>
</div>
<p><code>第五次课结束</code> </p>
<p>不同的译码器：</p>
<p>三位译八位译码器（多一译码）：从三位二进制数中，翻译出他们的最小项表达式。</p>
<blockquote>
<p>高电平译重：翻译出来的那个最小项的电平是高电平</p>
<p>低电平译重：翻译出来的最小项的电平是低电平</p>
<p>如果使用与非门实现译码器，使用低电平译重可以节省非门</p>
</blockquote>
<h3 id="2-5-格雷码转8421码："><a href="#2-5-格雷码转8421码：" class="headerlink" title="2.5.格雷码转8421码："></a>2.5.格雷码转8421码：</h3><p>利用异或的性质，一个逻辑表达式异或同一个逻辑表达式两次，等于原逻辑表达式</p>
<p>已知从8421码到格雷码的转换有：</p>
<p>G0 = B0 ⊕ B1</p>
<p>G1 = B1 ⊕ B2</p>
<p>G2 = B2 ⊕ B3</p>
<p>G3 = B3</p>
<p>则根据异或的性质</p>
<blockquote>
<ol>
<li><p>B3 = G3                    已知</p>
</li>
<li><p>G2 = B2 ⊕ B3         已知</p>
</li>
<li><p>G2 = B2 ⊕ G3        （2）</p>
</li>
<li>G3 ⊕ G2 = B2 ⊕ G3 ⊕ G3    两边同时异或G3</li>
<li>B2 = G2 ⊕ G3        异或的性质，消去两个G3</li>
</ol>
</blockquote>
<p>于是我们有：</p>
<p>从格雷码到8421码：</p>
<p>B3 = G3    </p>
<p>B2 = G2 ⊕ G3 </p>
<p>B1 = G1 ⊕ G2 ⊕ G3 </p>
<p>B0 = G0 ⊕ G1 ⊕ G2 ⊕ G3 </p>
<h3 id="2-6-奇偶校验器"><a href="#2-6-奇偶校验器" class="headerlink" title="2.6 奇偶校验器"></a>2.6 奇偶校验器</h3><p>分为奇校验和偶校验：</p>
<p>我们有一个n位二进制数和一个校验位p</p>
<p>奇校验：n位二进制数和p中，1的个数是奇数</p>
<p>偶校验：n位二进制数和p中，1的个数是偶数</p>
<p>奇偶校验的原理：</p>
<p>n个二进制数异或，如果他们中1的数目是奇数，则结果为1</p>
<blockquote>
<p>这个原理可以使用数学归纳法证明</p>
</blockquote>
<p>一个逻辑变量异或1等于它的非</p>
<p>一个逻辑变量异或0等于它本身</p>
<p>下面以奇校验为例：</p>
<p>生成校验位:</p>
<p>p = B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ 1</p>
<p>校验</p>
<p>is_valid = B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ P</p>
<p>偶校验</p>
<p>p = B8 ⊕B4 ⊕B2 ⊕B1</p>
<p>校验</p>
<p>is_valid = B8 ⊕B4 ⊕B2 ⊕B1⊕p⊕1</p>
<h2 id="第三章-组合线路的设计"><a href="#第三章-组合线路的设计" class="headerlink" title="第三章 组合线路的设计"></a>第三章 组合线路的设计</h2><p>设计流程：</p>
<ol>
<li>确定逻辑功能</li>
<li>列真值表（也就得到了最小项表达式）</li>
<li>根据卡诺图化简逻辑表达式</li>
<li>按照设计要求变换逻辑表达式</li>
<li>考虑工程问题</li>
</ol>
<h3 id="3-1-逻辑函数的变换"><a href="#3-1-逻辑函数的变换" class="headerlink" title="3.1 逻辑函数的变换"></a>3.1 逻辑函数的变换</h3><p>与或变与非：</p>
<ol>
<li>两次取反，中间DM断开</li>
<li>对F的反函数，三次取反（可以理解为四次取反，怎样好用用那个）</li>
</ol>
<p>与或非：</p>
<ol>
<li>两次取反，不断开</li>
<li>对反函数一次取反</li>
</ol>
<p>或非</p>
<ol>
<li><p>首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开</p>
</li>
<li><p>首先将原函数转换成其对偶函数，再将对偶函数化成最小项表达式，两次取反转换成与非形式</p>
<p>在进行一次对偶，变回原函数，得到或非形式</p>
</li>
</ol>
<p><code>第六次课结束</code> </p>
<h3 id="3-2-利用任意项的线路设计"><a href="#3-2-利用任意项的线路设计" class="headerlink" title="3.2 利用任意项的线路设计"></a>3.2 利用任意项的线路设计</h3><p>任意项定义：是的约束方程推的逻辑值为0的最小项，也称无关项。</p>
<blockquote>
<p>任意项再当前约束条件下的逻辑值必定为0，因此我们将任意项和原函数进行或运算，不影响原函数的取值。</p>
</blockquote>
<p>任意项在卡诺图或真值表中，用φ表示，将它在卡诺图中画出来可以方便形成更大的圈，从而简化得到的逻辑表达式。但我们使用真值表化简带有任意项的逻辑函数时，不必考虑任意项是否被圈全部包含，只需要考虑逻辑函数的最小项。</p>
<h3 id="3-3-多输出函数的线路设计（需要考虑共享项）"><a href="#3-3-多输出函数的线路设计（需要考虑共享项）" class="headerlink" title="3.3 多输出函数的线路设计（需要考虑共享项）"></a>3.3 多输出函数的线路设计（需要考虑共享项）</h3><p>当我们有多个逻辑函数，共享输入时，我们需要从全局出发考虑，看是否有可以共享的项目，从而减少要使用的逻辑器件。</p>
<p>考虑共享项的最小覆盖修改原则：</p>
<ol>
<li><p>若F~i~的一个素项B~k~也是F~j~的一个素项，则B~k~不作修改，除非修改后能减少总圈数。</p>
</li>
<li><p>若B~i~、B~j~分别是F~i~、F~j~的素项，且B~i~、B~j~都包含一个蕴涵项B~k~,在选取B~k~后，B~i~、B~j~中余下的最小项均分别包含在F~i~、F~j~其它素项中，则在F~i~、F~j~中改选B~k~ </p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202210031001060.png" alt="image-20221003100116410"> </p>
</li>
<li><p>F~i~的一个素项B~i~，中的一些最小项分别被F~j~, F~j+1~, … , F~j+m~中的素项B~j~, B~j+1~ , … , B~j+m~覆盖，且B~j~, B~j+1~, … , B~j+m~  ⊆ B, 若在F~i~中选取B~j~,B~j+1~, …, B~j+m~ 后，B~i~中余下的最小项均包含在的其它素项中，则将B~i~改选为B~j~, B~j+1~, …, B~j+m~ </p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202210031008326.png" alt="image-20221003100828764"></p>
</li>
</ol>
<p><code>第七次课到此结束</code> </p>
<h3 id="3-4-应用MSI功能块的组合线路设计"><a href="#3-4-应用MSI功能块的组合线路设计" class="headerlink" title="3.4 应用MSI功能块的组合线路设计"></a>3.4 应用MSI功能块的组合线路设计</h3><p>SSI：小规模集成电路</p>
<p>MSI：中规模集成电路</p>
<ul>
<li><p>利用数据多路选择器进行设计</p>
<p>首先要知道数据多路选择器的原理</p>
<p>f = a~0~┐x~0~┐x~1~ +  a~1~┐x~0~x~1~ + a~2~x~0~┐x~1~ + a~3~x~0~x~1~ </p>
<p>设计步骤：</p>
<ol>
<li><p>首先，对于给定n变量的逻辑函数，我们选择N = 2^n-1^ 路数据选择器</p>
</li>
<li><p>选定n-1个变量作为地址输入，作为数据选择器的控制端，根据选择的地址输入，确定数据选择器输入端的各表达式输入</p>
<p>对于如何确定数据选择器输入端的各表达式，我们可以使用代数方法得到，也可以使用卡诺图方法得到。</p>
</li>
</ol>
</li>
<li><p>利用译码器进行线路设计</p>
<p>将对应逻辑表达式转换为最小项表达式，直接将译码出来的最小项用或门连接（高电平译中）或用与非门连接（低电平译中），输出即可。</p>
</li>
</ul>
<p><code>第八次课到此结束</code> </p>
<h2 id="第四章-时序电路的分析"><a href="#第四章-时序电路的分析" class="headerlink" title="第四章 时序电路的分析"></a>第四章 时序电路的分析</h2><h3 id="4-1-触发器的外特性"><a href="#4-1-触发器的外特性" class="headerlink" title="4.1 触发器的外特性"></a>4.1 触发器的外特性</h3><h4 id="4-1-1-基本触发器"><a href="#4-1-1-基本触发器" class="headerlink" title="4.1.1 基本触发器"></a>4.1.1 基本触发器</h4><p>基本触发器通过其电路的设计，可以具有存储二进制位的功能，其电路就是存储器，而不是有单独的存储器。</p>
<p>基本触发器有两个稳态，分别表示0和1。当基本触发器（R~D~ ，S~D~）输入 1，1时，基本触发器里存储的位被保持输出，当输入0，1时，基本触发器被置零，当输入1，0时，基本触发器被置一，当输入0，0时不能确定输出的是当前存储的状态，还是其他状态。因此不能输入0。</p>
<p>基本触发器的R~D~ 和S~D~ 端都是低电平有效，R端是Reset重置，置零端，S端是Set，置一端。</p>
<p>基本触发器的特征表达式</p>
<p>┐R~D~┐ S~D~ = 0 (R~D~ 和S~D~ 不能同时为0)</p>
<p>Q^n+1^  = ┐S~D~ + R~D~ Q</p>
<h4 id="4-1-2-RS触发器"><a href="#4-1-2-RS触发器" class="headerlink" title="4.1.2 RS触发器"></a>4.1.2 RS触发器</h4><blockquote>
<p>电位触发，高电位时触发</p>
</blockquote>
<p>五个输入端，R~D~ , S~D~ ，R, S, CP</p>
<p>CP只有在为1时才有效，CP为0时保持。</p>
<p>特征方程：</p>
<p>Q^n+1^ = S + ┐RQ</p>
<h4 id="4-1-3-D-触发器"><a href="#4-1-3-D-触发器" class="headerlink" title="4.1.3 D 触发器"></a>4.1.3 D 触发器</h4><blockquote>
<p>边缘触发器，正跳变触发</p>
<p>关于电位触发和边缘触发：</p>
<p>边缘触发：输出不能迟于触发信号到达，但触发信号已到达，输入信号就可以撤下来</p>
<p>电位触发：输入信号可以迟于触发电位到达，但在触发电位变回非触发电位前，输入信号不能改变</p>
</blockquote>
<p>Q^n+1^ = D</p>
<h4 id="4-1-4-JK-触发器"><a href="#4-1-4-JK-触发器" class="headerlink" title="4.1.4 JK 触发器"></a>4.1.4 JK 触发器</h4><blockquote>
<p>边缘触发器，负跳变触发</p>
</blockquote>
<p>Q^n+1^ = J ┐Q^n^  + ┐K Q^n^ </p>
<p>当J，K同为0时，输出Q</p>
<p>当J，K同为1时，输出┐Q</p>
<p>当J，K相异时，输出 J</p>
<h4 id="4-1-5-T触发器"><a href="#4-1-5-T触发器" class="headerlink" title="4.1.5 T触发器"></a>4.1.5 T触发器</h4><blockquote>
<p>边缘触发器，负跳变触发</p>
</blockquote>
<p>Q^n+1^ = T┐Q^n^ + ┐TQ^n^ </p>
<p>当T为0时，输出Q</p>
<p>当T为1时，输出┐Q</p>
<p><code>第九次课到此结束</code></p>
<h3 id="4-2-时序电路的分析方法"><a href="#4-2-时序电路的分析方法" class="headerlink" title="4.2 时序电路的分析方法"></a>4.2 时序电路的分析方法</h3><ol>
<li><p>列些输出函数和控制函数表达式</p>
<blockquote>
<p>输出函数：线路的外输出函数（z）</p>
<p>控制函数：向存储元件的输入</p>
</blockquote>
</li>
<li><p>建立次态表达式及状态转移表</p>
</li>
<li><p>建立状态表及状态图</p>
</li>
<li><p>画波形图（optional）</p>
</li>
<li><p>说明时序线路的功能</p>
</li>
</ol>
<p>异步电路分析：</p>
<ol>
<li>写出输出函数和控制函数和每个触发器的CP端</li>
<li>建立次态表达式，次态表达式要将CP写进去，注意，不同触发器CP为一的条件不同</li>
<li>建立状态转移，如果输入信号是脉冲信号，那么输入信号为一代表打一个脉冲，而非输入信号恒唯一。</li>
<li>建立状态表和状态图</li>
<li>画波形图</li>
<li>说明时序电路功能</li>
</ol>
<p><code>第十&amp;十一次课到此结束</code></p>
<h3 id="4-3-同步时序电路的设计"><a href="#4-3-同步时序电路的设计" class="headerlink" title="4.3 同步时序电路的设计"></a>4.3 同步时序电路的设计</h3><p>同步时序电路设计的一般步骤：</p>
<ol>
<li>根据问题的描述，建立原始的状态表</li>
<li>使用隐含表法（下三角矩阵）化简原始状态表</li>
<li>对最简状态表进行编码，建立编码状态表</li>
<li>画出真值表（包括外部输入，现态，次态，控制函数，输出）</li>
<li>根据真值表写出触发器的控制函数</li>
<li>设计组合线路，考虑工程问题</li>
</ol>
<h4 id="4-3-1-关于状态的化简"><a href="#4-3-1-关于状态的化简" class="headerlink" title="4.3.1 关于状态的化简"></a>4.3.1 关于状态的化简</h4><p>两个状态可以合并的条件：</p>
<ol>
<li>在所有不同的输入下，输出均相同且满足以下条件<ol>
<li>两个次态完全相同</li>
<li>两个次态为其现态的交错</li>
<li>两个次态的某一后续状态对可以合并</li>
<li>两个次态为状态对封闭链中的一个状态对。</li>
</ol>
</li>
</ol>
<p><code>本课程结束</code> </p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>模板与泛型编程 - C++</title>
    <url>/2022/10/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-C/</url>
    <content><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><p>模板的定义以关键字<code>template</code> 开始，它的形式如下</p>
<p><code>template &lt;typename T, typename T1, ...&gt;</code> ，尖括号括起来的部分叫做模板参数列表，我们使用模板时，显示或隐式地将模板实参绑定到模板参数列表上。</p>
<p><code>typename</code> 关键字也可以用<code>class</code> 关键字代替，在模板参数列表中，它们是等价的。</p>
<p><strong>模板参数：</strong></p>
<p><code>T</code>  叫做模板类型参数。</p>
<blockquote>
<p>也可以定义非类型的模板参数，它必须是整形或指向对象的或函数的指针或者左值引用，整形必须是一个常量表达式，指针或者引用必须要具有静态生存期。总而言之，它必须能够在编译期间被确定。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>模板编译：</strong></p>
<p>编译器遇到模板的定义时，并不会生成代码，只有在使用模板时，编译器才会生成代码。</p>
<blockquote>
<p>建议：函数模板和类模板成员函数的定义通常放在头文件中</p>
<p>当我们使用一个函数时，我们只需要它的声明，它的定义可以由链接器在链接期间与其他文件链接。</p>
<p>而模板通常在使用时就要实例化，生成代码，因此，模板的声明和定义最好都放在头文件中。</p>
</blockquote>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板通常是使用隐式模板实参推断，编译器会用函数的实参推断模板实参。</p>
<p>在函数模板中，模板类型参数 <code>T</code> 可用于指定返回类型或函数的参数类型，也可以在函数体内声明变量和进行类型转换。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>编译器不能为类模板推断模板类型参数，我们必须显式指明。</p>
<p><strong>类模板的成员函数：</strong></p>
<p>在类内部定义的成员函数隐式<code>inline</code> </p>
<p>在类模板外部定义成员函数：</p>
<p>必须以template + 模板参数列表开始，因为不同类型的模板实例对应不同的成员函数</p>
<p><strong>类模板的模板实例化：</strong></p>
<p>只有程序用到类模板时，才会实例化它。如果没有用到某个成员函数，只用到了这个类，那么这个成员函数也不会被实例化。</p>
<p><strong>简化模板类名</strong></p>
<p>模板名不是类型，只有提供模板实参，模板名才能称为类名。因此我们在使用模板类型时，必须提供模板实参。</p>
<p>但在类模板的作用域内，我们可以只是用模板名，而省略模板实参。</p>
<blockquote>
<p>在类模板的定义外，只有遇到类名之后，我们才进入类的作用域。在此之前，例如我们想要是使用模板类型作为返回值，都不能省略模板实参</p>
</blockquote>
<p><strong>类模板和友元</strong> </p>
<p>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有的模板实例，</p>
<p>如果友元自身是模板，则友元可以授予模板的所有实例，也可以授予部分实例。</p>
<p><strong>模板类型的静态成员</strong></p>
<p>对于每个类型的模板实例，都有一个静态成员。</p>
<p><strong>默认模板实参</strong></p>
<p>可以像函数形参一样，提供一个默认参数。</p>
<p>对于类模板，就算我们需要使用默认模板实参，我们也不能省略尖括号。</p>
<p><code>templateType&lt;&gt; foo;        // 使用默认模板实参</code> </p>
<p><strong>成员模板</strong> </p>
<p>可以将类模板或普通类的成员函数声明称模板</p>
<p>普通类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">mem</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">base</span>(It begin, It end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板作用域"><a href="#模板作用域" class="headerlink" title="模板作用域"></a>模板作用域</h3><p>模板参数遵循普通的作用域规则，一个模板参数的可用范围在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明相同的名字。</p>
<blockquote>
<p>使用类的类型和类的静态成员：</p>
<p>当我们模板使用<code>classType::name</code> 引用类的类型或静态成员，会导致语义不明（因为只有用到模板是才会生成代码，错误检查不会立即发生）</p>
<p>我们必须使用<code>typename</code> 关键字显式声明这是一个类内定义的类型</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>两个独立编译的源文件使用相同的模板，并提供了相同的模板实参，每个文件中就都会有一个模板的实例。在一个大型工程中，会造成很大空间浪费。</p>
<p>因此我们需要显式控制模板实例化</p>
<p>形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> chass&lt;string&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>对于传递给模板类型参数的实参，编译器可以选择对实参进行类型转换，也可以不进行类型转换直接生成新的模板。</p>
<blockquote>
<p>对于非类型的参数，会进行</p>
</blockquote>
<p>只有在一下两种情况会进行类型转换，其他的情况都会生成新的模板</p>
<ul>
<li>非const转换成const，顶层const会被忽略</li>
<li>数组或函数指针：数组可以转换成指针（即使它们的大小不同，但引用不可以，因为对不同长度的数组的引用不是同一个类型），，函数可以转换成函数指针</li>
</ul>
<p>特殊情况：因为模板不会进行算数转换，如果一个函数的两个参数使用一个模板形参。即使，传递的实参可以转换成一个类型，调用也会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T &amp;, <span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="type">long</span> lint = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">cmp</span>(<span class="number">123</span>, lint);    <span class="comment">// 错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<p>这是我们可以这样处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T1 &amp;, <span class="type">const</span> T2 &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板显式指定模板参数"><a href="#函数模板显式指定模板参数" class="headerlink" title="函数模板显式指定模板参数"></a>函数模板显式指定模板参数</h3><p>放在函数名之后，模板名之前，靠右的模板参数如果可以通过实参推断出来，则可以省略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">cmp</span><span class="params">(<span class="type">const</span> T2 &amp;, <span class="type">const</span> T3 &amp;)</span></span>;</span><br><span class="line"><span class="built_in">cmp</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">20</span>, <span class="number">30</span>);    <span class="comment">// T1被显式指定，T2、T3自动推断</span></span><br></pre></td></tr></table></figure>
<p>显式指定参数之后，模板函数即可执行正常的类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T &amp;, <span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="type">long</span> lint = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">cmp</span>(<span class="number">123</span>, lint);    <span class="comment">// 错误，类型不匹配</span></span><br><span class="line"><span class="built_in">cmp</span>&lt;<span class="type">long</span>&gt;(<span class="number">123</span>, lint);  <span class="comment">// 正确，显式指定模板类型参数之后就可以执行正常的类型转换了。</span></span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h3><p>当返回类型需要传入的实参，经过<code>decltype</code> 推断后得出时，我们遇到了一个问题，在写返回类型时，形参还没有被创建。</p>
<p>针对这种情况，我们可以使用尾置返回类型，将返回类型放在参数列表后面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>省略608 - 613 关于右值引用 和 转发</code></p>
<h2 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h2><blockquote>
<p>C++ Primer P614 - P617</p>
</blockquote>
<p>重载规则：</p>
<ol>
<li>对于一个调用，其候选包括所有的模板实参推断和非模板函数</li>
<li>如果有一个函数（不论是模板还是非模板），提供比其他类型的函数更好的匹配，选择它</li>
<li>如果有多个函数提供同样好的匹配，则<ol>
<li>如果同样好的函数中，有一个时非模板函数，选择它</li>
<li>如果都是模板函数，则选择更加特例化的哪一个模板函数</li>
<li>否则，调用有歧义</li>
</ol>
</li>
</ol>
<h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>模板函数的特例化：必须为模板函数的每一个模板参数提供模板实参，不能部分特例化，因此，函数模板特例化必须以<code>template&lt;&gt;</code> 开始。</p>
<p>模板特例化本质上是接管了编译器的工作，特例化的函数也是一个模板实例而不是一个重载函数。</p>
<p>类模板特例化</p>
<p>特例化方法与函数模板特例化无异，但类模板特例化可以部分特例化，详见P628。</p>
<blockquote>
<p>感觉我也不会用到多少这东西。</p>
</blockquote>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课程</title>
    <url>/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h2><h3 id="1-1-顺序实现"><a href="#1-1-顺序实现" class="headerlink" title="1.1 顺序实现"></a>1.1 顺序实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LIST_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LIST_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    ElemType * elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function">Status <span class="title">insert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入的合法范围为 1 &lt;= i &lt;= length + 1, 插入在length + 1时，需要另外申请空间，等价于append</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若已满，重新分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.listsize) &#123;</span><br><span class="line">        ElemType * newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem, (L.listsize + LIST_INCREMENT) * <span class="built_in">sizeof</span> (ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位移</span></span><br><span class="line">    ElemType * pos = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ElemType * rear = &amp;(L.elem[L.length - <span class="number">1</span>]); rear &gt;= pos; rear--)</span><br><span class="line">        *(rear + <span class="number">1</span>) = * rear;</span><br><span class="line">    * pos = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    ElemType * pos = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = * pos;</span><br><span class="line">    ElemType * rear = &amp;(L.elem[L.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (pos++; pos &lt;= rear; pos++)</span><br><span class="line">        * (pos - <span class="number">1</span>) = * pos;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-链式实现"><a href="#1-2-链式实现" class="headerlink" title="1.2 链式实现"></a>1.2 链式实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> * next;</span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">// 由于头节点的存在，计数器从0开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找第i - 1个结点，也就是待插入节点的前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)    <span class="comment">// i超出表长+1(append), 或i为负数</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L;     <span class="comment">// 指向头节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到待删除结点的前驱</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 这里的第一个测试条件是p-&gt;next是因为下面要引用p-&gt;next,如果测试条件是p的话，下面会报段错误</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除结点的位置超出表厂或者为负数</span></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || j &gt; i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法创建单链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入 1 2 3 4 5</span></span><br><span class="line"><span class="comment"> * 建好的单链表为 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));   <span class="comment">// 为头节点分配空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));  <span class="comment">// 分配新节点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;          <span class="comment">// 插入</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法创建单链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入 1 2 3 4 5</span></span><br><span class="line"><span class="comment"> * 建好的单链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_L_tail</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    <span class="keyword">auto</span> r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-循环链表"><a href="#1-3-循环链表" class="headerlink" title="1.3 循环链表"></a>1.3 循环链表</h3><ul>
<li>表中最后一个结点的指针域指向第一个节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> seqNumber;      <span class="comment">// 存储每个人的编号</span></span><br><span class="line">    <span class="type">int</span> psd;            <span class="comment">// 存储每个人的密码</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> * next;</span><br><span class="line">&#125;Node, * NodePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    NodePtr rear;       <span class="comment">// 存储循环链表的尾指针</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;CirLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">empty</span><span class="params">(<span class="type">const</span> CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(CirLinkedList * L, <span class="type">int</span> sq, <span class="type">int</span> psd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NodePtr p = (NodePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    p-&gt;seqNumber = sq;</span><br><span class="line">    p-&gt;psd = psd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(L)) &#123;    <span class="comment">// 不想单链表一样有头节点，因此插入第一个元素时需要特殊处理</span></span><br><span class="line">        L-&gt;rear = p;</span><br><span class="line">        p-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;next = L-&gt;rear-&gt;next;</span><br><span class="line">        L-&gt;rear-&gt;next = p;</span><br><span class="line">        L-&gt;rear = p;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt, psd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入表长:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入元素%d的密码:&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;psd);</span><br><span class="line">        <span class="built_in">append</span>(L, i + <span class="number">1</span>, psd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">const</span> CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(L)) <span class="keyword">return</span> ;</span><br><span class="line">    NodePtr p = (L-&gt;rear)-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p-&gt;seqNumber);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = L-&gt;rear-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p-&gt;psd);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(CirLinkedList * L, NodePtr *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NodePtr prev = L-&gt;rear, t = *p;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != (*p))</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    prev-&gt;next = (*p)-&gt;next;</span><br><span class="line">    *p = prev;</span><br><span class="line">    <span class="keyword">if</span> (t == L-&gt;rear) L-&gt;rear = prev;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>)</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不设头节点，存储尾指针，尾指针指向循环链表的最后一个结点，尾指针的next指向头节点</li>
</ul>
<h3 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> * prior, * next;</span><br><span class="line">&#125;DuLNode, * DuLinkList</span><br></pre></td></tr></table></figure>
<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2. 栈和队列"></a>2. 栈和队列</h2><h3 id="2-1-顺序栈"><a href="#2-1-顺序栈" class="headerlink" title="2.1 顺序栈"></a>2.1 顺序栈</h3><ul>
<li>空栈：<code>S.base == S.Top</code></li>
<li>栈长：<code>S.Top - S.base</code></li>
<li>栈满：<code>S.top – S.base &gt;= S.stacksize</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的课本典型实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STACK_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType * base;</span><br><span class="line">    SElemType * top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="built_in">sizeof</span> (SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base == S.top)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理栈满的情况 栈的有效范围是 0 ~ stacksize - 1</span></span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base + S.stacksize) &#123;    <span class="comment">// S.base + S.stacksize 刚好是尾后指针</span></span><br><span class="line">        S.base = (SElemType *)<span class="built_in">realloc</span>(S.base, (S.stacksize + STACK_INCREMENT) * <span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(--S.top);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">const</span> SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.base - S.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-链栈"><a href="#2-2-链栈" class="headerlink" title="2.2 链栈"></a>2.2 链栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">SNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SNode</span> *next;</span><br><span class="line">&#125;SNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line">    p = (LinkStack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = p; <span class="comment">//头插栈顶元素</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//若栈不空，则删除栈顶元素，用e返回其值，并返回OK；</span></span><br><span class="line">  <span class="comment">//否则返回ERROR	</span></span><br><span class="line">  <span class="keyword">if</span>(S-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR;  <span class="comment">//栈空</span></span><br><span class="line">  p = S-&gt;next;</span><br><span class="line">  e = p-&gt;data;</span><br><span class="line">  S-&gt;next = p-&gt;next; </span><br><span class="line">  <span class="built_in">free</span>(p); <span class="comment">//删除栈顶元素</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-栈的应用"><a href="#2-3-栈的应用" class="headerlink" title="2.3 栈的应用"></a>2.3 栈的应用</h3><ul>
<li>数制转换</li>
<li>括号匹配</li>
<li>迷宫问题</li>
<li>表达式求值</li>
</ul>
<h3 id="2-4-循环队列"><a href="#2-4-循环队列" class="headerlink" title="2.4 循环队列"></a>2.4 循环队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxQSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType * base;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头元素的下标</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾元素的下标</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断队空：<code>Q.front == Q.rear</code></li>
<li>判断队满：<code>(Q.rear + 1) % MaxQSize == Q.front</code> 也可以用 变量记录当前队列长度</li>
<li>求队长：<code>(Q.rear - Q.front + MaxQSize) % MaxQSzie</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = (QElemType *)<span class="built_in">malloc</span>(MaxQSize * <span class="built_in">sizeof</span> (QElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Q.base)</span><br><span class="line">        <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxQSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxQSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxQSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">const</span> SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MaxQSize) % MaxQSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-链队列"><a href="#2-5-链队列" class="headerlink" title="2.5 链队列"></a>2.5 链队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> * next;</span><br><span class="line">&#125;QNode, * QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插入到rear</span></span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">auto</span> p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要特判只有一个元素的时候，此时被释放的结点为rear,必须改变rear的指向，是指与front相同</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front) &#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h2><p>树的度：结点拥有的子树个数</p>
<p>叶子节点或终端结点：度为0的结点</p>
<p>层次：树的根为第一层，根的孩子为第二层</p>
<p>深度：树中结点的最大层次。</p>
<h3 id="3-1-二叉树的性质"><a href="#3-1-二叉树的性质" class="headerlink" title="3.1 二叉树的性质"></a>3.1 二叉树的性质</h3><ol>
<li><p>二叉树的第i层至多有2^i-1^ 个结点</p>
</li>
<li><p>深度为k的二叉树至多有2^k^ -1个结点</p>
</li>
<li><p>对任何一棵二叉树，若它含有n~0~ 个叶子结点、n~2~ 个度（出度）为 2 的结点，则必存在关系式：n~0~ = n2+1。</p>
<blockquote>
<p>推论：适用于Huffman树</p>
<p>对于有n~0~ 个结点的Huffman树，它的总结点数为n~0~ + n~2~ = 2n~0~ -1</p>
</blockquote>
</li>
<li><p>具有n个结点的完全二叉树的深度为 <code>floor(log2 n) + 1</code></p>
<blockquote>
<p>ceil()向上取整，floor向下取整</p>
</blockquote>
</li>
<li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p>
<ol>
<li><p>若 i = 1，则该结点是二叉树的根，无双亲，</p>
<p>否则，编号为<code>floor(i/2)</code> 的结点为其双亲结点；</p>
</li>
<li><p>若 2i &gt; n，则该结点无左孩子，</p>
<p>否则，编号为 2i 的结点为其左孩子结点；</p>
</li>
<li><p>若 2i+1 &gt; n，则该结点无右孩子结点，<br>  否则，编号为2i+1 的结点为其右孩子结点。</p>
</li>
<li>具有n个结点的<strong>完全二叉树</strong>有<code>ceil(n/2)</code>个叶子结点</li>
<li><strong>完全二叉树</strong>最后一个非终端结点的编号为<code>floor(n/2)</code> </li>
</ol>
</li>
</ol>
<h3 id="3-2-二叉树的链式存储"><a href="#3-2-二叉树的链式存储" class="headerlink" title="3.2 二叉树的链式存储"></a>3.2 二叉树的链式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; *Tree, Node;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNodeCnt = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按先序遍历顺序创建二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(Tree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> Node;</span><br><span class="line">        T-&gt;val = ch;</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreorderTraverse</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderTraverse</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;left);</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">PostorderTraverse</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PostorderTraverse</span>(T-&gt;right);</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> myqueue::queue;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> ;</span><br><span class="line">    queue&lt;Tree&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Tree t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left) Q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) Q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先序遍历非递归思路：</p>
<p>从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，访问所遇结点，并依次把所遇结点进栈，当左子树为空时，从栈顶退出某结点，并将指针指向该结点的右孩子。如此重复，直到栈为空或指针为空止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree cur = T;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 当未走到最左边的结点时，继续向左走，同时访问结点</span></span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            stack[top++] = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 访问右子树</span></span><br><span class="line">            cur = stack[--top];</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序非递归思路</p>
<p>从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，把依次遇到的结点进栈待左子树为空时,从栈中退出结点并访问,然后再转向它的右子树。如此重复，直到栈空或指针为空止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree cur = T;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack[top++] = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack[--top];</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序非递归思路</p>
<p>利用栈来实现二叉树的后序遍历要比前序和中序遍历复杂得多，在后序遍历中，</p>
<ol>
<li><p>当搜索指针指向某一个结点时，不能马上进行访问，而先要遍历左子树，所以此结点应先进栈保存，</p>
</li>
<li><p>当遍历完它的左子树后，再次回到该结点，还不能访问它，</p>
</li>
<li><p>还需先遍历其右子树,所以该结点还必须再次进栈，</p>
</li>
<li><p>只有等它的右子树遍历完后，再次退栈时，才能访问该结点。</p>
</li>
<li><p>为了区分同一结点的两次进栈，引入一个栈次数的标志，一个元素第一次进栈标志为0，第二次进标志为1，并将标志存入另一个栈中，当从标志栈中退出的元素为1时，访问结点。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> cnt[MaxNodeCnt], top = <span class="number">0</span>, tc;</span><br><span class="line">    Tree cur = T, tt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack[top] = cur;</span><br><span class="line">            cnt[top++] = <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tt = stack[top - <span class="number">1</span>];</span><br><span class="line">            tc = cnt[--top];</span><br><span class="line">            <span class="keyword">if</span> (tc) &#123;</span><br><span class="line">                cout &lt;&lt; tt-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack[top] = tt;</span><br><span class="line">                cnt[top++] = tc + <span class="number">1</span>;</span><br><span class="line">                cur = tt-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4-二叉树遍历的应用"><a href="#3-4-二叉树遍历的应用" class="headerlink" title="3.4 二叉树遍历的应用"></a>3.4 二叉树遍历的应用</h3><ul>
<li>求树的叶子节点个数</li>
<li>求树的深度</li>
<li>复制二叉树</li>
</ul>
<h3 id="3-5-线索化："><a href="#3-5-线索化：" class="headerlink" title="3.5 线索化："></a>3.5 线索化：</h3><p>可以以线性的方式访问二叉树结构</p>
<h4 id="3-5-1-中序线索树"><a href="#3-5-1-中序线索树" class="headerlink" title="3.5.1 中序线索树"></a>3.5.1 中序线索树</h4><blockquote>
<p>对于中序线索树，我们约定：</p>
<p>它有两个存储左右子树标记的域，如果左子树的标记为0，那么它存储的是其左孩子，如果左子树的标记为1，那么它存储的是其中序遍历时的直接前驱.</p>
<p>如果右子树的标记为0，它存储的是其右孩子。如果右子树的标记为1，那么它存储的是中序遍历时的直接后继。</p>
</blockquote>
<ul>
<li><p>求中序线索树的前驱：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">如果 左标记为1</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">直接返回其左孩子</span></span><br><span class="line"><span class="attribute">否则</span><span class="punctuation">:</span></span><br><span class="line">  返回其左子树的最右下的结点</span><br></pre></td></tr></table></figure>
</li>
<li><p>求中序线索树的后继：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">如果 右标记为1</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">返回其右孩子</span></span><br><span class="line"><span class="attribute">否则</span><span class="punctuation">:</span></span><br><span class="line">  返回其右子树的最左下的孩子</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历中序线索树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (BiThrTree p = T-&gt;lchild; p != T; p = <span class="built_in">in_suss</span>(p))</span><br><span class="line">    <span class="built_in">visit</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找后继的函数</span></span><br><span class="line"><span class="function">BiThrTree <span class="title">in_succ</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;RTag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BiThrTree q;</span><br><span class="line">        <span class="keyword">for</span> (q = p-&gt;rchild; q-&gt;LTag == <span class="number">0</span>; q = q-&gt;lchild)</span><br><span class="line">            ;  <span class="comment">// 找到右子树的最左下的孩子</span></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒序遍历</span></span><br><span class="line"><span class="keyword">for</span> (BiThrTree p = T-&gt;rchild; p != T; p = <span class="built_in">in_pre</span>(p))</span><br><span class="line">    <span class="built_in">visit</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找前驱</span></span><br><span class="line"><span class="function">BiThrTree <span class="title">in_pre</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LTag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BiThrTree q;</span><br><span class="line">        <span class="keyword">for</span> (q = p-&gt;lchild; q-&gt;LTag == <span class="number">0</span>; q = q-&gt;rchild)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T, <span class="type">void</span> (*Visit)(TElemType e))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = T-&gt;lchild;           <span class="comment">// p = first_node</span></span><br><span class="line">  <span class="keyword">while</span> (p != T) &#123;     		<span class="comment">// 空树或遍历结束时，p==T</span></span><br><span class="line">        <span class="comment">// case 1: </span></span><br><span class="line">      <span class="keyword">while</span> (p-&gt;LTag==Link)</span><br><span class="line">            p = p-&gt;lchild;    <span class="comment">//第一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Visit</span>(p-&gt;data))</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// case 2:</span></span><br><span class="line">      <span class="keyword">while</span> (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">          <span class="built_in">Visit</span>(p-&gt;data);      <span class="comment">// 访问后继结点</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;rchild;           <span class="comment">// p进至其右子树根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// InOrderTraverse_Thr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>建立中序线索树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">BiTNode *Pre = <span class="keyword">new</span> BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化带头结点二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiTree &amp;Thrt, BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thrt = <span class="keyword">new</span> BiTNode; <span class="comment">//建立头结点</span></span><br><span class="line">  Thrt-&gt;LTag = <span class="number">0</span>;		<span class="comment">//头结点有左孩子，若树非空，则其左孩子为树根</span></span><br><span class="line">  Thrt-&gt;RTag = <span class="number">1</span>;		<span class="comment">//头结点右孩子为右线索</span></span><br><span class="line">  Thrt-&gt;right = Thrt; <span class="comment">//初始化时右孩子指向自己</span></span><br><span class="line">  <span class="keyword">if</span> (!T)				<span class="comment">//如果树为空则左孩子也指向自己</span></span><br><span class="line">    Thrt-&gt;left = Thrt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Thrt-&gt;left = T;</span><br><span class="line">    Pre = Thrt;</span><br><span class="line">    <span class="built_in">InThreading</span>(T);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成在线索化中未完成的那部分事情</span></span><br><span class="line">    Pre-&gt;right = Thrt;		<span class="comment">// 最后一个结点的后继指向头节点</span></span><br><span class="line">    Pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;right = Pre;		<span class="comment">// 头节点的右指针为最后一个结点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一个算法，中序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T) <span class="comment">//根节点非空</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">InThreading</span>(T-&gt;left); <span class="comment">//左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;left)		  <span class="comment">// T的左孩子为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      T-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">      T-&gt;left = Pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      T-&gt;LTag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Pre-&gt;right) <span class="comment">// T的右孩子为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      Pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">      Pre-&gt;right = T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Pre-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">    Pre = T;</span><br><span class="line">    <span class="built_in">InThreading</span>(T-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-一般的树和森林的表示："><a href="#1-3-一般的树和森林的表示：" class="headerlink" title="1.3 一般的树和森林的表示："></a>1.3 一般的树和森林的表示：</h3><p>三种表示法：</p>
<ol>
<li><p>父亲表示法（并查集的实现方法）</p>
</li>
<li><p>孩子表示法</p>
</li>
<li><p>孩子表示法（将一般的树或森林转换成二叉树）</p>
<p>让二叉树结点的左孩子指向这个一般的树的第一个孩子，右孩子指向下一个兄弟</p>
</li>
</ol>
<h3 id="1-4-一般的树和森林的遍历："><a href="#1-4-一般的树和森林的遍历：" class="headerlink" title="1.4 一般的树和森林的遍历："></a>1.4 一般的树和森林的遍历：</h3><p>二叉树：</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>一般的树</p>
<ul>
<li>先根遍历（先遍历根，再从左到右依次遍历子树） 先序遍历</li>
<li>后根遍历 （遍历一个树的根时，先左到右依次遍历该树的子树）中序遍历</li>
<li>层次遍历 层次遍历</li>
</ul>
<p>森林</p>
<ul>
<li>先序遍历（即从左到右对森林中的每一棵树进行先根遍历） 先序遍历</li>
<li>中序遍历（从左到右对森立中的每一棵树进行后根遍历） 中序遍历</li>
</ul>
<h3 id="1-5-Huffman树"><a href="#1-5-Huffman树" class="headerlink" title="1.5 Huffman树"></a>1.5 Huffman树</h3><ul>
<li>路径长度l：路径上的分支数目</li>
<li>树的带权路径长度WPL = 求和(k = 1, n) w~k~ l~k~ </li>
</ul>
<h2 id="4-图"><a href="#4-图" class="headerlink" title="4. 图"></a>4. 图</h2><h3 id="4-1-术语"><a href="#4-1-术语" class="headerlink" title="4.1 术语"></a>4.1 术语</h3><ul>
<li><p>弧：有向边</p>
</li>
<li><p>网：弧或边带权的图成为有向网或无向网</p>
</li>
<li><p>完全图，有向完全图，稀疏图，稠密图</p>
<p>设图有n个结点，e条边</p>
<p>含有e = <code>n(n-1)/2</code>条边的无向图成为完全图</p>
<p>含有e = <code>n(n-1)</code> 条弧的有向图成为有向完全图</p>
<p>若边或弧的个数e，<code>e&lt;nlogn</code> 则成为稀疏图，否则成为稠密图</p>
</li>
<li><p>结点的度 = 入度 + 出度</p>
</li>
<li><p>简单路径：顶点不重复的路径</p>
</li>
<li><p>简单回路：除起点终点，顶点不重复的回路</p>
</li>
<li><p>图中任意两个顶点之间都有路径可以联通则成为<strong>连通图</strong>（有向图 / 无向图）</p>
</li>
<li><p>无向图中，极大连通子图称为<strong>连通分量</strong></p>
</li>
<li><p>有向图中，任意两点都有路径可以连通，即为<strong>强连通图</strong>，否则，各强连通子图成为<strong>强连通分量</strong> </p>
<p>有向图的底图连通即为<strong>弱连通图</strong></p>
</li>
<li><p>假设一个连通图有 n 个顶点和 e 条边，其中 n-1 条边和 n 个顶点构成一个极小连通子图，称该极小连通子图为此连通图的<strong>生成树</strong> </p>
</li>
</ul>
<h3 id="4-2-图的遍历"><a href="#4-2-图的遍历" class="headerlink" title="4.2 图的遍历"></a>4.2 图的遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  visited[v] = TRUE;</span><br><span class="line">    <span class="built_in">VisitFunc</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w : G.Adj)</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">          <span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-最小生成树"><a href="#4-3-最小生成树" class="headerlink" title="4.3 最小生成树"></a>4.3 最小生成树</h3><ul>
<li><p>Prim算法</p>
<p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在待添加的顶点w 和已经在生成树上的顶点v之间必定存在一条边<strong>，</strong>并且该边的权值在所有连通顶点v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n个顶点为止。</p>
</li>
<li><p>Kruskal算法</p>
<p>具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。</p>
</li>
</ul>
<h3 id="4-4-重连通图和关节点"><a href="#4-4-重连通图和关节点" class="headerlink" title="4.4 重连通图和关节点"></a>4.4 重连通图和关节点</h3><ul>
<li>重连通图：若从一个连通图中删去<strong>任何</strong>一个顶点及其相关联的边，他仍为一个连通图的话，则该连通图为重（双）连通图。 </li>
<li>若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为<strong>关节点</strong>。没有关节点的连通图即为重连通图</li>
<li>如何判断关节点？<ul>
<li>若生成树的根结点，有两个或两个以上的分支，则此顶点(生成树的根)必为关节点；</li>
<li>对生成树上的任意一个“顶点”，若其某棵子树的根或子树中的其它“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点。 </li>
</ul>
</li>
</ul>
<h3 id="4-5-拓扑排序"><a href="#4-5-拓扑排序" class="headerlink" title="4.5 拓扑排序"></a>4.5 拓扑排序</h3><ol>
<li>从有向图中选取一个没有前驱的顶点，并输出之；</li>
<li>从有向图中删去此顶点以及所有以它为尾的弧；</li>
</ol>
<p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p>
<h2 id="5-查找"><a href="#5-查找" class="headerlink" title="5. 查找"></a>5. 查找</h2><ul>
<li><p>评价指标 ASL</p>
<p>ASL = 求和(i=1, n) C~i~ × P~i~ </p>
<p>C~i~查找到第i条记录时，K与关键字的比较次数</p>
<p>P~i~ 查找第i条记录的概率</p>
</li>
</ul>
<h3 id="5-1-顺序查找表"><a href="#5-1-顺序查找表" class="headerlink" title="5.1 顺序查找表"></a>5.1 顺序查找表</h3><ul>
<li>查找成功ASL = n(n+1)/2 * (1 / n) = n+1/2</li>
<li>查找失败的ASL = n+1</li>
<li>平均 = (3/4)(n+1)</li>
</ul>
<h3 id="5-2-折半查找"><a href="#5-2-折半查找" class="headerlink" title="5.2 折半查找"></a>5.2 折半查找</h3><ul>
<li>折半查找判定树</li>
<li>查找失败并不会多查找一次</li>
</ul>
<p>课本上的典型实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">1</span>, high = ST.length;</span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; ST[mid].key)</span><br><span class="line">      high = mid - <span class="number">1</span>; <span class="comment">//在左区间继续查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (K &gt; ST[mid].key)</span><br><span class="line">      low = mid + <span class="number">1</span>; <span class="comment">//在右区间继续查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">//查找成功的出口</span></span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//查找失败的出口</span></span><br><span class="line">&#125;<span class="comment">//Search_Bin</span></span><br></pre></td></tr></table></figure>
<p>yxc的二分一般实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="5-3-分块索引"><a href="#5-3-分块索引" class="headerlink" title="5.3 分块索引"></a>5.3 分块索引</h3><h3 id="5-4-二叉排序树"><a href="#5-4-二叉排序树" class="headerlink" title="5.4 二叉排序树"></a>5.4 二叉排序树</h3><ul>
<li>二叉排序树的中序遍历序列是一个有序序列</li>
<li>和折半查找判定树类似，查找失败也不会增加比较次数</li>
</ul>
<ul>
<li><p>二叉排序树的删除</p>
<ol>
<li><p>设待删除的结点为p，若p的度为0，直接删除</p>
</li>
<li><p>若p的度为1，则直接用其孩子替换它</p>
</li>
<li><p>若p的度为2，方法1：</p>
<p>将p的右孩子交给其中序前驱，p的左孩子交给其双亲，删除p</p>
</li>
<li><p>用p的中序前驱（后继）替换它，然后删除其中序前驱。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>AVL树</p>
<p>插入：四种旋转</p>
<p>删除：</p>
<ul>
<li>要删除的结点为叶子结点，直接删除它，并自下而上调整AVL树。</li>
<li>要删除的结点只有左孩子，用其左孩子替换该节点，并删除其左孩子。因为AVL树的性质，左右子树高度只差不超过1，因此左孩子一定是叶子结点，这种情况便转换为了第一种情况。</li>
<li>要删除的结点只有右孩子，和只有左孩子的情况相同。</li>
<li>要删除的结点既有左孩子，也有右孩子，此时只需寻找其中序遍历的前驱节点或后继结点，用它们替换该结点，在删除它的中序前驱结点或后继结点，而它的中序前驱后后继必定是叶子结点，该情况也转换为了第一种情况。</li>
</ul>
</li>
</ul>
<h3 id="5-5-哈希表"><a href="#5-5-哈希表" class="headerlink" title="5.5 哈希表"></a>5.5 哈希表</h3><p>构造哈希函数的方法：</p>
<ul>
<li>直接定址法</li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
<li>除留余数法</li>
<li>随机数法</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li><p>开放定址法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hi = (H(key) + di) mod m</span><br><span class="line"></span><br><span class="line"><span class="bullet"> -</span> i = 1, 2, 3, ..., k (k &lt;= m - 1)</span><br><span class="line"><span class="bullet"> -</span> H(key) hash值</span><br><span class="line"><span class="bullet"> -</span> di 增量序列</span><br><span class="line"><span class="bullet"> -</span> m 哈希表的容量</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123446806.png" alt="image-20221226123446806"></p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123504750.png" alt="image-20221226123504750">  </p>
</li>
<li><p>拉链法</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123407144.png" alt="image-20221226123407144"> </p>
</li>
<li><p>再哈希法</p>
</li>
<li><p>建立公共溢出区法</p>
<p>查找成功失败的ASL</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226122114871.png" alt="image-20221226122114871">  </p>
</li>
</ul>
<h2 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h2><ul>
<li><p>插入排序</p>
<p>直接插入排序</p>
<p>折半插入排序</p>
<p>2路插入排序</p>
<p>希尔排序</p>
</li>
<li><p>交换排序</p>
<p>冒泡排序</p>
<p>快速排序</p>
</li>
<li><p>选择排序</p>
<p>选择排序</p>
<p>堆排序</p>
</li>
<li><p>归并排序</p>
</li>
<li><p>基数排序</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>模电课程 - 大学课程</title>
    <url>/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="电工学"><a href="#电工学" class="headerlink" title="电工学"></a>电工学</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>基尔霍夫电压定理</p>
<p>基尔霍夫电流定理</p>
<p>结点电压法：<a href="https://zhuanlan.zhihu.com/p/341727367">第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com)</a> </p>
<p>回路电流法：</p>
<p>叠加定理：<a href="https://baijiahao.baidu.com/s?id=1662486398509859685&amp;wfr=spider&amp;for=pc">电学基础理论之叠加定理 (baidu.com)</a> </p>
<p>戴维南等效电路</p>
<p>二极管：</p>
<p>正向压降 ： 正向通过后，电压的减小量。</p>
<p>二极管的功能：</p>
<ol>
<li><p>钳位</p>
<p><a href="https://baike.baidu.com/item/钳位二极管/6307364?fr=aladdin">钳位二极管_百度百科 (baidu.com)</a> </p>
</li>
<li><p>隔离</p>
</li>
<li><p>稳压 ： 见下面稳压二极管视频</p>
</li>
</ol>
<p>稳压二极管：</p>
<blockquote>
<p>详见视频： <a href="https://www.bilibili.com/video/BV1qY4y1t7sc">https://www.bilibili.com/video/BV1qY4y1t7sc</a></p>
<p>详见P15页笔记</p>
</blockquote>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li><p>电压源</p>
<p>理想的电压源内阻为0，输出电压<code>U = E - IR0</code>, R0 = 0，因此输出电压恒定不变。当内阻远小于外电阻时，可近似看作理想电压源。</p>
</li>
<li><p>电流源</p>
<p>理想电流源的内阻为无穷大，因此输出的电流I = I~S~ - U / R ，恒定不变。</p>
</li>
</ul>
<h2 id="第十四章-半导体器件"><a href="#第十四章-半导体器件" class="headerlink" title="第十四章 半导体器件"></a>第十四章 半导体器件</h2><h3 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h3><ul>
<li><p>导通电压：</p>
<p>硅管：0.5V</p>
<p>锗管：0.1V</p>
</li>
<li><p>正向压降</p>
<p>硅管：0.6 ~ 0.8 V</p>
<p>锗管：0.2 ~ 0.3 V</p>
</li>
<li><p>主要参数</p>
<p>最大整流电流 I~OM~ : 长时间使用所允许通过的最大正向平均电流</p>
<p>反向工作峰值电压 U~RWM~ : 保证二极管不被击穿而给出的反向峰值电压，一般是反向击穿电压的1/2或2/3。</p>
<p>反向峰值电流 I~RM~ ：在U~RWM~ 下的电流</p>
</li>
<li><p>作用</p>
<ol>
<li>整流</li>
<li>限伏/钳位</li>
<li>隔离：两个二极管并联，某个二极管的电压高，则它优先导通。因而电压低的那一个二极管被隔离了。</li>
</ol>
</li>
</ul>
<h3 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h3><ol>
<li>使用稳压二极管时一定要有限流电阻R，不然二极管必定会被烧坏。</li>
<li>稳压二极管的工作原理：当电源电压升高，使得稳压二极管两侧电压有升高的趋势时，此时稳压二极管的电阻升高，电流增大，引起干路限流电阻的电流增加，限流电阻的电阻不变，因此限流电阻的分压增大，抵消了电源增加的电压。</li>
<li>在分析使用稳压二极管之前，假设二极管尚未反向导通，先判断二极管两侧的电压，只有二极管反向击穿时，才能有稳压的效果。</li>
</ol>
<h3 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h3><ul>
<li>放大区，I~E~ = I~C~ + I~B~ , I~C~ = β I~B~ ，发射结正偏，集电结反偏。</li>
<li>截止区，I~C~ = 0, U~CE~ = U~CC~ ， 约等于断开，此时 I~B~ = 0或以下</li>
<li>饱和区，此时I~B~ 和I~C~ 关系很小，I~C~ = U~CC~ / R~C~ , U~CE~ = 0, 相当于短路</li>
<li><p>如何判断三极管的工作状态？</p>
<ol>
<li>求出 I~C~ ~Maximun~  = (Vcc - U~CE~)  / R~C~</li>
<li>求出 I~B~ </li>
<li>若βI~B~ &gt; I~CMaximun~ 饱和</li>
<li>否则处于放大区</li>
</ol>
</li>
<li><p>参数</p>
<p>硅管 U~BE~ = 0.6 ~ 0.7 V    </p>
<p>β 杠 ： 静态电流放大系数</p>
<p>β：动态电流放大系数</p>
<p>I~CBO~ </p>
<p>I~CEO~ </p>
<p>I~CM~ 集电极允许的最大电流，超过它放大系数将会下降</p>
<p>U~（BR）CEO~ </p>
</li>
</ul>
<ul>
<li>如果U~CE~ 固定，那么随着I~B~ 的增加，三极管的工作状态会慢慢从放大状态转为过饱和状态。</li>
</ul>
<h2 id="第十五章-基本放大电路"><a href="#第十五章-基本放大电路" class="headerlink" title="第十五章 基本放大电路"></a>第十五章 基本放大电路</h2><p>放大电路的输入电阻：输入电路的等效负载电阻</p>
<p>放大电路的输出电阻：输出电路的等效内阻</p>
<h3 id="共发射极放大电路（固定偏置放大电路）"><a href="#共发射极放大电路（固定偏置放大电路）" class="headerlink" title="共发射极放大电路（固定偏置放大电路）"></a>共发射极放大电路（固定偏置放大电路）</h3><p>(名字来源：因为偏置电路是固定的)</p>
<p>输入: U~I~或者I~B~ 或U~BE~ </p>
<p>输出：U~O~ (U~CE~ 的交流分量 阻容耦合)</p>
<p>静态值是指</p>
<ul>
<li>I~B~</li>
<li>I~C~</li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~</li>
</ul>
<p>静态值的直接求解法：</p>
<ul>
<li>I~B~ ： (U~CC~ - U~BE~ ) / R~B~ </li>
<li>I~C~ ： βI~B~ </li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~ : U~CC~ - R~C~ I~C~ </li>
</ul>
<p>静态值得图解法：</p>
<ul>
<li>三极管的输出特性曲线是I~C~ - U~CE~ (y - x) 因此，只要求出I~C~ = f(U~CE~ ) 即可</li>
<li>由U~CE~ =  U~CC~ - R~C~ I~C~ 因此只要求出U~CC~ 和 R~C~ 即可</li>
</ul>
<p>偏置电路是指产生偏流I~B~ 的电路，偏置电阻是指限流I~B~的电阻 </p>
<h3 id="非线性失真"><a href="#非线性失真" class="headerlink" title="非线性失真"></a>非线性失真</h3><p>原因：静态工作点不合适 或 信号太大</p>
<p>分类</p>
<ul>
<li>截止失真 : 静态工作点位置太低，输入产生的I~B~ 在负半周截止了，导致输出的IC也截止了（负半周），导致U~CE~ 的正半周截止了</li>
<li>饱和失真 ： 静态工作点位置太高，输出的I~C~ 在正半周饱和，导致输出的U~CE~ 在负半周失真。</li>
</ul>
<p>什么可以影响静态工作点：</p>
<p>最直接的因素是I~C~，可以影响I~C~的因素都可以影响静态工作点 </p>
<h3 id="静态工作点的稳定"><a href="#静态工作点的稳定" class="headerlink" title="静态工作点的稳定"></a>静态工作点的稳定</h3><h4 id="分压式偏置放大电路"><a href="#分压式偏置放大电路" class="headerlink" title="分压式偏置放大电路"></a>分压式偏置放大电路</h4><h3 id="射级输出器"><a href="#射级输出器" class="headerlink" title="射级输出器"></a>射级输出器</h3><p>输入电阻大：对内阻高的信号源很有意义</p>
<p>输出电阻小：具有恒压输出的特性，带负载能力较强</p>
<p>一般用于多级放大电路的输入级或输出级或者多级之间的缓冲级/隔离级</p>
<h2 id="第十六章-集成运算放大器"><a href="#第十六章-集成运算放大器" class="headerlink" title="第十六章 集成运算放大器"></a>第十六章 集成运算放大器</h2><h3 id="集成运放的组成"><a href="#集成运放的组成" class="headerlink" title="集成运放的组成"></a>集成运放的组成</h3><ul>
<li><p>输入极</p>
<p>输入极要求输入电阻高，静态电流小，差模放大倍数高，抑制零点漂移和共模干扰信号强，输入极都采用差分放大电路。</p>
</li>
<li><p>中间级</p>
<p>进行电压放大，要求电压放大倍数高，一般采用共发射极放大电路</p>
</li>
<li><p>输出级</p>
<p>要求输出电阻低，带负载能力强，一般由互补功率放大电路或射级输出器构成</p>
</li>
<li><p>偏置电路</p>
<p>为上述个电路提供稳定合适的偏置电流，决定各级的静态工作点，一般由各种恒流源电路组成。</p>
</li>
</ul>
<h3 id="理想运放"><a href="#理想运放" class="headerlink" title="理想运放"></a>理想运放</h3><p>开环电压放大倍数 ∞</p>
<p>差模输入电阻 ∞</p>
<p>开环输出电阻 0</p>
<ul>
<li><p>工作在线性区</p>
<p>虚断：由于差模输入电阻为∞，可以认为两个输入端的电流 i~+~ = i~-~  = 0</p>
<p>虚短：由于开环电压放大倍数 ∞，可以认为 u~+~ = u~-~ </p>
<ul>
<li>虚地，如果由于虚短，如果两个输入端有一个接地，相当于另一个也接地</li>
</ul>
</li>
<li><p>工作在饱和区</p>
<p>虚断：仍然存在</p>
<p><del>虚短</del>：此时工作在饱和区，不能满足在线性区的放大关系，因此，两个输入端的电压不必相等，虚短不存在</p>
<p>u+ &gt; u- : uo = + Uo(sat)</p>
<p>u+ &lt; u- : uo = - Uo(sat)</p>
</li>
</ul>
<h3 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h3><ul>
<li><p>反向比例运算</p>
<p>运放工作在线性区</p>
<p>只要运放的开环放大倍数很高，比例运算的放大能力就只与外接电阻有关</p>
<p>这个放大倍数就是闭环放大倍数</p>
<p>Uo = -(R~F~ / R1) U1</p>
</li>
<li><p>正向比例运算</p>
<p>电压从正向端输入</p>
<p>放大比例也只与外接电阻有关</p>
<p>Uo = (1 + R~F~ / R1) U1</p>
</li>
<li><p>加法运算</p>
<p>Uo = -[(R~F~/R~11~)U~11~ + (R~F~/R~12~)U~12~ + (R~F~/R~13~)U~13~]</p>
<p>Uo = -(R~F~ / R1)(U11 + U12 + U13)</p>
</li>
<li><p>减法运算</p>
<p>Uo = (1 + R~F~ / R~1~ ) (R~3~ / (R1 + R2)) U12 - R~F~ / R~1~ U11</p>
<p>当R1 = R2, R2 = R~F~ </p>
<p>Uo = R~F~ / R~1~(U12 - U11)</p>
<p>当 R1 = R2 = R2 = R~F~ </p>
<p>Uo = U12 - U11</p>
</li>
</ul>
<h2 id="第十七章-电子电路中的反馈"><a href="#第十七章-电子电路中的反馈" class="headerlink" title="第十七章 电子电路中的反馈"></a>第十七章 电子电路中的反馈</h2><p>反馈的模态判断：</p>
<p>反馈信号与输入信号在</p>
<ul>
<li>相同端子上（并联）<ul>
<li>极性相同：正反馈</li>
<li>极性相反：负反馈</li>
</ul>
</li>
<li>相异端子上（串联）<ul>
<li>极性相同：负反馈</li>
<li>极性相反：正反馈</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何判断反馈是电压反馈还是电流反馈？</p>
<p>将输出电压U~O~ 置零，看是否还存在反馈？</p>
<ul>
<li>存在：电流反馈</li>
<li>不存在：电压反馈</li>
</ul>
</li>
<li><p>负反馈对输入输出电阻的影响：</p>
<p>电压负反馈使得输出有电压源的特性，因此电压负反馈可以降低输出电阻ro</p>
<p>电流负反馈使得输出有电流源的特性，因此电流负反馈可以增高输出电阻ro</p>
<p>串联反馈可以增大输入电阻ri</p>
<p>并联反馈可以减小输入电阻ri</p>
</li>
<li><p>负反馈可以减小波形失真，但不能完全消除波形失真</p>
</li>
<li><p>引入负反馈之后可以降低放大倍数</p>
</li>
<li><p>引入负反馈可以提高放大倍数的稳定性</p>
</li>
</ul>
<h2 id="第十八章-直流稳压电源"><a href="#第十八章-直流稳压电源" class="headerlink" title="第十八章 直流稳压电源"></a>第十八章 直流稳压电源</h2><h3 id="整流"><a href="#整流" class="headerlink" title="整流"></a>整流</h3><ul>
<li><p>单相半波整流</p>
<p>变压器的输出（整流电路输入的交流电压，变压器的二次电压）为 u = √2Usin wt (U为交流电压的有效值，也叫变压器的二次电压有效值)</p>
<p>整流电压的平均值 U~O~ = 0.45U</p>
<p>整流电流（负载电流）的平均值 I~O~ = U~O~ / R~L~ = 0.45U/R~L~ </p>
<p>整流元件截止时的最高反向电压 U~RM~ = √2U (并不是元件能承受的最大电压，元件能承受的最大反向电压要看元件自己的参数)</p>
</li>
<li><p>单相全波整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~ </p>
<p>I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = 2√2U</p>
</li>
<li><p>三相半波</p>
<p>U~O~ = 1.17U</p>
<p>I~O~ =  1.17U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45U</p>
</li>
<li><p>单向桥式整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~</p>
<p>每个二极管中流过的平均电流 I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = √2U</p>
<blockquote>
<p>变压器的变比K = 交流电源电压 / 二次电压有效值</p>
<p>变压器容量 S = UI = 变压器二次电压有效值 * 变压器二次电流有效值</p>
</blockquote>
</li>
<li><p>三相桥式整流</p>
<p>U~O~ = 2.34U</p>
<p>I~O~ = 2.34U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45 U</p>
</li>
</ul>
<h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><ul>
<li><p>电容滤波器</p>
<p>U~O~ = 1.2U</p>
<p>对滤波电容，一般要求</p>
<p>R~L~ C &gt;= (3~5)T/2</p>
</li>
<li><p>电感电容滤波（LC滤波）</p>
<p>适用于电流较大、要求输出电压脉动很小的场合，用于高频时更加合适</p>
</li>
</ul>
<h3 id="直流稳压电源"><a href="#直流稳压电源" class="headerlink" title="直流稳压电源"></a>直流稳压电源</h3><ul>
<li><p>稳压二极管稳压电路</p>
<p>一般交流电压经过整流（桥式整流）和滤波之后，得到的直流电仍存在波动，此时需要进行稳压</p>
<p>引起负载电压变化的原因有二：</p>
<ol>
<li>交流电源电压的变化</li>
<li>负载电流的变化</li>
</ol>
<p>可以对负载电阻，先串联一个保护电阻，在并联一个稳压二极管，稳压二极管通过提高或减小电流，是的保护电阻承担增大或减少的电压。</p>
<p>选取稳压二极管时，一般取：</p>
<ul>
<li><p>U~Z~ = U~O~ （U~Z~ 为稳压二极管的稳定电压，Uo为输出的负载电压）</p>
</li>
<li><p>I~ZM~ = (1.5~3) I~OM~ （I~ZM~ 为最大稳压电流，I~OM~ 为负载电流的最大值） </p>
</li>
<li>U~1~ = (2~3) U~O~ (其中U~1~ 是经过整流 滤波后的输出电压，也就是稳压部分的输入电压，即需要被稳压的部分)</li>
</ul>
</li>
<li><p>集成三端稳压电源</p>
<p>W78XX（输出固定正电压），W79XX（输出固定负电压），W117/217/317（输出电压可调）</p>
<p>有三个引脚，分别是输入端I，输出端O，地段GND</p>
<p>使用时需要在其输入端，输出端，地段并联一个电容</p>
</li>
</ul>
<p>  几种典型的电路：</p>
<ol>
<li>正负电压同时输出的电路</li>
<li>输出电压可调的电路<ol>
<li>用集成运放 + W78XX/W79XX</li>
<li>用W117/217/317</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>网络编程 - CS:APP 第十一章</title>
    <url>/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="网络编程-CS-APP-第十一章"><a href="#网络编程-CS-APP-第十一章" class="headerlink" title="网络编程 - CS:APP 第十一章"></a>网络编程 - CS:APP 第十一章</h1><p>客户端和服务器都是进程，而不是机器或主机。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32位IP地址，使用网络字节顺序（大端法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。</p>
<p>字节顺序和主机顺序的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to net</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// net to host</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;  <span class="comment">// net to host</span></span><br></pre></td></tr></table></figure>
<p>点分IP地址与32位IP地址的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点分十进制转换成32位地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">得到的32位地址也要转换成本地顺序</span></span><br><span class="line"><span class="comment">返回：若成功返回1，串非法返回0，错误返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位地址转换成点分十进制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用该函数之前，要将32位IP地址转换成网络顺序</span></span><br><span class="line"><span class="comment">把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中</span></span><br><span class="line"><span class="comment">返回：若成功返回指向点分十进制地址的指针，出错返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>附</p>
<ol>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将十六进制字符串转换成十进制数：</span></span><br><span class="line">使用<span class="built_in">sscanf</span>(str, <span class="string">&quot;%x&quot;</span>, &amp;num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用32位IP地址时，可以直接使用<code>in_addr</code>结构而不是<code>in_addr</code>结构里的<code>s_addr</code></p>
</li>
</ol>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>是一组绝大多数操作系统都定义的函数，可以实现网络应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209231151155.png" alt="image-20220923115128790"></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个结构体所占字节数相同，可以互相转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;  <span class="comment">// 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6)</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;    <span class="comment">// 端口号，使用网络字节顺序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IP地址结构</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">// 填充0，为了满足struct sockaddr的大小</span></span><br><span class="line">&#125;;    <span class="comment">// 这个结构体一共占16个字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="socket-通用"><a href="#socket-通用" class="headerlink" title="socket() 通用"></a>socket() 通用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使套接字称为一个连接的结点</span></span><br><span class="line"><span class="comment">返回一个还不能用于读写的描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使称为一个连接点</span></span><br><span class="line">clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="connect-客户端"><a href="#connect-客户端" class="headerlink" title="connect() 客户端"></a>connect() 客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="bind-服务器"><a href="#bind-服务器" class="headerlink" title="bind()  服务器"></a>bind()  服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="listen-服务器"><a href="#listen-服务器" class="headerlink" title="listen() 服务器"></a>listen() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="accept-服务器"><a href="#accept-服务器" class="headerlink" title="accept() 服务器"></a>accept() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功返回非负连接描述符， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>服务器：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>bind()</code> 成为一个服务器套接字</li>
<li>调用<code>listen()</code> 转换成监听描述符</li>
<li>调用<code>accept()</code> ，阻塞程序，等待客户端连接，返回连接描述符</li>
</ol>
<p>客户端：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>connect()</code>， 连接服务器</li>
</ol>
<h3 id="套接字地址和主机名服务名的转换"><a href="#套接字地址和主机名服务名的转换" class="headerlink" title="套接字地址和主机名服务名的转换"></a>套接字地址和主机名服务名的转换</h3><p>首先了解，域名和IP地址是等价的，服务名和端口号是等价的</p>
<p>例如localhost和127.0.0.1是等价的，http和80是等价的</p>
<h4 id="从-字符串主机名服务名信息-到-二进制套接字地址信息"><a href="#从-字符串主机名服务名信息-到-二进制套接字地址信息" class="headerlink" title="从 字符串主机名服务名信息 到 二进制套接字地址信息"></a>从 字符串主机名服务名信息 到 二进制套接字地址信息</h4><blockquote>
<p>为什么要使用这个函数？</p>
<p>域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">host: 域名或点分十进制IP地址</span></span><br><span class="line"><span class="comment">service: 服务名或端口号</span></span><br><span class="line"><span class="comment">hints: 可选 传递设置</span></span><br><span class="line"><span class="comment">result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放返回的链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo, *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将错误代码转换成错误信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getaddrinfo</code> 使用的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;</span><br><span class="line">    <span class="type">int</span> ai_family;</span><br><span class="line">    <span class="type">int</span> ai_socktype;</span><br><span class="line">    <span class="type">int</span> ai_protocol;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ai_canonname;</span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从-二进制套接字地址信息-到-字符串主机名服务名信息"><a href="#从-二进制套接字地址信息-到-字符串主机名服务名信息" class="headerlink" title="从 二进制套接字地址信息 到 字符串主机名服务名信息"></a>从 二进制套接字地址信息 到 字符串主机名服务名信息</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen,</span></span><br><span class="line"><span class="params">               <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, </span></span><br><span class="line"><span class="params">               <span class="type">char</span> *service, <span class="type">size_t</span> servlen,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="辅助简化函数"><a href="#辅助简化函数" class="headerlink" title="辅助简化函数"></a>辅助简化函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> clientfd, rc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;  <span class="comment">/* Open a connection */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV;  <span class="comment">/* ... using a numeric port arg. */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;  <span class="comment">/* Recommended for connections */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (%s:%s): %s\n&quot;</span>, hostname, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Walk the list for one that we can successfully connect to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Connect to the server */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(clientfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Connect failed, try another */</span>  <span class="comment">//line:netp:openclientfd:closefd</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_clientfd: close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* All connects failed */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* The last connect succeeded */</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="type">const</span> <span class="type">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* No address worked */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echoserver.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received:%s\n&quot;</span>, buf);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE,</span><br><span class="line">        client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>protocol family 协议簇：一组相关联的协议</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>系统级I/O - CS:APP 第十章</title>
    <url>/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="系统级I-O-CS-APP-第十章"><a href="#系统级I-O-CS-APP-第十章" class="headerlink" title="系统级I/O - CS:APP 第十章"></a>系统级I/O - CS:APP 第十章</h1><p>Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。</p>
<p>在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul>
<li><p>定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。</p>
</li>
<li><p>Linux Shell 创建的进程会打开三个文件：</p>
<p>0：标准输入；也可以使用定义在<code>unistd.h</code> 中的<code>STDIN_FILENO</code> 来显示表述</p>
<p>1：标准输出；<code>STDOUT_FILENO</code></p>
<p>2：标准错误；<code>STDERR_FILENO</code> </p>
</li>
<li><p>EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;= m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。</p>
</li>
</ul>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul>
<li>普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。</li>
<li>目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是<code>.</code> 和<code>..</code> 分别代表自己和上层目录。</li>
<li>套接字 socket ：用来和其他进程进行跨网络通信的文件。</li>
</ul>
<h2 id="系统级IO函数"><a href="#系统级IO函数" class="headerlink" title="系统级IO函数"></a>系统级IO函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开和关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flags: 文件的打开方式</span></span><br><span class="line"><span class="comment">O_RDONLY   只读</span></span><br><span class="line"><span class="comment">O_WRONLY  只写</span></span><br><span class="line"><span class="comment">O_RDWR    可读可写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">O_CREAT   如果文件不存在，创建</span></span><br><span class="line"><span class="comment">O_TRUNC    如果文件已存在，截断它（即覆盖原文件）</span></span><br><span class="line"><span class="comment">O_APPEND  添加到文件末尾</span></span><br><span class="line"><span class="comment">不同的flag可以使用管道符| 连接使用 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mode:</span></span><br><span class="line"><span class="comment">一般为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回-1，EOF返回0，出错返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回写的字节数，出错返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>ssize_t</code> ：signed size type</p>
<p>read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n</p>
<p>可能会返回不足值得情况：</p>
<ul>
<li>读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。</li>
<li>从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li>
<li>读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。</li>
</ul>
<h2 id="RIO包函数"><a href="#RIO包函数" class="headerlink" title="RIO包函数"></a>RIO包函数</h2><p>RIO(Robust I/O)：用于网络编程中，会自动处理不足值的情况。</p>
<h3 id="总览："><a href="#总览：" class="headerlink" title="总览："></a>总览：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带缓冲区的版本</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替read</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带缓冲区的版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;  <span class="comment">// 带缓冲区的rio_readn</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>带缓冲区和不带缓冲区的优劣：</p>
<p>带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。</p>
<p>不带缓冲区：比较快速，方便在网络上进行数据传输（臆断）</p>
</blockquote>
<h3 id="不带缓冲区的函数"><a href="#不带缓冲区的函数" class="headerlink" title="不带缓冲区的函数"></a>不带缓冲区的函数</h3><h3 id="rio-readn"><a href="#rio-readn" class="headerlink" title="rio_readn()"></a>rio_readn()</h3><p>用来代替<code>read</code> 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// 整个程序中，还没有被读取的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// 单次调用read 函数所读取的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// read 函数发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)     <span class="comment">// interrupted by a sig handler return</span></span><br><span class="line">                nread = <span class="number">0</span>;      <span class="comment">// call read again</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;      <span class="comment">// 这个程序读取的所有字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-writen"><a href="#rio-writen" class="headerlink" title="rio_writen()"></a>rio_writen()</h3><p>用来代替<code>write</code> 的函数，无缓冲区，绝对不可能返回不足值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;    <span class="comment">// 整个程序中，还没有被写入的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nwritten;    <span class="comment">// 单词write函数写入的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;  <span class="comment">// 下一个将被写入的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)    <span class="comment">// 被一个信号处理程序返回打断</span></span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带缓冲区的函数"><a href="#带缓冲区的函数" class="headerlink" title="带缓冲区的函数"></a>带缓冲区的函数</h3><p>缓冲区的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192  <span class="comment">// 缓冲区的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;        <span class="comment">// 与缓冲区关联的文件描述符</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;      <span class="comment">// 缓冲区中的未读字节数</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;    <span class="comment">// 下一个未读字节地址</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];    <span class="comment">// 缓冲区</span></span><br><span class="line">&#125;<span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>
<p>初始化缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> rio_</span><br></pre></td></tr></table></figure>
<h3 id="rio-read"><a href="#rio-read" class="headerlink" title="rio_read()"></a>rio_read()</h3><p>带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数</p>
<p>该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。</p>
<p>该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;  <span class="comment">// 本次调用函数读取的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 如果缓冲区为空，重新填满缓冲区</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)    <span class="comment">// 被信号打断，自动重启</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// EOF</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">// 重置bufptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)    <span class="comment">// 缓冲区字节数不够</span></span><br><span class="line">        cnt = rp-&gt;rio_cnt;      <span class="comment">// 返回不足值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readlineb"><a href="#rio-readlineb" class="headerlink" title="rio_readlineb()"></a>rio_readlineb()</h3><p>读取一行，最多读取maxlen-1个字节，最后一个字节要填充<code>&#39;\0&#39;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, rc;    <span class="comment">// n 程序读取字节数， rc 单次rio_read 的返回值</span></span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;    <span class="comment">// c一个临时变量，用于逐个读取，测试是否为换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;  <span class="comment">// 正常</span></span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;  <span class="comment">// 返回不足值</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// EOF，什么字节也没读取，直接返回0</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">// EOF, 但已经读取了一些字节，需要处理后返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *bufp = <span class="number">0</span>;      <span class="comment">// 最后一位用 &#x27;\0&#x27; 填充</span></span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readnb"><a href="#rio-readnb" class="headerlink" title="rio_readnb()"></a>rio_readnb()</h3><p>rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// bytes that has not been read</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// read() func had read nread bytes</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)   <span class="comment">// someting wrong</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>stat()</code> 函数以文件名作为输入，填写<code>struct stat *buf</code>  </p>
<p>我们只对<code>struct stat</code> 的一些条目感兴趣：</p>
<ul>
<li><p><code>buf-&gt;st_size</code> 文件的大小</p>
</li>
<li><p><code>buf-&gt;st_mode</code> 使用在<code>sys/stat.h</code> 的三个宏可以判断文件类型：</p>
<p><code>S_ISREG(mode)</code> 这是一个普通文件吗？</p>
<p><code>S_ISDIR(mode)</code> 这是一个目录文件吗？</p>
<p><code>S_ISSOCK(mode)</code> 这是一个网络套接字吗？</p>
</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent * <span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;      <span class="comment">// inode number 文件位置</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];    <span class="comment">// Filename		文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO重定位"><a href="#IO重定位" class="headerlink" title="IO重定位"></a>IO重定位</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>西方哲学史 希尔贝克</title>
    <url>/2023/01/22/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2%20%E5%B8%8C%E5%B0%94%E8%B4%9D%E5%85%8B/</url>
    <content><![CDATA[<h1 id="《西方哲学史》希尔贝克-读书笔记"><a href="#《西方哲学史》希尔贝克-读书笔记" class="headerlink" title="《西方哲学史》希尔贝克 读书笔记"></a>《西方哲学史》希尔贝克 读书笔记</h1><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>在这里记录一下自己感兴趣的问题：</p>
<ol>
<li><p>是否存在普遍的善和正当的价值规范存在</p>
<p>智者派的相对主义</p>
<p>苏格拉底的驳斥</p>
<p>柏拉图的理念论</p>
</li>
</ol>
<p>从这里记录一下自己的想法：</p>
<ol>
<li><p>很多哲学家都强调过一些东西：</p>
<p>比如苏格拉底强调要通过开放性的对话获得对真正自我的洞见</p>
<p>康德说要运用理性是自己摆脱不成熟状态</p>
<p>罗素说要告诉自己事实是什么</p>
<p>他们的意思都大体相同，都是在强调通过理性形成自己的观点。</p>
</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="苏格拉底"><a href="#苏格拉底" class="headerlink" title="苏格拉底"></a>苏格拉底</h2><ul>
<li><p>苏格拉底感兴趣的是 认识论 和 伦理-政治问题</p>
</li>
<li><p>在<strong>认识论</strong>上，苏格拉底认为的知识可由粗略的三分法来表述</p>
<blockquote>
<ol>
<li>有关是什么的知识</li>
<li>对于应当是什么的知识</li>
<li>对真正自我的洞见（即通过理性的信服而不是通过修辞术的说服）</li>
</ol>
</blockquote>
<p>要如何获得第三种知识，苏格拉底赞同一种开放性的对话方法，在公开讨论中，让讨论的各方充分地了解论题，得到自己信服的观点。</p>
</li>
<li><p>在<strong>伦理政治问题</strong>上，驳斥怀疑论，承认有普遍的善和正当的价值规范存在</p>
<p>知识即美德，拥有知识就回去行善，就会导向幸福。</p>
<blockquote>
<p>即使苏格拉底得不出一个确定的哲学答案，但他仍在努力寻求答案，仍在赋予道德一个特定的认识论基础</p>
</blockquote>
<p>我的理解是，苏格拉底想要在认识论上为道德奠定一个基础，即一个拥有“对真正自我的洞见”的人不去行善，是不可思议的。</p>
</li>
</ul>
<h2 id="柏拉图"><a href="#柏拉图" class="headerlink" title="柏拉图"></a>柏拉图</h2><ul>
<li><p>本体论，理念论，认为理念是客观存在的第一实体</p>
</li>
<li><p>认识论，回忆说，灵魂通过可感现象的刺激回忆起前世对理念的知识。但柏拉图认为对理念的洞见只有少数人才能达到。</p>
</li>
<li><p>在伦理学上，由于理念论的存在，存在客观存在的善的理念，因此道德具有稳固的基础，即存在普遍的善和正当的价值规范。</p>
<p>一个行为之所以是善的，是因为它分有了善的理念，而善的理念还与智慧、勇敢和节制有关，理念和理念之间交织在一起。</p>
</li>
<li><p>政治上，柏拉图怀疑人们的知善能力，认为必须由「专家」们执政，因此有了三种社会层次——生产者、管理者和统治者。（理想国）</p>
</li>
<li><p>艺术上，柏拉图认为艺术作品不能「为艺术而艺术」，理念之间是相互联系的，善、美的理念交织在一起，艺术不能脱离道德，艺术不是道德中立的。</p>
<p>柏拉图认为艺术的本质是复制和摹仿，理念是可感事物的原型，它是复制可感事物的艺术品的原型，因此艺术家应该努力复制理念。艺术家可以不只受可感事物的激发，而直接被理念激发，这样艺术家就成了传递理念的媒介。</p>
</li>
</ul>
<h2 id="亚里士多德"><a href="#亚里士多德" class="headerlink" title="亚里士多德"></a>亚里士多德</h2><ul>
<li><p>本体论（形而上学），</p>
<p>实体与属性论，亚里士多德认为只有个别的事物是存在的，即「实体」。颜色，形状等都是作为实体的属性，离开了实体，属性无法独立存在。属性分为本质属性和非本质属性，根据这两种属性之间的划分，形成了「种的概念」，属性和种是相对存在的。</p>
<p>四因说，亚里士多德将世界上事物变化与运动背后的原因归纳为四大类，即质料因、形式因、动力因、目的因。</p>
<p>潜能 - 现实，变化是潜能的现实化</p>
<p>分级的有机世界观，从纯质料到达纯现实，从无机物到人。在亚里士多德的世界观中，每一种事物都倾向于以最好的方式去实现自己的潜能，万事万物都有一种「向上」的渴望。但是每一个种在宇宙中都有既定的位置。</p>
</li>
<li><p>认识论</p>
<p>获取知识的第一步是用我们的感官来经验个别事物，第二步是从偶然性中抽象出本质和共相。</p>
<p>亚里士多德把知识的获取过程看成一个从感觉经验到本质洞见的过程。</p>
<p>亚里士多德区分了三种学科：</p>
<p>理论科学：目的是确定真理。如自然哲学、数学、形而上学。</p>
<p>实践科学：通过获得性的伦理能力导向明智的行动。如政治学。</p>
<p>创制科学：生产某物，具有创造性。如诗学和修辞学。</p>
</li>
<li><p>伦理学，亚里士多德认为人如同一粒种子，具有可实现的潜力（理性），人要经历社会化的三个阶段（家庭、村落、城邦），在共同体中找到自己的位置。</p>
</li>
<li><p>政治上，支持平等原则。收集了158中城邦材料，讨论其中最好的形式：必须要听取民众的意见，必须要依法治国。</p>
<p>结论是：有限民主是最好的国家政体。这一国家由法律治理，而且是「混合政体」：在量上实行民主制原则，质上实行贵族制原则。</p>
</li>
<li><p>艺术上，亚里士多德认为，艺术是自身产生愉悦的模仿。艺术同样具有道德上的功能，具有净化或纯化的作用。</p>
<p>关于艺术在道德上的功能的两种解释：</p>
<blockquote>
<ol>
<li>艺术的净化作用在于它能使我们「释放情绪」。通过体验戏剧中的英雄、恶棍和崇高的感情，我们释放出被压抑和控制不住的情感，这样就恢复和谐，并重新开始过依照「中道」理想的生活。</li>
<li>艺术的净化作用在于，我们人可以通过艺术来得到教化，使精神升华。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="希腊化-罗马时期"><a href="#希腊化-罗马时期" class="headerlink" title="希腊化 - 罗马时期"></a>希腊化 - 罗马时期</h2><ul>
<li>希腊化时期人民对政治感到无能为力，这种无能为力在思想上表现在：回避对社会进行哲学思辨，而关注如何确保个人的幸福。希腊化时期有一种从关心共同体中的人向关心孤立的、私人的个体的普遍转向。</li>
<li>对于希腊人，法律仅仅适用于地方共同体中的人。到了希腊化时期，出现了一种把法律当作不分国家，不分地位人人适用的普遍法则的观点。（自然法）</li>
<li>「政治」词义的转变，在古希腊，政治指调节一个城邦的地方共同体中的公共活动的理性讨论，在希腊化时期，它主要指统治一个帝国的一般的法律原则。</li>
</ul>
<h3 id="伊壁鸠鲁主义"><a href="#伊壁鸠鲁主义" class="headerlink" title="伊壁鸠鲁主义"></a>伊壁鸠鲁主义</h3><ul>
<li><p>伊壁鸠鲁主义是一种受谨慎和深思熟虑影响的快乐哲学，它可以被概括如下</p>
<blockquote>
<ol>
<li>存在着唯一的善是快乐</li>
<li>要确保最大的快乐，我们必须只享受我们能支配的快乐。</li>
</ol>
</blockquote>
</li>
<li><p>伊壁鸠鲁主义的快乐不是一时的感性欲望，伊壁鸠鲁主义者强调那些更精致、更稳定的快乐形式，如友谊、文采。</p>
</li>
</ul>
<h3 id="犬儒学派"><a href="#犬儒学派" class="headerlink" title="犬儒学派"></a>犬儒学派</h3><ul>
<li>犬儒们从社会中抽身，过着一种简单地、半原始的生活</li>
<li>犬儒主义教导境遇不利者要满足于他们所拥有的东西，即使他们一无所有。</li>
</ul>
<h3 id="希腊斯多葛学派"><a href="#希腊斯多葛学派" class="headerlink" title="希腊斯多葛学派"></a>希腊斯多葛学派</h3><ul>
<li><p>幸福观（同苏格拉底和柏拉图）：一个人幸福的唯一条件是他或她过有德性的生活，而美德是以知识为基础的。</p>
<blockquote>
<p>补充：美德 arete，与英语中的virtue一词相似</p>
<p>arete，美德意味着一个人在社会中实现他的真正潜能，因此是积极美德。（消极美德：不去作恶）</p>
<p>这种美德是道德上的优秀也是指一个人尽可能好地履行被赋予地职能或角色的优秀。教师的优秀体现在教的好，铁匠的优秀体现在能制作出好的工具，人的美德在于尽其所能，实现人之为人的真正潜能。</p>
</blockquote>
</li>
<li><p>宿命论，万物都受逻各斯或神的引导，人的任务是去学会对发生的一切事情都愉快地接受，在命运的判决面前，一个人应该显示出斯多葛式的平静。 或者说 人应该去支配自己能够支配的东西，如自己的内心。</p>
</li>
<li></li>
</ul>
<h3 id="希腊-希腊化时期的斯多葛学派"><a href="#希腊-希腊化时期的斯多葛学派" class="headerlink" title="希腊 - 希腊化时期的斯多葛学派"></a>希腊 - 希腊化时期的斯多葛学派</h3><ul>
<li>成为了中产阶级的意识形态，强调责任与品格，重视一种适用于所有人的自然法。</li>
</ul>
<h3 id="罗马的斯多葛学派"><a href="#罗马的斯多葛学派" class="headerlink" title="罗马的斯多葛学派"></a>罗马的斯多葛学派</h3><ul>
<li><p>历史观，对世界历史持有一种循环的观点（宿命论的），任何事物都会像四季那样重复自身，万物都重复自己，那么我们就无法改善这个世界，我们只能尽可能地忍受。</p>
</li>
<li><p>个人，个人不再是群体的有机部分，而是普遍法典和政府体制下的一个人。</p>
</li>
<li><p>法律的来源，对斯多葛学派来说，每个人心中都存在一团「圣火」，他们从普遍理性中引出自然法。（即自然法基于普遍理性）</p>
<blockquote>
<p>「完善的法律要到智者的灵魂之中去找」 西塞罗</p>
</blockquote>
</li>
<li><p>自然法，法律的-政治的法则的基础在于一个普遍的自然法则（自然法），自然法适用于所有人。</p>
</li>
</ul>
<h2 id="霍布斯"><a href="#霍布斯" class="headerlink" title="霍布斯"></a>霍布斯</h2><ul>
<li><p>自然哲学：彻底机械唯物主义</p>
</li>
<li><p>政治哲学：</p>
<p>观点：</p>
<p>建立一个可以确保和平与秩序的政府，权力必须集于一身，不论是国王的政府还是议会的政府，都要确保和平与秩序。</p>
<p>研究方法：功能主义的分析与综合</p>
<p>霍布斯用一种功能主义的方法去理解社会，他考察社会各部分的功能，然后将他们组合到一起。霍布斯的方法，不是一种还原论，他不认为整体的功能是部分的组合。</p>
<p>研究历程：</p>
<p>首先考虑政府的作用，用一个思想实验来说明政府的功能，如果没有政府，人们将生活在一种一切人反对一切人的战争的自然状态。由于个人自我保存的需要，一个建立在一种受理性承认的社会契约的基础上的国家出现了。这个国家的政府通过确保和平与秩序而获得合法性，它拥有所有的权力，当政府不能确保和平与秩序时，它也就失去了合法性。</p>
<p><strong>（个人感想）</strong>霍布斯的说明是功能主义的，他说社会契约创造的国家政府使人们远离自然状态，并不是说真的存在自然状态，只是在功能主义的思想实验中，如果没有政府，可能会存在一切人对一切人的战争。</p>
<p>正如作者在洛克一节中补充道：</p>
<blockquote>
<p>自然状态学说并不是一种关于国家起源的学说，并不是关于国家实际上如何产生的学说，而是一种说明国家是什么，并为国家提供合法性的学说。</p>
</blockquote>
</li>
<li><p>资本主义的发展与意识形态之间的联系：</p>
<p>早期的资本主义：生存斗争非常艰苦，需要一个专制君主（霍布斯的观点）</p>
<p>比较成形的资本主义：市民阶级有必要关注专制君主和相对不可侵犯的权利。</p>
<p>完全形成的私人资本主义和自由放任的自由主义：出现了关注快乐的功利主义。</p>
</li>
<li><p>关于自由和自由主义</p>
<p>自由主义（liberalism）和自由主义者（liberalist）:其基本概念是个人、契约和国家</p>
<p>自由气度（liberality）和自由派人士（liberal）：倾向于宽容和司法自由的正面的道德的态度。</p>
<p>洛克既是自由主义者又是自由派人士，霍布斯可有说是自由主义者但不是自由派人士。</p>
<blockquote>
<p><strong>自由并不是一个独立成立的概念，一种关于自由的哲学必须预设了一个讨论有关什么是自由的、以什么方式它是自由的学说。</strong></p>
<p>对于自由主义者来说，自由地主体是被理解为自我满足的、理性的、自私自利地行动着地个人，因此我们把自由主义定义为一种形式地个人主义的时候，并不是随心所欲的。</p>
<p>理解自由主义，是离不开它所预设的社会哲学或存在论的——同样，理解任何其他有关自由的学说，也离不开与之伴随的有关什么是自由的、相对于什么而自由的学说。</p>
</blockquote>
<p>通常人们用<strong>自由主义</strong>这个术语来表示这样一些政治-经济理论，他们把自由看作一个基本价值，把个人的开明的自利看作是基础的驱动力，而把国家的任务看作是为独立的行动者确保和平与秩序。</p>
</li>
</ul>
<h2 id="笛卡尔"><a href="#笛卡尔" class="headerlink" title="笛卡尔"></a>笛卡尔</h2><p>唯理论 </p>
<ul>
<li>有条理的怀疑，确定什么是逻辑上可怀疑的。</li>
<li>我思故我在，是笛卡尔的出发点，他认为自己拥有一个关于完美存在的观念，而关于完美存在的观念不能是由不完美的存在（自己）引起的，因此只能是由上帝引起的。</li>
<li>这样笛卡尔为之前那些原则上可错的知识进行了平反，他们有了一个牢固的基础。</li>
</ul>
<p>心物二元论：物质实体和精神实体都是存在的，他们相互影响，在松果体交互。</p>
<h2 id="斯宾诺莎"><a href="#斯宾诺莎" class="headerlink" title="斯宾诺莎"></a>斯宾诺莎</h2><ul>
<li><p>斯宾诺莎在认识论上是一个唯理论者，在道德理论上与斯多葛学派相近，在自然理论上与泛神论有联系。</p>
</li>
<li><p>在认识论上，斯宾诺莎预设了我们拥有清晰的直觉（清晰而确定的知识）。有三种认识的道路，其中借助逻辑推理的方式获得知识是可靠的。</p>
</li>
<li><p>在本体论上（斯宾诺莎在他的《伦理学》中阐述），斯宾诺莎以一种几何学、唯理论的方式进行思考，它首先设定了一些公理，然后从这些公理出发去演绎。</p>
<p>斯宾诺莎对实体的定义（公理）是：「实体，我理解为在自身内并通过自身而被认识的东西。」，即实体是独立的，不依赖他物而存在的。</p>
<p>根据这个定义，如果存在两个以上的实体，那么第一个实体和第二个实体之间的关系就会被包括到我们对实体的理解中，这样实体就不是独立存在的了，这与我们所定义的实体的概念相悖，因此只有一个实体，实体是一，也是无限。</p>
<p>如果存在一个神的话，神不可能是有别于实体的东西，因此实体就是神。（我的理解是，如果一个人信仰存在神的话，它可以把实体理解为神）</p>
</li>
<li><p>实体，属性和样式</p>
<p>实体可以有无限多的显现方式，它向我们现行的方式就是两种属性——思维的属性和广延的属性，而一本书可以是广延属性之下的样式，一个人的思想可以是思想属性下的样式。（关于样式，我认为可以这样理解，想象实体是一个巨大的球体，而上边有很多纹路，即样式，我们用不同的属性去观察实体上的样式，用广延的属性去观察，我们看到了人的形体，用思维的属性去观察，我们看到了人的思想）</p>
</li>
<li><p>关于自由</p>
<p>斯宾诺莎认为，一个人根本上是与实体统一的，因此说一个人相对于实体而自由或者受实体强制是毫无意义的。</p>
</li>
</ul>
<h2 id="莱布尼茨"><a href="#莱布尼茨" class="headerlink" title="莱布尼茨"></a>莱布尼茨</h2><blockquote>
<p>莱布尼茨说表面上给人印象是物质的、被动的那些东西，本质上确实能动的力量。我们简短地看看莱布尼茨是如何设法在机械论的，唯理论的宇宙地下建立一个非唯物主义的，目的论的「底层」的。</p>
</blockquote>
<ul>
<li><p>单子论</p>
<p>单子是宇宙建立于其上的基本元素，单子是存在等级的，每个单子都不受其他单子影响。</p>
<p>前定和谐：上帝确保了单子的和谐运行（一种目的论的解释）</p>
</li>
<li><p>「所有可能世界中最好的世界」</p>
</li>
</ul>
<h2 id="洛克"><a href="#洛克" class="headerlink" title="洛克"></a>洛克</h2><ul>
<li><p>认识论</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208111207303.png" alt="洛克的经验主义认识论"></p>
<ul>
<li><p>唯理论者认为清晰的概念使我们洞察实在的本质。从洛克到康德，标准的论证是说，对概念的洞见并不必然提供对实在的洞见。</p>
</li>
<li><p>洛克在进行思考前的预设：要做一个理性的人，就意味着去追求真理的意思，追求真理就预设了某种思想自由和宽容，即别人也可能是正确的，我们也能从他们那里学到什么。这样讨论就预设了一种非独断的、开放的态度。</p>
</li>
<li><p>洛克面临着一个关于还原的问题：知识是经验的总和呢，还是不仅仅是这种总和呢？ </p>
<p>如果我们回答说知识可以还原到经验的部分，我们会得到一种彻底的经验论立场，即知识可以被完全地、充分地分析为简单地直觉观念。</p>
<p>如果我们回答说知识的构成开始于简单的直觉观念，那我们的意思是说知识仍然包含着某种与这些观念之和有质的区别的东西。</p>
<p>洛克很有可能是第二种立场。</p>
</li>
</ul>
</li>
<li><p>政治理论</p>
<p><strong>概括：</strong> 洛克的政治理论延续了霍布斯的传统，从自然状态开始，通过社会契约来维护政府的合法性。</p>
<p><strong>背景</strong></p>
<p>洛克是资本主义这样一个时期中的自由主义的思想代表，在这个时期，市民阶级不需要一个绝对君主（霍布斯）来约束贵族，统一民族国家，而希望废除绝对君主制、直接支配政府。</p>
<p>洛克思想的前提：1. 资源足够每个人所用，私人财产是个人劳动的结果。2. 当人们在谈论人民，<strong>谈论个人的时候，他们所指的一般是中产阶级或贵族。</strong> </p>
<p><strong>内容</strong></p>
<p>洛克的自然状态：洛克的自然状态不同于霍布斯的自然状态（比霍布斯的自然状态要发达），在这里每个人都是平等与自由的，这意味着我们自由地支配着我们自己的身体和我们用我们身体所取得地任何东西。洛克区分了社会和国家，社会是一种自发地有规律地运作，国家则是一种政治安排。在洛克的自然状态中，人们已经订立了一种引进货币的「默许和自愿的同一」，已经产生了土地的不公平分配，人们可以用货币，正当的取得东西，不再有自然的限度。</p>
<p>有两个理由让我们离开这种自然状态：1.每个人都确保对声明感兴趣。2.拥有财产的人确保对这种财产感兴趣，因此每个人都对这样一种社会契约感兴趣。</p>
<p>由此，在人们签订的社会契约下，产生了国家。对洛克来说，</p>
<blockquote>
<ol>
<li>国家首先确保私有财产。</li>
<li>洛克支持这样一种经济制度，国家保护私有财产，对其他国家实行贸易保护主义政策，但不对贸易和产业实行监督和控制。</li>
<li>洛克反对专制主义，认为主权在共同体的公民那里，既然公民们已经批准了社会契约，他们就必须接受多数人的意志。</li>
<li>洛克关心限制统治者的权利，支持政府中的权力分立原则。</li>
</ol>
</blockquote>
<p><strong>关于经济不平等</strong></p>
<p>洛克认为，在人们签订社会契约之前，人们已经订立了一种引进货币的「默许和自愿的同意」，经济不平等就已经出现了，这时候政治意义上的社会还没有建立，人们仍处在自然状态。没有理由因为随着货币的引入而产生的物质不平等去责怪政治意义上的社会。即，对于经济不平等，洛克归结为由于大众自由地达成的一个自愿的同意。</p>
</li>
</ul>
<h2 id="贝克莱"><a href="#贝克莱" class="headerlink" title="贝克莱"></a>贝克莱</h2><ul>
<li><p>贝克莱从经验主义的认识论出发，拒绝了物质是某种不同于性质的东西的观点，即洛克的第一性质和第二性质都是依赖感知他们的主体，这样贝克莱把通常的物质观诠释为诸多感觉印象的一种集合，当我们谈论实在时，我们谈论的是不依赖我们意志出现的感觉印象。</p>
</li>
<li><p>「存在」就是「被感知」：不可能被感知的就不存在，某物存在就是某物可能被感知。</p>
</li>
<li><p>引入上帝，到达有神论：贝克莱不认为存在依赖于我们的感觉印象，他认为存在就是被感知这个原则，预设了有某人在感知着，这个某人就是上帝。上帝确保了经验的规则性、有序性，事件之间的必然联系的根源在于上帝。</p>
<p>上帝在贝克莱这里起的作用，大致相当于物质在洛克那里起的作用，以及物自体在康德那里起的作用。</p>
</li>
<li><p>评价（希尔贝克）：贝克莱从经验主义的认识论出发，达到了一种关于存在之形式的二元论，意识和印象，理解者和被理解者。</p>
<p>贝克莱从概念唯名论出发拒绝了哲学的物质观念，像马和人类这样的词是作为简略语，但不意味着像马和房子这样的普遍概念存在着。</p>
<p>（所以什么是「存在着」呢？）</p>
</li>
</ul>
<h2 id="休谟"><a href="#休谟" class="headerlink" title="休谟"></a>休谟</h2><ul>
<li><p>认识论：彻底的/激进的经验主义立场</p>
<p>关于知识的起源：休谟在印象和观念之间做出了区分，印象包括外在知觉和内在知觉，观念被视作建立在这些印象之上的心灵图像。</p>
<p>休谟认为存在两种知识：</p>
<ol>
<li>逻辑知识，它涉及的是概念之间的关系，它们是「分析的」</li>
<li>经验知识，它的基础是简单地感觉印象。它们是「综合的」</li>
</ol>
<p>休谟认为关键的是，观念有没有正当的「谱系」，即有没有可能把观念回溯到印象</p>
</li>
<li><p>对物质实体、精神实体、因果性的批判</p>
<p>对于物质实体，我们把稳定的印象群成为实体，我们对这些性质群「背后」所存在的任何基础性的物质实体是没有经验的，因此，休谟认为物质实体的观念是一种站不住脚的形而上学的观念。</p>
<p>对于精神实体，我们能把握的仅仅是内部印象，这些印象常常以确定的、比较稳定的方式成群出现。因此我们谈论一个处在「背后」，并将这些内在印象连接在一起的自我，实际上只是一种形而上学的幻觉。</p>
<p>对于因果性，休谟认为，原因的概念具有以下特征1. 相继性2. 接触性 3.必然性，我们能经验到原因的相继性和接触性，但我们通过经验无法保证原因的必然性。</p>
</li>
<li><p>休谟并没有说在原因和结果之间没有必然联系，他只是说我们不可能知道这样一种必然性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存视角下的Linux进程 &amp; 动态内存分配 - CS:APP 第九章</title>
    <url>/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="虚拟内存视角下的Linux进程-amp-动态内存分配"><a href="#虚拟内存视角下的Linux进程-amp-动态内存分配" class="headerlink" title="虚拟内存视角下的Linux进程 &amp; 动态内存分配"></a>虚拟内存视角下的Linux进程 &amp; 动态内存分配</h1><h2 id="Linux的虚拟内存系统"><a href="#Linux的虚拟内存系统" class="headerlink" title="Linux的虚拟内存系统"></a>Linux的虚拟内存系统</h2><p>Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分：</p>
<ul>
<li>进程虚拟内存部分</li>
<li>内核虚拟内存部分</li>
</ul>
<p>进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>用户栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rsp →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>共享库的内存映射区域</td>
</tr>
<tr>
<td>brk →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>运行时的堆（通过malloc分配的）</td>
</tr>
<tr>
<td></td>
<td>未初始化的数据(.bss)</td>
</tr>
<tr>
<td></td>
<td>已初始化的数据(.data)</td>
</tr>
<tr>
<td>0x400000 →</td>
<td>代码(.text)</td>
</tr>
</tbody>
</table>
</div>
<p>内核虚拟内存可分为两部分：</p>
<ul>
<li>内核中的代码和数据及数据结构</li>
<li>被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>与进程相关的数据结构（页表、task和mm结构、内核栈）</th>
<th>每个进程都不相同</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理内存</td>
<td>每个进程都相同</td>
</tr>
<tr>
<td>内核代码和数据</td>
<td>每个进程都相同</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171118039.png" alt="image-20220917111815524"></p>
<h2 id="Linux如何组织虚拟内存"><a href="#Linux如何组织虚拟内存" class="headerlink" title="Linux如何组织虚拟内存"></a>Linux如何组织虚拟内存</h2><p>Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段</p>
<p>这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap）</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171117123.png" alt="image-20220917111745313"></p>
<h2 id="用户级内存映射"><a href="#用户级内存映射" class="headerlink" title="用户级内存映射"></a>用户级内存映射</h2><p>Linux 可以使用<code>mmap</code>函数来创建新的虚拟内存，并将对象映射到这些区域中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prot:</span></span><br><span class="line"><span class="comment">PROT_EXEC  该页面的区域可以被执行</span></span><br><span class="line"><span class="comment">PROT_READ  该页面区域可读</span></span><br><span class="line"><span class="comment">PROT_WRITE  ... 可写</span></span><br><span class="line"><span class="comment">PROT_NONE  ... 不能被访问</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">flags:</span></span><br><span class="line"><span class="comment">MAP_ANON    被映射的对象是一个匿名对象</span></span><br><span class="line"><span class="comment">MAP_PRIVATE    是一个私有对象，使用写时复制机制</span></span><br><span class="line"><span class="comment">MAP_SHARE    是一个共享对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">// 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误</span></span><br></pre></td></tr></table></figure>
<p>例子：将任意磁盘文件赋值到<code>stdout</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmapcopy</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bufp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load to virtual memory</span></span><br><span class="line">    bufp = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    Write(STDOUT_FILENO, bufp, size);   <span class="comment">// write to stdout</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open file </span></span><br><span class="line">    fd = Open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    fstat(fd, &amp;stat);   <span class="comment">// get detailed message of file</span></span><br><span class="line">    mmapcopy(fd, stat.st_size);     <span class="comment">// call mmapcopy</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理部分笔记</title>
    <url>/2023/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h2><p><strong>☆海明码是什么？</strong></p>
<blockquote>
<p>海明码是一种可以对数据校验，并至多可以校正一位出错的校验方法。</p>
<p>海明码有以下特点：</p>
<ul>
<li>海明码使用多重奇偶校验</li>
<li>海明码可以校正一位出错，并且可以指出出错的位置。</li>
<li>即使，校验位出错，对海明码的校验也没有影响。</li>
<li>海明码的校验位长度有规定。</li>
</ul>
</blockquote>
<p>海明码有n位数据和k位校验码组成n+k位，即p = n + k。海明码可生成k位的指示码$G_kG_{k-1}…G_1$ </p>
<p><strong>☆ 海明码的生成：</strong> </p>
<p>假如有4个要传输的数据位，即n=4。</p>
<p>海明码的校验位数k与数据位数n需满足：$2^k\ge n+1$（稍后解释） ，因此k取3。</p>
<p>于是我们有4位数据位，3位校验位，共七位。将3位校验位放到第2^i-1^ （i=1,2,3,…）位置上，数据位放到校验位的空隙中。如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>待定</td>
<td>待定</td>
<td>1</td>
<td>待定</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>接着计算校验位 k1, k2, k3</p>
<p>根据使用的校验方式不同，选择不同的校验方式（奇校验 / 偶校验），以偶校验为例：</p>
<p>$k_1=p_3\oplus p_5\oplus p_7=0$ </p>
<p>$k_2=p_3\oplus p_6\oplus p_7=1$</p>
<p>$k_1=p_5\oplus p_6\oplus p_7=0$ </p>
<p>这样我们得到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>k~1~ (001) 是 3 (011), 5 (101), 7 (111) 的偶校验位</p>
<p>k~2~ (010)是 3 (011), 6 (110), 7 (111) 的偶校验位</p>
<p>k~3~ (100) 是 5 (101), 6 (110), 7 (111) 的偶校验位</p>
<p>每个校验位的生成方法可归纳如下：首先校验位和数据位的索引变化成二进制形式，因为校验位只出现在2^i-1^ （i=1,2,3）的位置，因此校验位索引的二进制形式只有一个位置是1。对于其他的数据位，如果其索引的二进制形式的某个位置为1，且这个位置与某个校验位索引为1的位置相同，那么这个数据位就要参与这个校验位的生成。</p>
<p><strong>☆ 海明码的检验与校正：</strong> </p>
<p>当我们收到一个带海明校验的数据，我们对所有的校验位进行校验，并将得到的结果作为指示位$G_kG_{k-1…G_1}$。</p>
<p>对于上面的例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>$G_1 = k_1\oplus p_3\oplus p_5\oplus p_7=0$</p>
<p>$G_2 = k_2\oplus p_3\oplus p_6\oplus p_7=0$</p>
<p> $G_3 = k_3\oplus p_5\oplus p_6\oplus p_7=0$ </p>
<p>由于$G_3 G_2 G_1=000$ ，因此数据无误。</p>
<p>若第六位出错，$G_3 G_2 G_1=110$ 刚好指出了错误的位置，我们只要将第六位取反即可纠正。</p>
<p><strong>☆ 海明码的原理^[1]^：</strong> </p>
<ul>
<li><p>海明码由n位数据位和k位校验位组成，校验位可以指出数据出现错误的地方。</p>
<p>k位校验位可以表示 2^k^ 中状态，因此若要能指出每一位可能发生错误的地方，2^k^ &gt;= n</p>
<p>又因为，校验位必须还可以表示数据没有出错的情况，因此校验位还要多出一个状态。</p>
<p>综上，校验位数k和海明码数n需满足 2^k^ &gt;= n+1</p>
</li>
<li><p>海明码是如何分布的，为什么是这样分布的？</p>
<p>海明校验码的k个校验位$k_1,k_2,…k_i,…,k_n$ 的第i位（i = 1, 2, …, n）分别分布在第2^i-1^ 位上。</p>
<p>这是因为，当k = 3时，有一位校验位传输出错的话，则校验位与数据为进行奇偶校验的结果有3中，001，010，100，如果想要处理这种情况，只要令校验位位于001，010，100的位置就可以了。</p>
</li>
<li><p>海明码如何能指出错误的位置，为什么？</p>
<p>对于一个三位校验指示码$G_3G_2G_1$ ，</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    |<br>| —— | —— | —— | —— | —— | —— | —— |<br>| k1   | k2   | n1   | k3   | n2   | n3   | n4   |</p>
<p>G1等于1意味着001，011，111，101，必然有一个出错，因此$G_1=p_1\oplus p_3\oplus p_5\oplus p_7$ 。</p>
<p>同理，G2等于1意味着010，011，110，111，必有一个出错 ，即$G_2=p_2\oplus p_3\oplus p_6\oplus p_7$ </p>
<p>$G_3=p_4\oplus p_5\oplus p_6\oplus p_7$ </p>
<p>因此当n1出错时，G1=1,G2=1,G3=0，即011B = 3D，可以指出错误的位。</p>
<p>（参考文献 1 解释得更加详细！）</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 海明校验码是怎么实现的？: <a href="https://www.zhihu.com/question/29169628/answer/837787585">https://www.zhihu.com/question/29169628/answer/837787585</a> (这个讲得很好，循序渐进)</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>配置博客</title>
    <url>/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="博客配置-amp-使用教程"><a href="#博客配置-amp-使用教程" class="headerlink" title="博客配置 &amp; 使用教程"></a>博客配置 &amp; 使用教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。</p>
<p>本文章记录了配置博客和使用博客的一些细节，供以后的我参考。</p>
<p>持续更新中 ……</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>调试：</p>
<p><code>hexo server --debug</code> 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面</p>
</li>
</ul>
<ul>
<li><p>修改/发布博客 进行更新：</p>
<p><code>hexo clean</code> 清理缓存和public文件夹</p>
<p><code>hexo g</code> generate，生成静态页面，该操作之后即可在本地预览。</p>
<p><code>hexo d</code>  deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。</p>
</li>
</ul>
<ul>
<li><p>发布博客</p>
<p><code>hexo new [layout] [title]</code> 使用layout，在_post/title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。</p>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>可以在 <code>_config.yml</code> 里配置Hexo，在 <code>_config.nexmoe.yml</code> 里配置nexmoe主题。</li>
</ul>
<p><strong>_config.yml :</strong></p>
<ol>
<li><p>配置 网站的标题、副标题、关键词、作者、语言、时区<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208211114450.png" alt="image-20220821111147069"> </p>
</li>
<li><p>部署设置，其中repository可以填ssh的链接（执行<code>git clone</code> 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208211114595.png" alt="image-20220821111400429"> </p>
</li>
</ol>
<p><strong>_config.nexmoe.yml：</strong></p>
<ol>
<li>网站的默认头图，头像，图标等均在这里配置。</li>
<li>如果要使用本地相对路径，<code>./</code> 的绝对路径即博客根目录下的source文件夹。</li>
</ol>
<h2 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h2><p>在这里可以配置文件的变量。</p>
<p>hexo 的文档：<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter | Hexo</a></p>
<p>nexmoe 的私有 front-matter 文档：<a href="https://docs.nexmoe.com/v3.2/article/front-matter.html">Front-matter | Hexo Theme Nexmoe</a> </p>
<ol>
<li><p>如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">title: <span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span></span><br><span class="line">others...</span><br><span class="line"></span><br><span class="line"><span class="section">cover: 图片链接</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置分类和标签要像这样配置：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="bullet">-</span> Games</span><br></pre></td></tr></table></figure>
<p>其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见<a href="https://hexo.io/zh-cn/docs/front-matter#分类和标签">这里</a> </p>
</li>
</ol>
<h2 id="widgets"><a href="#widgets" class="headerlink" title="widgets"></a>widgets</h2><ol>
<li>关于 “文件归档”：<a href="https://docs.nexmoe.com/v3.2/article/archive.html">归档页面 | Hexo Theme Nexmoe</a> </li>
<li>关于 “关于博客”：是<code>./</code> 目录下的一个markdown文件，与其他博文相同。</li>
<li>其他部件可以在<code>_config.nexmoe.yml</code> 里配置</li>
</ol>
<h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 <a href="https://valine.js.org/">Valine</a> ，使用方法非常简单，按照Valine的官方手册一步步操作即可。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">iconfont-阿里巴巴矢量图标库</a> </p>
<h2 id="使用mathjax渲染inline-latex"><a href="#使用mathjax渲染inline-latex" class="headerlink" title="使用mathjax渲染inline latex"></a>使用mathjax渲染inline latex</h2><p><a href="https://blog.csdn.net/weixin_43318626/article/details/89407031">(1条消息) 在HEXO博客中使用LaTeX公式的简单方法_Loy_Fan的博客-CSDN博客</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo参考文档</a> </p>
<p><a href="https://docs.nexmoe.com/v3.2/">Nexmoe 参考文档</a> </p>
<p><a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe">nexmoe GitHub地址</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a> </p>
<p><a href="https://benn314.github.io/2022/11/22/Hexo-Next主题配置教程/">Hexo-Next主题配置教程 | Ben’s Blog (benn314.github.io)</a> （2023/3/23添加）</p>
]]></content>
      <categories>
        <category>使用教程</category>
      </categories>
  </entry>
  <entry>
    <title>链接 - CS:APP 第七章</title>
    <url>/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>本文将介绍：</p>
<ul>
<li>编译的过程</li>
<li>三种目标文件</li>
<li>三种链接和链接的过程</li>
</ul>
<h2 id="1-编译的过程"><a href="#1-编译的过程" class="headerlink" title="1 编译的过程"></a>1 编译的过程</h2><ol>
<li><p>源文件（.c /.cpp）经过翻译，形成可重定位目标文件（.o）</p>
<p>具体过程：</p>
<p>预处理</p>
<p><code>cpp main.c -o main.i</code> 或 <code>gcc -E -o main.c main.c</code> </p>
<p>编译器 ：翻译成汇编语言</p>
<p><code>cc1 或 cc main.i -o main.s</code> 或 <code>gcc -S -o main.s main.c</code></p>
<p>汇编器 ：形成可重定位目标文件</p>
<p><code>as [args] -o main.o</code> 这中间参数很多，</p>
<p>如果向直接到这一步可以使用 <code>gcc -c -o main.o main.c</code> </p>
</li>
<li><p>链接器 链接形成可执行目标文件</p>
<p><code>ld -o prog main.o other.o</code> 或 <code>gcc -o prog main.o other.o</code> </p>
</li>
</ol>
<p>如果想要一步一步生成<code>.i</code> <code>.s</code> <code>.o</code> 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。</p>
<p>除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 <code>-E</code> <code>-S</code> <code>-c</code> 参数进行编译。</p>
<blockquote>
<p>顺带一提，在bash中，可以通过 <code>echo $?</code> 来展示上一次程序退出的返回值</p>
</blockquote>
<h2 id="2-三种目标文件"><a href="#2-三种目标文件" class="headerlink" title="2 三种目标文件"></a>2 三种目标文件</h2><p>首先，什么是目标文件？</p>
<blockquote>
<p>计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。</p>
<p>——360百科</p>
</blockquote>
<p>目标文件可以分为三类：</p>
<ol>
<li>可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。</li>
<li>可执行目标文件 ： 可以被复制到内存中执行。</li>
<li>共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接</li>
</ol>
<p>window系统使用<code>PE portable Executable</code> 格式</p>
<p>Linux使用 <code>Executable and Linkable Format, ELF</code>格式  </p>
<h3 id="2-1-可重定位目标文件格式"><a href="#2-1-可重定位目标文件格式" class="headerlink" title="2.1 可重定位目标文件格式"></a>2.1 可重定位目标文件格式</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209091204533.png" alt="image-20220909120357886"> </p>
<p>可重定位目标文件 以ELF头开始，通过<code>readelf -a main.o</code> 我们可以看到ELF头的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              <span class="number">2</span> 补码，小端序 (little endian)</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          <span class="number">0</span></span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  版本:                              <span class="number">0x1</span></span><br><span class="line">  入口点地址：               <span class="number">0x0</span></span><br><span class="line">  程序头起点：          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  标志：             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">13</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。</p>
<p>我倾向于认为这是节头部表的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000025</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">00000358</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000068</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000000</span>c  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.gnu.propert NOTE             <span class="number">0000000000000000</span>  <span class="number">000000</span>a8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">8</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>c8</span><br><span class="line">       <span class="number">0000000000000038</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000388</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">00000000000001</span>c8  <span class="number">0000000000000018</span>          <span class="number">11</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000002</span>c8</span><br><span class="line">       <span class="number">0000000000000090</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">12</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000003</span>a0</span><br><span class="line">       <span class="number">000000000000006</span>c  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。</p>
<p>一个典型的ELF可重定位目标文件包含下面的节：</p>
<p><code>.text</code> : 已编译的机器代码</p>
<p><code>.rodata</code> : read only data 只读数据，如printf的格式字符串</p>
<p><code>.data</code> : 已初始化的全局和静态变量</p>
<p><code>.bss</code> : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节）</p>
<p><code>.symtab</code> ：符号表</p>
<p><code>rel.text</code> ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量</p>
<p><code>.rel.data</code></p>
<p><code>.debug</code> ：调试信息</p>
<p><code>.line</code> ：调试时的行号</p>
<p><code>strtab</code> ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字</p>
<h4 id="2-1-1-符号表"><a href="#2-1-1-符号表" class="headerlink" title="2.1.1 符号表"></a>2.1.1 符号表</h4><p>符号表的条目格式是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;    <span class="comment">// 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>,  <span class="comment">// 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ...</span></span><br><span class="line">       binding:<span class="number">4</span>;	<span class="comment">// 全局变量还是本地变量 GLOBAL OR LOCAL</span></span><br><span class="line">    <span class="type">char</span> reserved;  <span class="comment">// 保留的，未使用</span></span><br><span class="line">    <span class="type">short</span> section;  <span class="comment">// 在ubuntu 上的名字是Ndx,指明该符号是在那个section的</span></span><br><span class="line">    <span class="type">long</span> value;    <span class="comment">// 距离节section 起始位置的字节偏移</span></span><br><span class="line">    <span class="type">long</span> size;    <span class="comment">// 该符号最小的大小</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure>
<p>对于section 字段，在<code>ubuntu</code> 的<code>readelf</code> 命令中，显示为 Ndx。</p>
<p>该字段有三个伪节，他们分别是 <code>UNDEF</code> <code>COMMON</code> <code>ABS</code> 。</p>
<p><code>ABS</code> ：代表不改被重定位的符号</p>
<p><code>UNDEF</code> ：代表未定义的符号，即在本模块引用却在其他模块定义的符号</p>
<p><code>COMMON</code> ：还未被分配位置的未初始化的数据目标</p>
<p><code>COMMON</code> 和 <code>.bss</code> 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到<code>COMMON</code> 和<code>.bss</code></p>
<p><code>COMMON</code> ：未初始化的全局变量</p>
<p><code>.bss</code> ：未初始化的静态变量，以及初始化为0的全局或静态变量</p>
<p>下面我们通过一个程序来展示以下ubuntu 中的符号表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_not_init;</span><br><span class="line"><span class="type">int</span> global_init = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> global_init_zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_not_init;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init_zero = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们生成可重定位的目标文件<code>gcc -c main.c</code> </p>
<p>接着使用<code>readelf -a main.o</code> 读取elf，即可查看符号表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.c</span><br><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.o</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x0</span><br><span class="line">  程序头起点：          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1040 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000025  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000358</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000068</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000078</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000078</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  000000a8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000388</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000100</span><br><span class="line">       00000000000001c8  0000000000000018          11    12     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  000002c8</span><br><span class="line">       0000000000000090  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  000003a0</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in this file.</span><br><span class="line"></span><br><span class="line">本文件中没有程序头。</span><br><span class="line"></span><br><span class="line">There is no dynamic section in this file.</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000014  000c00000002 R_X86_64_PC32     0000000000000000 array - 4</span><br><span class="line">000000000019  001200000004 R_X86_64_PLT32    0000000000000000 sum - 4</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class="line"></span><br><span class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 19 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    3 stat_init.1921</span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">     7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">    12: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_not_init</span><br><span class="line">    14: 0000000000000008     4 OBJECT  GLOBAL DEFAULT    3 global_init</span><br><span class="line">    15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">    16: 0000000000000000    37 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    18: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum</span><br><span class="line"></span><br><span class="line">No version information found in this file.</span><br><span class="line"></span><br><span class="line">Displaying notes found in: .note.gnu.property</span><br><span class="line">  所有者            Data size   Description</span><br><span class="line">  GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0</span><br><span class="line">      Properties: x86 feature: IBT, SHSTK</span><br></pre></td></tr></table></figure>
<p>符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量<code>global_not_init</code> 在COMMON 伪节，已经初始化了的全局变量<code>global_init</code>和静态变量<code>stat_init</code>都在<code>.data</code> 节，而初始化为0的全局变量<code>global_init_zero</code> 和没有初始化的静态变量<code>stat_not_init</code> 和初始化为0的静态变量<code>stat_init_zero</code> 在<code>.bss</code> 节</p>
<p>根据这三行的<code>value</code> 字段我们还可以看到这三个变量在<code>.bss</code> 节的存储顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">   7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br></pre></td></tr></table></figure>
<p>另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_init_zero<span class="number">.1920</span></span><br><span class="line">   <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_not_init<span class="number">.1919</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意观察两个静态变量多了两个后辍</p>
</blockquote>
<p>这样做其实是为了区分在同一个模块中同名的两个静态变量</p>
<p>如下面程序的这个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。</p>
<h3 id="2-2-可执行目标文件格式"><a href="#2-2-可执行目标文件格式" class="headerlink" title="2.2 可执行目标文件格式"></a>2.2 可执行目标文件格式</h3><p>下面是典型的ELF 可执行目标文件</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220910192419982.png" alt="image-20220910192419982"></p>
<p>在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过<code>readelf</code> 来看一下这个段头部表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span></span><br><span class="line">               <span class="number">0x0000000000000498</span> <span class="number">0x0000000000000498</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000401000</span> <span class="number">0x0000000000401000</span></span><br><span class="line">               <span class="number">0x0000000000000205</span> <span class="number">0x0000000000000205</span>  R E    <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000402000</span> <span class="number">0x0000000000402000</span></span><br><span class="line">               <span class="number">0x0000000000000120</span> <span class="number">0x0000000000000120</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002e50</span> <span class="number">0x0000000000403e50</span> <span class="number">0x0000000000403e50</span></span><br><span class="line">               <span class="number">0x00000000000001e0</span> <span class="number">0x00000000000001e8</span>  RW     <span class="number">0x1000</span> </span><br></pre></td></tr></table></figure>
<p> 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。</p>
<blockquote>
<p>ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。</p>
</blockquote>
<p>加载可执行文件：</p>
<p>在shell中输入 <code>./prog</code> 后：</p>
<ol>
<li>shell调用fork() 函数，创建子进程</li>
<li>子进程调用execve()，execve调用加载器，加载prog程序</li>
<li>加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址)</li>
<li>_start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数</li>
</ol>
<h3 id="2-3-可共享目标文件格式"><a href="#2-3-可共享目标文件格式" class="headerlink" title="2.3 可共享目标文件格式"></a>2.3 可共享目标文件格式</h3><h2 id="3-三种链接和链接的过程"><a href="#3-三种链接和链接的过程" class="headerlink" title="3 三种链接和链接的过程"></a>3 三种链接和链接的过程</h2><p>三种链接：</p>
<ol>
<li>静态链接</li>
<li>动态链接库</li>
<li>程序运行时链接共享库</li>
</ol>
<h3 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1 静态链接"></a>3.1 静态链接</h3><p>静态链接的两个过程</p>
<ol>
<li>符号解析</li>
<li>重定位</li>
</ol>
<h4 id="3-1-1-符号解析"><a href="#3-1-1-符号解析" class="headerlink" title="3.1.1 符号解析"></a>3.1.1 符号解析</h4><p>链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p>
<p>对于局部符号，它不会出现在符号表中。</p>
<p>对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。</p>
<p>唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。</p>
<p>对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。</p>
<p>而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。</p>
<p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量 (在COMMON伪节)</p>
<p>接着使用以下规则来处理这些符号：</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果一个强符号与多个弱符号同名，选择强符号</li>
<li>若有多个弱符号同名，从这些弱符号中任选一个。</li>
</ol>
<blockquote>
<p>这三个规则很容易造成一些不易察觉的运行时错误。</p>
<p>为什么会有.COMMON伪节？</p>
<p>如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。</p>
<p>而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节</p>
</blockquote>
<p>以上讲的是几个.o 文件的链接，他们都是<code>目标文件</code> </p>
<p>接下来我们讲与静态库的链接，其中会有<code>存档文件</code> 这个概念，注意区别</p>
<blockquote>
<p>静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是  .a</p>
<p>在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。</p>
</blockquote>
<p>生成静态库：</p>
<p>首先编译：<code>gcc -c addvec.c multvec.c</code></p>
<p>接着生成静态库：<code>ar rcs libvector.a addvec.o multvec.o</code> </p>
<p>得到静态库 <code>libvector.a</code>，存档文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101743742.png" alt="image-20220910174348618"> </p>
<p>(重要) 链接器如何使用静态库来解析引用：</p>
<blockquote>
<p>链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。</p>
<ul>
<li>对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。</li>
<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义<br>的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m<br>加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成<br>员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E<br>中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。</li>
<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错<br>误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>
</ul>
</blockquote>
<p>注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。</p>
<p>因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。</p>
<p>但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的</p>
<p>如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B</p>
<p>假如有这样的依赖关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101815751.png" alt="image-20220910181532038"></p>
<p>我们要写成<code>gcc A.o B.a C.a B.a -o prog</code>  因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。</p>
<h4 id="3-1-2-重定位"><a href="#3-1-2-重定位" class="headerlink" title="3.1.2 重定位"></a>3.1.2 重定位</h4><p>《深入理解计算机系统》原书第三版 P 478 7.7</p>
<h3 id="3-2-动态链接库"><a href="#3-2-动态链接库" class="headerlink" title="3.2 动态链接库"></a>3.2 动态链接库</h3><p>静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。</p>
<p>所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。</p>
<p>创建动态库 <code>gcc -shared -fpic -o libvector.so addvec.c multvec.c</code> </p>
<p>与动态库链接：</p>
<p><code>gcc -o prog main.c ./libvector.so</code></p>
<p>与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。</p>
<p>下面是动态链接库的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209112059039.png" alt="image-20220911205952800"> </p>
<blockquote>
<p>一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章)</p>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到 <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
</blockquote>
<h3 id="3-3-程序运行时链接共享库"><a href="#3-3-程序运行时链接共享库" class="headerlink" title="3.3 程序运行时链接共享库"></a>3.3 程序运行时链接共享库</h3><p>可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7.11 load and link shared library from an application</span></span><br><span class="line"><span class="comment">// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * handle;  <span class="comment">// shared lib handle</span></span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">void</span> (*multvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">char</span> * error;   <span class="comment">// point to error massages string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load shared library</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search the symbol &quot;multvec&quot; from the shared library</span></span><br><span class="line">    multvec = dlsym(handle, <span class="string">&quot;multvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = (dlerror())) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute the function</span></span><br><span class="line">    multvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unload the shared library</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="名词索引"><a href="#名词索引" class="headerlink" title="名词索引"></a>名词索引</h2><p>ELF-64 目标文件格式</p>
<p>PIC(Position-Independent Code) 位置无关代码</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>傅里叶变换</title>
    <url>/2023/03/30/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/majinlei121/article/details/46745359">(1条消息) 高斯函数的傅里叶变换_残月飞雪的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统笔记</title>
    <url>/2023/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Chapter-3-关系数据库设计理论"><a href="#Chapter-3-关系数据库设计理论" class="headerlink" title="Chapter - 3 关系数据库设计理论"></a>Chapter - 3 关系数据库设计理论</h2><p>关系型数据库的<strong>依赖理论</strong>涉及如何构建良好的关系数据库模式，以及一个模式存在缺陷时应当如何改进。</p>
<h3 id="3-1-函数依赖的定义"><a href="#3-1-函数依赖的定义" class="headerlink" title="3.1 函数依赖的定义"></a>3.1 函数依赖的定义</h3><p>函数依赖（functional dependency，FD）的定义：如果模式R的两个元组在属性$A_1,A_2,…A_n$上的分量值都相等，那么必定其他属性$B_1,B_2,…,B_n$上的分量值也相等，则有函数依赖$A_1A_2…A_n\to B_1B_2…B_n$ </p>
<p>如果确定关系R的每个实例都能使一个给定的FD为真，那么则称R满足函数依赖f。这是在R上声明了一个约束，而不是仅仅针对R的一些特殊实例。</p>
<p>也就是说，函数依赖左边的属性能<strong>先天必然地</strong>决定函数依赖右边的属性！</p>
<h3 id="3-2-关系的键和超键"><a href="#3-2-关系的键和超键" class="headerlink" title="3.2 关系的键和超键"></a>3.2 关系的键和超键</h3><p>关系的键是一组满足以下两个条件的属性的集合：$\lbrace A_1,A_2,…,A_n\rbrace$ </p>
<ol>
<li>这些属性函数决定其他所有属性</li>
<li>这些属性的真子集不能函数决定其他属性</li>
</ol>
<p>关系的超键即「键的超集」，也就是只需要满足上面第一个条件的属性集合。</p>
<h3 id="3-3-函数依赖的规则"><a href="#3-3-函数依赖的规则" class="headerlink" title="3.3 函数依赖的规则"></a>3.3 函数依赖的规则</h3><h4 id="★-3-3-1-函数依赖的传递规则"><a href="#★-3-3-1-函数依赖的传递规则" class="headerlink" title="★ 3.3.1 函数依赖的传递规则"></a>★ 3.3.1 函数依赖的传递规则</h4><p>如果关系R中的FD： $A_1A_2…A_n\to B_1B_2…B_m$和$B_1B_2…B_m\to C_1C_2…C_k$成立，则FD：$A_1A_2…A_n\to C_1C_2…C_k$在R中也成立。</p>
<p>传递规则的一个特例是：如果关系R(A, B, C)，满足FD：$A\to B, B\to C$ 则，R也满足FD：$A\to C$ </p>
<blockquote>
<p>术语说明：</p>
<p>对于FD集合S, T</p>
<p>等价：若关系实例集合满足S和T的情况完全一样，就认为S和T是<strong>等价</strong>的。</p>
<p>推断：若满足T中所有FD的每个关系实例也满足S中的所有FD，则认为S是从T中<strong>推断</strong>而来。</p>
<p>如果S从T中推断而来，T从S中推断而来，那么S与T是等价的。</p>
</blockquote>
<h4 id="★-3-3-2-分解-结合规则"><a href="#★-3-3-2-分解-结合规则" class="headerlink" title="★ 3.3.2 分解/结合规则"></a>★ 3.3.2 分解/结合规则</h4><p>2.1 分解规则：</p>
<p>函数依赖$A_1A_2…A_n\to B_1B_2…B_m$ </p>
<p>等价于一组函数依赖：$A_1A_2…A_n\to B_1, A_1A_2…A_n\to B_2, … , A_1A_2…A_n\to B_n$ </p>
<p>2.2 组合规则</p>
<p>组合规则即分解规则的逆运算</p>
<h4 id="★-3-3-3-平凡函数依赖规则"><a href="#★-3-3-3-平凡函数依赖规则" class="headerlink" title="★ 3.3.3 平凡函数依赖规则"></a>★ 3.3.3 平凡函数依赖规则</h4><p>平凡函数依赖的定义：两个元组在$A_1A_2…A_n$上的取值相同，则它们在这n个属性的任意一个子集上的取值都相同。</p>
<p>平凡函数依赖规则：如果函数依赖右边有一些属性在函数依赖左边出现，则这些属性可以在右边去除。</p>
<blockquote>
<p>补充：</p>
<p>属性在函数依赖集合下的闭包：</p>
<p>属性集合$\lbrace A_1A_2…A_n \rbrace$在函数依赖集合S下的闭包记为$\lbrace A_1A_2…A_n \rbrace^+$ ，它是能由$ A_1A_2…A_n $在函数依赖集合S下推到出来的属性的集合。它也包含属性集合本身，因为原属性集合可由平凡FD推导出来。</p>
<p>闭包的作用：计算任一属性的闭包，可以判定任一给定的FD : $A_1A_2…A_n\to B$是否可由FD集合S推断，若B在$\lbrace A_1A_2…A_n \rbrace^+$中，则给定的函数依赖可由函数依赖集合S推断，反之则不能。</p>
<p>判断一个FD$X\to A$能否由FD集合S推断：</p>
<p>计算X在S下的闭包$X^+$， 若$A\in X^+$，则FD：$X\to A$可由S推断</p>
<p><strong>属性集合闭包的求法</strong>：</p>
<p>输入：属性集合{A}，函数依赖集合S</p>
<p>输出：闭包$\lbrace A\rbrace^+ $ </p>
<p>方法：</p>
<ol>
<li>分解S中的函数依赖，使得函数依赖右边只有一个属性</li>
<li>初始化属性集合$X=\lbrace A_1A_2…A_n\rbrace$，作为属性集合的闭包</li>
<li>不断寻找这样的FD：$B_1B_2…B_m\to C$使得$B_1B_2…B_m$在X中，而C不在X中，若找到这样的FD，则把C加入到X中，不断重复这个过程，知道X不再增长。</li>
</ol>
</blockquote>
<h4 id="★-3-3-4-Armstrong-公理"><a href="#★-3-3-4-Armstrong-公理" class="headerlink" title="★ 3.3.4 Armstrong 公理"></a>★ 3.3.4 Armstrong 公理</h4><p>通过Armstrong 公理，可以从一个给定的函数依赖集合中推断出任意它能导出的FD，这些公理是：</p>
<ol>
<li>自反律：如果$\lbrace B_1B_2…B_m\rbrace \subseteq\lbrace A_1A_2…A_n\rbrace $ 则，$A_1A_2…A_n\to B_1B_2…B_m $ 即平凡FD</li>
<li>增广律：如果$A_1A_2…A_n\to B_1B_2…B_m $ 则$A_1A_2…A_nC_1C_2…C_k \to B_1B_2…B_mC_1C_2…C_k $</li>
<li>传递律：如果关系R中的FD： $A_1A_2…A_n\to B_1B_2…B_m$和$B_1B_2…B_m\to C_1C_2…C_k$成立，则FD：$A_1A_2…A_n\to C_1C_2…C_k$在R中也成立。</li>
</ol>
<h3 id="3-4-函数依赖集合的基本集"><a href="#3-4-函数依赖集合的基本集" class="headerlink" title="3.4 函数依赖集合的基本集"></a>3.4 函数依赖集合的基本集</h3><p><strong>基本集</strong>：任何一个与函数依赖集合S等价的函数依赖集合T被称为S的基本集，为了避免基本集激增，只考虑哪些FD右边是单一属性的FD。</p>
<p><strong>最小基本集</strong>：满足下面三个条件的基本集B被称为S的最小基本集：</p>
<p>1.　B中FD右边均为单一属性<br>1.　B中删除任意一个FD后，该集合不再是基本集<br>1.　对于B中任意一个FD，删除其左边任意一个属性后，B不再是基本集</p>
<blockquote>
<p>判断一个FD集合是不是最小基本集</p>
<p>性质2：对于B中每一个FD:$X\to A$，求其在除了该FD的其他FD下的闭包，如果，$A\in 闭包$ ，则说明该FD可由其他FD推断，反之则说明该FD是不可去除的。（闭包的作用）</p>
<p>性质3：对于每个左边由两个以上属性的FD，去掉一个属性，得到一个新FD，若新FD可由原始FD集合推断，则说明该属性是多余的，反之则说明该属性是不可去除的。</p>
</blockquote>
<h3 id="3-5-投影函数依赖"><a href="#3-5-投影函数依赖" class="headerlink" title="3.5 投影函数依赖"></a>3.5 投影函数依赖</h3><p>对于在关系R上成立的函数依赖集合S，如果关系R经过投影后得到$R_1$，即$R_1=\pi _L(R)$ ，那么在R1上有哪些函数依赖成立呢？</p>
<p><strong>求函数依赖集投影的算法</strong></p>
<p>输入：R, $R_1$，在R上成立的函数依赖集合S</p>
<p>输出：在$R_1$上成立的函数依赖集合</p>
<p>方法：</p>
<ol>
<li><p>令T为最终输出集合，初始化T为空集</p>
</li>
<li><p>对于$R_1$的每一个子集X，依据S计算$X^+$，对于所有在$X^+$中且属于$R_1$的属性A，将所有非平凡FD：$X\to A$添加到T中。 </p>
</li>
<li><p>现在，T是在$R_1$中成立的FD的基本集，但可能不是最小基本集，通过以下方法修改得到最小基本集</p>
<p>a) 如果T中的某个FD F能从T中其他FD推断出来，删除F</p>
<p>b) 设$Y \to B$ 是T中一个FD，Y至少有两个属性，从Y中删除一个属性即为Z，如果$Z\to B$能从T中的其他FD推断（包含$Y\to B$），则用$Z \to B$替换$Y\to B$ </p>
<p>c) 重复以上步骤，知道T不再变化</p>
</li>
</ol>
<h3 id="3-6-异常"><a href="#3-6-异常" class="headerlink" title="3.6 异常"></a>3.6 异常</h3><p>当试图在一个关系中包含过多信息时，会产生异常，一般异常可分为三种</p>
<ol>
<li>冗余：信息没有必要地在多个元组中重复</li>
<li>更新异常：更新了某些元组地信息，另一些与之相关地元组信息没有修改</li>
<li>删除异常：一些信息被删除，导致与之相关地其他信息被删除，造成信息丢失。</li>
</ol>
<h3 id="3-7-Boyce-Codd范式"><a href="#3-7-Boyce-Codd范式" class="headerlink" title="3.7 Boyce-Codd范式"></a>3.7 Boyce-Codd范式</h3><p>可以通过将一个关系分解成多个不存在异常的关系替换，也就是说可以在一个简单地条件下保证前面讨论的异常不存在，这个条件被称为BC范式（Boyce Codd Normal form, BCNF）。</p>
<p>BC范式：关系R属于BC范式，当且仅当，R中的非平凡FD：$A_1A_2…A_n\to B_1B_2…B_m$成立，则$\lbrace A_1A_2…A_n\rbrace$是关系R的超键。</p>
<p>特别地</p>
<ol>
<li>如果一个关系R中没有函数依赖，这个关系属于BC范式</li>
<li>任意一个二元关系属于BC范式，证明略。</li>
</ol>
<p><strong>BCNF分解算法</strong></p>
<p>目的：把任意一个关系模式分解为带有以下性质的属性的子集</p>
<ol>
<li>以这些子集为模式的关系都属于BCNF</li>
<li>原始关系能从分解后的关系实例中重构</li>
</ol>
<p>输入：关系$R_0$以及其上的函数依赖集合$S_0$ </p>
<p>输出：由$R_0$分解得到的关系集合，每一个关系都属于BCNF</p>
<p>方法：</p>
<ol>
<li>令$R = R_0, S = S_0$</li>
<li>如果R属于BCNF，返回R作为结果</li>
<li>如果存在BCNF的违例，假设词违例为$X\to Y$ ，计算$X^+$ ，选择$R_1=X^+$作为一个关系模式，并使用另一个关系模式$R_2$包含属性X以及那些不在$X^+$中的属性。</li>
<li>计算$R_1, R_2$的投影函数依赖，记为$S_1, S_2$ </li>
<li>递归地分解$R_1,R_2$ ，返回这些分解得到的结果集合</li>
</ol>
<blockquote>
<p>一个好的分解应当具有以下三个性质：</p>
<ol>
<li>消除异常</li>
<li>无损连接：能否从分解后的各个元组中恢复原始关系</li>
<li>依赖保持：如果FD的投影在分解后的关系上成立，能否确保分解后的关系用链接重构后的原始关系仍然满足原来的FD</li>
</ol>
</blockquote>
<h3 id="3-8-第三范式"><a href="#3-8-第三范式" class="headerlink" title="3.8 第三范式"></a>3.8 第三范式</h3><p>第三范式（third normal form，3NF）：只要$A_1A_2…A_n\to B_1B_2…B_m$是非平凡FD，那么或者$\lbrace A_1A_2…A_n\rbrace$是超键，或者每个属于$\lbrace B_1B_2…B_m\rbrace$但不属于$\lbrace A_1A_2…A_n\rbrace$的属性都是某个键的成员。</p>
<blockquote>
<p>第三范式是对BC范式的放松</p>
<p>如果一个属性是某个键的成员，则其为「主属性」，因此第三范式也可以表述为「对于每个非平凡FD，或者其左边是超键，或者其右边仅有主属性组成」</p>
</blockquote>
<p><strong>3NF模式综合算法</strong></p>
<p>目的：将关系R分解为满足以下条件的关系</p>
<ol>
<li>分解得到的关系都属于3NF</li>
<li>分解包含无损连接</li>
<li>分解具有依赖保持的性质</li>
</ol>
<p>输入：关系R和其上成立的函数依赖集合F</p>
<p>输出：由R分解出来的关系集合</p>
<p>方法：</p>
<ol>
<li>找到F的一个最小基本集，即为G</li>
<li>对于G中每一个函数依赖$X\to A$ ，将$\lbrace X, A\rbrace$作为分解出来的结果</li>
<li>如果第二步分解出来的所有模式均不包含R的超键，则增加一个关系，其为模式R的任何一个键。</li>
</ol>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>概率论与数理统计课程笔记</title>
    <url>/2023/04/17/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章-概率论的基本概念"><a href="#第一章-概率论的基本概念" class="headerlink" title="第一章 概率论的基本概念"></a>第一章 概率论的基本概念</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>随机试验</strong>的定义：</p>
<ol>
<li>可以在相同的条件下重复进行</li>
<li>每次实验的可能结果不止一个，并且事先明确试验的所有可能结果</li>
<li>进行一次试验之前不能确定哪一结果出</li>
</ol>
<p>假设我们有一个随机试验E，它的所有可能结果组成的集合为E的<strong>样本空间</strong>，样本空间的每个元素，即E的每个结果，称为<strong>样本点</strong>。</p>
<p><strong>随机事件</strong>：试验E的样本空间S的子集为E的随机事件，简称为<strong>事件</strong>。当这一子集的一个样本点出现时，称<strong>这一事件发生</strong>。</p>
<p>特别地，由一个样本点组成的单点集称为<strong>基本事件</strong>。如{1}，{2}，{3} …</p>
<p>样本空间S本身是随机试验的<strong>必然事件</strong>，空集$\emptyset$ 被称为<strong>不可能事件</strong>。 </p>
<h3 id="事件之间的运算"><a href="#事件之间的运算" class="headerlink" title="事件之间的运算"></a>事件之间的运算</h3><p>事件相等：</p>
<p>和事件：</p>
<p>积事件：</p>
<p>差事件：</p>
<p>事件互不相容/互斥：$A \cap B=\empty $ </p>
<p>逆事件/对立事件：$A\cap B=\empty \and A\cup B=S$ </p>
<h3 id="频率-、-概率的公理化定义"><a href="#频率-、-概率的公理化定义" class="headerlink" title="频率 、 概率的公理化定义"></a>频率 、 概率的公理化定义</h3><p><strong>频率</strong>：在相同的条件下，进行n次试验，在这n次试验中，事件A发生的次数记为$n_A$ 称为事件A发生的<strong>频数</strong>，比值$n_A/n $称为事件A发生的<strong>频率</strong>，并记为$f_n(A)$ </p>
<p>频率的基本性质：</p>
<ol>
<li>$0 \le f_n(A) \le 1 $</li>
<li>$f_n(S)=1$</li>
<li>若$A_1,A_2,…A_n$是两两互不相容的事件，则$f_n(A_1\cup A_2\cup …\cup A_k)=f_n(A_1)+f_n(A_2)+…+f_n(A_k)$ </li>
</ol>
<p><strong>概率：</strong> 设E是随机试验，S是它的样本空间，对于E的每一事件A赋予一个实数，记为P(A)，称为事件A的<strong>概率</strong>。</p>
<p>概率的基本性质：</p>
<ol>
<li>非负性：对于每一个事件A，有$P(A) \ge 0$</li>
<li>规范性：对于必然事件S，有P(S) = 1</li>
<li>可列可加性：设$A_1,A_2,…$是两两不相容的事件，即对于$A_iA_j=\empty,i \ne j,i,j=1,2,…$，有$P(A_1\cup A_2\cup …)=P(A_1)+P(A_2)+…$ </li>
</ol>
<blockquote>
<p>证明，当$n\rarr \infin $时，$f_n(A)$在一定义一下接近于概率P(A)</p>
<p>TODO：见第五章</p>
</blockquote>
<p>由概率的基本性质可推出的概率重要性质：</p>
<ol>
<li>$P(\empty)=0$</li>
<li>有限可加性：设$A_1,A_2,…A_n$是两两不相容的事件，即对于$A_iA_j=\empty,i \ne j,i,j=1,2,…$，有$P(A_1\cup A_2\cup …\cup A_n)=P(A_1)+P(A_2)+…+P(A_n)$ </li>
<li>设A，B是两个事件，若$A\sub B$则有$P(B-A)=P(B)-P(A)$ 且$P(B)\ge P(A)$ </li>
<li>对于任意事件A，$P(A) \le 1$ </li>
<li>逆事件的概率：对于任意事件A，$P(\bar{A})=1-P(A)$ </li>
<li>加法公式：对于任意两事件A，B，$P(A\cup B) = P(A)+P(B)-P(AB)$ (容斥原理)</li>
</ol>
<blockquote>
<p>常用公式：$B\bar{A}=B-A=B-AB$ </p>
</blockquote>
<h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p><strong>古典概型</strong>：样本空间中只有有限个元素，且基本事件发生的可能性相同的试验。</p>
<p>古典概型是一类试验。</p>
<p>P(A) = A包含的基本事件数 / S中的基本事件数</p>
<h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><p>P(A) = A的长度、面积 …  / S的长度、面积 …</p>
<h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>条件概率的定义：设A、B是两个事件，且P(A) &gt; 0，称$P(B|A)=\frac{P(AB)}{P(A)}$ 为在事件A发生的条件下事件B发生的条件概率。</p>
<p><strong>条件概率也是概率，它也满足概率的公理化定义，即非负性、规范性、可列可加性</strong></p>
<p>乘法定理：设P(A) &gt; 0，则有P(AB) = P(B|A)P(A)</p>
<p>全概率公式：$P(A)=\sum_{i=1}^{n} P(A|B_i)P(Bi)$ </p>
<p>贝叶斯公式：$P(B_i|A)=\frac{P(B_iA)}{P(A)}=\frac{P(A|B_i)P(B_i)}{\sum^{n}_{j=1}P(A|B_j)P(B_j)}$ </p>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>若事件A的发生对事件B的发生没有影响，即P(B|A)=P(B)，则事件A、B相互独立。此时有P(AB)=P(B|A)P(A) = P(A)P(B)</p>
<p>定义：设A，B是两事件，如果满足等式P(AB)=P(A)P(B)，则称事件A、B相互独立，简称事件A、B独立。</p>
<blockquote>
<p>条件A对样本空间和事件B进行了等比例约束就是独立事件</p>
</blockquote>
<p>定理：若事件AB相互独立，则下列事件也相互独立$A\bar{B},\bar{A}B,\bar{A}\bar{B}$  </p>
<p>三事件相互独立：</p>
<p>P(AB)=P(A)P(B)</p>
<p>P(AC)=P(A)P(C)</p>
<p>P(BC)=P(B)P(C)</p>
<p>P(ABC)=P(A)P(B)P(C)</p>
<h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><p>随机变量的定义：设随机试验的样本空间S={e}，X=X(e)是定义在样本空间S上的实值单值函数，则称X=X(e)为随机变量。随机变量的本事是一个函数，是从样本空间到实数集的映射。</p>
<h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><p>离散型随机变量取X=xk时的概率：$P\lbrace X=x_k\rbrace =p_k,k=1,2,3,…$ </p>
<ul>
<li>0-1分布：$P\lbrace X=k\rbrace =p^k(1-p)^{1-k},k=0,1$ </li>
<li>二项分布：$X \thicksim b(n, p)$ ：$P \lbrace X=k\rbrace =C_n^kp^k(1-p)^{n-k}$ </li>
</ul>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记：An introduction to Political Philosophy</title>
    <url>/2023/10/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20An%20introduction%20to%20Political%20Philosophy/</url>
    <content><![CDATA[<h2 id="Ch-2-Justifying-the-state"><a href="#Ch-2-Justifying-the-state" class="headerlink" title="Ch 2 Justifying the state"></a>Ch 2 Justifying the state</h2><p>为什么我们对政府具有道德上的责任？</p>
<p>Consent Theory: 对于洛克(Locke)，他认为人生来自由、平等、独立，任何人都不能生来就能够统治他人。若是，则其他人必须同意(consent)他的统治。因此，对于洛克，政府的合法性问题就转变成了政府的权威如何能与每个每个人自然的自治的生活（the natural autonomy of the individual）相适应(reconciled)。[p.35]</p>
<p>Utilitarian Theory: 对于边沁(Bentham)，政府的合法性来源于它能最大化社会的总体幸福(total happiness)，并且只有它比其他的政府更能做好这一点，它才具有合法性，而个人的同意是不相关的。[p.35]</p>
<hr>
<p>什么是政府(The State)?</p>
<p>洛克认为，政府至少拥有政治权力(Political Power)，政治权力即制定法律，惩罚违法者的权力。[p.36]</p>
<p>马克斯·韦伯(Max Weber)认为，在一个给定的领土上，政府垄断合法的暴力。在它的统治范围内，一切合法的暴力都直接或间接地来源于政府，例如警察，军队，人的自卫。它的反面是，政府有保护其领土上的所有人不受非法的暴力的责任。[p.36]</p>
<hr>
<p>什么是 Justifying the State？</p>
<p>它是说，在原则上，在正常情况下，每个人都有Universal Political Obligation，即每个政府下的公民都有遵守法律的道德责任。[p.38]</p>
<p>（换句话说，Justifying the State 也可以告诉你一个政府什么时候不具有合法性，什么时候我们不再有道德责任去遵守法律。）</p>
<hr>
<p>社会契约：</p>
<p>Voluntaristic Obligation</p>
<p> 公民的政治责任来源于他们的自愿同意。</p>
<p>但是这种自愿同意的问题在于，没有一部确切的契约说明所有公民都同意政府的合法性。即使把参与投票看作对政府的同意（即使投了反对票，也代表他认可这个系统），也存在一些完全不投票的人。[p.41]</p>
<p>Tacit consent</p>
<p>政府对于它的公民来说是合法的，因为每个被其统治的人都享受了政府带来的好处，只要公民没有离开这个国家，他们就默默地同意了政府的统治。[p.42]</p>
<p>反对的意见：没有方法可以表达公民的不同意，除非公民移民到其他国家，但对当代公民来说，这太困难了。[p.43]</p>
<p>Hypothetical consent</p>
<p>社会契约是假设的，它告诉我们在自然状态下，我们一定会通过社会契约去缔造一个政府，因此我们就拥有政治责任。换句话说，在经历复杂的思想实验后，我会意识到我一直都同意我对政府负有政治责任。[pp.44-46]</p>
<p>但问题是，这种同意是脆弱的，且是与道德与传统混在一起的。</p>
<p>Anarchism</p>
<p>有些无政府主义者可能会主张，我们要接受部分人在自愿同意的理论下是可以逃脱政治责任的。这样，这些人之所以遵守法律，只是因为它们符合道德。[p.47]</p>
<p>这种观点的好处在于，它可以用来反对恶法，例如纳粹德国对犹太人的种族灭绝。但这种观点也有另一种风险：如果你只遵守哪些符合你的道德观点的法律，你可能不会尊重他人的权利、财产…，因为不同的人会有不同的道德观点。这样公民们又再次进入了自然状态。[p.48]</p>
<p>The principle of fairness[pp.55-60]</p>
<p>Hume认为，人们不能考虑长远利益，因此需要有法律来达到长远利益。</p>
<p>H.L.A.Hart推广了Hume的论述，我们享受了政府带给我们的利益，因此我们需履行政治责任。</p>
<p>反对观点：</p>
<p>政府带给我们的利益并不一定是我们想要的，而且我们也没有办法显式地拒绝这种利益。</p>
<p>Robert Nozick认为，我们只对我们显式地接受的利益负有政治责任，如果接受Nozick的观点，那么这种论断就退化为了tacit consent。[pp.58-59]</p>
<hr>
<p>Utilitarianism</p>
<p>功利主义的要义：一个行为之所以是道德上合法的，是因为它带给了社会最高的utility(happiness, pleasure, satisfaction of desire)。[p.49]</p>
<p>功利主义的一个困难：Problem of ‘interpersonal comparsions of utility’，比较每个人之间的utility是困难的。但我们要知道，比较utility是可行的，即使没有一个完备的方法，但我们在讨论功利主义的时候也要假定这个问题是可以解决的。[p.50]</p>
<p>Justifying the state中的两种功利主义：</p>
<p>indirect utilitarianism:We need a body of laws that will be respected, even when breaking one of these on a particular occasion would, if it were permitted, lead to an increase in happiness.[p.51]</p>
<p>direct utilitarianism:I should obey the law if, but only if my obedience will lead to the greater happiness of society than my disobedience.[p.50]</p>
<p>边沁所选择的必然是indirect utilitarianism，因为即使每个人违反法律不会明显的损害他人的利益，而自己的利益却有很大提升，但如果每个人都这样做，所有人的利益就会受损。(公地问题，囚徒困境)。[p.51]</p>
<blockquote>
<p>Fragment on Government中利用功利主义立法的几条Idea：[p.51]</p>
<ol>
<li>法律只有当它提升了人们的幸福，并且比其他法律做得更好时，才应该被通过。</li>
<li>法律之所以要被遵守，仅仅是因为它们是法律，只有需要规避灾难时，才不需要遵守法律。</li>
<li>当法律不能服务与公民的幸福时，应被废除。</li>
</ol>
</blockquote>
<p>功利主义对政府合法性/公民的政治责任的辩护：</p>
<p>The state, as provider and enforcer of a body of law, is justified if, and only if, it contributes more to human happiness than any feasible competing arrangement.[p.52]</p>
<p>对功利主义的反对：</p>
<p>功利主义对Political Obligation的辩护有大致三个前提[p.52]。最重要的一个是，功利主义假设，道德上最好的社会就是功利/幸福被最大化的社会。</p>
<p>对此前提的一个反驳是替罪羊问题，一个人被当成冤枉是合理的，因为当公众知道罪犯被绳之以法后，他们的功利提升大于个人的冤屈。[p.53]</p>
<p>对此反驳的一个反驳是indirect utilitarianism。[p.54]</p>
<p>但也有人提出，功利主义的思路就是不对的，一个人不应被冤屈，并不是因为功利计算，而是它本身就是有价值的。[p.55]</p>
<p>综上所述，功利主义的前提——道德上最好的社会就是功利/幸福被最大化的社会，是存在问题的。</p>
<hr>
<p>Conclusion:</p>
<p>即使我们能够接受一些人可以不受政治责任的约束，例如僧人可能不需要交税。但不代表它们可以肆意伤害他人，因为人们不仅仅有政治责任，还有道德责任。</p>
<blockquote>
<p>The fact that some people avoid political obligations does not give them the right to harm anyone. These people still have a set of moral obligations. Further, on Locke’s view at least, all individuals have the right to enforce moral law, even in the absence of government.[p.61]</p>
</blockquote>
<p>2023/9/12, My Opinions：</p>
<ol>
<li><p>与其Justifying the state, 不如Justifying the single term。首先，政府的法律多种多样，有些法律条款是所有人都认同的，而有些条款是大部分人都反对的，例如最近治安管理处罚法的34条，伤害中华民族感情。因此可以单独审视每一个条款，判断它是否是经过公民同意的，或是对社会有益的。</p>
</li>
<li><p>从这里就看出民主政体的优点了，在民主政体的立法活动中，至少公民直接或间接地表达了对法律的同意，如果我生活在民主国家，我想我不会对它的法律有太多质疑与不信任。</p>
</li>
<li><p>本章的一直是在假设这个国家的政府是一个好的政府，虽然作者没有明确的表达，但我想当人们在面对一个坏的政府时，自然也可以用本章的一些意见来攻击其合法性。如果是面对一个坏的独裁政府，他既没有人们的同意，也没有实现社会效益的最大化，人们自然对他没有什么政治责任。除非你要采用Hart的观点，认为只要你从政府那里收益，你就对他富有政治责任，显然还有更好的政府存在，因此独裁政府是要下台的。</p>
<p>但如果只要这个政府做的不够好，我们就对他没有政治责任了吗？我想可以从利用民主和独裁政府的区别来划分这道线，因为民主政府至少有来自公民的consent，而独裁国家没有，因此公民仍然对民主政府富有Political Obliging。</p>
</li>
</ol>
<h2 id="Ch-3-Who-should-rule"><a href="#Ch-3-Who-should-rule" class="headerlink" title="Ch 3 Who should rule?"></a>Ch 3 Who should rule?</h2><p>Democracy’s Definition：</p>
<p>Democracy, we are told, is government ‘of the people, by the people, and for the people’.</p>
<p>民主的三个特征：</p>
<ol>
<li>for the people:Government for the people is the idea that the government exists for the sake of its citizens, not for the benefit of the rulers.</li>
<li>by the people: 通过公民来进行治理</li>
<li>of the people: a democracy state has power only over the people who make up the electorate.</li>
</ol>
<p>民主通常被当作当代政府合法性的试金石。</p>
<p>民主本身也有两个tension/debate:</p>
<ol>
<li>Major rule VS. individual rights.</li>
<li>representative  democracy VS. direct democracy.</li>
</ol>
<blockquote>
<p>除此之外，<a href="https://www.britannica.com/topic/democracy">大英百科全书</a>也有介绍关于讨论民主的全面的范畴：</p>
<p>If a government of or by the people—a “popular” government—is to be established, at least five fundamental questions must be confronted at the outset, and two more are almost certain to be posed if the <a href="https://www.merriam-webster.com/dictionary/democracy">democracy</a> continues to exist for long.</p>
<p>(1) What is the appropriate unit or association within which a democratic government should be established? A town or city? A country? A business <a href="https://www.britannica.com/money/topic/corporation">corporation</a>? A university? An <a href="https://www.britannica.com/topic/international-organization">international organization</a>? All of these?</p>
<p>(2) Given an appropriate association—a city, for example—who among its members should enjoy full citizenship? Which persons, in other words, should <a href="https://www.merriam-webster.com/dictionary/constitute">constitute</a> the <em>dēmos</em>? Is every member of the association entitled to participate in governing it? Assuming that children should not be allowed to participate (as most adults would agree), should the <em>dēmos</em> include all adults? If it includes only a subset of the adult population, how small can the subset be before the association ceases to be a democracy and becomes something else, such as an <a href="https://www.britannica.com/topic/aristocracy">aristocracy</a> (government by the best, <em>aristos</em>) or an <a href="https://www.britannica.com/topic/oligarchy">oligarchy</a> (government by the few, <em>oligos</em>)?</p>
<p>(3) Assuming a proper association and a proper <em>dēmos</em>, how are citizens to govern? What political organizations or institutions will they need? Will these institutions differ between different kinds of associations—for example, a small town and a large country?</p>
<p>(4) When citizens are divided on an issue, as they often will be, whose views should prevail, and in what circumstances? Should a majority always prevail, or should minorities sometimes be empowered to block or overcome majority rule?</p>
<p>(5) If a majority is ordinarily to prevail, what is to constitute a proper majority? A majority of all citizens? A majority of voters? Should a proper majority <a href="https://www.merriam-webster.com/dictionary/comprise">comprise</a> not individual citizens but certain groups or associations of citizens, such as hereditary groups or territorial associations?</p>
<p>(6) The preceding questions presuppose an adequate answer to a sixth and even more important question: Why should “the people” rule? Is democracy really better than <a href="https://www.merriam-webster.com/dictionary/aristocracy">aristocracy</a> or <a href="https://www.britannica.com/topic/monarchy">monarchy</a>? Perhaps, as <a href="https://www.britannica.com/biography/Plato">Plato</a> argues in the <em>Republic</em>, the best government would be led by a <a href="https://www.britannica.com/topic/minority">minority</a> of the most highly qualified persons—an aristocracy of “<a href="https://www.britannica.com/topic/philosopher-king">philosopher-kings</a>.” What reasons could be given to show that Plato’s view is wrong?</p>
<p>(7) No association could maintain a democratic government for very long if a majority of the <em>dēmos</em>—or a majority of the government—believed that some other form of government were better. Thus, a minimum condition for the continued existence of a democracy is that a substantial proportion of both the <em>dēmos</em> and the leadership believes that popular government is better than any <a href="https://www.merriam-webster.com/dictionary/feasible">feasible</a> <a href="https://www.merriam-webster.com/dictionary/alternative">alternative</a>. What conditions, in addition to this one, favour the continued existence of democracy? What conditions are harmful to it? Why have some <a href="https://www.merriam-webster.com/dictionary/democracies">democracies</a> managed to endure, even through periods of severe crisis, while so many others have collapsed?</p>
<p>简单总结一下就是：</p>
<ol>
<li>组建民主政府的合适单元是什么？</li>
<li>民主国家的公民由谁组成？</li>
<li>实行民主需要的制度有哪些？这些制度是否会因为其大小而改变？(这里考虑的应该是直接民主和代议制民主)</li>
<li>当公民的意见产生分歧应该怎么办？什么时候由多数人统治，什么时候由少数人统治？</li>
<li>如何定义多数？</li>
<li>为什么需要民主，民主制度真的是优越的吗？</li>
<li>什么条件使得民主制度存续，为什么有些民主国家很稳定而有些则会崩溃？</li>
</ol>
</blockquote>
<hr>
<p>Plato:</p>
<p>柏拉图认为democracy是rule by mob。</p>
<p>柏拉图用来反对民主的最基本的工具是 craft analogy: 如果你生病了需要一些建议，你应该去找专家。</p>
<p>craft analogy告诉我们：Buling is a skill. A special training is necessary, and not everyone is naturally capable even of acquiring the skill.</p>
<p>对柏拉图的反对：</p>
<p>虽然有些人拥有治理国家的技巧，但如何才能保证它们不滥权腐败呢？与其让小人牟利，不如让庸人少贪一点。</p>
<p>柏拉图对此的回应是：应该立法最小化哲学王的腐败空间——它们不能拥有私有财产…[p.69]</p>
<p>但新的问题是，既然这样为什么会有人去想要去当统治者呢？而且又有哪些权利可以制衡哲学王不去改变这些法律呢？</p>
<p>柏拉图对第一个问题的回答是，哲学王去统治，是为了不让其他庸人统治，这是他们的责任。[p.69]</p>
<p>柏拉图的另一个问题是，挑选哲学王是困难的。 </p>
<hr>
<p>利益问题：</p>
<p>即使柏拉图反对民主，但柏拉图认为仁慈的独裁者仍然要考虑人民的利益，但柏拉图反对民主制度能够达成这个目标，因此想要反对柏拉图，一个方法就是证明柏拉图的方法是无效的，只有民主制度可以真正为了人们的利益。[p.71]</p>
<p>其中最重要的问题是如何知道人们的利益诉求，民主制度可以通过投票得到。[p.72]</p>
<p>柏拉图认为，哲学王们同样是哲学家，它们可以知道人们的诉求，但反对者们又会说，美学伦理学物理学形而上学…的知识不会让他们知道人们的诉求。[p.72]</p>
<p>但民主制度也有其缺点，民主制度如何在不同的利益间决策？还有一个更严重的问题是，民主制度(不如说是投票制度)可能不能告诉我们任何东西，因为有些人可能会基于所有人的共同利益投票，而一些人仅仅考虑自己的利益，(Mixed-motivation Voting)这样的投票会是一团糟。[p.73]</p>
<hr>
<p>Voting and the common good: 在什么条件下民主制度比柏拉图的监护人制度更能达成common good？</p>
<p>如果每个人都根据他认为的common good去投票，那么有很大概率会达成最好的结果。[pp.74-75]</p>
<p>民主制度若想很好地发挥作用，并由于柏拉图的监护人制度，需要满足以下两个条件：[p.75]</p>
<ol>
<li>每个人的选择在平均上必须是正确的。</li>
<li>每个人都会以他认为的common good为基础去投票。</li>
</ol>
<hr>
<p>The values of democracy</p>
<p>很多人认为他们追求民主不仅仅是因为他能更好地达成common good (instrumental justification)，而更是因为他有其内在价值 (intrinsically good)。[p.76]</p>
<p>Democracy just likes the Hobbies, Hobbies allow people to enrich and test their physical and mental powers, and develop their sense of self-worth.[p.76]</p>
<p>Democracy is most commonly thought to be expressive of two values we hold dear : freedom and equality. Freedom, as understood here, is a matter of giving people a say in political decision-making, particularly those decisions that affect them. Equality lies in this freedom being given to all.[p.77]</p>
<blockquote>
<p>ChatGPT：</p>
<p>一般意义上，自由是指个人或群体在行动、思想和表达上不受限制的状态。它涉及到个人的权利和能力来做出选择、追求目标，并以自己认为合适的方式生活。自由包括以下几个方面：</p>
<ol>
<li><p>个人自由：个人可以自主决定自己的行动和生活方式，不受强制或压迫。这包括言论自由、宗教自由、思想自由、信仰自由等。</p>
</li>
<li><p>政治自由：个人有权参与和影响政治过程，包括选举、成立政党、表达政治观点和参与公民运动等。</p>
</li>
<li><p>经济自由：个人有权选择职业、参与市场经济和拥有财产，并享有公平竞争和合理收入的权利。</p>
</li>
<li><p>社会自由：个人在社会交往中享有平等对待和不受歧视的权利，包括平等的教育机会、平等的婚姻权利、性别平等等。</p>
</li>
</ol>
<p>自由是民主社会的基石，它赋予了人们权利和机会，使其能够自主地决定自己的生活，并与他人和谐共处。然而，自由并不是绝对的，它也要受到法律和公共利益的限制，以保护他人的权利和社会的稳定。</p>
<p>本文中提到的自由属于政治自由和社会自由的范畴。这包括个人在政治决策中拥有发言权，以及个人在社会交往中享有平等对待和不受歧视的权利。政治自由强调个人在政治过程中的权利和自主参与，而社会自由关注个人在社会环境中的平等和自由。这两个方面的自由共同构成了个人的权利和自主决策的重要基础，使人们能够追求自己的目标和生活方式，并参与社会的发展和进步。</p>
</blockquote>
<hr>
<p>Rousseau</p>
<p>For Rousseau, the problem of political order is ‘to find a form of association which will defend and protect with the whole common force the person and goods of each associate, and in which each, while uniting himself with all, may still obey himself alone, and remain as free as before’ (Social Contract, bk. I, ch. 6, p. 191).[p.77]</p>
<blockquote>
<p>对于卢梭来说，政治秩序的问题是“找到一种联合形式，以全部共同的力量捍卫和保护每个联合体的人身和财产，并且其中每个人在与所有人联合的同时，仍然可以单独服从自己” ，并像以前一样自由’(Social Contract, bk. I, ch. 6, p. 191).[p.77]</p>
</blockquote>
<p> It is remarkable that Rousseau thinks he can solve this problem. How can any political system allow ‘each associate [to] obey himself alone’? [p.77]</p>
<p>Rousseau can defend democracy both on instrumental grounds(as a way of achieving the common good) and in itself(as an expression of freedom and equality).[p.77]</p>
<p>卢梭的政府：</p>
<p>卢梭最重要的观念是general will，The general will demands the policy that is equally in everyone’s interests。卢梭认为，general will必须被平等的给予每个人，因此general will必须被立法，然后平等的影响所有人。[p.79]</p>
<p>卢梭认为，general will的执行必须由 ‘An elected aristocracy’执行，即政府或执行官。卢梭的政府与柏拉图的philosophical king的区别在于，卢梭的政府没有立法权，只有执行法律的权力。[p.80]</p>
<p>卢梭的系统满足了前面提到的两个条件：[p.75]</p>
<ol>
<li>每个人的选择在平均上必须是正确的。</li>
<li>每个人都会以他认为的common good为基础去投票。</li>
</ol>
<p>针对第一个条件，卢梭用教育来解决这个问题：Rousseau denies that training ought to be given only to the few(As Plato). Far better, Rousseau believes that individuals need to be educated in to citizenship.[p.78, p.81]</p>
<p>针对第二个条件，卢梭提出了三种解决方法：1. 教育，education for civic virtue.[p.83] 2. Censorship.[pp.83-84] 3.Civil religion.</p>
<p>Censor is charged with the duty of upholding, and clarifying where necessary, public morality.</p>
<blockquote>
<p>卢梭的Civil religion：</p>
<p>卢梭对宗教的论述包含三个方面。首先，他要求每个公民都应该信仰某种宗教，因为这会“让他爱他的责任”。其次，应该容忍多元宗教存在，但只有那些本身包含宽容原则的宗教才应该被容忍。否则，一些公民将被迫成为敌人，这与社会和平的理念相违背。最后，最独特的是，除了私人道德之外，每个人都应该信奉公民宗教。这个宗教应该包含“不完全是宗教教条，而是社会观念，缺少这些观念，一个人无法成为好公民或忠实的臣民”</p>
<p>First, he requires that every citizen  should subscribe to some religion or other, for this will ‘make him love his duty’.  Second, a diversity of religions should be tolerated, but only those which  themselves include a principle of toleration. Otherwise some citizens will be  compelled to become enemies, which is contrary to the idea of social peace.  Finally, and most distinctively, in addition to private morality, each person  should subscribe to the civil religion. This should have articles which are ‘not  exactly… religious dogmas, but… social sentiments without which a man cannot  be a good citizen or a faithful subject’ (Social Contract, bk. IV, ch. 8, p. 307).</p>
</blockquote>
<p>针对第二个条件，卢梭认为，当公民中出现阶级分化或出现小团体时，它们也会倾向于自身阶级的利益或小团体的利益。因此，<strong>卢梭认为要消除过大的不平等以减少阶级分化 (可以作为支持社会平等的一个理由)</strong>，其次卢梭认为公民中的小团体要么没有要么就有很多。</p>
<p>针对卢梭的解决方案，有人认为它有点法西斯主义和极权主义。[p.83]</p>
<p>如何评价卢梭的系统，它真的保证了自由与平等吗？</p>
<p>卢梭的体系的确保证了平等，但很难说它保证了人们的自由，卢梭的体系拒绝了人们的思想自由，而且由于存在“多数人的暴政”，一些人可能被强制自由，但至少可以说卢梭的体系保证了“积极自由”——theorists of positive freedom define freedom in terms of ‘living the life that the rational preson would choose to live’。[pp.86-87]</p>
<p>对卢梭的批评：</p>
<ol>
<li><p>在一个复杂的社会中，General will 可能并不存在。[p.88]</p>
</li>
<li><p>许多人不认同卢梭对持有少数观点人的做法：Those who first affirm the principles of the civil religion and then disobey them are put to death. Dissent is a crime, and crime is treason.[p.88]</p>
</li>
<li><p>虽然卢梭支持公民定期去投票，但他似乎并不支持公民太过于积极地参与政治，他认为嘈杂的讨论会阻碍对General will的感知。</p>
<p>但卢梭的看法是不对的，因为他一直假定General will的存在，但如果并没有General will，那么每个人的声音都需要被兼顾。</p>
<p>因此：Thus Rousseau’s critics have argued that extensive political debate is not a  sign of decay, but vital to the functioning of democratic politics. <strong>Furthermore,  outvoted minorities have no duty to change their mind about what is correct. In  general we would expect them to obey the law, but they can continue to speak  up, and, if they feel strongly enough, to agitate for change.（少数人应当这样做）</strong>[p.89]</p>
</li>
</ol>
<p>卢梭为了使他的体系在工具理性上被辩护——即更能达成General Will，他必须把社会团结的纽带拉得很紧。</p>
<p>In order for Rousseau to be  able to argue that democracy is instrumentally justified—that it is a highly  reliable way of achieving morally correct outcomes—he has to draw the bonds of social unity very tight. So tight, in fact, that the system  becomes unacceptably repressive. [p.89]</p>
<p>因此对卢梭非常中肯的评价是：</p>
<p><strong>So the same measures which, in Rousseau’s  model, make democracy defensible in instrumental terms also make it  intrinsically undesirable.</strong> [p.89]</p>
<hr>
<p>Participatory Democracy:</p>
<p>All citizens should be involved in deciding the most important particular acts of administration.</p>
<p>这是一个非常理想的政体，在这个政体中，不光法律是由人们集会投票得到的，只要会影响到公民们生活的决定都需要民主程序。</p>
<p>优点：</p>
<ol>
<li><p>Theorists of participatory politics claim that only active, democratic  involvement in all matters of concern can achieve real freedom and equality for  all. Only when we are involved in making the decisions which structure our  lives in all spheres are we really free, they argue. [p.91]</p>
</li>
<li><p>And, to put this in the context  of the discussion of political obligation from the last chapter, only in a  participatory democracy are the voluntaristic assumptions of social contract  theory satisfied. In such a society we can genuinely be thought of as voluntarily  contributing members of society. And so, on this view, it is only under these  conditions that we even acquire an obligation to obey the state.[p.91]</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>可能无法得出好的结果。[p.92]</li>
<li>投票的议程难以决定，且政策很难具有连续性。[p.92]</li>
<li>人们花费太多的时间在政治上。[p.93]</li>
</ol>
<hr>
<p>Representative Democracy</p>
<blockquote>
<p>补充：根据管理者被给予了不同程度的权力，可以划分出不同的政体：[p.94]</p>
<ol>
<li>柏拉图式的政府：公民们几乎没有任何权利，而政府——The Guradians几乎垄断了所有权力</li>
<li>密尔式的政府(Representative)：人们选举代表来制定法律和执行法律</li>
<li>卢梭式的政府：人们直接制定法律，并选举代表来执行法律</li>
<li>直接民主(Participatory Democracy)：几乎所有的事项都需要公民决定，仅有的管理者只是用来决定今天的投票议题。</li>
</ol>
</blockquote>
<p>Representative Democracy, Mill式的政府是什么样的？</p>
<ol>
<li><p>The people elect representatives who then both make laws and put them into practice.[p.94]</p>
</li>
<li><p>There are many branches of government.[p.94]</p>
</li>
<li>立法权，行政权，司法权独立，每个政府的部门都要接受其他两个部门的监督。[p.97]</li>
<li>拥有选票转移机制，保护人权，以防止多数人的保证。[pp.100-101]</li>
</ol>
<p>为什么需要代议制政府？</p>
<ol>
<li><p>对于Mill来说，代议制民主是现代社会民主唯一能够存续下去的形式。[p.94]</p>
</li>
<li><p>对于Mill来说，评判政府的标准有两个：1. to ‘improve’ the citizens 2. to manage their public affairs.[p.94]</p>
<p>专制政府使人走向消极，公民没有被教育的必要。而人只有在独立的条件下才能在各个方面繁荣，因此人们必须参与国家的治理。而直接民主是最能让人在道德和智力上改善的，但它的效率太低下了。因此代议制政府即保证了民主的内在价值(intrinsically good: improve the citizens)，又兼顾了民主的工具价值(instrumental good: manage the public affairs)。[p.95]</p>
</li>
</ol>
<p>Mill的担心：</p>
<ol>
<li><p>在民主制度下，那些偷奸耍滑的人可能更容易上位，即How to protect ourselves from unsavoury leaders who may attempt to  obtain power?[p.96]</p>
<p>James Madison在<em>The Federalist Paters(联邦党人文集)</em>中给出了解决方案，即’Separation of powers’，分权制衡(洛克、孟德斯鸠)。立法权，行政权，司法权独立，每个政府的部门都要接受其他两个部门的监督。[p.97]</p>
<p>Mill对Madison的补充：1. 对候选人的投资应该受到限制。2. members of the government should not be paid.</p>
</li>
<li><p>Mill最担心的问题：人们肯能不会vote in accordance with their ideas of the general intersets.[p.97]</p>
<p>(1) 密尔提出可以用公开的投票替代秘密投票，这样它们必须解释自己投票的理由，在自由辩论下可能会达到general interests。但很多人反对，因为公开投票可能会受到其他人的影响，例如雇主强制雇员投票。[p.98]</p>
<p>(2) Mill 认为部分人不应该有选举权，例如那些不会识字，不会算数的人。而那些更有资格的人应该被给予多余一张选票。[p.99]</p>
<p>然而一些人提议应该使得人们首先投票选择代表它们投票的人，然后这些人再去投票选举议员。因为那些无知的人就算直接选举议员，也会去参考那些代表们的意见，与其采用多重选票(Plural voting)，不如采用这样的制度。[p.100]</p>
</li>
<li><p>多数人的暴政</p>
<p>(1) Mill approve a very complicated and elaborate system of proportional representation, involving the possibility of transferring your vote to a candidate in another constituency, should your favoured candidate fail. By such, or simiar, means we ought to  be able to ensure the representation of many minorities in parliament.[p.100]</p>
<p>(2) 人权: In fact Mill’s solution is to restrict the legitimate sphere of government activity. Some things are just not the bussiness of the government or of the majority. The government cannot legitimately interfere in particular areas of people’s lives and everyone has rights and liberties with which the government may not interfere.[p.101]</p>
</li>
</ol>
<p>对于Mill制度的评价：密尔面临和卢梭同样的问题，If democracy is to be instrumentally justified, it cannot achieve the twin virtues of freedom and equality.卢梭牺牲了人们的自由，而密尔牺牲了人们的公平。[p.101]</p>
<blockquote>
<p>freedom and equality. Freedom, as understood here, is a matter of giving people a say in political decision-making, particularly those decisions that affect them. Equality lies in this freedom being given to all.[p.77]</p>
<p>在这个意义上，自由是指人们在政治决策中有发言权，特别是那些影响他们的决策。自由意味着个人有权自由表达意见、参与公共事务，并且不受不合理的限制或压迫。</p>
</blockquote>
<hr>
<p>My Opinions:</p>
<p>独裁政府的好处是，良好的独裁者能够敏锐的发现社会中存在的问题，而且可能会有高的效率，但独裁政府的权利不受约束，很容易滑向坏的独裁政府。</p>
<p>而且，独裁政府下的官员需要向上负责，因此不会考虑公民们的切身利益。它们与其说是一个独立的人，不如说是独裁者的触手，没有独立思考的能力，缺乏灵活性，容易造成“上面的本意是好的，但下面执行坏了”。</p>
<p>独裁统治下的公民没有政治自由，没有权利参与、影响政治。加上独裁政府不需要公民们参与政治，所以公民们至少在政治层面的受教育程度低。因此，当自己的权利受到侵害时没有办法维护，甚至他们更加基本的人权也会受到政府的侵害。可以说，公民们在独裁统治下既没有参与政治的内在好处，甚至有时候连instrumental good也难以达成。</p>
<p>最后，独裁政府好像都以达成某个目标为口号，去统治他的公民，反而忽略了政府最初的目的是改善其公民的生活质量。或许这正是独裁政府借以欺骗其公民的手段。</p>
<p>看了很多资料之后，每当我问自己，什么是民主，我都还是会懵掉，因为民主的内涵太多了，甚至找不到一个出发点去解释他。今天我想从一个起点出发，尽量在脑中串起对民主是什么的回答。</p>
<blockquote>
<p>民主是Democracy，如果把Demo 和cracy翻译成英语就是people rule。推广一下，民主的定义就是：The government ‘of the people, by the people, and for the people’. 民主最主要的目标就是关注其公民的利益，不论是intrinsical good，还是instrumental good。但这两个价值往往是相冲突的，因此需要在他们之间进行权衡。根据政府统治的不同，政府的权力也不同，根据政府权力的多寡可以对民主政府进行分类，有代议制民主(密尔式的民主)，霍布斯式的民主，和直接民主。更复杂的，民主制度会因为其对民主的七个基本问题(大英百科全书)的回答而更加多种多样。</p>
</blockquote>
<p>本人认为民主制度面临最重要的问题是防止多数人的暴政，在本章中最让我满意的回答是密尔的回答。密尔从自由主义的角度出发，宣称政府不能随意侵犯他人的自由，而这些自由被统一归于人权之下(Principle of Liberty:<strong>the only purpose for which power can be rightfully exercised over any member of a civilized community against his will, is to prevent harm to others</strong>，而harm to others的界定标准就是法律规定的权利，而那些最基本的、放之四海而皆准的权利就是人权)。因此，无论如何，公民们都有一些基本不可侵犯的权利，因此多数人的暴政就有了一个上限。而其他的制度设计则会进一步防止多数人的暴政，补偿少数人。</p>
<h2 id="Ch-4-The-Place-of-Liberty"><a href="#Ch-4-The-Place-of-Liberty" class="headerlink" title="Ch 4 The Place of Liberty"></a>Ch 4 The Place of Liberty</h2><blockquote>
<p>Principle of Liberty</p>
<p>The only purpose for which power can be rightfully exercised over any member of a civilized community, against his will, is to prevent harm to others. His own good, either physical or moral, is a sufficient warrant.(Mill, <em>On Liberty</em>)</p>
</blockquote>
<p>自由问题来源于民主制度中的“the tyranny of the majority”，“The nature and limits of power which can be legitimately exercised by society over the individual”, 即政府对个人的干预，公众意见对个人信仰和行为的塑造必须受到限制。[pp.104-105]</p>
<p>Mill想要寻得适用于每一件事的评判标准，而不是依靠随意的传统与大众的道德标准，密尔的给出的答案是：Principle of Liberty——you may justifiably limit a person’s freedom of action only if they threaten harm to another.[p.106]</p>
<p>但密尔不认为自由原则适用于所有人，即并不是每个人都拥有自由原则所赋予的自由。他明确地表示该原则只适用于那些成熟的，能够在自由辩论中得到提升自己的人，孩子和那些退化到孩童状态的人不适用自由原则。[p.106]</p>
<hr>
<p><strong>Freedom of thought</strong></p>
<p>关于思想自由这里有三种情况：</p>
<ol>
<li>如果一种思想是正确的，某些社会可能会因为这种思想破坏了社会稳定，伤害了民族感情，破坏了人们虚假的幸福而将其禁止[p.109] (我认为这种禁止是荒谬的)。</li>
<li>如果一种思想是错误的，也不应该将其禁止。因为如果我们因为一种思想是错误的而将其禁止，那么这种思想对正确思想的挑战就被忽略了，人们因此不会思考真理为什么会是真的，最后真理就会变成教条。</li>
<li>而更多的情况是，真理往往混合在各个思想中的，那么思想自由就更重要了。在这种情况下，真理的最终显现只能在各种思想的公开辩论中。</li>
</ol>
<hr>
<p><strong>基于权利的自由原则</strong></p>
<p>继续回到Principle of Liberty，自由原则中，定义“Harm to others”是困难的，例如，一个人穿的衣服是另一个人不喜欢的颜色，这是对他人的伤害吗？一个人的姑姑剥夺了他的继承权，使他蒙受了巨大的损失，尽管他从未实际拥有这笔财产。</p>
<p>Mill更多的时候使用属于interest来表述他的自由原则，因此，这个版本的自由原则听起来像：Act as you like, so long as you do not harm the interest of another person.[p.113]</p>
<p>密尔对interest的两点限定：[pp.113-114]</p>
<ul>
<li>At least, an interest in their personal safety and security.</li>
<li>Mill intends that none of these forms of competition will be ruled out by the Liberty Principle. 即因为市场竞争而遭受的损失不再自由原则的范畴内。</li>
</ul>
<p>更进一步：</p>
<ul>
<li>In the passage just quoted Mill appeals to a new idea: interests which ought to be considered as rights, or ‘rights-based interests’.[p.114]</li>
<li>Indeed there are many interests which do not normally seem to give rise to claims of right. When my rich aunt strikes me out of her will, my interests may suffer, but he does not infringe my rights.[p.114]</li>
</ul>
<p>因此，密尔的Interest可以被视为古代斯多葛学派“自然权利”理论的延申，在当代，这些权利都被归到“人权”之下。</p>
<p>Within liberal circles it is often taken as a fundamental axiom that people  have certain basic rights. <strong>Normally included are the right to life, free speech,  free assembly, and freedom of movement, together with rights to vote and stand  for office. Some theorists, although not all, add rights to a decent standard of  living (shelter, food, and health-care). Most often these rights would now be  collected together under the name of ‘human rights’ or ‘universal human rights’.</strong>  In the past they would have been called ‘the rights of man’ or ‘natural rights’.[p.115]</p>
<p>对基于自然权利的人权/权利理论的批评：</p>
<ol>
<li>But the disadvantage is that we are left with nothing more  fundamental to say in defence of these rights. 这种自然权利好像没有什么能为其辩护的，因为这是一种宣言，宣称每个人都有自然权利/人权。就像康德对的宗教看法一样，不能说宗教对也不能说其不对，只能是一种信仰。[p.115]</li>
<li>我们或许不知道我们究竟拥有那些自然权利/人权，不同的理论家有不同的说法，倒不如说，自然权利只是不同的的私人意见(补充：其实有很多国际公约都有对人权的规定，如世界人权宣言)。</li>
<li>边沁对基于自然权利的人权/权利理论的批评：权利这个词一般是由法律派生而来的，但实际上自然权利没有任何法律规定它。[p.116]</li>
</ol>
<hr>
<p>基于以上理由，密尔也不认同基于自然权利的人权/权利理论，但它仍然坚信基于权力理论的自由原则，但这个原则不是基于自然权利的，而是基于功利的。</p>
<p><strong>功利主义</strong></p>
<p>这种功利主义继承了indrect utilitariansim，简单点说就是: The greatest happiness will be achieved by giving people a private sphere of rights-based interests where no intervention is permitted.[p.119]，通过基于人们不可侵犯的权利，可以保证社会最大的利益。</p>
<p>特别地，Henry Sidgwick主张功利主义的原则仅仅需要让那些立法者知道，而普通人只需要知道应该做什么，不能做什么就可以。因为普通人知道太多，他们就可能从direct utilitarianism的角度出发去思考问题。[p.118]</p>
<p>Mill也有类似的观点：Indeed, it may well be that Bentham and Mill thought of themselves as primarily addressing law-makers, rather than the public.[p.119]</p>
<p>功利主义的意义：This utilitarian defence of the Liberty Principle seems very plausible. The utilitarian theory of rights supplies exactly what is missing: a doctrine of rights which does not rest on the false foundation of natural rights theory, nor on the shifting sands of convention.</p>
<p>对功利主义的批评： In other words, utilitarianism would seem to encourage exactly the type of paternalistic intervention that the Liberty Principle expressly rules out: remember that the Liberty Principle does not permit anyone to interfere with another even for their own good. [p.120]</p>
<p>但比起纯粹的自由，密尔更多地效忠于功利，因此密尔的功利主义与其说是一种自由理论，不如说是一种基于功利主义的权利理论。This objection brings out that even if it is possible to construct a utilitarian theory of rights, it does not yet follow that the utilitarian theory would be a liberal theory.[p.120]</p>
<p>基于个人自由将导致更多的general happiness的原因：</p>
<ol>
<li>虽然人们时长犯错，但个人仍然能够做出对自己来说更加正确的选择，因为他们更加关注他们自己。[p.121]</li>
<li>The exercise of freedom of choice is itself vital to the full development of human nature. Those who are slaves to cunstom will never develop into rounded, flourishing individuals, because thay will fail to develop one of their most distinctively human capacities, the capacity for choice[p.122]</li>
<li>首先，人们是progressive的，他们拥有学习能力。更多的自由意味着人们可以开展很多 “experiments of living”，其他人将从这些实验的结果中学习，最终找到最适合的生存方式。[p.123]</li>
<li>反对: 人们可能根本不是progressive的，他们不会从历史中学到任何东西。</li>
</ol>
<p>有人说自由本身就像happiness一样，是一种intrinsic good，但Mill其实并不是这样认为的，Mill is clear that liberty is good primarily as a means to improvement, and where it fails to have that effect——in the case of children and barbarians ——there is no case for liberty. Liberty is good only when it adds to our happiness.[p.124]</p>
<p>对自由主义/mill的反对：</p>
<ol>
<li><p>对密尔的反对，Mill在论自由的最后一张为自由原则添加了许多限制，如禁毒，禁止暴力倾向的人喝酒……，就好像在他们的世界上不知有自由原则，还有道德原则，当有人触犯了道德，就是伤害了所有人，这种行为与他们那样的自由主义者所声称的观点不一致。[pp.125-127]</p>
</li>
<li><p>Marx对自由主义的批评，Marx认为自由主义——相对于奴隶制/君主制一种政治上的解放，还不能说是人类的解放，因为自由主义鼓励人们将其他人视为它自由之路上的障碍，它理想中的解放是Individual see themselves, and act, as fully co-operating members of a community of equals.[pp.128-129]</p>
</li>
<li><p>社群主义对自由主义的批评与Marx的观点基本相同，社群主义提倡用一种改良版的传统道德来达到积极自由。</p>
<blockquote>
<p>You do not make people free by leaving them alone. On the contrary, it is necessary to bring people to  a position where they can make the right choices about how to live: the choices that the rational person would make.</p>
<p>On that account negative liberty is “freedom from” constraint, and positive liberty is “freedom to” act.</p>
<p>If Mill’s negative definition leads to isolation and alienation, then the communitarian’s positive definition leads to repression in the name of freedom.</p>
</blockquote>
<p>一定要强调的一点是，密尔的消极自由一直假定人们是progressive的，这是Mill的信仰；但如果这是错的，那么社群主义的积极自由在功能主义的立场上可能是更好的。</p>
</li>
</ol>
<h2 id="Ch-5-The-Distribution-of-Property"><a href="#Ch-5-The-Distribution-of-Property" class="headerlink" title="Ch 5 The Distribution of Property"></a>Ch 5 The Distribution of Property</h2><p>本章的主要问题：How should a liberal socirty distribute property?</p>
<p>Mill: 从功利主义的角度出发，政府要保护私有财产，但不能干预时长竞争，个人有义务交税以为此政府的运行。[p.134]</p>
<p>Locke &amp; Nozick: 从自然权利理论的角度出发，主张只要财产来源合法，那么政府没有任何权力干涉，公民们只需交纳最少的税去维持政府的运作，通过税收进行再分配是不合法的。[p.135]</p>
<p>Rawls: welfare liberalism：政府处于保护自由和公正(liberty and justice)，可以对财产进行再分配。[p.136]</p>
<blockquote>
<p>本章讨论的问题包括，或者说The Distribution of Property的范畴包括：存在洛克式的自然财产权利吗？如何看待自由市场？我们应该接受财富的不平等吗？政府的角色应该是怎么样的？</p>
</blockquote>
<p>Locke and Nozick:</p>
<p>他们认为社会正义不需要通过不平等来体现，而只需要保证财富的来源是正当的即可。</p>
<p>Nozick的三条财富合法的原则：</p>
<ol>
<li>justice in initial acquisition</li>
<li>justice in transfer</li>
<li>justice in rectification</li>
</ol>
<p>Locke主要关注初始财产(土地，来自自然的材料)的合法性，并提出了四条论断：</p>
<ol>
<li><p>初始的财富是合法的，是因为我们必须要存活下去，我们需要自然的财产。但只有我们能够很好地使用这些财产（不造成浪费），而且留有足够的财产给他人，初始的财产才是合法的。</p>
</li>
<li><p>混合理论，我们之所以拥有这些初始财产，是因为它们身上混合了我们的劳动。</p>
</li>
<li><p>价值增加，…，是因为我们增加了他们的价值。</p>
</li>
<li><p>…</p>
<p>2，3都可以很容易地被反驳，我们只应该得到我们创造的价值，而不是初始财产。</p>
</li>
</ol>
<p>当代的看法：关注获取初始财产的正当性是没有意义的，我们可以接受一个有私有财产权的社会，并通过其他各种正当的理论为这些私有财产权辩护，而不是去关注初始财产的正当性。</p>
<p>自由市场可以为财产权辩护，从功利主义的立场出发，因为自由市场保证了社会生产的效率，因此它是好的，连通他的基础，财产权也得到了辩护，而由于存在市场失灵的情况，某些情况下的外部性需要政府来处理。</p>
<p>Rawls</p>
<ol>
<li><p>无知之幕</p>
</li>
<li><p>罗尔斯的不同正义原则：</p>
<blockquote>
<p>Principle 1 is the Liberty Principle, 2 (a) the Difference Principle, and 2(b)the Fair Opportunity Principle. According to Rawls the Liberty Principle has’lexical priority’ over the other two, as does the Fair Opportunity Principle over the Difference Principle. What this means, for Rawls, is that, once we have reached a certain level of well-being, considerations of liberty should have absolute priority over matters of economic wellbeing or equality of opportunity. On this account, for example, it is no defence of slavery that it makes the slavesbetter off than they would be with their freedom.</p>
<p>自由原则是：每个人都应享有平等的权利，享受与所有人的类似自由制度相兼容的最广泛的平等基本自由的总体制度。</p>
<p>差别原则：Rawls accepts the conditional statement that if an inequality is necessary to make everyone better off, and, in particular, to make the worst off better offthan they would otherwise be, then it should be permitted. This idea yields theDifference Principle. (差别原则的产生对那种认为无差别导致低效率的赞同和回应)</p>
<p>the Difference Principle. This, of course,  is the principle which says that the distribution of wealth and income in society  should be equal, unless an inequality will be to everyone’s advantage. </p>
<p>机会平等原则：它要求社会制度必须为每个人提供公平的机会，无论个人的出生、社会背景、种族、性别或其他不可控因素如何。机会平等原则强调每个人有平等的权利去竞争和追求自己的目标，而不会因为不公正的条件而受到限制。这意味着社会应该制定政策和制度来消除社会中存在的不公平机会，并提供平等的资源和教育等基础条件。</p>
<p>罗尔斯认为自由原则高于机会平等原则高于差别原则，当社会足够富足时，应该追求自由原则。</p>
</blockquote>
</li>
<li><p>差别原则主张在一个资源没有很稀缺，也不是非常富裕的社会下，财富平等与社会效率之间的均衡。那么应该选择什么样的原则来实现这种均衡呢？</p>
<p>一般有两种值得探讨的主张：</p>
<ol>
<li>Maximization of expectation : 最大化社会可以产生的财富期望</li>
<li>Maximin： 最大化社会的底线</li>
</ol>
<p>如果在“无知之幕”下，应该选择Maximin而不是Maximization of expectation，因为最大化期望的原则应该是在一个人有多次选择的时候被使用，而这种在无知之幕下的选择只有一次，而且这个选择和每个人的之后的每次选择都相关，可以说是一步错，步步错，因此应该选择Maximin。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>政治哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>摘抄：政治学通识</title>
    <url>/2023/10/10/%E6%91%98%E6%8A%84%EF%BC%9A%E6%94%BF%E6%B2%BB%E5%AD%A6%E9%80%9A%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Ch-3-意识形态"><a href="#Ch-3-意识形态" class="headerlink" title="Ch 3 意识形态"></a>Ch 3 意识形态</h2><h3 id="3-1-意识形态的定义："><a href="#3-1-意识形态的定义：" class="headerlink" title="3.1 意识形态的定义："></a>3.1 意识形态的定义：</h3><blockquote>
<p>意识形态的概念是法国哲学家德·特雷西（Destutt de Tracy）首先提出来的，最初的用法是指“观念的科学”（idea-ology）。马克思在1846年的《德意志意识形态》中，把意识形态这个概念政治化了。马克思认为，意识形态就是统治阶级的思想体系，因而具有比较强的欺骗性，其目的是为了让被统治阶级主动服从统治阶级的统治。所以，在马克思那里，意识形态有着强烈的政治色彩。[57]而现在的政治学研究中，通常把意识形态作为一个中性的词汇来处理，但是毫无疑问它仍然跟政治有非常密切的关系。</p>
<p>意识形态是现代社会科学体系中的一个概念和范畴，意指“一个行动导向的信念体系，一套以某种方式指导或激励政治行动的相互联系的思想观念”。</p>
<p>通常来说，政治意识形态有几个主要特征：</p>
<ol>
<li>第一，意识形态需要解释世界。为什么世界是这个样子而不是那个样子，意识形态需要给出一整套的理论解释。</li>
<li>第二，意识形态通常具有改造世界的企图心。多数意识形态都支持这样的信念：现状不够完美，现状能够变得更好。所以，很多意识形态倾向于承认存在某种社会改造计划的可能性。</li>
<li>第三，意识形态通常还带有行动导向的色彩。特定的意识形态通常会鼓励某些特定的行动或行为。</li>
<li>第四，意识形态的另一个特点是群众取向。很多理论学说非常高深，普通民众不太容易理解。但是，意识形态——如果要成为成功的意识形态——最终一定要简化到普通民众能够理解的语言，甚至最后简化为几个口号。</li>
<li>第五，值得提醒的是，某种意识形态和这种意识形体的实践往往是两回事。比如，一个国家据说要搞某某主义，而该国最终搞的是不是某某主义，不一定有必然的联系。</li>
</ol>
</blockquote>
<h3 id="3-2-自由主义的演变"><a href="#3-2-自由主义的演变" class="headerlink" title="3.2 自由主义的演变"></a>3.2 自由主义的演变</h3><blockquote>
<p>对政治意识形态的介绍一般从自由主义开始，原因在于自由主义在流行的意识形态中是最早出现的一种，而后来的意识形态通常是站在批评、反对或修正自由主义的立场上逐渐成形的。</p>
</blockquote>
<h4 id="3-2-1-自由主义的基本观点："><a href="#3-2-1-自由主义的基本观点：" class="headerlink" title="3.2.1 自由主义的基本观点："></a>3.2.1 自由主义的基本观点：</h4><blockquote>
<ol>
<li>政治上<ol>
<li>反对：一、欧洲民族国家兴起过程中尚存的封建主义和封建制，二、绝对君主制和专制主义。</li>
<li>主张立宪政府与个人自由。自由主义的基本政治主张是要有一个有限政府或立宪政府，政府的权力、行为和边界要受到强有力的约束。政府不能想干什么就干什么，其行为应该有明确限定。同时，社会中的普通公民和法人的权利应该享有明确的保护，特别是要防止他们受到政治权力恣意妄为的侵害。</li>
</ol>
</li>
<li>经济上，自由主义认为，政府要尽可能少干预市场，应该由“看不见的手”来协调市场主体的行为，而这是最有效率的一种方式。在自由主义框架内，国家的合理角色被界定为“守夜人”。</li>
</ol>
</blockquote>
<h4 id="3-2-2-古典自由主义："><a href="#3-2-2-古典自由主义：" class="headerlink" title="3.2.2 古典自由主义："></a>3.2.2 古典自由主义：</h4><p>代表人物：洛克，卢梭，约翰·斯图亚特·密尔，亚当·斯密</p>
<blockquote>
<p>笔者把古典自由主义总结为对若干重要原则的倡导：</p>
<ol>
<li>个人主义原则。<ol>
<li>个人被剥离了其他身份，而成为一个抽象的人类个体。这个抽象的人类个体本身的价值和权利就是至高无上的，这些权利无须依赖基本公民身份以外的其他任何身份，这些权利不能被国家或任何集体剥夺。</li>
<li>真正的个人主义至少应该包括两层含义：首先，个人要优先于群体。这里的优先，并不是说只要个人、不要群体，而是思考问题的一种特定视角。比如，对于一种政策，不要首先说这对整个社会有利，而要问是否改善或促进了个人福利。在个人主义看来，抽象的社会是看不见的，社会是由一个个不同的个人构成的。只有这种政策相当程度上能实现了个人福利时，社会福利才能得以实现。所以，个人主义主张个人优先于群体，既是一种认知问题的视角，又是在价值上倡导个人的优先性。</li>
<li>其次，把个人因素视为整个社会创造动力的来源。一个理想的社会应该激发每个人的主动性与创造力，让每个人的激励因素与个性特征成为促进社会进步的动力。个人主义把个人视为社会繁荣与创新的源头。</li>
</ol>
</li>
<li>二是个人自由原则。按照密尔的说法，界定这种自由的是“社会可以合法地施加于个人的权力之性质和界限”。倡导个人自由原则，意味着主张来自国家或社会的强制力干预越少越好。实际上，古典自由主义会认为，国家或社会可以干预个人行为的惟一正当理由是为了保护其他人同等的自由与权利。(政治自由或社会自由)</li>
<li>三是理性原则。德国哲学家康德说：“要有勇气运用你自己的理智！这就是启蒙运动的口号。”这里的理智与理性是一个意思。自由主义相信人的理性的力量，所以在历史维度上趋近于进步史观。自由主义相信随着人理性力量的发展，对自然和社会的科学知识的进一步发掘，这个社会能够不断地获得进步和加以改善。由于这种进步史观，自由主义倾向于支持变革。在这个维度上，自由主义与保守主义就发生了分野。自由主义相信人理性的力量，信奉进步史观，而保守主义并非如此。</li>
<li>四是平等原则。自由主义主张的平等更多的是指形式的平等和机会的平等，而非实质的平等和结果的平等。自由主义主张每个人都有同样的权利，但并不认为同样的权利就会得到同样的结果。自由主义承认每个人的天赋存在差异，认识到每个人付出的努力是不一样的，而且还存在运气等偶然因素的差异。再进一步说，自由主义者甚至认为要追求实质的平等和结果的平等可能是危险的，甚至最终会走向自由的反面。</li>
<li>五是宽容原则。自由主义相信，每个人的个性与自由非常重要，所以应该倡导宽容原则。社会要允许、容纳、甚至是鼓励多样性，宽容各种不同的选择和各种可能的见解。从功利的角度看，这些不同选择和不同见解可能会对社会产生重大的裨益。比如，创新的重要特征是其不确定性。由于不能确定创新来自于何处，一个允许和鼓励多样性的社会要比另外一个禁止或遏制多样性的社会更有可能出现创新。从权利上说，每个公民都有选择的自由，所以，社会应该对这些不同的选择保持尊重和宽容。</li>
<li>六是被治理者同意的原则。既然个人权利优先于群体，国家权力来自个人，因此自由主义认为，所有统治都应该基于被治理者的同意。统治要基于被治理者同意的原则往往跟某种程度的民主形式联系在一起。上文曾提到，自由主义未必主张民主政治。但如果说自由主义可能支持民主的话，很大程度上是因为统治要居于被治理者同意的这一原则。在现代社会，怎样落实统治要基于被治理者同意的原则呢？实际可操作性的办法就是让全体或多数公民以民主投票方式产生政府。需要说明的是，尽管如此，自由主义非常警惕普通民众是否会以多数投票方式侵犯自由权利，是否会导致托克维尔和密尔所警惕的“多数暴政”问题。所以，自由主义通常认为，民主政治同时需要宪政原则的约束。</li>
<li>七是宪政原则。自由主义认为，政府权力应该受到明确的限制，这就是最简单意义上的宪政原则。</li>
<li>八是自由放任原则。古典自由主义主张自由放任，无论是经济政策上还是社会政策上。诚如杰斐逊所言——“管得越少的政府越是好的政府”。上文提到的亚当·斯密的“看不见的手”原理，也是强调自由放任原则。所以，古典自由主义者眼中，守夜人国家就是理想的国家类型。</li>
</ol>
</blockquote>
<p>古典自由主义面临挑战/缺陷：</p>
<blockquote>
<ol>
<li>来自于自由市场经济本身的挑战：间歇性的经济危机、贫富悬殊以及托拉斯和大企业垄断等问题。</li>
<li>对大规模公共服务的需求：工业化和城市化的快速发展还产生了对大规模公共服务的需求。比如，19世纪早期的巴黎一度是一个臭气熏天的城市，主要原因在于大量人口的涌入、公共设施及基本公共服务的匮乏。如果以自由主义作为立国原则，当时的政治家和政府既不认为自己有权利、亦不认为自己有义务来应对城市大规模扩张所带来的实际问题。要知道，政府在历史上没有干过也不需要干这种事情。但客观上，大规模城市化对政府产生了极大的公共服务需求。</li>
</ol>
</blockquote>
<hr>
<h4 id="3-2-3-社会自由主义"><a href="#3-2-3-社会自由主义" class="headerlink" title="3.2.3 社会自由主义"></a>3.2.3 社会自由主义</h4><p>社会自由主义(social liberalism)/现代自由主义(modern liberalism)/左翼自由主义/福利自由主义(welfare liberalism)</p>
<p>代表人物：罗斯福、凯恩斯、罗尔斯</p>
<blockquote>
<p>现代自由主义认为，原先高度自由放任的制度安排是不恰当的，应该让政府发挥更积极的作用。因此，现代自由主义有两个基本特点：一方面，是尊重过去基本的制度安排，包括尊重私人财产权和市场经济，尊重宪政、法治与公民的自由权利；另一方面，在此基础上，主张强化政府干预——包括对市场、行业和企业的管制，加强对劳工阶层的保护以及建设福利社会。</p>
<p>罗尔斯的两条正义原则：</p>
<blockquote>
<p>第一个正义原则：每个人都拥有平等的权利来享有最广泛的、与他人类似的自由相容的基本自由。第二个正义原则：社会和经济的不平等应该：（1）有利于受惠最少者的最大利益；（2）职位和机会应该向所有人开放。</p>
</blockquote>
<p>罗尔斯的第一条正义原则可以称之为自由原则。简单地说，一个人的自由在不侵犯他人同等自由的条件下应该尽可能的大。第一条原则似乎与古典自由主义、与密尔在《论自由》中的主要观点没有区别。但是，罗尔斯的正义论还要兼顾第二条原则，可以称为平等原则。简单地说，罗尔斯强调的平等原则是要对社会中的弱势群体较为有利。这样的话，政府干预就成为必要，政府干预也成为塑造正义社会的一部分。所以，罗尔斯一方面强调每一个人都应该享有最广泛的自由，另一方面强调还应该采取辅助性手段来改善弱势群体的处境。他的学说实际上是两者的结合，这也就是现代自由主义的基本特征。</p>
</blockquote>
<p>社会自由主义面临挑战/缺陷：</p>
<blockquote>
<p>社会自由主义主张强化时长干预，那么这种干预是否合理？</p>
<blockquote>
<p>现代自由主义涉及很多实际而重大的政策争论。其中的一个争论是，美国政府是否应该去救助那些在金融危机中濒临倒闭的大企业？——特别是房利美、房地美这样的房地产金融机构，雷曼兄弟公司这样的大型投资银行，以及通用汽车这样的大型实业公司。</p>
<p>反对的理由来自三个方面：第一，直接援助某个企业的做法破坏了市场经济规则。有人经营不成功，就应该让它垮掉，这是一种优胜劣汰的机制。只有这样，那些原本被浪费或低效使用的经济资源才可以配置到更高效的部门中去。第二，政府拿谁的钱去拯救这些企业？纳税人的钱。问题就来了，政府凭什么把纳税人的钱花在一个特定的企业上呢？第三，政府出面拯救企业，无形中弱化了企业的主要股东和主要经营者的责任。这也违背市场经济的基本原则。</p>
<p>支持的理由更多是基于社会公益的视角。如果任由通用汽车彻底破产而不进行重组，会带来什么社会问题呢？首先，通用汽车本身就是一个大企业，这样会导致很多人失业。此外，通用汽车还有很多关联协作企业，特别是为数众多的主要供应商和主要经销商，他们都有可能面临经营困难，甚至是破产。这会通过连锁反应触发更严重的失业问题。</p>
</blockquote>
<p>现实中社会自由主义的问题：</p>
<blockquote>
<p> 到了20世纪70年代左右，凯恩斯主义政策开始引发很多问题，经济上主要表现是滞胀现象，即经济停滞与通货膨胀的并存；社会方面表现为福利政策导致的很多社会病。</p>
</blockquote>
</blockquote>
<hr>
<h4 id="3-2-4-新自由主义"><a href="#3-2-4-新自由主义" class="headerlink" title="3.2.4 新自由主义"></a>3.2.4 新自由主义</h4><p>新自由主义(neoliberalism)/新古典自由主义(neo-classical liberalism)</p>
<p>代表人物：哈耶克（《通往奴役之路》，《自由秩序原理》），路德维希·冯·米瑟斯，米尔顿·弗里德曼，罗伯特·诺齐克（《无政府、国家与乌托邦》）</p>
<p>哈耶克：</p>
<blockquote>
<p>首先，从方法论上说，哈耶克秉承的是个人主义方法论。他基于个人主义方法论来观察社会和世界。个人不仅被置于集体之前的优先位置，而且个人还被视为社会繁荣的真正根源与动力。</p>
<p>其次，哈耶克的学说很大程度上基于其知识论。他的基本观点是：人在很大程度上是无知的，因为人所具有的知识和信息与其决策所需的信息相比总是少得可怜。因此，人类无法借助完全的理性来认知所有复杂事物背后的关键信息。</p>
<ol>
<li>基于这种知识论，哈耶克有两个推论：第一，假定有一个中央机构基于理性和科学、依靠其所知的庞大信息来统一做经济决策，是完全靠不住的。理由是该机构所具有的知识和信息，与决策所需的知识和信息相比，还是少得太多。</li>
<li>第二，人是相对无知的，这个社会又需要创新，而创新具有高度的不确定性。因此，一个好的社会要给每一个人及组织以探索和尝试的自由。由于不能事先计划和确定创新来自于何处，自由就为创新所必需。没有此种自由，社会就会慢慢停滞和僵化。当创新不再，经济繁荣和社会进步也成了幻想。所以，哈耶克反对理性建构主义（rational constructuralism）的观点和社会工程（social engineering）的概念。他认为，人类认为可以凭借自己的完全理性与完全信息，把社会推倒并按照自己的意图重新设计一次，这种想法是完全靠不住的。</li>
</ol>
</blockquote>
<p>路德维希·冯·米瑟斯</p>
<blockquote>
<ol>
<li><p>如果一个人想致富，市场经济会给他提供机会。但惟有他设法改善其同胞的物质与生活条件，他才能实现自己的目标。谋求致富的年轻人发现，只有推动技术进步，实现产品创新，提供更好的消费者价值，才有机会致富。</p>
</li>
<li><p>米瑟斯认为，完全的公有制是行不通的，这种社会很快就会垮掉；如果是公有制和私有制结合的状态，就会导致生产力的下降，无法创造更多的财富。</p>
</li>
<li><p>米瑟斯主张的是权利的平等而非结果的平等，形式的平等而非实质的平等。实际上，如果消灭了财产或财富的不平等，就会有其他的不平等出现。比如，把财产和市场消灭掉后，社会上就会出现了一个掌握巨大政治经济权力的新阶级，而这个阶级跟普通人之间会产生新的巨大的不平等。</p>
<blockquote>
<p>有人指责自由主义关于法律面前人人平等的观念，他们认为法律面前的人人平等并不是真正的平等，这种指责毫无道理，想把人变得真正平等起来，这是依靠人的一切力量都办不到的事情，人与人之间本来就是不平等的，而且将继续不平等下去。……真正理智、清醒、并且合乎目的的处理办法就是争取在法律上平等待人。自由主义并不奢望得到比这更多的东西，因为超出这个范围以外的东西是不存在的，也是不可能办到的。</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>米尔顿·弗里德曼</p>
<blockquote>
<p>弗里德曼认为，经济自由是政治自由的前提；私有产权和契约自由是整个市场制度的核心；政府职能必须严格限定在较小范围内；政府权力必须有限度和足够分散。</p>
<blockquote>
<p>比如，他是国家垄断教育的坚定反对者。从政治上讲，教育国有化的一个弊端是政府有可能借助教育控制整个社会的思想和意识形态，所以公立教育系统可能会沦为政府的工具。另外，公立教育还会带来很多实际问题，比如，从公立学校内部管理来说，小学或中学教师们的薪水基本上是固定的，是根据等级及年资来晋升的，所以弗里德曼认为这会导致优秀教师拿得太少，而不合格教师拿得太多的问题。再比如，由于公立学校只能按学区来统一安排，就限制了家长选择教育的自由，家长在很大程度上丧失对自己子女教育的选择权。</p>
</blockquote>
</blockquote>
<p>罗伯特·诺齐克</p>
<blockquote>
<p>我们关于国家的主要结论是：能被证明为正当的就是一种最小国家（minimal state），即仅限于防止暴力、偷窃、欺骗和强制履行契约等有限功能的国家；更多功能的国家（extensive state）都将被证明为是非正当的，因为这样的国家会侵犯到个人不被强迫从事某些特定事情的权利。惟有这种最小国家是令人鼓舞的和值得期待的，也是公正的，而所有超出这个限度的国家都被认为是一种恶。</p>
</blockquote>
<h3 id="3-3-保守主义"><a href="#3-3-保守主义" class="headerlink" title="3.3 保守主义"></a>3.3 保守主义</h3><p>代表人物：埃德蒙·柏克</p>
<p>对保守主义的理解：[希尔贝克：西方哲学史P.347]</p>
<ol>
<li>一种形式上的理解：“希望保存既存之物”：希望保存的内容没有具体的定义，不是某种特定的东西。</li>
<li>价值保守主义：希望保存某种特定的东西。</li>
</ol>
<blockquote>
<blockquote>
<p>埃德蒙-柏克</p>
<p>因为保守主义者曾在这样那样的时间与场合，捍卫过皇权、立宪君主制、贵族特权、代议制民主和总统独裁；高关税和自由贸易；民族主义和国际主义；中央集权和联邦制；一个继承房产的社会，一个资本主义市场的社会以及福利国家的这种或那种版本。他们也捍卫普遍意义上的宗教、正统教会，及政府抵制宗教狂热分子的言论以捍卫自身的必要性。毫无疑问，今天那些自我声称的保守主义者很难想象过去的保守主义者会支持不同于其主张的制度和实践。</p>
</blockquote>
<p>借鉴安德鲁·海伍德的论述，这里把作为意识形态的保守主义总结为若干重要原则：</p>
<ol>
<li><p>一是捍卫传统的原则。保守主义认为，传统当中包含了很多有益的价值与思想。出于捍卫传统的考虑，保守主义都会反对激进变革。</p>
</li>
<li><p>二是经验主义原则保守主义强调的是人的有界理性。经验主义过度的理性主义持高度警惕和怀疑的态度。经验主义对很多过度乐观的方案持审慎、甚至怀疑的态度。经验主义认为，人的理性是有边界的，不能想对社会做什么改造就能做什么改造，在尊重现有惯例、传统与习俗基础上做逐步改进更为合理。</p>
</li>
<li><p>三是人类的不完善原则。某些意识形态最后都会塑造一个乌托邦，但保守主义对此从来就抱有警惕和怀疑。乔万伊·萨托利在《民主新论》中批评过“至善论”的危险——这是一种与塑造乌托邦有关的思维模式。当认识到这个社会的不完美时，一种可能性是对这种不完美性和不完善性感到厌恶，由此可能会产生一种念头：这个社会应该变得更加完美、完善和纯洁。既然这样，能否按照这种理想来构建和塑造一个新社会？能否把一切与真、善、美不相关的东西统统摒弃掉或消灭掉？至善论的观念，最后往往导向一条追求乌托邦的道路，就是想要创造一个无限美好的社会。保守主义对此持否定态度，他们往往以一种冷峻的态度来思考现实问题。正如霍布斯在《利维坦》中所说：“人类的事情决不可能没有一点毛病。”</p>
</li>
<li><p>四是社会作为有机体的原则。有机体的观点意味着社会是一个复杂的有机系统，社会内部不同部分之间是互相关联的。所以，不能凭自己的理论、臆想或理性来随意创造一种新社会。哈耶克极力反对的一个概念是“社会工程学”（social engineering），即凭借理性对社会进行再造，就如同把整个社会视为一个建筑工程一般。保守主义认为，社会中很多重要事物是人的理性无法完全认知的，却在现实中极其重要。如果要从头构建一个新的社会、彻底打破一切惯例和常规，最后可能会发现这个依靠理性构建起来的社会由于缺少有机体因素的支撑而难以有效运转，甚至完全陷于瘫痪。</p>
</li>
<li><p>五是重视等级、秩序和权威的原则。在保守主义者眼中，这个社会存在等级本身是很正常的。有些人更富有、更高贵、更有权势、更有影响力也很正常，社会本来就应该是这样的。</p>
</li>
<li><p>六是重视家庭的原则。自由主义更强调个人作为个体的价值和意义，并没有特别强调家庭的价值和意义。保守主义认为，家庭是很多重要社会功能的承担者，比如教育；同时，家庭也维系着一个社会的稳定与秩序。从更深层上说，家庭代表的是传统秩序的一部分。</p>
</li>
<li><p>七是重视和认同宗教的原则。</p>
</li>
<li><p>八是重视道德的原则。保守主义认为道德是一个良好社会的重要因素。</p>
<blockquote>
<p>自由主义学说对道德并不是很重视，自由主义很少专门论述道德问题——尽管创作《国富论》的亚当·斯密同时创作了《道德情操论》。当然，这并不是说自由主义反对道德，而是自由主义认为：每个人都倾向于追逐自己的利益，当外部法律环境公平时，自由市场机制就能有效运转，每个人追逐自我利益的行为客观上就能实现社会的共同利益。自由主义对这种基于自我利益的市场行为最后能达致社会和谐抱有充分的信心。麦特·里德雷（Matt Ridley）在《美德的起源》一书中干脆认为，美德是自利的个人互相博弈与长期演化的结果。换言之，美德是自利的产物。</p>
</blockquote>
</li>
<li><p>九是尊重财产权的原则。保守主义非常重要的一条原则是强调对财产权的保护和捍卫。在这一点上，保守主义与古典自由主义的立场别无二致。保守主义不仅反对国家剥夺或征收财产，而且反对国家对私人市场的过度干预、高税收和高福利等做法。上述这些做法违背了尊重财产权的原则。保守主义在20世纪70、80年代演变为新保守主义时，在这一问题上是跟新古典自由主义是一致的。</p>
</li>
</ol>
<p>保守主义意识形态内部的一大争论是，保守主义究竟是一整套系统的价值观念和意识形态体系，还是仅仅是一种对于现状的维系与变革之间的思想倾向。这方面并无定论。更为复杂的是，按照杰里·马勒的说法：“保守主义的内容不仅随着时间和国家语境改变，而且常常在同一时间地点自称保守主义者的人中也内涵不一。”</p>
</blockquote>
<h3 id="3-4-社会主义"><a href="#3-4-社会主义" class="headerlink" title="3.4 社会主义"></a>3.4 社会主义</h3><h4 id="3-4-1-社会主义的演变"><a href="#3-4-1-社会主义的演变" class="headerlink" title="3.4.1 社会主义的演变"></a>3.4.1 社会主义的演变</h4><blockquote>
<p>首先出现的是<strong>空想社会主义</strong>。像欧文、圣西门和傅里叶等人都是空想社会主义的代表，他们强调集体主义和互助，批评资本主义的诸种负面现象。</p>
<p>后来，这一派的学说就慢慢地发展为<strong>科学社会主义或者叫共产主义</strong>，这主要是指马克思和恩格斯的学说。马克思和恩格斯主张通过无产阶级革命来建立公有制，实行计划经济，建设共产主义。</p>
<p>马克思与恩格斯之后，社会主义学说后来又有新的发展，被称为<strong>改良的社会主义或社会民主主义</strong>。其中的一位杰出代表性人物是德国思想家与政治活动家爱德华·伯恩斯坦，他认为应该放弃暴力革命，主张通过议会方式进行民主斗争，并进而改变资本主义国家的经济政策，强化再分配，实现社会平等以及建设福利国家。数十年之后，伯恩斯坦倡导的很多主张已经成为欧洲发达国家的基本政策和实际状态。所以，从某种程度上说，今天的发达国家——特别是欧洲大陆的发达国家——其政治经济模式已经融合了自由主义和民主社会主义的因素。</p>
<p>后来社会民主主义中的一派与新自由主义合流。</p>
</blockquote>
<h4 id="3-4-2-社会主义的基本特征"><a href="#3-4-2-社会主义的基本特征" class="headerlink" title="3.4.2 社会主义的基本特征"></a>3.4.2 社会主义的基本特征</h4><blockquote>
<p>借鉴安德鲁·海伍德的论述，这里把社会主义意识形态视为对若干原则的倡导：</p>
<ol>
<li>一是强调共同体原则。在个人与群体的关系上，社会主义强调的是群体，认为脱离了群体的个人是不存在的，个人脱离群体实际上也无法生存。比如，如果一个小孩生活在孤岛上，如鲁宾逊一般，不跟其他社会成员发生交往，他最后是无法成为一个社会人的，只不过是一个具有人形的动物罢了。所以，倘若脱离了群体，个体的价值就无从体现，甚至难以成为一个完整意义上的人。</li>
<li>二是平等主义原则。如果说自由主义更重视自由，保守主义更重视秩序与财产，那么社会主义就更重视平等。社会主义的平等观，不只是形式平等和机会平等，同样重要的是实质平等和结果平等。所以，一个符合社会主义理想的社会，其社会成员之间的贫富差距程度应该要远远小于按照其他原则构建的社会。</li>
<li>三是博爱原则。社会主义主张博爱，认为应该以同等的方式去对待社会中的每一份子。社会主义的最终目标也是要让所有人或绝大多数人都过上一种更美好、更体面和更有尊严的生活。</li>
<li>四是阶级原则。社会主义秉承阶级分析方法，把社会分成资产阶级和无产阶级，或上层阶级和下层阶级。前者是统治阶级，后者是被统治阶级。社会主义认为，上层阶级与下层阶级之间存在压迫与被压迫关系。凡是下层阶级的一员，实际上时刻都受着上层阶级的压迫。所以，社会主义主张打破既有的阶级结构，以构建更平等的、甚至无阶级的社会作为理想。</li>
<li>五是财产的社会控制原则。社会主义认为，只要财产控制在私人手里，必定会带来前面提到的不平等和阶级压迫。所以，社会主义寻求的是让财产的私人占有过渡到某种形式的财产的社会控制。</li>
<li>六是满足需求的原则。社会主义比较注重人基本需求的满足。每一个人都有很多基本需求，每个人应该拥有满足这些基本需求的权利。所以，共产主义的口号是“各尽所能，按需分配”。与自由主义和保守主义相比，社会主义至少在意识形态上更注重人的基本需求，这也是社会主义意识形态的独特之处。</li>
</ol>
</blockquote>
<h4 id="3-4-3-伯恩斯坦与社会民主主义"><a href="#3-4-3-伯恩斯坦与社会民主主义" class="headerlink" title="3.4.3 伯恩斯坦与社会民主主义"></a>3.4.3 伯恩斯坦与社会民主主义</h4><blockquote>
<p>伯恩斯坦总体上并不赞成从马克思和恩格斯到后来列宁的无产阶级革命观点。相反，他认为应该在资产阶级宪政民主框架内，通过议会斗争的方式来实现社会主义的基本目标。</p>
<p>伯恩斯坦对马克思和恩格斯在《共产党宣言》中的政治纲领与社会设计充满了担忧。</p>
<ol>
<li>首先，他认为，完全的公有制将会造成劳工阶层的积极性不足。后来很多关于计划经济的研究已经为这种观点提供了理论和经验支持。</li>
<li>其次，这种模式会导致生产过程的官僚主义化。从企业与市场由资本家主导的管理模式变成一种由行政官僚统治的管理模式——行政官僚本身缺少市场激励，整个生产过程极易变成一种官僚化运作。</li>
<li>再次，无产阶级一党专政有可能会成为新的专制统治——伯恩斯坦认为至少有这种可能性。</li>
<li>最后，伯恩斯坦认为马克思的工人阶级中心论有可能是反人道主义的。如果说工人阶级需要特殊优待，那么其他阶级呢？比如，管理阶层、知识阶层、农民阶层呢？实际上，伯恩斯坦的部分担忧已经为苏联斯大林统治时期的某些实践所证实</li>
</ol>
<p>那么，社会民主主义主张何种政策呢？他们主张的一个主要政策是通过税收和再分配使不同社会阶层的收入更加平等化。</p>
</blockquote>
<h4 id="3-4-4-新工党与新自由主义"><a href="#3-4-4-新工党与新自由主义" class="headerlink" title="3.4.4 新工党与新自由主义"></a>3.4.4 新工党与新自由主义</h4><blockquote>
<p>在此种背景下，特别是20世纪80年代以来，社会民主主义阵营内部出现了分化，其主流开始与新自由主义的部分主张合流，兴起了“新的社会民主主义”“第三条道路”“中间道路”“新社会民主党”和“新工党”等概念。总的趋势是，他们部分地接受新自由主义的经济理论，承认市场经济的作用，强调企业家精神和激励因素的重要性，不赞同建设无所不包的福利国家。</p>
<p>英国“新”工党的基本政策：“市场应当在企业家的指导下起主导的作用，政府的干预应减少到最低限度；应缩减税收和公共开支；应尽可能淡化工会的作用。”这则言论非常明确地强调，英国工党在向新自由主义的政策靠近。</p>
</blockquote>
<h2 id="Ch-4-国家"><a href="#Ch-4-国家" class="headerlink" title="Ch 4 国家"></a>Ch 4 国家</h2><h3 id="4-1-国家"><a href="#4-1-国家" class="headerlink" title="4.1 国家"></a>4.1 国家</h3><h4 id="4-1-1-国家的定义"><a href="#4-1-1-国家的定义" class="headerlink" title="4.1.1 国家的定义"></a>4.1.1 国家的定义</h4><blockquote>
<p> 马克斯·韦伯提出来的：国家是这样一个人类团体，它在一定疆域之内（成功地）宣布了对正当使用暴力的垄断权。</p>
</blockquote>
<p>本书作者总结的现代国家的基本特征:</p>
<blockquote>
<ol>
<li>第一，国家要有特定疆域。就是说，国家的地理范围是确定的，而不是随意变动的。</li>
<li>第二，国家包含特定人口。问题是，有的国家人口的同质性程度很高，有的国家人口的异质性程度很高。人口的同质性程度高，自然对国家较为有利。那些族群、宗教和语言构成差异大的社会，国家面临的挑战会更大些。这个问题通常会涉及如何塑造国家认同和民族认同。</li>
<li>第三，国家的主要特征是垄断暴力。每个国家都需要把军队和警察部门掌握在自己手里。从很多国家的政治史来看，垄断暴力是国家构建过程中的核心问题。从韦伯到蒂利，这些学者都把处理暴力问题视为国家的基本问题。</li>
<li>第四，国家需要一整套官僚系统。政府是国家的载体，而政府是由一整套官僚系统组成的。这套官僚系统通常从中央延伸到地方，具有统一的命令协调体系，一般包含职能分工与层级分工。没有这套官僚系统的支持，国家是无法运转的。</li>
<li>第五，国家依赖于税收系统。通常，国家必须要靠社会来提供税收。按照诺思的说法，国家通过提供公共服务来换取收入，这里的收入主要是税收。</li>
<li>第六，国家主权需要得到国际承认。现代国家处于现代国际体系之中，国家主权是国家的主要特征之一。主权得到其他主要国家或国际社会的承认，也是现代国家的特点。</li>
</ol>
</blockquote>
<h4 id="4-1-2-国家的分类"><a href="#4-1-2-国家的分类" class="headerlink" title="4.1.2 国家的分类"></a>4.1.2 国家的分类</h4><p>根据国家的权利特征：</p>
<blockquote>
<p>在欧洲国家兴起的过程中，慢慢形成了两种国家类型：一种是<strong>绝对主义国家</strong>，一种是<strong>立宪主义国家</strong>（即宪政国家）。在立宪主义国家，君主权力受到宪法和法治传统的约束。在绝对主义国家，君主权力是绝对的，君主权力和意志是不受制约的。一般认为，英国是欧洲历史上第一个立宪主义国家，其宪政历史可以追溯至1215年《大宪章》。而大革命之前的法国是欧洲绝对主义国家的代表。欧洲不同国家的不同历史演进路径，是非常值得研究的一个问题。同样从封建主义到现代国家的演进，为什么会造成立宪主义国家和绝对主义国家的分野？</p>
</blockquote>
<p>根据国家的角色进行分类：</p>
<blockquote>
<ol>
<li><p>古典自由主义欣赏的是“守夜人”国家，即自由放任国家。这种类型下的理想国家主要扮演警察与法官的角色。他们相信：“管得越少的政府越是好政府。”</p>
</li>
<li><p>从19世纪晚期到20世纪以来，欧洲逐渐兴起了福利国家，福利国家的关键词是社会福利。这种国家观认为，国家不仅要给社会提供基本保护，还要为公民提供基本的社会福利。今天，欧洲发达国家或多或少都具有福利国家的色彩。</p>
</li>
<li><p>20世纪30—40年代，希特勒统治的德国一般被称为极权主义国家，又称政治全能主义国家。极权主义国家的关键词是政治控制，即国家通过政治手段渗透到经济、社会、甚至家庭各个领域，试图对个人和社会实现无所不包的政治控制。</p>
</li>
<li><p>随着东亚国家的经济崛起，国际学术界又提出了发展型国家的概念，这类国家的关键特征是发展导向。发展型国家通过适当规划和政府干预，在落后社会实现了经济增长与繁荣。</p>
</li>
<li><p>非洲等一些落后地区的国家则容易沦为掠夺型国家，这类国家以某种程度的“盗匪统治”为特征。在这类情形下，统治集团利用国家权力对社会进行肆无忌惮地掠夺。这样，经济和社会发展几乎是没有可能的。</p>
</li>
</ol>
</blockquote>
<h4 id="4-1-3-国家应该做什么？"><a href="#4-1-3-国家应该做什么？" class="headerlink" title="4.1.3 国家应该做什么？"></a>4.1.3 国家应该做什么？</h4><blockquote>
<p>目前大致有三种主要观点。</p>
<ol>
<li>第一种观点认为，国家的理想角色主要是提供保护；</li>
<li>第二种观点认为，国家的理想角色主要应该是促进发展；</li>
<li>第三种观点认为，国家的理想角色主要应该是提供福利。</li>
</ol>
</blockquote>
<h3 id="4-2-其他"><a href="#4-2-其他" class="headerlink" title="4.2 其他"></a>4.2 其他</h3><p>国家建构/国家能力，因为书中没有明确给出这些内容属于那些范畴，因此仅仅在这里提一下，不再继续摘抄。</p>
<h2 id="Ch5-政体"><a href="#Ch5-政体" class="headerlink" title="Ch5 政体"></a>Ch5 政体</h2><blockquote>
<p>一般认为，比较正式的政体类型学起源于亚里士多德。他区分政体类型有两个标准：第一个标准是最高统治权掌握在谁手中：是一个人手中，少数人手中，还是多数人手中；第二个标准是这种统治服务于部分人的利益还是城邦整体的利益。基于上述两个标准，亚里士多德区分了六种政体类型。</p>
<p>到20世纪，现代政体类型一般被分类为：民主政体、威权主义政体和极权主义政体。</p>
<p>胡安·林茨认为现代政体类型不止这三种，他在《民主转型与巩固的问题》中划分了五种现代政体类型，分别是民主政体、威权主义政体、全能主义（极权主义）政体、后全能主义（极权主义）政体和苏丹制政体。</p>
</blockquote>
<h3 id="5-1-民主政体"><a href="#5-1-民主政体" class="headerlink" title="5.1 民主政体"></a>5.1 民主政体</h3><blockquote>
<p>1942年，美国经济学家约瑟夫·熊彼特在《资本主义、社会主义与民主》一书中提出了民主的程序性定义，逐渐成为政治学界的常用定义。他说：民主方法就是那种为做出政治决定而实行的制度安排，在这种安排中，某些人通过争取人民选票取得作决定的权力。……民主政治并不意味着人民真正在统治——就“人民”和“统治”两词的任何明显意义而言——民主政治的意思只能是：人民有接受或拒绝将要来统治他们的人的机会。</p>
<p>目前学界形成了关于民主的两种定义：一种是实质性定义，另一种是程序性定义。当然，熊彼特提出的程序性定义也遭到部分学者的批评。比如，有学者认为，从这种视角定义民主容易导致“选举主义的谬误”（fallacy of elec-toralism），即过分强调选举的作用而忽略了民主的实质。</p>
<p>罗伯特·达尔早年在《多头政体》中定义的民主或多头政体，更接近于熊彼特的程序性定义。达尔认为：“民主国家的一个重要特征，就是政府不断地对公民的选择做出响应，公民在政治上被一视同仁。”他接着问：“一种制度要成为严格民主制度，还要具备哪些其他特征呢？”他依次列出了多头政体的八个条件：….</p>
<p>结合上述讨论，可以总结出民主政体的几个基本特征：</p>
<ol>
<li>第一个特征是政治参与。民主意味着多数成年公民拥有投票权。</li>
<li>第二个特征是政治竞争。按照程序性定义，民主本身就包括了政治竞争的含义。不同候选人可以就公共职位展开公开角逐，通过争取选民手中的选票来获得当选的机会。现代政治中，这种政治竞争不仅指单个政治家之间的竞争，而且指不同政治团体——主要是不同政党——之间的竞争。</li>
<li>第三个特征是问责制或责任制。当一个公职人员做事情的时候，是对某个政治共同体或特定地域内的选民负有责任的。简单地说，他要对别人有个交代，他要承担自己政治行为的后果，干得不好时通常就必须走人。</li>
<li>第四个特征是回应或响应机制。在民主政体下，政府对于公众的利益诉求有一种正式的回应或响应机制。例如，最近出现了重大的公共问题，如果很多人在报纸、电视、网络上呼吁，或以集会、示威游行方式呼吁的话，政治家和政府不会置之不理，他们通常都会做出回应。既然民主意味着政治家要根据大众的利益诉求和政治意愿来进行统治，民主政体就是一种正式的回应或响应机制。政府或政治家如果对民众诉求置之不理，通常会在下一次选举中遭到失败。</li>
<li>第五个特征是起码的政治平等。这里的政治平等是指具有平等的参与政治、政治表达和投票的基本权利，所有公民在这方面应该是平等的。这里的政治平等首先强调的是形式平等和资格平等，而非实质平等和结果平等。</li>
<li>第六个特征是多数决定的规则。这就是平时说的少数服从多数。</li>
<li>第七个特征是对少数权利的保护。与多数决定规则相关的一个问题是：多数决定规则并不意味着多数可以侵犯少数的权利。密尔在《论自由》、托克维尔在《论美国的民主》中都讨论过“多数暴政”问题。民主在尊重多数规则的同时，还要保护少数的权利。换句话说，多数统治并不意味着多数可以就任何事情做出任何决策。多数决定规则是有其明确的边界和范围的。现在一般把欧美发达国家的民主政体称为自由民主政体，其基本特征是对少数权利的保护与尊重。</li>
<li>第八个特征是言论自由与新闻自由。既然民主意味着政治参与和政治竞争，就必然需要政治表达和政治沟通，言论自由与新闻自由就是基本条件。只有在这种条件下，一个社会中才能听到不同的政治理念与政策主张，才存在实质性的政治竞争。在互联网时代，网络信息传播的自由也变得同样重要。</li>
</ol>
</blockquote>
<h3 id="5-2-威权政体"><a href="#5-2-威权政体" class="headerlink" title="5.2 威权政体"></a>5.2 威权政体</h3><h4 id="5-2-1-威权政体的分类"><a href="#5-2-1-威权政体的分类" class="headerlink" title="5.2.1 威权政体的分类"></a>5.2.1 威权政体的分类</h4><blockquote>
<p>威权主义政体是指一个人或一个小集团的统治，居于统治地位的可能是君主、独裁者、军队或政党等。一般来说，威权政体下缺少正式的政治参与和政治竞争，政府亦非责任制或问责制政府。</p>
<p>现代世界的威权政体主要有几种类型。</p>
<ol>
<li>一种类型是君主制，君主制一般是家族统治，有明确的家族继承关系，统治者从传统中获得一定的合法性。</li>
<li>军人统治也是过去非常流行的一种威权政体类型。</li>
<li>威权政体的另一种类型是神权统治。这种国家一般是实行政教合一的宗教国家，而非世俗国家。在这样的国家，经由政治程序产生的最高行政长官至多是该国的第二号人物，该国最重要的政治人物是宗教领袖，他的实际政治权力和影响力往往要超过最高行政长官。</li>
<li>另外，按照萨托利的说法，一党制与霸权党制都是威权主义的统治类型。</li>
</ol>
</blockquote>
<h4 id="5-2-2-威权政体基本特征"><a href="#5-2-2-威权政体基本特征" class="headerlink" title="5.2.2 威权政体基本特征"></a>5.2.2 威权政体基本特征</h4><blockquote>
<p>威权主义政体的基本特征:</p>
<ol>
<li>第一个特征是政治上的非多元化。在这种政体形式下，政治参与和政治竞争受到严格的限制。当然，有些威权国家保留着政治参与的形式，甚至一些国家也有政治竞争，但这种参与和竞争或多或少受到实质性的限制，通常不会出现像民主国家那样的不受限制的、公开的政治竞争。</li>
<li>第二个特征是在经济和社会领域倡导多元化，这是威权政体不同于极权主义政体的地方。威权政体之下通常都存在私人企业部门，允许发展市场经济，部分威权国家还允许开办私人报纸和私人电台。威权政体应该是政治领域非多元化与经济社会领域多元化的结合。</li>
<li>第三个特征是实行一定的政治控制和政治压制。如果不实行一定的政治控制和政治压制的话，政治的非多元化和封闭性就会被打破掉，上面提及的第一个特征——即政治上的非多元化——就会出现问题。</li>
<li>第四个特征是意识形态控制和政治动员程度总体偏低，这也是威权政体不同于极权政体的一个重要方面。</li>
<li>第五个特征是政治领导权的更迭规则完全不同于民主政体。如果是君主制的话，政治领导权的更迭规则是清晰的，子承父业或兄弟相承是主要方式。还有一些威权政体，政治领导权的更迭遵循元老政治模式。比如，由上一任领导人来指定下一任领导人，或由一个规模非常小的封闭精英团体来决定下一任领导人。还有一些威权政体则经常借助暴力方式来完成政治领导人的更迭。一个将军去世后，会有第二个将军依靠武力优势脱颖而出，成为新的领导人。甚至当前一任领导人尚健在的时候，新崛起的将军会通过军事政变来取代他。所以，这种政治领导权更迭规则带有明显的暴力色彩。而民主政体下政治领导权的更迭通常是通过公开的政治竞争完成的。</li>
</ol>
</blockquote>
<h4 id="5-2-3-威权政体存在的问题"><a href="#5-2-3-威权政体存在的问题" class="headerlink" title="5.2.3 威权政体存在的问题"></a>5.2.3 威权政体存在的问题</h4><blockquote>
<ol>
<li><p>首先是合法性问题。第二次世界大战以后，全球的政治意识形态为民主价值观所支配。反过来，不民主在意识形态上被认定为坏的。所以，在观念上，民主政体要优于非民主政体。一旦国际主流社会接受民主价值观，威权政体或多或少都会面临合法性的严峻挑战。威权政体始终不能解决程序合法性的问题。</p>
<p>有人说，威权政体通过改善经济绩效可以增强自己的合法性。这种说法不无道理，但威权政体同时还面临着“发展悖论”。一方面，优质威权政体一旦推动发展，更加现代化的经济、教育与观念往往会引发更多的民众抗争，从而构成对原有体制的挑战；另一方面，如果没有发展，劣质威权政体会由于经济停滞、社会不公和治理不善而激起严重的怨愤心理，从而在另一个方向上引发抗争。所以，合法性始终是威权政体的“阿喀琉斯之踵”</p>
</li>
<li><p>威权政体在国家治理问题上的挑战。一方面，威权政体的治理方式通常是自上而下的。这种治理方式天然地会导致严重的委托代理问题。在委托代理关系中，如果是一层委托代理关系，委托人通常都能有效地监督代理人。但是，如果是多层委托代理关系，对有效治理的挑战就非常大。总的来说，委托代理关系链条越长，在链条终端的最后一级代理人能实现最初委托人意图的可能性就越低。</p>
<p>另一方面，威权政体的治理挑战还来自于信息问题。印度经济学家阿玛蒂亚·森在《贫困与饥荒》中认为，在自由民主国家，因为新闻自由，从来没有发生过大规模的饥荒致死案例。[132]他认为主要机制在于：自由民主国家若发生非常小规模的饥荒，媒体就会报道，全国就会知晓，然后应急机制就会启动。但是，在威权政体下，最大的风险是所有这些不同层级的政府与部门都可能会封闭和阻塞信息。中央政府封锁信息的原因在于担心听到批评的声音，包括防止批评者借此挑战其合法性。地方政府封锁信息的原因在于主要地方官员担心自己的乌纱帽。如果地方官员统辖下的地区出现负面消息，并为更高级别的上级政府所知，上级政府不排除会启动对该地主要官员的惩戒程序。所以，威权政体下封锁消息是可以理解的。</p>
</li>
<li><p>第三个重要问题是威权国家的稳定性很多时候取决于政治领导人这一偶然因素。由于威权政体产生或选择政治领导人的机制不是开放的，所以选择领导人方面的风险就尤其大。而一旦成为政治领导人，由于没有充分的权力制约，他既有可能行为端正、治国有方，又有可能不知节制、为所欲为。与民主政体不同的是，如果威权政体遭遇一位较为逊色、甚至极其糟糕的政治领导人时，内部可能缺乏有效的矫正机制。这就使得单个政治领导人与政体稳定之间的关联性会被大幅放大。</p>
</li>
</ol>
</blockquote>
<h3 id="5-3-极权主义政体"><a href="#5-3-极权主义政体" class="headerlink" title="5.3 极权主义政体"></a>5.3 极权主义政体</h3><p>汉娜·阿伦特</p>
<blockquote>
<p>极权主义政体是另一种政体类型，是指国家试图“完全”控制国民和社会的一种政治体系。当然，这里的“完全”需要打引号，世界上没有哪一种政体国家能真正做到完全控制国民和社会，但极权主义试图这样做。</p>
<p>极权主义基本特征，卡尔·弗里德里希和兹比格纽·布热津斯基认为，极权主义包括了六个基本特征：一个包罗万象的意识形态；单一政党；有组织的恐怖；传媒垄断；武器垄断；经济管制。</p>
</blockquote>
<h2 id="Ch-6-政府结构与政治制度"><a href="#Ch-6-政府结构与政治制度" class="headerlink" title="Ch 6 政府结构与政治制度"></a>Ch 6 政府结构与政治制度</h2><h3 id="6-1-政府机构"><a href="#6-1-政府机构" class="headerlink" title="6.1 政府机构"></a>6.1 政府机构</h3><h4 id="6-1-1-政府机构的定义"><a href="#6-1-1-政府机构的定义" class="headerlink" title="6.1.1 政府机构的定义"></a>6.1.1 政府机构的定义</h4><blockquote>
<p>一个国家政治生活的重要方面就是政府机构的设置，政府机构设置还对应着一整套政治制度的安排。一国政府机构设置的不同意味着该国政治制度安排的不同。政治学还关心政府机构和政治制度安排的不同会造成何种不同的政治效应？这是一个重要问题。</p>
<p>从概念上说，政府是制定和实施公共决策与政策的机构，政府履行着国家的基本职能。大家还经常提到政府机构，比如上海市卫生局。大家一般不说上海市卫生局是一个政府，而说是一个政府机构。政府正是由很多不同类型和层级的政府机构组成的。从政府机构类型来说，可以从两个维度进行分类：一个是职能维度，一个是层级维度。</p>
</blockquote>
<h4 id="6-1-2-政府机构的分类"><a href="#6-1-2-政府机构的分类" class="headerlink" title="6.1.2 政府机构的分类"></a>6.1.2 政府机构的分类</h4><blockquote>
<p>从职能维度来说，政府机构主要有三类：行政机构、立法机构和司法机构，其中行政机构的规模通常是最大的。凡是有国家和政府的地方，必定存在行政机构，而后面两种机构——功能分离且相对独立的立法机构和司法机构——的产生则是特定环境下政治演进的产物。</p>
<p>一是行政机构。行政机构是政府的核心。一个政府可以没有立法机构、可以没有司法机构，但是一个政府必须要有行政机构。行政机关通常被视为是政府的核心，是具体制定和实施公共政策的部门。对行政机构来说，除了个别国家的最高行政长官职位实行委员会制度以外，绝大多数国家都拥有单一最高行政长官。这个最高行政长官的头衔通常是总统、总理、首相或主席。在行政机构内部，通常都有严格的上下级等级关系。</p>
<p>二是立法机构。立法机构一般称为国会、议会、国民大会或代表大会，或直接叫立法机构。立法机构是指审议和批准法律及公共决策的机构，它是一个由较多成员组成的代议机构。与行政机构不同的是，立法机构内部的所有成员通常都是平等的。所以，立法机关内部不像总统或总理领导的政府内部有等级森严的上下级关系，所有议员或代表之间是更平等的关系。</p>
<p>三是司法机构。司法机构是指维护法律、确保法律执行以及解决法律争议的政府机构。司法机构通常由不同层级的法院构成，法院的主要工作人员是法官。如果一国的法治程度较高，法官应该是不存在上下级等级关系的独立工作人员。</p>
<p>另一个方面是政府机构不同层级的划分。对于规模较大的国家，通常会有几级政府机构来管理。最高层级的政府机构被称为中央政府，有些联邦制国家称为联邦政府。第二层级的政府机构是次国家（sub-national）层次的政府机构，最常见的名称是省政府、州政府或邦政府。此外，如果国家比较大的话，省、州或邦之下还会有第三层级的地方政府。</p>
</blockquote>
<h3 id="6-2-政治系统与官僚系统"><a href="#6-2-政治系统与官僚系统" class="headerlink" title="6.2 政治系统与官僚系统"></a>6.2 政治系统与官僚系统</h3><blockquote>
<p>关于政府机构，要区分具有较强政治色彩的狭义的政治系统和负责具体行政事务的行政系统或官僚系统。通常，政治系统和官僚系统的差异是明显的。美国政治学者弗兰克·古德诺在《政治与行政》一书中说：“政治是国家意志的表达，行政是国家意志的执行。”政治系统与官僚系统的差异，可以参见表6.1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202310092021582.png" alt="image-20231009202151667"></p>
</blockquote>
<h4 id="6-2-1-政治系统与官僚系统的区别"><a href="#6-2-1-政治系统与官僚系统的区别" class="headerlink" title="6.2.1 政治系统与官僚系统的区别"></a>6.2.1 政治系统与官僚系统的区别</h4><blockquote>
<p>从定位来说，政治系统更多是跟政治权力获取有关的。比如，两个人竞争一个地方议员的席位，是一个政治过程。而官僚系统更多是跟公共政策执行有关的。比如，卫生局开会商讨如何应对禽流感疫情，这里更多是政治权力如何执行、具体公共事务如何管理的问题。</p>
<p>从身份来说，在政治系统中工作的核心人员通常被称为政治家或政务官。在美国，这是随着选举结果的不同而更迭的那一部分人，在联邦层面包括总统、联邦参议员、联邦众议员以及美国总统任命的包括国务卿、财政部长、驻外大使等在内的一大批高级官员。在官僚系统里工作的人员通常被称为公务员、官僚或事务官。英国的文官系统用政务官和事务官来区分上述两种身份角色。</p>
<p>从录用方式来说，两者也是不同的。民主政体下的政治家职位或政务官的产生主要有两种方式：一种是选举的方式；另一种是经由选举产生的主要行政官来任命，亦政治任命，比如总统任命国务卿、部长或驻外大使。官僚系统的公务员与事务官的录用一般是考试和升迁的办法。</p>
<p>从主要规则来说，政治系统强调的是回应性。政治家要对选民具有回应性。回应性对应的是问责制，问责制的直接表现是：如果选民们觉得某个政治家干得不好，这个政治家通常会输掉下一轮选举。</p>
<p>官僚系统更多强调服从和科层制原则。上面怎么决定，下面就应该怎么执行，这是服从原则。按照德国著名社会学家马克斯·韦伯的论述，官僚制具有如下基本特征：第一，一个正式的等级制结构。每个等级控制其下的等级并为其上的等级所控制。一个正式的等级制是中央规划与集中化决策的基础。第二，用规则来管理。经由规则控制的系统使得高层决策能够被较低层级保持一致地执行。下级的基本职责就是服从上级的命令并执行上级的决策。第三，功能专业化的组织。任务由专家来完成，所有人都基于他们任务的类型或专长技能进行分类组织。第四，两种使命类型：关注上面或者关注内部。前者的使命是服务于股东、董事会或上级授权机构，后者的使命是服务于该组织本身。第五，非人格化。对所有雇员与客户一视同仁，而不会受到个人差异的影响。第六，雇佣基于专业能力。这意味着雇佣不是基于人的天然身份或人际关系，而是专业能力。</p>
</blockquote>
<h4 id="6-2-2-政治系统与官僚系统的联系"><a href="#6-2-2-政治系统与官僚系统的联系" class="headerlink" title="6.2.2 政治系统与官僚系统的联系"></a>6.2.2 政治系统与官僚系统的联系</h4><blockquote>
<p>政治系统要有效，很大程度上依赖官僚系统的有效性。在政治过程中，实际做事的是官僚机构，政治家把握的是方向和目标，政治家的意图要依赖官僚系统去贯彻和执行。如果官僚系统有效性很低，就会导致整个政治系统出现问题，整个国家的治理绩效就不会太好。另一方面，官僚系统则依赖于政治系统的指导。事务官只能到副部长这一级，政策方向与目标应该是部长、内阁及政府首脑来把握的。当然，在一些特殊领域，两者的关系更为复杂。如果某个领域的专业性程度非常高，政治家可能不得不更多地依赖专业官僚给出建议。比如，对美国来说，当年面对伊拉克或阿富汗的局势，究竟是否要采取军事行动？这里既有政治决策，又要听取美国军方的建议和意见。所以，一般来说，官僚系统依赖于政治系统的指导，但有时因为专业性的原因，官僚系统也可能会影响政治系统的决策。</p>
</blockquote>
<h3 id="6-3-民主国家的政治制度"><a href="#6-3-民主国家的政治制度" class="headerlink" title="6.3 民主国家的政治制度"></a>6.3 民主国家的政治制度</h3><blockquote>
<p>对一个国家来说，有四个主要层次的政治制度。</p>
<ol>
<li>第一，是政府形式。对民主国家来说，狭义的政府形式通常是指议会制、总统制与半总统制。</li>
<li>第二，选举制度。民主政体的主要选举制度包括多数决定制、比例代表制与混合制等。</li>
<li>第三，政党体制。民主政体的政党体制主要包括两党制与多党制，也包括一党独大制，多党制还可以区分为温和多党制与极化多党制。政党体制对整个政治生活的影响通常是重大的。</li>
<li>第四，央地关系。两种常见的制度安排是联邦制和单一制，当然还有两者之间的混合形式。与联邦制和单一制这样的制度标签相比，更重要的是中央与地方之间实际的分权安排。</li>
</ol>
</blockquote>
<h4 id="6-3-1-政府形式"><a href="#6-3-1-政府形式" class="headerlink" title="6.3.1 政府形式"></a>6.3.1 政府形式</h4><blockquote>
<ol>
<li><p>[美国]在总统制条件下，选民选举立法机构，即一院制或两院制国会；同时选举总统，民选总统选择与任命内阁部长并领导内阁管理政府部门。总统制的主要特征是：第一，行政机关和立法机关均由民选产生，民选总统是政府首脑。第二，总统任期与国会任期固定，彼此互不统属，互相均不能推翻对方。第三，总统任命与指导内阁，并具有宪法承认的部分立法权。</p>
<blockquote>
<p>美国是典型的总统制国家。民选总统任命内阁成员并领导政府，内阁部长是由总统任命的。美国总统拥有强大的行政权，但实际上又处处受到国会的制约。美国总统在预算、重要人事任命、法案及重要决策上都需要跟国会协商，需要经过国会的批准与同意。总统和议会任期固定，并且互相均不能推翻对方以垄断全部的权力。从制度上说，总统和议会都有固定任期，而且行政部门和立法机构成员之间不能互相重叠。因此，总统制是非常典型的立法权和行政权分立的制度，再加上政治上具有很强独立性的法院与司法权，美国是典型的三权分立制度。</p>
<p>美国国会实行两院制，拥有立法权，有权批准美国政府的预算、部长人选及法案。众议院由美国选民选举产生，任期两年，各州议员数量按照人口比例确定，共435人；参议员由美国各州议会选举产生，任期为6年，每两年改选1/3左右，每州2个席位，共100人。一般认为，美国参议院代表的是各州，众议院代表的是美国人民。在总统与国会的权力关系上，没有一方能够支配另一方。在批准财政预算、重大人事任免和立法方面，美国国会的权力是非常大的。</p>
</blockquote>
</li>
<li><p>[英国]议会制下，选民选举议员组成一院制或两院制立法机构，然后由立法机构（通常是下院或众议院）选举或任免首相及内阁。纯粹的议会制的主要特征是：第一，立法机关由民选产生。第二，由首相（或总理）与内阁成员构成的行政机关来自于立法机关。第三，立法机关多数通过“不信任投票”可以罢免行政机关。</p>
<blockquote>
<p>英国是典型的议会制模式。下议院掌握主要的政治权力，赢得下议院选举多数席位的政党组成政府，党魁一般出任首相，并挑选20多名议会同僚组成内阁。内阁来源于国会，内阁部长通常仍然是立法机构成员。与总统制不同，内阁是通常同僚合作型的。在内阁制下，首相或者总理通常是所有平等内阁成员中的第一个（first among equals）。换句话说，英国首相和美国总统的不同在于，英国首相某种程度上算不上是内阁部长们的老板。<strong>英国内阁成员之间更多的是一种合作关系，而首相只是其中为首的一个。</strong>在议会制下，首相和内阁需要对议会负责，议会多数的不信任票可以解散内阁。</p>
</blockquote>
</li>
<li><p>[法国]半总统制下，选民同时要选举立法机构和总统，总统任命总理及各部部长，但总统任命总理时必须要得到立法机构半数以上的支持。半总统制的主要特征是：第一，总统与立法机构均由民选产生。第二，总统拥有巨大的宪法权威，可以任免首相（或总理）与内阁。第四，首相（或总理）与内阁必须要得到立法机关多数的信任。</p>
</li>
</ol>
</blockquote>
<p>议会制和总统制孰优孰劣？</p>
<blockquote>
<p>Evaluation Metrics</p>
<p>现代政治学分析不同的政府形式与政治制度通常需要考虑两个维度：一个是分权制衡维度，一个是政府效能维度。实际上，政府形式与政治制度既需要强调分权制衡，又需要注重政府效能。</p>
<p>在这两个维度上，大家熟知的三权分立学说强调的是前者，即分权制衡的因素。有学者把自启蒙运动时代以来洛克、孟德斯鸠及麦迪逊等人强调的这种观点，称为西方政治传统中的分权学说。</p>
<p>但其实，西方政治传统中还有另外一种传统，即强调政府效能的因素。比如，汉密尔顿在《联邦党人文集》的多处都强调政府效能的重要性，以及强有力的联邦政府的必要性。实际上，《联邦党人文集》倡导的是分权制衡和政府效能两者之间的平衡。</p>
<p>英国著名法学家白芝浩在《英国宪法》说</p>
<blockquote>
<p>在一个主要的方面，英国的制度远胜于美国。由议会产生并可由这个立法性机构中占多数席位的党派撤换的英国首相肯定依凭于这个议会。如果他想让立法机构支持他的政策，他就能够得到这种支持，并进而推行他的政策。但美国总统得不到这种保证。总统是某个时候用某种方式产生的，而国会（无论是哪一院）是在另外某个时候用另一种方式产生的。二者之间没有什么东西将其捆绑在一起，且从事实上讲，二者之间不断地产生冲突。</p>
</blockquote>
<p>胡安·林茨重新挑起了议会制与总统制之争。1990年，他先后发表了《总统制的危害》和《议会制的优点》两篇论文。他认为，总统制存在五个严重问题。</p>
<ol>
<li>首要的问题是总统和议会双重合法性的冲突。在总统制下，总统拥有最高的政治权力与合法性，议会也拥有最高的政治权力与合法性。当这两种政治权力不一致的时候，就会产生双重合法性的冲突。</li>
<li>其次的重要缺陷是总统的固定任期，这种固定任期或可导致政治僵局。总统任期是固定的，通常是四年或五年。由于总统任期固定，而且通常长达四或五年，就容易导致长期的政治僵局。在议会制下，当总理和内阁不能得到议会多数支持时，总理和内阁就只能去职，进行内阁的重新选举，这样行政机关就能进行重新调整。这展示了政治上的灵活性。</li>
<li>第三个问题是总统制下更容易出现“赢家通吃”与“零和博弈”的局面。通常在议会制下，总理或首相的职位及内阁相关职位固然可能是一党主导，但很多时候也是不同政党妥协的产物。在这种制度安排下，不同的政治力量可以分享政治权力。但是，在总统制下，由于总统职位的惟一性以及选举方式的限制，结果往往是一个政治家或一个政党实质性地控制了行政权，这就更容易导致“赢家通吃”。在政治竞争中，关于总统职位的选举则更接近于“零和博弈”。这可能引发更大的政治冲突，更不容易激励政治合作与妥协。</li>
<li>第四个问题是总统制更不容易宽容反对派，这是林茨经验观察的结果。</li>
<li>第五个问题也非常重要，总统制下政治新星快速崛起的可能性更大，这种情况下更容易导致政治不稳定。</li>
</ol>
<p>美国学者约瑟·柴巴布认为，总统制本身意味着权力分立——即立法权与行政权的分立。通常，总统制并没有为形成政治联盟提供有效激励；而且总统制下的政党纪律往往并不严格，也导致政党力量总体上比较弱。当这种情形与多党制相结合时，就容易出现少数派政府。这意味着总统在议会中只拥有不到50%的支持率。少数派政府是一个立法权与行政权分裂的政府，从立法角度看容易成为一个无效的政府。比如，行政机构与立法机构很容易就关键人事任命、重要法案及重大公共政策发生冲突。当总统的提案常常无法在议会通过时，就陷入了某种程度的“僵局”。有人把这种行政权与立法权之间的僵局称为“宪法危机”。如果总统和议会之间的政治僵局或宪法危机长期持续，最后会导致民主政体无法有效运转，甚至就会导致民主政体的崩溃。</p>
</blockquote>
<h4 id="6-3-2-选举制度"><a href="#6-3-2-选举制度" class="headerlink" title="6.3.2 选举制度"></a>6.3.2 选举制度</h4><blockquote>
<p>选举投票是公民政治参与的基本方式。选举，是指选民通过投票来选择自己代表的政治活动。</p>
<p>狭义上的选举制度，是指选票转化为席位（from votes to seats）的方式。广义的选举制度除了把选票转化为席位的方式外，还包括选区规模、当选门槛、议会规模等基本制度安排。</p>
<p>选区规模，不是指一个选区的人口多寡或面积大小，而是指一个选区产生几个议员的名额。如果每个选区只产生一个名额，一般称为小选区制；如果每个选区产生较多名额，一般称为大选区制。</p>
</blockquote>
<p>议会的选举制度</p>
<blockquote>
<p>议会的选举制度主要有三种：</p>
<ol>
<li><p>第一种是多数决定制（plurality system）。多数决定制就是得票最多者当选，又分为两种类型。</p>
<ol>
<li>一种是简单多数决定制，即在所有候选人中得票最多者胜出（first past the post，简称FPTP）。</li>
<li>另一种是绝对多数决定制（majority system），要求当选者至少需要获得50%的选票。当然，存在多个候选人的情况下，第一轮投票可能很难产生获得绝对多数票的候选人，这就需要对得票最多的两名候选人举行第二轮投票。</li>
<li>还有一种具有绝对多数决定制特征的选举制度是选择性投票制（alterna-tive vote），又译偏好投票制。在这种投票制度下，选民投票时被要求给所有候选人排序。比如，选票上有A、B、C、D、E五个候选人，选民需要做的是给五个候选人排序，即区分出1、2、3、4、5的次序。然后，清点选票时需要统计每个候选人得到选民第1、2、3、4、5排序的得票比率。现在假定A获得所有投票第一选项的比率为40%，B获得所有投票第一选项的比率是25%，C获得20%，D获得10%，E获得5%。从结果来看，没有一个候选人得第一选项的选票率超过50%，那怎么办？在这种情况下，需要把第一选项得票比率最低的候选人E划掉，投E第一选项的这部分选票根据他们的第二选项，把选票分别分配给排名靠前的A、B、C、D四人。然后，再重新统计他们四人的选票。以此类推，直到其中一位候选人的得票率达到50%为止。这种选举制度目前主要在澳大利亚众议院选举中采用。<strong>美国政治学者霍洛维茨在研究高度分裂社会的制度设计时认为，这种选举制度有利于塑造跨族群的选举激励。因为在偏好性投票制度下，候选人不仅要谋求自己主要选民群体的支持，而且还要努力成为所有选民群体最不讨厌的那位候选人。</strong> </li>
</ol>
</li>
<li><p>第二种是比例代表制（proportional representation）。比例代表制的基本原则是要尽可能让代表的结构更好地反映整个社会选民的结构。比例代表制最流行的投票方法是政党名单比例代表制。</p>
<p>在比例代表制中，选区规模也是一个重要因素。总的来说，选区规模越大，比例性就越高；选区规模越小，比例性就越低。如果一个选区的席位数量由10个变为20个，更多政党就有机会当选。如果一个选区的席位数量由10个变为5个，通常只有较大政党才有机会当选，小党当选可能性会降低。</p>
</li>
<li><p>第三种是混合型选举制度，也就是把多数决定制与比例代表制结合起来。目前有大量国家采用混合型选举制度，其目标是结合多数决定制与比例代表制的优点。比如，德国国会选举中，一半议席由简单多数决定制产生——全国划为240个选区，每个选区只产生一个名额；一半议席由政党名单比例代表制产生，总共也是240个议席，全国为一个大选区，当选政党须达到总选票数量5%的当选门槛。目前，日本、泰国等大量国家都采用这种混合型选举制度。</p>
</li>
</ol>
<p>一种主流的观点认为，选举制度之所以重要，是因为选举制度直接影响政党体制的类型。法国政治学家莫里斯·迪韦尔热在其早期研究中提出了一项选举制度影响政党体制的定律，学界称之为“迪韦尔热定律”（Duverger’s Law）。后来，迪韦尔热本人将其表述为：（1）比例代表制倾向于导致形成多个独立的政党……（2）两轮绝对多数决定制倾向于导致形成多个彼此存在政治联盟关系的政党；（3）简单多数决定制倾向于导致两个政党的体制。</p>
</blockquote>
<h4 id="6-3-3-政党制度"><a href="#6-3-3-政党制度" class="headerlink" title="6.3.3 政党制度"></a>6.3.3 政党制度</h4><blockquote>
<p>学术界一般认为，政党是一个有政治愿景的、以执政为政治目标的政治组织，政党旨在通过选举或其他手段来控制政府的人事与政策。</p>
</blockquote>
<p>政党的功能</p>
<blockquote>
<ol>
<li>首先，政党有代表的功能，即代表了部分选民的意志和利益。通常，左派政党代表的是下层阶级的利益，右派政党代表的是上层阶级的利益，宗教政党代表的是特定宗教群体的利益，族群政党代表的是特定族群的利益，“绿党”代表的则是环境保护主义者的利益诉求。</li>
<li>其次，政党还有培养和录用精英的功能。</li>
<li>此外，政党有利益表达和整合的功能。社会利益非常多元化，当这些利益诉求方向不一、甚至互相冲突时，该怎么办？政党此时可以扮演利益整合者的角色。</li>
<li>再者，政党具有政治社会化和政治动员的功能。很多消极选民，正是由于政党的政治动员——包括通过宣传、组织、运动等多种方式——被卷入到政治过程中了。当政党发挥作用时，往往可以提高一个社会政治社会化的程度。</li>
<li>最后，政党还具有组建政府的功能。</li>
</ol>
</blockquote>
<p>政党的分类</p>
<blockquote>
<p>现代政党通常可以区分为不同的类型。一种分类是把政党划分为干部型政党和群众型政党，</p>
<ol>
<li>在现代政治中，群众性政党往往是因为选举才临时组织到一起的，选举一结束就各自走散了。</li>
<li>相比之下，干部型政党有较为严密的组织，有较为严格的纪律，有相对完善的内部管理。从理论上讲，干部型政党应该是一个更有凝聚力的政党，具有更强的组织能力。此外，干部型政党通常有比较严格的入党手续。</li>
</ol>
<p>另一种分类是把政党划分为宪政型政党和革命型政党。</p>
<ol>
<li>宪政型政党在现有基本政治框架内提出政治主张和诉求。</li>
<li>革命型政党旨在颠覆现有的基本政治秩序。</li>
</ol>
</blockquote>
<p>政党体制的分类</p>
<blockquote>
<p>政党体制或政党制度是指一个国家中政党的数量及其权力结构。美国政治学者乔万尼·萨托利在1976年政党学名著《政党与政党体制》中区分了两大类型的政党体制：一种是非竞争性政党体制，一种是竞争性政党体制。</p>
<ol>
<li><p>非竞争性政党体制是指政党之间不存在实质性的政治竞争关系，而某一主导政党居于支配性地位。非竞争性政党体制有两种类型：一党制和霸权党制。一党制是该国只有一个基于统治和支配地位的政党，不存在任何其他政党。霸权党制是该国存在多个政党，但有一个主要政党基于统治和支配地位；其他政党并非民主政体意义上的政党，这些政党可能也参与政治竞争，但该霸权政党控制着全部的或绝大部分的政治权力。</p>
</li>
<li><p>竞争性政党体制，是指不同政党之间存在实质性竞争关系的政党体制类型。萨托利认为，根据竞争性政党数量的多少，竞争性政党体制有几种主要类型。第一种是主导党体制（或竞争性的一党独大制）。一些国家的历史上曾出现过主导党体制，比如日本从1955年到1993年间自民党的主导党体制，其选举是自由而公正的，政党之间是竞争性的，但自民党始终控制议会的多数席位。第二种是两党制。过去的英国和现在的美国都是典型的两党制。两党制不是说只有两个政党，而是说两大主要政党能够赢得绝大多数选票和席位。第三种是温和多党制。温和多党制下，议会通常有三到五个重要政党，现在的法国和德国基本上符合这种类型。第四种是极化多党制。这是指议会中重要政党有六到八个以上。德国魏玛共和国时代的政党制度符合极化多党制的类型。第五种是碎片化政党体制。从名称来看就知道这种政党体制的数量和结构比极化多党制更加碎片化，通常包括了10或20个以上的政党。</p>
<blockquote>
<p>在论述诸种竞争性政党体制时，萨托利认为极化多党制不利于民主政体的稳定，原因在于极化多党制具有很多不利于民主有效运转的基本特征：1.反体制政党的出现；2.双边反对党的存在；3.中央存在一个（意大利）或一组（法国、德国魏玛共和国）政党为特征；4.政治的极化体制；5.离心型驱动力对向心型驱动力可能的超越；6.存在固有的意识形态型式（ideological patterning）；7.不负责任的反对党的出现；8.抬价政治（out-bidding）或过度承诺的政治。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h4 id="6-3-4-央地关系"><a href="#6-3-4-央地关系" class="headerlink" title="6.3.4 央地关系"></a>6.3.4 央地关系</h4><blockquote>
<p>对大型现代国家而言，央地关系上有两条通行的基本原则。一方面，必须实行某种程度的中央集权，以保证国家统一；另一方面，必须实行某种程度的地方分权，以保证治理的有效性与灵活性。所以，任何一个大型政治体基本上不存在不要集权或不要分权的问题，而一定是集权和分权的某种组合。</p>
<p>由于中央集权与地方分权组合模式的不同，世界上多数国家的央地关系可以区分为两种类型：联邦制和单一制。</p>
<ol>
<li>一般来说，联邦制指主权或主要政治权力由联邦政府与州或邦政府共同分享的一种央地关系模式，联邦政府和州或邦政府同时从宪法与人民的授权中获得政治权力。在这种模式下，州或邦政府的政治权力不是来自中央政府的授予，而是独立地来自于宪法与人民的授权，邦或州政府不是联邦政府的下级或下属单位。</li>
<li>单一制指主权或主要政治权力掌握在中央政府手里，州或省政府的政治权力来自于中央政府的授予。这种模式下，地方政府实际上相当于中央政府的派出机构，是中央政府的下级或下属单位。在单一制国家法国，各个地方的政治权力主要来自于法国中央政府的授予。</li>
</ol>
</blockquote>
<h2 id="Ch-7-宪法、宪政与法治"><a href="#Ch-7-宪法、宪政与法治" class="headerlink" title="Ch 7 宪法、宪政与法治"></a>Ch 7 宪法、宪政与法治</h2><h3 id="7-1-宪法"><a href="#7-1-宪法" class="headerlink" title="7.1 宪法"></a>7.1 宪法</h3><blockquote>
<p>宪法是一个国家的基本大法，它规定了国家正式的政治制度结构，明确了个人所享有的权利与自由。宪法的两个主要内容，一是跟国家的正式政治制度结构有关的，二是跟公民自由和基本权利有关的。从类型上讲，宪法可以分为两种：一种是成文宪法，一种是不成文宪法。</p>
<p>多数成文宪法均有四个部分构成：第一部分是宪法的序言，往往近似一个煽情的宣言，强调这部宪法和现行政府的合法性；第二部分对政治系统和制度安排的规定，设立哪些不同形式的政府机构，确立它们彼此间的政治关系等；第三部分是权利法案，即保护公民个人权利与自由的条款，可能还包括对救济机制的说明；最后一部分会涉及修改宪法的规则与程序等，通常修改宪法要比一般立法更为严格。</p>
</blockquote>
<p>宪法的作用</p>
<blockquote>
<ol>
<li>宪法的第一种功能是确立合法性。自启蒙运动以来，公民们的政治意识开始觉醒。在人类历史上，君主的统治总的来说是一件自然而然的事情。但是，近代启蒙运动以来，统治不再是一件自然而然的事情。这种统治要基于一套说法：为什么有人可以统治，为什么其他人需要服从？总之，如今的统治需要有一套言之成理的说法，而宪法正是提供了这样一套说法，其首要功能是确立政府合法性和赋予政治权力。</li>
<li>宪法的第二个功能是确立基本的政治制度结构。</li>
<li>宪法的第三个功能是明确公民的自由与权利。绝大多数国家的宪法或宪法性法律文件中都会说明，国家应该保护和尊重公民的生命权、财产权与自由权，还有不少宪法规定了需要保护公民的受教育权、工作权与基本保障权。</li>
<li>宪法的第四个功能是限制政府活动和政治权力。符合宪政原则的宪法通常还规定，什么事情是政府不能做的。比如，美国宪法的第一条修正案就明确规定：“国会不得制定关于下列事项的法律：确立国教或禁止宗教活动自由；限制言论自由或出版自由；或剥夺人民和平集会和向政府请愿申冤的权利。”</li>
<li>宪法的第五个功能是提供关键政治争端的解决方法。</li>
</ol>
</blockquote>
<h3 id="7-2-立宪主义-宪政"><a href="#7-2-立宪主义-宪政" class="headerlink" title="7.2 立宪主义/宪政"></a>7.2 立宪主义/宪政</h3><h4 id="7-2-1-立宪主义"><a href="#7-2-1-立宪主义" class="headerlink" title="7.2.1 立宪主义"></a>7.2.1 立宪主义</h4><blockquote>
<p>宪政，又译立宪主义。宪政是国内法学界和政治学界热烈争论的一个概念。宪政一般是指基于宪法与法律来实施统治，或者说是国家的强制性权力受到宪法与法律普遍约束的观念和制度。理解宪政，主要可以从三个方面入手：</p>
<ol>
<li>第一，宪法与法律限制政府活动和政治权力的范围。这与有限政府原则是一致的。换句话说，政府不是什么事情都能做，宪法和法律允许政府做的事情是有限的，政府只能在这一限定范围内活动，而不是想做什么就做什么。西方启蒙运动以来的政治哲学传统把国家视为一种“必要的恶”，意思是国家当然是必不可少的，但国家又可能对这个社会带来侵害，因为政治权力可能会肆无忌惮地扩张。所以，国家与政治权力应该受到强有力的约束。按照这一原则，如果政府活动范围是无限的，政治权力没有受到制约，这样的国家就不符合宪政原则。有人说，宪政就是“限政”，这个说法不那么完整，但总体上是恰当的——宪政包含着限制政府或限制政治权力的意思。</li>
<li>第二，宪法与法律应明确及保障公民平等的自由和权利。宪政意味着每个公民的自由与权利受到明确的保护。</li>
<li>第三，宪法与法律创造政府越权时给予救济的手段。如果政府做了违反宪法与法律的事情，又该怎么办？如果个人的自由和权利遭到政府的侵害，又该怎么办？这时，宪法与法律应该要创造一种政府越权时给予救济的手段。</li>
</ol>
</blockquote>
<h4 id="7-2-2-法治与法制"><a href="#7-2-2-法治与法制" class="headerlink" title="7.2.2  法治与法制"></a>7.2.2  法治与法制</h4><blockquote>
<p>与宪政密切相关是法律和法治的概念。法律是指一整套运用于政治共同体的公开的、具有强制力的规则，或者说是具有强制约束力的规则。在国内，法治的概念则容易跟法制的概念相混淆。国内学界的一般看法是，法治对应的是“rule of law”，法制对应的是“rule by law”。法治是指法律的统治，而法制则是用法律统治。对于前者，法律具有至高无上的地位；而对于后者，法律不过是一种统治或治理的工具。就后者而言，如果法律只是一种统治或治理的工具，这意味着法律本身并没有超越政治权力。</p>
<p>柯克爵士提到的“国王在万人之上，但却在上帝和法律之下”这句名言早在13世纪就出自另一位英格兰大法官亨利·布拉克顿之口。所以，这种传统把法治视为“法律的统治”，而不是说法律是“统治的工具”。</p>
</blockquote>
<h3 id="7-3-宪政的实施：司法审查"><a href="#7-3-宪政的实施：司法审查" class="headerlink" title="7.3 宪政的实施：司法审查"></a>7.3 宪政的实施：司法审查</h3><h4 id="7-3-1-司法审查简介"><a href="#7-3-1-司法审查简介" class="headerlink" title="7.3.1 司法审查简介"></a>7.3.1 司法审查简介</h4><blockquote>
<p>宪法与宪政是两回事。如果宪法不被执行的话，它只不过是几张纸而已。那么，有没有什么办法能够让宪法真正起作用呢？由于宪法既不能自我制定、又不能自我实施，所以宪法必须依赖于机构和人才能起作用。在一些发达国家，<strong>实践宪政的一个重要方面就是司法审查或违宪审查制度。</strong>司法审查一般是指最高法院或宪法法院对行政机构或立法机构的法律与决定进行合宪性审查的机制。换句话说，如果议会通过的立法或政府作出的决定违反宪法的话，最高法院或宪法法院可以判决此类立法或决定违宪，从而宣布取缔这样的法律或决定。</p>
<p>司法审查或违宪审查通常涉及三项内容：</p>
<ol>
<li>一是裁决具体的法律或决定是否符合宪法；</li>
<li>二是解决国家和公民关于基本自由权的冲突；</li>
<li>三是解决不同政府机构或不同层级政府之间的冲突。</li>
</ol>
<p>那么，由何种机构来实施司法审查或违宪审查呢？全球范围内主要是两种制度安排：</p>
<ol>
<li>一个是像美国那样由联邦法院即最高法院来负责实施，</li>
<li>一个是像德国那样由专门的宪法法院来负责实施。</li>
</ol>
</blockquote>
<h4 id="7-3-2-司法审查的重要性"><a href="#7-3-2-司法审查的重要性" class="headerlink" title="7.3.2 司法审查的重要性"></a>7.3.2 司法审查的重要性</h4><blockquote>
<p>司法审查的重要性，还在于它可以解决国家和公民关于基本自由权的冲突。</p>
<p>联邦法院最后的判决是所有餐馆以及所有的私人和公共机构必须无差别地对所有公民开放，无论他的肤色是什么，否则就是违宪。后来，借助立法，这一准则又成为美国基本的法律原则。在这一案例中，大家看到了司法权的强大力量，而且这种司法权的影响甚至超越了民主的多数规则。比如，如果要就这个事情进行全民投票，结果则可能完全不同。如果黑人人口比例只有15%，其他有色人种人口比例只有5%，而白人人口比例占80%的话，全民投票更有可能反对联邦法院的判决，而非支持这一判决。实际上，与上面假想的这一案例相似的事件大致在美国历史上就发生过，当然细节的差异是很大的。</p>
</blockquote>
<p><strong>司法审查可以保证宪法的执行，使国家转为宪政，而宪政可以解决“多数人的暴政”。即宪法规定公民的基本权利，通过司法审查保证宪法的实施，以防止多数人侵犯少数人的人权。</strong></p>
<blockquote>
<p>司法审查还可以解决不同政府机构或不同层级政府之间的冲突。政治不成熟的国家，出现关键争端以后通常需要用武力来解决，而政治成熟的国家可以借助政治或法律手段来解决。违宪审查通过司法判决，解决了不同层级政府之间的冲突，从而增进了民主政体的稳定性。</p>
</blockquote>
<h4 id="7-3-3-宪法-宪政面临的问题"><a href="#7-3-3-宪法-宪政面临的问题" class="headerlink" title="7.3.3 宪法/宪政面临的问题"></a>7.3.3 宪法/宪政面临的问题</h4><blockquote>
<ol>
<li><p>灵活性低</p>
<blockquote>
<p>由此可见，现代国家的宪政观念是指通过宪法和法律约束政府与政治权力。这样，宪政的一边是宪法和法律，另一边是政府和政治权力。但问题是，在政治实践中，宪法和法律可能是死的，政府和政治权力是活的。如果是这样，宪法和法律如何能限制住政府和政治权力呢？这实在是一个非常困难的事情。</p>
<p>再次，是宪法本身的挑战，即宪法有没有适应变化的能力。有些宪法由于制度设计的问题，本身存在重大缺陷。这种缺陷主要表现在两个方面：一是宪法条款由于设计不当而导致政治僵局；二是宪法条款本身弹性较低，不能适应快速变化的政治局势。这种情况下，宪法也难以运转起来。</p>
</blockquote>
</li>
<li><p>宪法的执行与宪法约束的对象相同，容易导致宪法成为一纸空文。</p>
<blockquote>
<p>另一个悖论是，谁是宪法或法律的捍卫者和执行者呢？一个通常的回答是政府（广义的政府）。那么，问题就来了，一方面政府是法律的执行者，另一方面却又要用法律来约束政府，这又如何可能呢？因此，对很多国家来说，实践宪政并非易事。</p>
<p>戈登认为，宪政在政治实践中表现为政治权力分立与制衡的原则，就像美国那样，实现立法权、行政权和司法权的分立并使之互相制衡。他还认为，宪政原则包含着对抗性的元素，即政治权力内部的对抗性。<strong>如果有一个最高权力能统辖其他所有的权力，就不符合宪政原则。按照戈登的观点，权力分立与制衡是宪政的核心。</strong></p>
</blockquote>
</li>
</ol>
</blockquote>
<h2 id="Ch-9-政治参与"><a href="#Ch-9-政治参与" class="headerlink" title="Ch 9 政治参与"></a>Ch 9 政治参与</h2><h3 id="9-1-非暴力不合作"><a href="#9-1-非暴力不合作" class="headerlink" title="9.1 非暴力不合作"></a>9.1 非暴力不合作</h3><blockquote>
<p>社会运动是政治参与的一种重要形式。除了选举投票，社会运动是很多普通公民卷入过的最重要的政治活动。社会运动一般是指一种特定形式的集体行动或集体行为，其动机主要来源于成员的态度和期望，通常有松散的组织框架，具有明确的诉求。社会运动一般被视为社会抗争的一种表现形式。</p>
</blockquote>
<h4 id="9-1-1-理论来源"><a href="#9-1-1-理论来源" class="headerlink" title="9.1.1 理论来源"></a>9.1.1 理论来源</h4><blockquote>
<p>非暴力不合作运动的思想可以追溯至美国哲学家亨利·大卫·梭罗，他在早期的哲思作品中阐述了“公民不服从”（civil disobedience）思想。按照梭罗的见解，一个人的行事准则不在于服从政府或者法律，而在于服从自己的良心。他说：“我有权承担的惟一义务，乃是不论何时，都做我认为正当的事情。”由此，梭罗认为，当一个人认为政府不义时，便拥有反对的权利。每个人都承认革命的权利；这便是说，当政府沦于暴政，或它效力极低、无法忍受，就有权拒绝向其效忠，且有权对其反抗。”沿着这样的逻辑，梭罗接着问：“不公正的法律依然存在：我们是甘心服从这法律，还是致力于修正之，在达到目的之后才来服从，甚或立即破坏了它？”他在很大程度上倾向于最后一种立场，即每个人都有权破坏他良心上认为不公正的法律。</p>
</blockquote>
<h4 id="9-1-2-甘地"><a href="#9-1-2-甘地" class="headerlink" title="9.1.2 甘地"></a>9.1.2 甘地</h4><blockquote>
<p>非暴力不合作运动的最伟大实践者是印度政治家甘地。非暴力不合作”这个词组本身已经昭示了甘地的核心观点。在甘地看来，对英国统治者，印度作为一个民族的惟一正确做法是两者的结合：一是彻底的不合作，二是彻底的非暴力。从具体政策来说，甘地呼吁以非暴力的不合作手段来抵制英国殖民者的统治。他呼吁印度人不纳税、不入公立学校、不到法庭、不承担公职以及不购买英货，等等。有人认为非暴力不合作运动之所以能够奏效，乃是因为英国政府尽管是外来的却是较为文明的统治者。</p>
</blockquote>
<h4 id="9-1-2-马丁·路德·金"><a href="#9-1-2-马丁·路德·金" class="headerlink" title="9.1.2 马丁·路德·金"></a>9.1.2 马丁·路德·金</h4><blockquote>
<p>美国黑人民权运动也是试图经由非暴力的抗议活动来达成他们的政治目标，这也是马丁·路德·金的政治主张。他认为：“任何非暴力运动，都要包括四个阶段：收集事实，以判定不公正是否存在；谈判；自我净化；以及直接行动。”他还以伯明翰社区为例，说明了非暴力运动的四个阶段。首先是，通过显而易见的事实判断该社区存在显著的种族不公正。随后，他们努力与本社区的头面人物们展开谈判，但收效甚微。他们在自己的希望遭到沉重打击、决定采取直接行动之前，还要先进行一个自我净化的过程。他们不断自问：“我是否能挨打而不还手？”“我能否忍受监狱的考验？”在这一切准备就绪后，他们开始采取直接行动，而直接行动的目标是“制造一种充满危机的局面，以期不可避免地开启谈判之门”。当然，目的就是要消除美国的种族隔离制度，最终并使黑人获得同等的公民权利。</p>
</blockquote>
<h2 id="Ch-10-政治文化"><a href="#Ch-10-政治文化" class="headerlink" title="Ch 10 政治文化"></a>Ch 10 政治文化</h2><blockquote>
<p>安德鲁·海伍德在《政治学》教科书中这样定义“政治文化”：</p>
<p>政治学家在更为狭隘的意义上用该词来指人们的心理倾向，政治文化就是针对政党、政府和宪法等政治客体的倾向模式（pattern of orientations），并表现为信仰、符号和价值。政治文化不同于公共舆论，它由长期的价值而非对具体政策、问题或人物的反应塑造而成。</p>
<p>还需要理解政治社会化问题，这是指对政治文化习得的过程，包括政治认知、态度、价值观与行为的习得。一般认为，12—30岁是政治社会化的关键时期。对任何一个公民的政治观念养成来说，其从小到大的成长环境非常重要。家庭、学校、教堂、工作场所、社交网络、新闻媒体与互联网以及政府等等都会对塑造他的政治观念产生影响。</p>
</blockquote>
<h4 id="10-1-阿尔蒙德与公民文化"><a href="#10-1-阿尔蒙德与公民文化" class="headerlink" title="10.1 阿尔蒙德与公民文化"></a>10.1 阿尔蒙德与公民文化</h4><blockquote>
<p>政治文化之所以重要，在阿尔蒙德和维巴看来，政治文化是微观的政治和宏观的政治之间的连接纽带。通过研究政治文化，特别是从微观层次上观察公民个体的政治行为、信念与倾向，可以发掘出一个国家民主或不民主这一宏观政治现象的成因。他们认为，可以用政治文化来解释从微观的个体行为到宏观的政治现象之间的机制。换句话说，这些个体拥有什么样的政治文化，会影响到民主政体能否维系或实现稳定。</p>
<p>他们首先区分出了政治文化的三种不同类型。</p>
<ol>
<li>第一种是村民文化（paro-chial culture）。这里的村民概念，强调的是他们的活动范围和视野都局限在一个非常小的范围之内。他们从小生活在自己的家乡，也只关心极小范围内的一些事情。通常来说，这是一种比较原始落后的生活状态所塑造的政治文化。</li>
<li>第二种是臣民文化（subject culture）。这种文化的直接表现是政治上比较消极，这些人认为普通民众是无力影响政治的，他们具有更好的服从权威的意识。</li>
<li>第三种是参与者文化（participant culture）。这种文化强调公民意识，这些人关心政治，正如美国新英格兰的乡镇居民一般。他们通常是政治积极分子，希望参与政治，希望通过政治参与来改善公共治理。</li>
</ol>
<p>那么，什么样的政治文化有利于民主政体的稳定呢？他们认为是<strong>公民文化</strong>。公民文化是参与者文化、臣民文化和村民文化三者的混合。阿尔蒙德认为，<strong>公民文化有时明显地包含着互相矛盾的诸种政治态度，但这似乎特别适合于民主政治系统，原因在于民主政治系统也是一种矛盾的混合体。简单地说，身为民主政体下的公民，理想状态应该是：该参与的时候就要参与，该服从的时候就要服从；该积极的时候就要积极，该消极的时候就要消极。当公民文化把这三种东西结合起来时，最有利于民主政体的维系和稳定。</strong></p>
<p>阿尔蒙德这样论述具有混合特质的公民文化：当这些被保留的较传统的态度和参与者取向相融合的时候，便导致了一种平衡的政治文化，在这种文化中，既存在着政治的积极性、政治卷入和理性，但又为消极性、传统性和对村民价值的责任心所平衡。[254]</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记:西方美学简史</title>
    <url>/2023/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A5%BF%E6%96%B9%E7%BE%8E%E5%AD%A6%E7%AE%80%E5%8F%B2/</url>
    <content><![CDATA[<p>Aesthetics from Classical Greece to the Present</p>
<p>Monroe C Beardsley </p>
<p>[美] 门罗 · C.比厄斯利 高建平译本</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>美学(aesthetics)与艺术哲学(philosophy of art)，虽然他们的内容很相似，但也存在一些区别。作者和很多通行的做法都使用美学来概括那些属于艺术哲学范畴的东西。</p>
<blockquote>
<p>“美学”一词（Aesthetics）源自希腊语“αἰσθητικός”，意为美学的、敏感的、感性的，是一个用于修饰感觉、知觉的形容词。</p>
<p>——维基百科：<a href="https://zh.wikipedia.org/zh-hans/美学">美学</a> </p>
<p>直到十八世纪的启蒙运动，哲学的转向渐渐开始更多地探讨知识论的问题，「美」的概念在这时开始转化成「感性」或「美感」等主题，「美学」的发展方向在此也有了一个清晰的定义，德国哲学家鲍姆加登（Alexander Baumgarten）首次提出以「感性之学」（aesthetics）赋予了「感性」和「美感」等这些哲学命题一个独立的地位， 在鲍姆加登看来，人的感性认识能力所能达到的完善境界就是「美」。 自此开始，美学开始独立成科，虽然在此之后，美学的研究方向又因为哲学史的变迁而慢慢转移到「艺术」、「心理判断」和「符号」之上，但美学的基本定义仍旧还沿用着鲍姆加登所留下来的「感性」一词。</p>
<p>原文網址: 甚麼是：美學 - EP04 | 香港01 <a href="https://www.hk01.com/article/40737?utm_source=01articlecopy&amp;utm_medium=referral">https://www.hk01.com/article/40737?utm_source=01articlecopy&amp;utm_medium=referral</a> </p>
</blockquote>
<p>可见，美学的研究范畴更加经验性。</p>
<p>对美学边界的界定：</p>
<p>针对对艺术作品的提问可以划分出三个层次</p>
<ol>
<li>针对具体地作品，问具体的问题。</li>
<li>问一些对一种对音乐或文学或的本性，或对这些艺术门类的某些重要特征的研究——理论与解释、分析与归纳。</li>
<li>针对批评本身，针对他们所使用的术语，针对研究与争论的方法，针对<strong>它的潜在假定来提问</strong>，这些问题显然从属于哲学美学。</li>
</ol>
<p>一般美学的范畴在第二层中部到第三层，第二层的某些内容可能不属于哲学美学，而是文学批评或音乐批评，但很多哲学家也将他们看作美学问题。</p>
<h2 id="Ch-1-最初的思想"><a href="#Ch-1-最初的思想" class="headerlink" title="Ch 1 最初的思想"></a>Ch 1 最初的思想</h2><p>在美学出现之前，会有这样的阶段：某些对象会被区分开来，作为专门的审美对象。然后转向对有趣的对象做哲学上的反思，最后开始提出命题，这些命题由于其普遍性与渗透性而可以被说成是真正哲学性的。</p>
<h3 id="1-1-古埃及"><a href="#1-1-古埃及" class="headerlink" title="1.1 古埃及"></a>1.1 古埃及</h3><p>E.Baldwin Smith 对古埃及人是否达到了对审美本身的意识持强烈的怀疑态度，他发现“很难想象”埃及人“具有一种对待艺术的审美的态度”。</p>
<p>埃及人虽然拥有制作精美雕塑的能力，但他们会把这些雕塑放到人们很少能看得到的地方，给帝王们陪葬，他们所称赞的不是作品之美，而是他们所使用金属的力量与持久性，或者丰富与奢侈。</p>
<p>埃及人似乎没有将他们对艺术本身的反应与他们的宗教和政治态度区分开来，或者说他们没有因此意识到艺术呈现出的特殊问题。</p>
<h3 id="1-2-希腊人"><a href="#1-2-希腊人" class="headerlink" title="1.2 希腊人"></a>1.2 希腊人</h3><p>希腊人意识到了艺术的特殊性，鲍桑认为荷马的讲述着所说的：在阿克琉斯的盾牌上“犁后面的土地看上去是黑色的，就像刚刚耕过一样，尽管它是金子制成的；这是一件无与伦比的作品”</p>
<p>以后西方许多美学问题都能从希腊人这里看到端倪，此外，希腊人的发展也促进了以后的人（如柏拉图）的美学的成熟，具体表现如下：</p>
<ol>
<li><p>荷马的审美判断，将意象与它所代表之物的关系提了出来，有关感性知识合法性的问题出现了。摹仿(mimesis)，这个词以及它的同源词就是在这个时候提出的(公元前5世纪)。</p>
</li>
<li><p>艺术家创造力的性质与源泉：在荷马和赫西俄德那里出现了对世界以及世界秩序起源的兴趣。希腊人认为绘画和诗歌涉及某种超自然性。德谟克里特说：“荷马具有一种神的本性，他制造了一个有着多种多样故事的世界。”</p>
</li>
<li><p>早期的自然哲学对可观察到的自然秩序的兴趣和一个更大的潜在秩序来解释我们观察到的事物的要求，是我们所谓自然科学的最初动因。也是音乐的动因，例如毕达哥拉斯学派对音乐背后数学规律的发现。</p>
<p>在某些<code>Galgame</code>中看到的情节也可能源于毕达哥拉斯学派的思想。</p>
<blockquote>
<p>毕达哥拉斯学派还设计出一套精密的天文学模式，在其中，天体依照它们与地球的距离而发出一种恒定的音调，尽管这种星球的音乐人们听不到，或者不能在一般情况下听到也许是由于人们缺乏敏锐的感受力去作出反应，也许是由于这种音乐的恒定性质本身落在了意识的阈限之下，就像海浪不再为那些住在岸边的人所注意一样。</p>
</blockquote>
</li>
<li><p>从公元前6世纪后半叶，到公元前五世纪，在各种工艺与艺术门类中的理论大师们越来越自觉地开始对他们工作所依据的原理进行思考，并将这些原理写下来。哲学美学最有成果的著作，必须等待这些研究取得成功。</p>
</li>
</ol>
<h2 id="Ch-2-柏拉图"><a href="#Ch-2-柏拉图" class="headerlink" title="Ch 2 柏拉图"></a>Ch 2 柏拉图</h2><blockquote>
<p>柏拉图的美学思想出自以下篇幅：</p>
<p>《伊翁篇》《会饮篇》《理想国》</p>
<p>《斐德罗篇》</p>
<p>《智者篇》《法律篇》</p>
</blockquote>
<h3 id="2-1-术语：艺术与模仿"><a href="#2-1-术语：艺术与模仿" class="headerlink" title="2.1 术语：艺术与模仿"></a>2.1 术语：艺术与模仿</h3><p>柏拉图的术语不是很清晰，因此需要对他的术语做说明，而且这些术语也被以后的美学家所使用。从这些术语的说明中，也可以看到一条思想线索，柏拉图通多对工艺进行区分，认为艺术只是伪工艺，没有认识价值。</p>
<ol>
<li><p>艺术(techne)</p>
<p>其含义更接近于“技艺”，指异乎寻常的专门做某种事的技能。</p>
<p>柏拉图将一般的技艺区分为“获取性的”（如挣钱）与“生产性的”/“创造性的”（木工、演奏、绘画、纺织…）（除此之外，柏拉图默认更为狭义的艺术与其他工艺的区分，即音乐绘画雕塑等狭义的艺术与其他工艺的区分）。</p>
<p>由于生产型的工艺，某些新的东西出现了（即模仿）：物质媒介必须以某种方式操纵、组合或变化；必须有一种相关的技巧；必须有一种知识（如乐理）。但是理智的生产物还具有一种目标，或服从一个计划，它自始至终都对工匠起指导性的作用。因此，总的来说，所有的生产都是模仿。</p>
</li>
<li><p>模仿（imitation）</p>
<p>希腊语：摹仿（mimesis），语法上与该词类似的三个词是methexis（分有），homoiosis（相似），paraplesia（类似）</p>
<p>对柏拉图来说，重要的是艺术在某种意义上说是模仿的而其他工艺不是。</p>
<p>柏拉图在《智者篇》对生产性的工艺进行了进一步区分，即有：（1）实际对象的生产（2）图像的生产，如反思、梦、图画。这距离里艺术理论更进了一步。</p>
<p>“模仿的艺术”可以产生两类事物：（1）具有原型功能、性质的相似物（2）在某个视角看上去的样子，即一种外观。</p>
<p>因此柏拉图认为存在一种狭义的“模仿”/“伪工艺”，即欺骗性外观的制造。并且区分了四种伪工艺：体操产生健康，化妆产生健康的错觉；存在着真正的立法，也存在着诡辩论，即伪装的正义…</p>
<p>柏拉图提出了两条鉴定伪工艺的标准：（1）是否以知识为基础（2）是否有一个清晰的思想，能否用理性进行说明。</p>
<p>所以，柏拉图非常轻视音乐家画家作家，柏拉图否认他们具有真正的知识，“诗人的危险在于许多人以为他们确实知道他们在说什么”。</p>
<p>同样的结论也可以在使人写诗时，“失去理智”的状态中得出。但这一思想线索容易转变成这样的想法——诗人的非理性也许不是低于理性，而是高于理性。</p>
<p>虽然可以说，画家不仅假装要实践一门艺术，而且时间一门存在于假装之中的艺术，即使得事物像某种东西，但又不是那种东西。但总而言之，柏拉图认为不存在什么艺术，而只有伪工艺。</p>
</li>
</ol>
<h3 id="2-2-大美、回忆说、艺术品与艺术家"><a href="#2-2-大美、回忆说、艺术品与艺术家" class="headerlink" title="2.2 大美、回忆说、艺术品与艺术家"></a>2.2 大美、回忆说、艺术品与艺术家</h3><p>美（tokalon）</p>
<p>柏拉图认为，世界上除了变化的美，还有一个大美，它是的美的范式/理型，是绝对的大美，不能用眼睛看，只能被心灵从概念上把握。</p>
<p>柏拉图的回忆说：带领我们到达关于真正大美的知识的向导，本质上是带领我们回到了一个我们已经忘却的家园。在那个概念的王国中，美的范式和其他诸如正义，善的概念一起存在。</p>
<p>想要到达那个概念的世界，我们就需要知识。而想要到达美，我们就需要</p>
<blockquote>
<p>“这个世界的美”使我们回忆起“真正的美”；…；只有这样我们心中的神性的爱（Eros，又译“厄洛斯”）才能得到满足。</p>
</blockquote>
<p>虽然苏格拉底没有承认艺术的作用，但《会饮篇》显然诱使我们想到，艺术作品有让我们回忆起真正大美的作用。“只要我们承认悦耳的音调与绘画可以是美的，…，他们在一定程度上体现、参与并揭示了大美范式。”因此，阿伽通说，爱（Eros）发明了艺术，包括那些产生美的艺术。（这其中的逻辑在于，我们回忆起真正的美时，我们心中的神性的爱会得到满足。反过来为了满足神性的爱（Eros），我们便需要艺术作品是我们回忆起大美，因此爱（Eros）发明了艺术）。</p>
<blockquote>
<p>个人观点：因此，某种意义上讲，艺术家具有一种神性，不仅仅是因为他们像神创造世界一样创造艺术作品，还因为他们能够接近大美范式，他们能够创造出艺术作品让人们回忆起美的范式。事实上2.3中，柏拉图也确实是这样认为的。</p>
<p>补充：Plato and Eros</p>
<p>TODO</p>
</blockquote>
<h3 id="2-3-什么是美？"><a href="#2-3-什么是美？" class="headerlink" title="2.3 什么是美？"></a>2.3 什么是美？</h3><p>柏拉图试图在《大西庇阿斯篇》和《斐利布篇》为美下一个定义，但他没有成功，在书中，苏格拉底与他人的讨论中，美的功能主义概念，即认为一个对象如果能很好地实现其功能，就是美。遭到了拒斥。最终他们得出的结论是：也许美是“有益的快感”。</p>
<p>在《斐利布篇》中，柏拉图至少总结了两种美的特征：</p>
<ol>
<li>度（metron）、比例（symmetron）的性质总是构成美与优秀。（复杂的东西具有比例的性质是美的）</li>
<li>某种具有同一、整一、规则和单纯性的东西是美的。（简单单纯的东西是美的）</li>
</ol>
<p>对美进行分析后，我们发现艺术家们并非仅仅是疯子，他们的作品也是有章可循的，因此我们需要重新考察艺术家及其创造力：</p>
<blockquote>
<p>那种幻觉的编织者所具有的突出的非理性就显得像一种更高的智慧，他的疯狂被当成了某种接近神性的灵感的东西。</p>
<p>苏格拉底用神的启示（缪斯）去解释灵感，他在《斐德罗篇》中说：</p>
<blockquote>
<p>它凭附到一个温柔贞洁的心灵，感发它，引它到兴高采烈、神飞色舞的境界…若是没有这种诗神的迷狂，无论谁去敲诗歌的门，他和他的作品都永远站在诗歌的门外，尽管他自己妄想单凭诗的艺术就可以成为一个诗人。他的神智清醒的诗遇到迷狂的诗就黯然无光了。</p>
</blockquote>
<p>也许艺术家和哲学家都是具有真正的知识的，艺术家们也许有他们对理想美本性的考察，尽管他们需要一种启示的状态去表达它。哲学家们看起来疯狂，而实际上是看到真正的美时的狂喜与眩晕。</p>
</blockquote>
<h3 id="2-4-审美快感从何而来？"><a href="#2-4-审美快感从何而来？" class="headerlink" title="2.4 审美快感从何而来？"></a>2.4 审美快感从何而来？</h3><p>什么是审美享受的本性？以及它与善的关系？</p>
<ol>
<li><p>“真正的快乐”是那些由色彩与形式，由气味与声音，以及几何构造的美所提供的。例如你与一阵香味不期而遇，在它之前并没有饥渴，在它之后也没有什么严重的后果。这种快感是未掺杂任何因素的天降之福，这构成了一种边沁意义上的纯粹性。(PS: 就是后面提到的那种“无关利害的美”)</p>
<blockquote>
<p>快乐的量并不构成对快感的检验标准，除非它向观众提供正确的快感。</p>
</blockquote>
</li>
<li><p>许多艺术作品，特别是悲剧与史诗，是人的生活与命运的模仿，其中许多可愉悦性都来自于处于高度情感状态中的人们的再现，他们强烈地表现情感，这样也激发了观众的情感。</p>
<blockquote>
<p>但柏拉图似乎并不看重这种快感，他认为，这些艺术作品对理性起一个破坏作用，使人更具情感性，更少自我控制倾向。</p>
</blockquote>
</li>
</ol>
<h3 id="2-5-艺术作品与道德"><a href="#2-5-艺术作品与道德" class="headerlink" title="2.5 艺术作品与道德"></a>2.5 艺术作品与道德</h3><p>柏拉图还关注艺术作品对道德的影响：</p>
<p>在柏拉图思想中占主导地位的是强烈的广义道德主义。他坚持，对任何艺术作品的最终评价，以及政治家关于是否应允许其存在的决定，必须全面地将整个社会的最重要的目的与价值考虑在内。</p>
<p>柏拉图认为艺术必须被审查和限制。</p>
<blockquote>
<p>在柏拉图的众多思想中，很少有像这种思想受到如此强烈的抨击，也很少有像这种思想被用来为专制政府控制艺术生产，并借此控制公民的思想进行令人羞愧的辩护。</p>
</blockquote>
<h2 id="Ch-3-亚里士多德"><a href="#Ch-3-亚里士多德" class="headerlink" title="Ch 3 亚里士多德"></a>Ch 3 亚里士多德</h2><blockquote>
<p>其美学思想出自于《诗学》</p>
<p>亚里士多德不存在可以称之为美学体系的东西，但他为一种文学门类提供了理论。也对柏拉图的美学做了回应。</p>
<p>值得注意的是，亚里士多德的诗学其实没有自己的古代史，因为在此书完成后的几个世纪里，绝大多数从事诗学研究的人都没有办法得到这本书。</p>
</blockquote>
<p>亚里士多德在开辟一个新的研究领域是，他喜欢根据一种分类体系来为该研究领域确定位置。</p>
<p>亚里士多德对三种“思想”——知（theoria）、做（praxis）、和造（poiesis）进行了区分，他认为做是一般性的生产艺术，而造是指对事件或对象的模仿或再现。而模仿艺术又可以分为两种：（1）通过色彩和线条来模仿视觉外观的艺术（2）通过诗句、歌唱和舞蹈来模仿人的行动的艺术。</p>
<p>亚里士多德主要关注戏剧与史诗，即喜剧与悲剧；他感兴趣的是判断的基础，是可用来支持一种比较性评价的理由，即他想研究一种评价体系。</p>
<h3 id="3-1-悲剧"><a href="#3-1-悲剧" class="headerlink" title="3.1 悲剧"></a>3.1 悲剧</h3><p>亚里士多德研究悲剧的方法：寻找一种艺术门类的功能提供的一种特殊种类的快乐，来研究批评性的评价问题。亚里士多德提出了对悲剧提出了两个问题：</p>
<ol>
<li>悲剧中是什么吸引了我？</li>
<li>生产这些东西是基于什么冲动？</li>
</ol>
<h4 id="3-1-1-一般的模仿艺术的快感"><a href="#3-1-1-一般的模仿艺术的快感" class="headerlink" title="3.1.1 一般的模仿艺术的快感"></a>3.1.1 一般的模仿艺术的快感</h4><p>对于第二个问题，亚里士多德的观点可以推广至所有的模仿艺术，他认为，生产悲剧是一种模仿，而作为理性的动物，我们从模仿中得到快感，是因为模仿是认识的一个特殊的实例。模仿的艺术产生快感，是因为模仿与模仿对象的同一性的推论，让我们学到了某些东西，因此我们感到快乐。</p>
<h4 id="3-1-2-作为特殊的模仿艺术——悲剧，所独有的快感"><a href="#3-1-2-作为特殊的模仿艺术——悲剧，所独有的快感" class="headerlink" title="3.1.2 作为特殊的模仿艺术——悲剧，所独有的快感"></a>3.1.2 作为特殊的模仿艺术——悲剧，所独有的快感</h4><p>上述讨论的是所有的模仿作品，但为什么悲剧会让我们沉迷，其必有某些独特的快感，这也就是第一个问题。</p>
<p>对于第一个问题。亚里士多德说，悲剧所特有的快感是“来自通过模仿而获得的怜悯与恐惧”</p>
<p>当怜悯被感受为一种从恐惧或其他紧张而痛苦的感情，如惊慌或愤怒，中解脱时，也许就变成了某种快感一类的情感，即一种解脱的快感。</p>
<h4 id="3-1-3-关于快感-什么样的悲剧更美"><a href="#3-1-3-关于快感-什么样的悲剧更美" class="headerlink" title="3.1.3 关于快感: 什么样的悲剧更美?"></a>3.1.3 关于快感: 什么样的悲剧更美?</h4><p>[关于快感，什么样的东西是更好地，更美的] 快感依其所完成的活动而各归其类，每种活动都有其特有的快感，在任何感官的直觉中，感官处于最好的状态和对象是同类对象中最好的之时，活动就最好，从而这一活动就会是最完善的，最令人愉悦的。</p>
<p>在《诗学》第七章，他突然说，任何由部分组成的整体，若要显得美，就必须符合（1）不仅是各部分有秩序的排列，而且是（2）必须有<strong>一定的，不是偶然</strong>的体积。亚里士多德指出，一部好的悲剧确实具有“有秩序的排列”，以及所有这个表述所表示的完满、适当的比例和尺度的含义。</p>
<p>或许亚里士多德的意思是说：一部戏必须具有统一而凝成一体的影响，并且必须尽最大可能地使时间进程给人以不可避免之感。</p>
<h3 id="3-2-对柏拉图的回应"><a href="#3-2-对柏拉图的回应" class="headerlink" title="3.2 对柏拉图的回应"></a>3.2 对柏拉图的回应</h3><h4 id="3-2-1-诗具有认识的意义"><a href="#3-2-1-诗具有认识的意义" class="headerlink" title="3.2.1 诗具有认识的意义"></a>3.2.1 诗具有认识的意义</h4><p>柏拉图认为诗是诗人在疯狂中写下的作品，他其实并没有任何真理，写下的诗也没有意义。</p>
<p>亚里士多德认为，诗必须做到逻辑自洽，即诗的情节必须给人比可避免之感。因此使人必须理解人的本性，他必须有真正关于某种心理机制的一般性知识，没有这些他连一部好戏也写不出来。</p>
<h4 id="3-2-2-疏泄"><a href="#3-2-2-疏泄" class="headerlink" title="3.2.2 疏泄"></a>3.2.2 疏泄</h4><p>疏泄是指艺术作品，如悲剧，具有：“通过怜悯和恐惧产生对这些情感的合适的净化”，就是说通过激发这些情感，提供一种令人愉悦的解脱感，对于观众的精神具有治疗的效用。</p>
<p>柏拉图反对诗，因为它能激发和滋养激情，从而破坏公民的灵魂与理性的和谐。</p>
<p>但亚里士多德可能会这样反驳：如果直接去观看那些疯狂的场景，情况可能是柏拉图说的那样，但我们看到的是经验的后续和更深层的心里效果，去看戏的人通过情感的释放而得到净化。从长远的观点来看，看戏的公民可能是最冷静和有智慧的，因为他们一次次拜托啦那些困扰人的，毒化人性和理性的情感上的非理性。</p>
<p>因此亚里士多德认为，不需要对戏剧做道德上的审查，而只需要做审美上的审查，因为让好人不幸福，坏人幸福的那些戏剧必然在审美上也不是什么好戏，道德和与正义将与审美上的优秀一致。</p>
<h2 id="Ch-4-古典晚期的哲学家们"><a href="#Ch-4-古典晚期的哲学家们" class="headerlink" title="Ch 4 古典晚期的哲学家们"></a>Ch 4 古典晚期的哲学家们</h2><blockquote>
<p>希腊化时期：</p>
<p>罗马古典主义时期：</p>
</blockquote>
<h3 id="4-1-斯多葛学派"><a href="#4-1-斯多葛学派" class="headerlink" title="4.1 斯多葛学派"></a>4.1 斯多葛学派</h3><p>斯多葛学派的教义是，正确的行动在于个人的逻各斯符合自然的普遍逻各斯。</p>
<p>帕那修斯将事物的美比作灵魂的理性秩序，并提出美的快乐与「在有秩序的生活中表现自身的美德」联系在一起。</p>
<p>审美和谐的观念与有关「得体」（to prepon）的道德交易联系在一起。</p>
<h3 id="4-2-伊比鸠鲁学派"><a href="#4-2-伊比鸠鲁学派" class="headerlink" title="4.2 伊比鸠鲁学派"></a>4.2 伊比鸠鲁学派</h3><p>菲洛德穆反对音乐与道德联系在一起，他认为早期的理论家将属于词语的效果归结到了音乐本身。并且说，旋律本身是非理性的（alogon），没有旋律能将灵魂从平静安息的状态中唤醒。既然音乐是非理性的，它产生的快感就完全是无害的。</p>
<p>此外，菲洛德穆反对将对于诗歌的批评建立在「一种对诗歌的两个方面的区分的基础上」，即实质与风格的区分，他说被认可的思想不是好诗的充分或必要条件，如果用词不好，好的思想也不能使文学本身成为可称赞的。他的观点是：好诗就好在形式与内容的同一，以及诗人所提供的个人特性。</p>
<h3 id="4-3-怀疑主义"><a href="#4-3-怀疑主义" class="headerlink" title="4.3 怀疑主义"></a>4.3 怀疑主义</h3><p>怀疑主义者反对关于物质本性的知识的观点肯能部分出自他们反对艺术的模仿理论，原因是这种理论预设了关于物质，我们能知道什么，并能够把握共相。</p>
<h3 id="4-4-罗马古典主义"><a href="#4-4-罗马古典主义" class="headerlink" title="4.4 罗马古典主义"></a>4.4 罗马古典主义</h3><p>贺拉斯（Horace）</p>
<ul>
<li><p>诗具有娱乐和教育的双重功能：一首诗既是自然也是艺术的作品；他必须或者令人愉悦，或者改造人，而更好的则是兼有这两者。</p>
</li>
<li><p>贺拉斯最著名的一句话是“诗画一律”。在《诗艺》原文中，赫拉斯说：“诗歌就像图画：有的要近看才能看出它的美，有的要远看……”</p>
</li>
</ul>
<p>卡修斯·朗吉努斯（Cassius Longinus）</p>
<p>在本书中第一次提到「崇高」或「庄严」。</p>
<p>伟大的文学作品是以某种特性作为其特征的，朗吉努斯将这种特征说成是——庄严（hypsous）。他提出了庄严的五种特征。其中最重要的两种是</p>
<ol>
<li>巨大而重要的（有血性的）思想</li>
<li>热烈的情感</li>
</ol>
<p>当探讨「崇高」的性质时，朗吉努斯似乎认为中国只能根据结果确定。他对美学的观点没有耐心，仅满足于说「崇高」是在读者那里所产生的不仅仅是快感或理性的信念，而且是激动的狂喜：一种仿佛由魔法产生的陶醉感。</p>
<h3 id="4-5-新柏拉图主义：普罗提诺"><a href="#4-5-新柏拉图主义：普罗提诺" class="headerlink" title="4.5 新柏拉图主义：普罗提诺"></a>4.5 新柏拉图主义：普罗提诺</h3><p>普罗提诺（Plotinus）</p>
<p>普罗提诺的思想很大一部分继承了柏拉图的思想，并且给予美的概念以全新而影响深远的形而上学的地位上的尝试。</p>
<h4 id="4-5-1-普罗提诺的形而上学-本体论"><a href="#4-5-1-普罗提诺的形而上学-本体论" class="headerlink" title="4.5.1 普罗提诺的形而上学/本体论"></a>4.5.1 普罗提诺的形而上学/本体论</h4><p>普罗提诺的形而上学建立在「太一，the One, to hen」「努斯，nous」和「灵魂，psyche」之上。</p>
<p>太一可以理解成一个无法被规定的神，它比人格化的神更加广阔和原始，有时被称作「原始之善」。太一创造了万物，但太一却不是万物的一部分。太一没有形式，既不是一个东西，也不是性质，也不是数量，即超脱空间，又超脱时间。</p>
<p>努斯是比太一次一等的实体，它是由于太一因自身充盈而流溢的结果。努斯是从太一中发出来的辐射，是太一借以显示自身和认识自身的形式。普罗提诺有时把努斯称作太一的影子，并认为这些影子本质上和太一是同一种东西。不可定义的太一通过努斯而获得了自身的规定性，这种规定性就是理念和整个理念世界。（PS：抛开它的起源不谈，努斯其实就是柏拉图的理念/范式）</p>
<p>努斯是体现为一体的太一。而太一再往下分化就是灵魂，包括人的灵魂和其他生物的灵魂；再往下流溢就是灵魂凭借理念所创造出的自然界。自然界的万物以理念为形式，以纯粹的黑暗为质料。</p>
<p>灵魂本质上来源于一个更高的世界，具有一种回到太一的向往，每个灵魂都试图通过与「努斯」的联系而窥见和分有「太一」。因此善的生活在于摆脱肉体的束缚，循着实践的美德（如政治），到理论的美德（如辩证法），再到精神的沉思这样一个方向不断上升，最后借助于一个无意识的「出神」(迷狂) 与「太一」融为一体。</p>
<h4 id="4-5-2-同一与美"><a href="#4-5-2-同一与美" class="headerlink" title="4.5.2 同一与美"></a>4.5.2 同一与美</h4><p>普罗提诺从各种美的事物开始考察（事物，德行之美），并问道（1）使他们美的东西是？（2）再他们之中，这种显示自身的某物是什么？</p>
<p>普罗提诺最初回答，各部分之间朝向一个整体的对称，…，美的事物从本质上是对称的，图案化的。</p>
<p>但普罗替诺通过归谬法否定了上述的回答，并用形而上学的方法将对称请了回来。他说，美的事物之所以美，是因为艺术将范式与理念引入到了其中。这种范式不是在材料中，而是在被引入前就存在于人的心中了。由于物质具有取得与拥有范式的能力，因此神性的理智与理性的宇宙的美可以在关照中被揭示出来。或者换句话说，可见世界的美在于它对不可见世界的反映。</p>
<p>但是，普罗提诺的美还有某种神秘主义：他说，在获得美之时，物质也得到了一些深刻的与灵魂的亲属关系，并且这种灵魂在认识到自身的本性被客观化之时而快乐，同时也因此意识到自身对神性的参与。</p>
<p>为什么说普罗提诺将对称请了回来呢？普罗提诺说：</p>
<p>理想-范式所到之处，将原本多种多样的部分组合与调整，使之成为一个统一体。理念是一个统一体，它所铸造的必须成为多样性所可能的范围内的统一。是什么将各部分构成了整体呢，是美，美将自身提供给各部分，存在着由带着其各部分的一所房子的整体的美。</p>
<p>因此统一是至关重要的，所有的美都是一种统一化的结果。</p>
<h4 id="4-5-3-美感"><a href="#4-5-3-美感" class="headerlink" title="4.5.3 美感"></a>4.5.3 美感</h4><p>对感性美的解释：</p>
<p>知觉的能力就是在某些对象中辨认出「理想-范式」。</p>
<p>至于高贵行为的美与学识的美，不是为肉眼所见，而是为灵魂之眼所见的美。要看到是什么使有道德的灵魂成为美，就要看到它的对立面——丑。丑陋的情况是由于外在的物质侵入了。因此道德训练就在于将外在的东西「净化」，使纷争变成和谐——归结为一个词：统一。</p>
<p>从这一观点看，美几乎与善完全统一。</p>
<hr>
<p>接着普罗提诺转向了「对以各种形式出现的美」的爱。不论灵魂知道与否，它的渴望与快乐都指向神性（太一），这种神性从一方面看是绝对的、最高的、原初的美。要使自己熟悉这种美，就必须放弃「材料的美」，而集中在高贵的追求上，最后还要使自己在精神上美，在道德上卓尔不群。</p>
<p>这是一种从感性美的经验，经过对道德美的关照，到达真理本身的逐级上升。</p>
<blockquote>
<p>PS：这种对美或善的追求，让我想到了《窄门》中，阿莉莎对进步，对进展性的快乐的渴望，从而到达德行的巅峰。</p>
<blockquote>
<p>赵林 邓晓芒：西方哲学史 P78:</p>
<p>这种三位一体的形而上学具有明显的神秘主义成分，这种神秘主义成为基督教摈弃肉体享受、向往灵魂自由的神学思想的重要根源，并为超理性的信仰提供了理论支持。奥古斯丁甚至认为，如果普罗提诺再晚生一点，只需「改动几个字句，就是一个基督徒了」。</p>
</blockquote>
</blockquote>
<h4 id="4-5-4-普罗提诺对柏拉图的回应"><a href="#4-5-4-普罗提诺对柏拉图的回应" class="headerlink" title="4.5.4 普罗提诺对柏拉图的回应"></a>4.5.4 普罗提诺对柏拉图的回应</h4><p>普罗替诺对柏拉图关于模仿的疑问的温和的回答：一棵树与一幅树的画共享被分别可能赋予的美的范式，而且画家具有自由，可在他的画中实际上比树更加全面地捕捉和展示树的范式。</p>
<h2 id="Ch-5-中世纪"><a href="#Ch-5-中世纪" class="headerlink" title="Ch 5 中世纪"></a>Ch 5 中世纪</h2><h3 id="5-1-基督教哲学家们对待艺术与美的态度"><a href="#5-1-基督教哲学家们对待艺术与美的态度" class="headerlink" title="5.1 基督教哲学家们对待艺术与美的态度"></a>5.1 基督教哲学家们对待艺术与美的态度</h3><ol>
<li>有些人，例如德尔图良，认为，艺术活动是对尘世间事物感到强烈兴趣的标志，这容易挑战基督徒对在另一个世界中得到拯救的真诚而全神贯注的决心。</li>
<li>另一些人认为数字与比例是现实的原理，具有某些神性。古典文学也许在教育中有着正面的作用。</li>
<li>对于视觉艺术，很多人质疑视觉艺术，因为视觉艺术再现了神或自我神化了的罗马皇帝，因此成为了一种令人厌恶的偶像崇拜。</li>
</ol>
<h3 id="5-2-奥古斯丁"><a href="#5-2-奥古斯丁" class="headerlink" title="5.2 奥古斯丁"></a>5.2 奥古斯丁</h3><ul>
<li>奥古斯丁认为美是一种异质的整体，他说：“不同的声音合理而秩序井然地以和谐的多样性构成协调一致，暗示着紧密结合起来的城市内秩序井然，甚至能够成为一种神性的‘神秘再现’ ”</li>
<li>奥古斯丁关于美的理论中关键的概念是 整一、数、相等、比例和秩序。</li>
</ul>
<h3 id="5-3-托马斯-·-阿奎那"><a href="#5-3-托马斯-·-阿奎那" class="headerlink" title="5.3 托马斯 · 阿奎那"></a>5.3 托马斯 · 阿奎那</h3><blockquote>
<p>本章的翻译不是很好，很难读懂。因此我省略了阿奎那思想中的形而上学的部分，只保留了阿奎那的美的经验性条件。</p>
</blockquote>
<ul>
<li>种类或美与圣子具有一种类似，这是由于美包含了三个条件：<ol>
<li>完整或完善，缺少了这些性质的事物也因此是丑的。</li>
<li>合适的比例或和谐</li>
<li>明亮或清晰：澄明（Claritas）这个词与一些概念有着重要的关联，我们将之与中世纪新柏拉图主义的光的象征的传统联系在一起——即光作为神圣的真理与美的象征的思想。澄明还能与“形式的光彩照耀在物质的合比例部分”（《论美与善》）。</li>
</ol>
</li>
</ul>
<h2 id="Ch-6-文艺复兴"><a href="#Ch-6-文艺复兴" class="headerlink" title="Ch 6 文艺复兴"></a>Ch 6 文艺复兴</h2><p>文艺复兴时期，经院哲学的成熟体系已经达到了收成而非进取的阶段。这时，有希望的哲学是一种复兴了的柏拉图主义或新柏拉图主义。</p>
<h3 id="6-1-新柏拉图主义"><a href="#6-1-新柏拉图主义" class="headerlink" title="6.1 新柏拉图主义"></a>6.1 新柏拉图主义</h3><h4 id="6-1-1-马西尼奥-·-菲奇诺"><a href="#6-1-1-马西尼奥-·-菲奇诺" class="headerlink" title="6.1.1 马西尼奥 · 菲奇诺"></a>6.1.1 马西尼奥 · 菲奇诺</h4><p>菲奇诺对神性创造的世界做了这样的描绘：所有范式与理念的合成，被称为mundus（拉丁文）/cosmos(希腊文)，即合规则性，这种合规则性的吸引人之处就是美。那么，“爱”就被定义为“对美的欲望”</p>
<p>美不仅是视觉与声音，而且是德行的一种性质，其必然是非物质性的。</p>
<blockquote>
<p>一个例子：身体的美是“活跃、活泼以及由于灌注了它自身的理念而在身体中闪现出来的某种优雅”。换句话说，一个身体匀称的人的外貌和形体非常清楚地符合于我们灵魂从一切的创造者那里捕捉和保留的关于人类的概念。</p>
<p>这个例子很有普罗提诺的感觉，或者说，他的 所有范式与理念的合成 实际上就是「太一」或「努斯」。</p>
</blockquote>
<p>「观照理论」</p>
<p>观照在于使灵魂在某种程度上从身体的事务中抽离，在所产生的内在经验中，范式在一种纯粹的理性仪式中被关注，为永恒的秩序所包围的认知者，变得镇定而平静。</p>
<p>这是每一门艺术都需要的关于创造性活动的经验。人由于比动物更能关照而成为自然的主人，因而能够从事多种多样的艺术。</p>
<blockquote>
<p>PS：其实观照理论就是反思，反思可以促进人类艺术的进步，这里指的是广义的艺术，即狭义的艺术加上各种工艺。</p>
</blockquote>
<h4 id="6-1-2-乔尔丹诺-·-布鲁诺"><a href="#6-1-2-乔尔丹诺-·-布鲁诺" class="headerlink" title="6.1.2 乔尔丹诺 · 布鲁诺"></a>6.1.2 乔尔丹诺 · 布鲁诺</h4><p>布鲁诺的《论英雄气概》模糊地反映了感性美与纯粹抽象美的对比，那些沉湎于前者的人，有达不到后者的危险，而以正确的精神接近低等美的人，会以此为台阶，达到对高等美的爱。</p>
<p>布鲁诺的书是对诗人和艺术家的赞美，目的在于使美成为一种生活方式，一种宗教。它反映出了文艺复兴时期的一个重要发展，即艺术家被判定为一种高等的人，具有独特的天才，超越规则，是一种需要自由与机会的勇士，将自己的个性打在作品之上，因此作品部分由于是他的作品而有趣和有价值。</p>
<h3 id="6-2-绘画理论"><a href="#6-2-绘画理论" class="headerlink" title="6.2 绘画理论"></a>6.2 绘画理论</h3><h4 id="6-2-1-阿尔贝蒂"><a href="#6-2-1-阿尔贝蒂" class="headerlink" title="6.2.1 阿尔贝蒂"></a>6.2.1 阿尔贝蒂</h4><p>文艺复兴时期的艺术家们不光创造了很多艺术作品，也涉及到了关于艺术价值标准，以及获取它们的正确方法。</p>
<p>列翁·巴蒂斯塔·阿尔贝蒂（Leon Battista Alberti）</p>
<p>《论绘画》（第一部提出单点透视理论的著作）《论雕塑》《论建筑》；</p>
<p>关于绘画：</p>
<ol>
<li><p>对于绘画，他说，要根据眼睛看到的实际来画，画家要仅仅注意去再现可以被看见的东西。</p>
</li>
<li><p>在阿尔贝蒂那里，将绘画看成视觉的设计与看成是再现的区别虽然还没有形成，但已经慢慢清晰。</p>
<blockquote>
<p>他说对画家的教育必须用图型、线条和色彩，但这些本身还不构成绘画。（个人理解：用不构成绘画的元素绘画，就是一种视觉的设计。）</p>
</blockquote>
<p>传统的观念将绘画看作再现，而文艺复兴精神则强调视觉的逼真（质感与深度），不再追求更高的象征目的。</p>
</li>
<li><p>阿尔贝蒂认为绘画最重要的特征是被称为“伊斯托尼亚”（istoria）的东西，可以理解为戏剧性的题材或场景。画家最重要的工作在于“伊斯托尼亚”——行动、所表现的情感、主题。为了成为一个好的“伊斯托尼亚”，就要避免不适宜性。</p>
</li>
</ol>
<p>关于设计艺术的高贵：</p>
<ul>
<li><p>阿尔贝蒂认为绘画、雕塑和其他技术是区分开的，绘画、雕塑、建筑应该是属于更自由的范畴，属于「Arti di disegno」（设计艺术）。</p>
<p>理由是：</p>
<ol>
<li>画家的工作实际会更难。</li>
<li>绘画艺术总是最适于自由地灵魂与高贵的灵魂。</li>
<li>由于必须正确地再现事物在视觉中的样子，画家必须懂得自然规律。</li>
</ol>
</li>
</ul>
<p>关于美：</p>
<ul>
<li><p>阿尔贝蒂将美定义为各部分间的和谐，在一切物体之上，只要有美，就以这样的比例和关联结合到一起，只要增一点、减一点或改变一点，就会变得不美。</p>
</li>
<li><p>与美不同的是所谓的“装饰”：一种对美的辅助性光泽与改进。美是一种性质，是固有的与天生的，并散布于全身，而装饰只是某种附加或固定于其上的东西，而非固有与天生的东西，是一种局部的与外在的美。</p>
</li>
<li><p>当再次被问道自然界中使一件事物美的性质是什么时？他又说：</p>
<p>数学，以及我称之为完成和配置的东西。除此之外是一致性，一致性的任务是将那些本性不同的成员放到一起，这样的话，他们也许会协力成为一个美的整体。</p>
</li>
</ul>
<hr>
<p>阿尔贝蒂没有看到我们对美的认知，或对它感到喜悦，可根据其他东西来解释。他假定一个特殊的美的感官来接受他：“自然的本能或感官存在于心灵之中，…，我们根据他判断美”（或许，当他意识到这个问题时，它也会像丢勒一样感到困惑）</p>
<h4 id="6-2-2-达·芬奇"><a href="#6-2-2-达·芬奇" class="headerlink" title="6.2.2 达·芬奇"></a>6.2.2 达·芬奇</h4><p>列奥纳多·达·芬奇</p>
<p>他的思想不仅是文艺复兴时期关于绘画的思想，而且已成了后来创作的前提。</p>
<p>达芬奇的目的在于将被当作自然物再现的绘画科学系统化。</p>
<p>他论述绘画是自然科学，或是经验科学，因为</p>
<ol>
<li>再现的原理能够得到系统地表述</li>
<li>包含数学</li>
<li>处理身体的运动及速度</li>
</ol>
<p>他说画家还需要拥有关于人的知识，他说：“使你的人物的运动适合于这些人物的精神状态，要做到这一点，你必须知道人们如何通过脸，手势和身体的运动来表现他们的情感与意图”。那种在17世纪的画家与理论家那里占据主导地位的关于「绘画的存在不是为了再现原初的自然，而是人与自然（以及与人有关的自然）」的主张，从这里可见其端倪。</p>
<h4 id="6-2-3-阿尔布雷希特·丢勒"><a href="#6-2-3-阿尔布雷希特·丢勒" class="headerlink" title="6.2.3 阿尔布雷希特·丢勒"></a>6.2.3 阿尔布雷希特·丢勒</h4><p>阿尔布雷希特·丢勒（Albrecht Dürer）</p>
<p>丢勒有一些美学的思想，但比起他的困惑，这些思想都不值一提。</p>
<p>对了承认自己非常困惑：</p>
<blockquote>
<p>但是，美在人身上是这样结合在一起，以至于我们对它的判断是如此不确定：我们也许会发现两个人都很美，都很好看，但是，不管是在尺度还是在类型上，在任何一点或任何一部分，他们都不相像；我们的知觉会如此地迟钝，无法分辨其中的哪一个更美，如果我们一定要提供一个意见的话，那么这个意见也会缺乏可靠性。</p>
</blockquote>
<h3 id="6-3-音乐"><a href="#6-3-音乐" class="headerlink" title="6.3 音乐"></a>6.3 音乐</h3><blockquote>
<p>这部分内容与音乐批评而不是美学有关</p>
</blockquote>
<p>文艺复兴时期的音乐是牧歌、经文歌、大型多声部弥撒曲的时代。</p>
<p>文艺复兴时期的作曲家迷恋于恢复可恢复的古典文化，他们关注很多，但我们在这里仅仅谈论伦理效果。</p>
<p>音乐的伦理和情感效果是如何产生的？</p>
<ol>
<li>一方面通过音乐资源的增强来实现：更丰富的和弦语言，调式的混合，更广音域的乐器…</li>
<li>通过使音乐服从于文本：旋律、和声和节奏的情感资源存在的意义在于增强诗人语言的感受性。</li>
</ol>
<p>音乐理论家奥赛夫·扎利诺，强调文本的优先性：「我们必须在包含的话语里、与素材的性质相类似的和弦与节奏中做出选择，以便以一种比例将这些事物结合起来，产生一个合于目的的旋律」。他甚至提出格里高利圣咏的旋律需要加以修改，以便更加精确地符合歌词。（当时的音乐大多数是声乐，因此强调旋律屈从于文本）。</p>
<p>这一提议会带来许多理论与实践上的问题：</p>
<ol>
<li><p>[音乐之美与伦理的冲突] 存在着伦理与文本的冲突，当对一首“情欲的”诗谱曲时，应该终于伦理还是忠于文本？</p>
</li>
<li><p>[音乐之美与文本的冲突] 表现性地忠于文本与音乐结构之间存在冲突，如果过分强调文本，音乐可能就不好听了。</p>
<blockquote>
<p>例如，作曲家应该追求逐词逐字的对应，依照文本而不断改变调式与和弦吗？难道<br>这不会造成音乐上的毫无意义吗？既然理论家为了符合这些基本论点，坚持词在<br>唱的时候必须清楚地被听众听出（这是一些音乐理论家反对对位法，赞同单声部<br>音乐的原因)，并且音乐的节奏不应扭曲说话的自然节奏（这意味着宣叙调是最<br>好的音乐)，这样的话，最忠实的音乐不就是最差的音乐了吗？</p>
</blockquote>
</li>
<li><p>[音乐之美与其表现情感的冲突] 还可能出现一种表现性与美的冲突。加利莱伊在这一点上捍卫一种音乐上的清教主义。他反对纯粹的器乐，理由是它仅仅用声音提供愉悦；他反对多声部（他将之看成是一种器乐造成的退化的表现)，也反对协和音。乐音的美所带来的愉悦必定会扰乱其表现情感的真正功能。</p>
<blockquote>
<p>PS：这可能有些难以理解，按照浪漫主义的说法，音乐之美在于其能表现人的情感，这样就不存在两者间的冲突了。但在文艺复兴时期，人们认为词语是激发感情，传递思想的最好手段，因此具有优先的地位。如果一首音乐听起来很好听，人们可能就忽略了歌词想要传递的感情或思想。</p>
</blockquote>
</li>
</ol>
<h3 id="6-4-诗歌"><a href="#6-4-诗歌" class="headerlink" title="6.4 诗歌"></a>6.4 诗歌</h3><p>文艺复兴时期对诗歌理论的发展的新刺激来源于亚里士多德《诗学》出版。</p>
<p>文艺复兴时期的诗学建立在两大假设之上：</p>
<ol>
<li>（源于柏拉图和亚里士多德）诗从某种意义上讲是模仿</li>
<li>（源于贺拉斯）诗具有娱乐与教育双重功能</li>
</ol>
<p>那个时期人们的讨论主要围绕着四个问题：</p>
<ol>
<li>关于“规则”的问题，例如，是否需要符合某种必要的条件才是好的悲剧。</li>
<li>… （原文没写清楚）</li>
<li>4 柏拉图式的诗的认识价值和道德性受到许多作家的挑战，这是一个为诗歌辩解的时代。（原文也没写34究竟是什么问题）</li>
</ol>
<h2 id="Ch-7-启蒙运动：理性主义"><a href="#Ch-7-启蒙运动：理性主义" class="headerlink" title="Ch 7 启蒙运动：理性主义"></a>Ch 7 启蒙运动：理性主义</h2><p>笛卡尔虽然几乎没有在任何地方提到美与艺术，但他的唯理论正如在所有其他的哲学分支上一样，也在美学上有着巨大的影响。新古典主义就是以笛卡尔的哲学为基础的一场文艺思潮，而本书介绍的这个时期的对诗学/绘画有贡献的美学家，几乎都是属于新古典主义阵营。</p>
<blockquote>
<p><a href="https://www.zgbk.com/ecph/words?SiteID=1&amp;ID=538315&amp;Type=bkzyb&amp;SubID=228940">新古典主义 - 《中国大百科全书》</a> ：</p>
<p>新古典主义（neoclassism）17世纪后期兴起的模仿古希腊-罗马时期艺术创作风格文艺思潮。</p>
<p>新古典主义常与广义的古典主义发生同义现象且可为替换。狭义的古典主义指古希腊罗马时期艺术创作的独特历史风格。不过，当这一风格成为文艺复兴时期艺术家们竞相效仿的美学风尚时，便形成了作为文艺思潮的“古典主义”，而“新古典主义”则是在新的历史阶段相对于前者所产生的文艺理论概念。</p>
<p>新古典主义缘起于17世纪后期，以法国诗人、文学理论家N.布瓦洛发表《诗的艺术》(1674)为代表性事件，跨越几乎整个18世纪，其主体大致消隐于法国大革命爆发前后，影响持续到19世纪，与浪漫主义形成美学理念上的抵悟和交锋，甚至在20世纪初依然为现代主义艺术所指涉。新古典主义以R笛卡尔的唯理主义为哲学基础，以地中海国家考古新发现（如庞贝古城发掘)为文化契机，先后围绕欧洲君主政治表现出截然相反的意识形态立场。</p>
<p>新古典主义强调理性立场，反对浪漫主义对个体情感的张扬，坚持以人自身作为艺术创作的对象，力图体现艺术的实用主义。在表现手法上强调整体设计理念，主张通过对称、比例、统一、和谐和雅致来实现艺术的寓教于乐之功效。</p>
</blockquote>
<h3 id="8-1-诗学"><a href="#8-1-诗学" class="headerlink" title="8.1 诗学"></a>8.1 诗学</h3><blockquote>
<p>诗的目的在于描写「自然/本性」</p>
</blockquote>
<p>对亚里士多德的推崇在17世纪达到高峰，他们相信亚里士多德的结论在理性上是可以被证实的。“诗是人的行动的模仿”，这一原理被当作是不证自明的公理，它源自于亚里士多德的《诗学》：诗是普遍的，而历史是特殊的。</p>
<p>亚里士多德说，理性在特殊中把握一般，每个群体都有其确定的共性，这构成了其成员的“自然”（本性），因此把握“自然”，就是把握本性。</p>
<p>布瓦洛（Nicolas Boileau-Despreaux）说</p>
<ol>
<li><p>爱理性：理性、好的判断力、可理解性，是最重要而最根本的。</p>
</li>
<li><p>让自然成为唯一关注的对象：「那么，你，如果想戴上喜剧作家的花冠，就让自然成为你唯一关注的对象」</p>
<blockquote>
<p>自然是特殊之下的普遍，是现象背后的现实，自然与理性有着内在的联系，两者都服从于同样的规则。</p>
<p>nature，这个词兼有本性的意思。新古典主义者有意将这两者结合在一起，以论证只有“普遍”、“一般”、和“共性”才是事物的自然或本性。</p>
</blockquote>
</li>
</ol>
<p>新古典主义严格的规定了诗的目的：</p>
<ul>
<li><p>布洛瓦提倡诗人应该描写共同人性的基本类型，而不是特殊而引人注目的个体。</p>
</li>
<li><p>约翰逊在《Rasselas》中说「诗人的工作不是考察别的，而是考察类型；评述一般特征和总体面貌：他不是去数郁金香上的斑点」</p>
</li>
</ul>
<h3 id="8-2-绘画理论"><a href="#8-2-绘画理论" class="headerlink" title="8.2 绘画理论"></a>8.2 绘画理论</h3><p>在15世纪晚期到16世纪早期，画家被告戒要模仿自然，用一种现实主义的方法来模仿，关注事物的感性显现。</p>
<p>这种观点逐渐被另一种观点取代，并在17世纪占据着统治地位：这种理论被成为「理想的模仿」，而「理想」一词是本质的、独特的，以及可赞美的等诸多性质的不同比例结合。理想的模仿，正像文学理论中的那样，意味着再现一般而非个别——画家也不需要「数郁金香的斑点」</p>
<p>新古典主义关于美的思想：</p>
<p>乔舒亚·雷诺兹说「我们所寻求的美是一般性的和知性的；它是一种仅仅存在于心灵中的想法；眼睛从不看到它，手也不能表现它；它是一种栖居在艺术家胸中的思想」</p>
<p>雷诺兹的意思是，艺术家应该关注再现一般的自然，因为任何物种的完善的美都不会被某个个体包括，所以「眼睛看不到它，手也不能表现它」。一个男人、孩子和少女所具有的美是某种画家必须自己去构造或重构的东西。</p>
<blockquote>
<p>在这里我观察到，雷诺兹似乎认为艺术家具有捕获潜在地美，并在自己的作品中重构，或使他更美。这种思想在普罗提诺那里也出现过。但其实雷诺兹虽然说「我们所寻求的美是一般性的和知性的」，但这都没有涉及到美的本质，他只是说画家需要去追求什么，而并没有说是什么是他们美。</p>
</blockquote>
<p>关于艺术中的规则与天才：</p>
<ol>
<li>一方面必须有规则，因为必须有一般的规律以解释绘画的效果。</li>
<li>但是天才是一种产生优秀作品的力量，它是艺术的规则不可企及的，不是通过学习规则和刻苦努力能获得的。</li>
<li>也许，「天才」开始于既有的庸俗而陈腐的规则丧失其地位之时。</li>
<li>真的艺术的规则也许比我们想象的要多，因为愉悦的对象是无穷无尽的，因此他们的原理也多种多样。</li>
<li>我们的艺术中很多美看似与规则无关，但又很容易地被归结到某些原理中。</li>
</ol>
<blockquote>
<p>这一部分在我看来已经有些怀疑论的色彩了。</p>
</blockquote>
<h3 id="8-3-音乐"><a href="#8-3-音乐" class="headerlink" title="8.3 音乐"></a>8.3 音乐</h3><h4 id="8-3-1-声音的和谐"><a href="#8-3-1-声音的和谐" class="headerlink" title="8.3.1 声音的和谐"></a>8.3.1 声音的和谐</h4><p>关于声音的和谐与不和谐问题：音乐中应该允许哪一种和谐的音程？</p>
<ol>
<li>一部分诉诸经验：照听上去对的去做</li>
<li>另一部分人主张从不证自明的原理中去推理</li>
</ol>
<h4 id="8-3-2-莱布尼茨"><a href="#8-3-2-莱布尼茨" class="headerlink" title="8.3.2 莱布尼茨"></a>8.3.2 莱布尼茨</h4><p>莱布尼茨关于音乐/绘画的审美欣赏解释：</p>
<blockquote>
<p>感官的快感实际上混合了理智的快感，绝大多数单子(或灵魂)的知觉都是「小知觉」，处于意识的阈限之下。单子(或灵魂)在听音乐的时候都在无意识地数着音乐的节拍，比较他们的数学比率，由于其比率简单尔发现他们可接受。</p>
<p>这实际上是对数学关系的欣赏，在混合意识的层面，显现为感性欣赏。</p>
</blockquote>
<p>莱布尼茨说，对绘画的审美欣赏无疑可以用同样的方法去解释。</p>
<h4 id="8-3-3-感受理论"><a href="#8-3-3-感受理论" class="headerlink" title="8.3.3 感受理论"></a>8.3.3 感受理论</h4><blockquote>
<p>在笛卡儿的情感理论的帮助之下，文艺复兴早期的人们对音乐的情感效果的猜测到17世纪就发展成了一种羽翼丰满的“感受理论”(Affectenlehre)。许多音乐理论家都对这一发展作出过贡献，也对音乐实践产生了影响。这方面的一个很好的例子是约翰·马特森的《完美的乐长》(Der Vollkommene Capellmeister,1739年)一书。</p>
<p>马特森的研究显然是以笛卡儿的理论为基础的。他对音乐力量的源泉，即音乐激发特定情感的能力，作了细致的分析。基本的情感很容易与音乐联系起来：例如，由于喜悦是生命精神的扩展，反之，对应的就是悲伤。复杂的情感可以用其情感构成成分进行分析，与音乐的对应关系，也是同样的。因此：</p>
<blockquote>
<p>音乐像诗一样，对嫉妒这种情感特别关注。由于这种情感状态是七种激情，即猜疑、欲望、报复、悲伤、恐惧和羞愧的结合，它们附属在一种主要的情感即热烈的爱之下，这是人们很容易看到它可以带来多种多样的音乐发明的原因。所有这些，按照其本性，指向不安、烦恼愤怒和悲哀。</p>
</blockquote>
</blockquote>
<h3 id="8-4-统一的美学"><a href="#8-4-统一的美学" class="headerlink" title="8.4 统一的美学"></a>8.4 统一的美学</h3><h4 id="8-4-1-鲍姆加登"><a href="#8-4-1-鲍姆加登" class="headerlink" title="8.4.1 鲍姆加登"></a>8.4.1 鲍姆加登</h4><p>笛卡尔哲学在艺术领域所隐含的意义是由亚历山大·歌特里布·鲍姆加登第一个表述的，他在《对诗的哲学沉思》中造出了「美学」这个词。他说，逻辑学的目标是研究专属于思想的那种完善，话句话说，分析知识的官能。美学（与逻辑学并列）的目标是研究专属于知觉的完善，是低层次的认识，却是独立的，并拥有自身的规律。美学是「感性认识的科学」。</p>
<hr>
<p>从笛卡尔的角度看，一门关于知觉的科学是一个悖论，知觉是那些没有精确而系统地处理的东西。笛卡尔经常强调真理是“清楚和明晰的”。清楚是指对一个心灵的呈现和显明，明晰则是它精确地与其他对象区分开。</p>
<p>莱布尼茨为他们提供了一个扩展的定义，观念可以是清楚的和朦胧的，清楚的观念又可以分为明细的和混合的。明细的观念是抽象的数学和哲学思想；混合的观念是感受：色彩、声音和气味。（他还用他的单子论为这些定义提供了一个形而上学的基础）</p>
<hr>
<p>鲍姆加登说，一个话语（discourse，oration）是「表示相互联系的表象的一连串词语」；一个感性的话语，其中的表象（representation）或观念（idea）是感官性的，即混合的；</p>
<p>鲍姆加登用「完善的感性话语」指话语的各部分指向对感性表象的领悟；诗指一个完善的感性话语；诗意指的是可对一首诗的完善做贡献的任何东西。（一首具有更多诗意的诗，其更加完善，因此其话语的各部分更指向对感性表象的领悟）。</p>
<p>鲍姆加登尽力区分「清楚而明晰的话语」与「混合的，尽管或多或少是清楚的诗的话语」。因为诗学理论要求我们必须能够对诗进行评价，而「好的诗是清楚地，而坏的诗是朦胧的」。原因就在于，如果感性的再现是清楚的而不是朦胧的，更多因素将对他们的传达起作用，这就更加的完善，更加是一个「完善的感性话语」，也就更有「诗意」。</p>
<blockquote>
<p>个人想法，从鲍姆加登的「感性话语」概念，可以看出，鲍姆加登非常强调诗的认识价值。因为他认为更加明晰的诗可以传达更多的东西，也就更是一个完善的感性话语。这也就可以理解，为什么作者在下面说，鲍姆加登的理论（艺术哲学）是「艺术模仿理论的一个技术性版本，却是一个使其摆脱其粗糙形式的版本」</p>
</blockquote>
<p>除了「程度上的清晰」，鲍姆加登还提出了一种「范围上的清晰」的概念：一个观念如果包含更多的观念，而其又是清楚的，就是范围上的清晰。最后他说：诗的技巧增加了范围上的清晰性，从而决定了诗的优秀程度。</p>
<blockquote>
<p>鲍姆加登的这部分内容写的是真的难懂。</p>
<p>而且我十分想吐槽：我认为应该明确地区分开「美学」「艺术哲学」与「aesthetica(感性学)」这三个词，即使将他们放在同一本书中，属于三个范畴的内容也应该彼此区分，否则很多读者会不明白这本书究竟想要讲什么。</p>
<p>在我的理解中，美学的问题应该是解决，什么是美，什么导致美，美的作用等问题；艺术哲学的范畴则是音乐、诗、绘画，以及他们的目的（艺术是模仿的，艺术是人的个性与情感的抒发）；感性学关注的对象则应该像康德的先验感性论一样，是关于人类最初级认识能力的。</p>
<p>前两者在本书的混杂已经让人感到迷惑了，而在鲍姆加登这里又出现了感性学的内容，真是让美学这个哲学分支显得特别混杂💩。</p>
</blockquote>
<h4 id="8-4-2-莱辛"><a href="#8-4-2-莱辛" class="headerlink" title="8.4.2 莱辛"></a>8.4.2 莱辛</h4><p>文艺复兴时期的音乐模仿理论在巴洛克时期仍然盛行，这种理论从认为音乐从根本上讲也是模仿，由此发展出一种广为流传的态度。</p>
<p>阿贝·查尔士·巴图在他的著作《归结为单一原理的美的艺术》中说：「艺术是对美的自然的模仿」。巴图将诗、绘画、音乐、雕塑和舞蹈包括起来，也许是人类历史上第一次将「美的艺术」定义为一个特殊的范畴。</p>
<hr>
<p>这种艺术的一元论观点在它占统治地位的时候就遭到了质疑。这种倾向在莱辛（Gotthold Ephraim Lessing）的《拉奥孔，或论诗与画的界限》那里达到了高潮。莱辛关注各门艺术在媒介上的差别，用他的话说，就是模仿的「指号（Zeichen）」的差别。他并没有对艺术是模仿的提出质疑，但他提出了这样的问题：「一门给定的艺术能模仿什么，以及它最成功的模仿是什么」</p>
<p>在拉奥孔中，他说：</p>
<ul>
<li>全部或部分在空间中并列的事物叫做物体，物体连通他们的可见属性是绘画所特有的题材。</li>
<li>全部或部分在实践中先后承接的事物一般叫做行动，行动是诗所特有的题材。</li>
<li>绘画也能模仿行动，但只能通过物体，通过暗示的方式去模仿行动；绘画在它的同时并列的构图里，只能运用行动的某一时刻，所以要选择富于孕含性的顷刻，使前前后后都可以从这一刻得到最清楚的解释。</li>
<li>同样，诗也可以模仿物体，但要描写在特定行动的施行中最具生动感性形象的那个属性。</li>
</ul>
<h2 id="Ch-8-启蒙运动：经验主义"><a href="#Ch-8-启蒙运动：经验主义" class="headerlink" title="Ch 8 启蒙运动：经验主义"></a>Ch 8 启蒙运动：经验主义</h2><ul>
<li><p>英国哲学家们推动了这一时期的关于艺术作品的心理原因和效果的思考。培根的传统从一开始就关注艺术的心里过程的经验性研究。</p>
</li>
<li><p>关于天才：急需要做的一件事是使艺术从批评中解脱出来，使批评本身从未经考察或没有充分考察的美学理论的控制中解放出来。</p>
<p>为了判断任何种类的作品，某种程度的天才是必不可少的，只有天才才能产生这些作品。</p>
<p>古典的权威——去模仿那种遵循自然、理性和规则的作品——受到削弱。爱德华·扬格在他的《试论独创性作品》中说，如果不停止模仿古人——古人的幸运在于没有东西可以模仿——我们就不能超越他们。</p>
</li>
</ul>
<h3 id="8-1-想象与艺术创造"><a href="#8-1-想象与艺术创造" class="headerlink" title="8.1 想象与艺术创造"></a>8.1 想象与艺术创造</h3><p>想象的概念初次成为思考的中心在17世纪，17世纪人们开始更加严格透彻地研究，并询问兴奋来自什么样的心理官能，以及这样的官能怎样与其他官能联系起来。</p>
<h4 id="8-1-1-培根"><a href="#8-1-1-培根" class="headerlink" title="8.1.1 培根"></a>8.1.1 培根</h4><p>笛卡尔将想象、理解、感受、记忆视为心灵中与认识有关的四种官能。笛卡尔那里，想象的含义在1. 被动的图像形成的官能记录下了感官的反应；2. 一种半主动的重组力量；两者间摇摆。并且被赋予了很低的地位。</p>
<p>培根则赋予了想象完全不同的地位。它首先对设计人类知解力的三个部分进行分类：历史与人的记忆关涉；诗歌与想象力联系；哲学与理性相对应。</p>
<p>培根说，诗（对应着想象）是虚构的历史，它的目的在于「给予人的心灵以虚构的满足，而正是在这些点上，事物的本性不能给予这种满足」；想象力使事物的外观服从于心灵的欲望，而与理性区分开，理性使心灵屈服于事物的本质。</p>
<p>培根为17世纪设定了一个问题：什么是想象，它是怎样作用产生出诗的？</p>
<h4 id="8-1-2-霍布斯"><a href="#8-1-2-霍布斯" class="headerlink" title="8.1.2 霍布斯"></a>8.1.2 霍布斯</h4><p>霍布斯说，没有什么观念是原初地发生在感官上的。霍布斯的「简单地想象」是指：</p>
<blockquote>
<p>他因此反对所有的先验观念，并赋予每一个观念以图像的性质一或者是单一的可感的性质，或者是它们的集合。知觉生理学由运动组成，对于我们来说它的表象就是“幻想”或者想象。当这些身体的运动停止之时，这些图像或幻象仍存在：“<strong>因此想象不过是正在衰退的感觉</strong>”。<strong>感觉并不会衰退，而只是在弱化：它变得朦胧，或被后来的、更为生动的图像所覆盖，正像星星的光芒被太阳光所覆盖，或者，“正像人的嗓音被白天的噪音所覆盖一样”。当感觉“弱化、变老，或成为过去之时，它被称为记忆”</strong>(第6页)。</p>
<p>个人观点：好像很多地方都混用了「先天」和「先验」，先天形容不涉及经验的，而先验则是指那些先于经验，而构成人类如何获取经验的东西。很多人用先验代替先天，形容那些不涉及经验的东西。</p>
</blockquote>
<p>另外还有「复合的想象」，即联想，例如一个人将他自己的图像与另一个人的行动联系起来，一个牛头人。</p>
<p>霍布斯直接地面对了这个问题：复合的想象是如何发生的，有什么规律可以解释？</p>
<ul>
<li>如何发生？（本书其实没有解释清楚复合的想象是如何发生的）</li>
<li>如何解释？复合的想象提供「给予人最大满足的新异性」（参见下文）</li>
</ul>
<p>在心理学观察中，霍布斯做出了一个广为流传的区分，当人们比较意象时，会发现其中的相似点与不同点：那些善于发现相似点的人被说成是巧智的，他们具有一种好的幻想，而善于察觉不同点的人被说成具有好的判断。判断提供力量和结构，幻想提供诗地装饰。</p>
<p>照霍布斯的观点，主要是想象为诗提供了激发激情的力量。他认为人是由一组欲望或厌恶组成的（内驱力），这种欲望与厌恶有自我保存的倾向，这种倾向导致了政治哲学中的“自然状态”。<strong>本质上，生命就是去欲求，以及通过自发地行动去满足欲望，而这种自发行动的动力及其伴随物就是情感。霍布斯将感性的快乐与心灵的快乐区分开开，其中提供最大满足的是新经验和新知识。“由于好奇心是令人兴奋的，因此所有新异的东西都是如此”——而复合的想象提供的正式这种新异性</strong>。</p>
<h4 id="8-1-3-洛克"><a href="#8-1-3-洛克" class="headerlink" title="8.1.3 洛克"></a>8.1.3 洛克</h4><p>洛克从对联想的考察开始它的艺术创造理论。</p>
<p>洛克区分了观念之间具有的「自然的呼应与联系」与「另一种完全是由于偶然或习惯形成的观念的联系」（观念的联想）（观念联想理论最后发展成一种系统的心理学理论）。</p>
<p>照洛克看来，观念的联想是错误迷信偏见的源泉，与那种有秩序的思维过程相反，后者可以产生真理。</p>
<p>洛克还对「巧智」与「判断」做了区分，他指出不仅一个人不能兼得两者，这两者也朝着不同的方向发展。巧智经由轻松与愉悦通向娱乐，判断经由艰难的学科通向知识。</p>
<p>洛克还说，语言中的比喻词都是语言的滥用（因此，经验主义最终演变成逻辑实证主义）。贺拉斯式的关于诗既有娱乐功能又有认识功能的观点第一次遇到了分裂的危险。</p>
<hr>
<p>18世纪后期的思想家对纯粹的联想主义提出了一个有趣的修正，尽管在浪漫主义兴起之前，它并没有产生重大影响，但还是在这里值得一提。这就是情感也在决定将所联系的观念结合起来的方面起着重要作用的理论。例如，亚历山大·杰拉德(Alexander Gerard)在他的联想主义著作《论天才》(Essay on Genius,174)中指出，一种强烈的激情的爆发就像是磁铁一样，将一切可能会满足、滋养它，或者与其因或其果有某种联系的观念都吸向它。因此，诗人在这种情感驱使下，几乎是奇迹般地将他的材料整合了起来。在情感的控制下，心灵中相关的观念被提了出来，不相关的被排除了。显然，一种新的与理性主义美学完全不同的关于艺术创造的观念，在这里出现了。</p>
<h3 id="8-2-趣味问题"><a href="#8-2-趣味问题" class="headerlink" title="8.2 趣味问题"></a>8.2 趣味问题</h3><p>对艺术得心理学研究要求在两个线索间做出区分，这两个线索是：</p>
<ol>
<li>艺术的起源或发生问题，即艺术创作过程的心理学</li>
<li>艺术效果方面得心理学，即艺术欣赏的心理学</li>
</ol>
<p>8.1 讲得大多是艺术创作过程的心理学，接下来要介绍艺术欣赏的心理学</p>
<h4 id="8-2-1-夏夫茨伯"><a href="#8-2-1-夏夫茨伯" class="headerlink" title="8.2.1 夏夫茨伯"></a>8.2.1 夏夫茨伯</h4><p><strong>「内在的眼睛」：</strong></p>
<p>夏夫茨伯的思想偏向普罗提诺的新柏拉图主义，夏夫茨伯认为：和谐是一个中心的主题一自然界的和谐由于是神所创造的，因而在道德品质上体现出自身，在其中特征与冲动得到了平衡与整合，也在艺术作品中体现出来。美与善是一致的，并且以同样的方式被为同样的能力所把握。</p>
<p>这是一种「内在的眼睛」理论，这种运用于人的行动与性情时称之为道德感官的能力，在被运用于自然或艺术这些外在对象时，被称为美感。</p>
<p>我们是否拥有一种「品味」美的官能，这个问题到了18世纪在审美经验主义那里变得极其重要，这种能力被称为「趣味」。并且自然存在绝对主义和相对主义的分裂。夏夫茨伯清楚地表示，趣味不是相对的，他认为审美感官像道德感官一样具有普遍的判断标准。</p>
<p><strong>审美态度：无关利害的审美静观：</strong></p>
<p>所有人的行动都是自私的吗？霍布斯认为是的，但夏夫茨伯则不这么认为。他提出了一个论点：一个人实际上从一个特殊的行动中获得快感这一事实，并不等于说那个行动就是自私的。对美的享受，是与占有的欲望完全分开的。</p>
<blockquote>
<p>想象一下，如果远处海洋的美令你入迷，出现在你头脑里的确实占有它，就像一位海军元帅征服大海一样，这个想法是不是有点荒谬。</p>
</blockquote>
<p><strong>扩展了审美的范围，承认除了美以外还有其他一些有价值的审美性质：</strong></p>
<p>随着朗吉努斯对崇高的反思（《论崇高》）被布洛瓦翻译，加上17世纪晚期一种有力的对自然和自然美的新的感觉的出现，一种新的思想出现了，夏夫茨伯就表达了这些思想。</p>
<p>夏夫茨伯认为自然与艺术一样可被当作审美关照的对象，观看和感受自然打开了人们的眼睛，是他们喜欢其荒蛮可怕的方面。从这种欣赏范围的扩大之中，发展出更为深刻的关于崇高的概念。他下面这一段话表达了这种思想：</p>
<blockquote>
<p>我认为，注视最伟大的自然对象就能给人以最大的喜悦：在宏伟的天穹，在星星们所栖居的无垠地带之下，没有什么比广阔的海洋和陆地上的高山更能给我带来快乐了。在这些事物的外观中，有着某种庄严肃穆的东西，带着伟大的思想和激情来启发着心灵；在这时，我们自然会想到上帝和他的伟大，想到无限者所具有的影子和外观。一切事物之中有了这种东西就过于巨大而超出我们的领悟力，以它们超越的量充实与压倒心灵，给心灵注入一种愉快的眩晕和赞叹。</p>
</blockquote>
<p>简单讲，自然的广袤无垠，对我们的理解力来说过于巨大了，提示人们想到了创造他们的无限者。</p>
<h4 id="8-2-2-约瑟夫·艾迪生"><a href="#8-2-2-约瑟夫·艾迪生" class="headerlink" title="8.2.2 约瑟夫·艾迪生"></a>8.2.2 约瑟夫·艾迪生</h4><p>艾迪生区分了两种审美快感：</p>
<ol>
<li>崇高，在他看来，「大」就是崇高，我们的想象力喜欢被一个对象所充满，或者想要去抓住超出它的能力的东西。我们在面对这无边无沿的视野时被投入到一种愉悦的震惊之中，在领悟他们时灵魂感受到一种兴奋的静默和赞叹。</li>
<li>他说的第二种快感远没有崇高那么清楚：「通过人为的音符组合，可以产生混合的、不完善的、源于想象的关于自然的观念」</li>
</ol>
<h4 id="8-2-3-哈奇生"><a href="#8-2-3-哈奇生" class="headerlink" title="8.2.3 哈奇生"></a>8.2.3 哈奇生</h4><p>强调了道德感官：</p>
<p>他说我们应该将我们接受这些思想的力量成为「内在的感官」，因为有很多人有很好地视听，但依然不能感受到美，因此它们缺少某种感官或「趣味」。</p>
<p>感知美的能力可以被称为一种「感觉」，因为他所产生的快改并非来自任何原理知识。美的观念立刻而直接地打动我们。由此而更进一步的关于对象的知识可以添加理智或实践方面的独特快感，但却不能进一步增加或减少那种专属于美的感受和快感。</p>
<p>他还说，美感只要存在，就都是按照同样的规律在运作。因此，这就为一种非相对主义的审美判断标准奠定了基础。</p>
<p>关于美：</p>
<blockquote>
<p>哈奇生建议在“绝对的或独创的美”（这时对象独立于任何与其他物的对比之外）与“比较的或相对的美”“我们从对象中感知到的，一般被认为是某种其他物的模仿与相似物”一之间作出区分(第15页)。比较的美是建立在“一种原理与复制之间的统一”(第40页)，并且这种原型并不一定要有美在其中</p>
<blockquote>
<p>我们所称之为对象的美，用数学的语言说就是，似乎是处于一致与多样性的复合的比例之中；因此，当身体的一致达到之时，美就成为其多样性，当多样性达到之时，美就成为其一致。</p>
</blockquote>
<p>那些包括了无穷集的图形与曲线的数学定理，那些具有丰富解释力量的原理，也从同样的特征中衍生出它们的美(第3节)。不仅在艺术中，而且在自然中，都存在着概括化的过程；</p>
</blockquote>
<h4 id="8-2-3-休谟"><a href="#8-2-3-休谟" class="headerlink" title="8.2.3 休谟"></a>8.2.3 休谟</h4><blockquote>
<p>P163-167 没看懂…</p>
</blockquote>
<h3 id="8-3-审美性质"><a href="#8-3-审美性质" class="headerlink" title="8.3 审美性质"></a>8.3 审美性质</h3><p>在18世纪的英国，理解和解释我们关于艺术的努力有两条根本的线索：</p>
<ol>
<li>「趣味」：要求考察批评家评语的性质，直至批评家判断的性质及其合理性，从而涉及一种规范性的研究。</li>
<li>审美性质：关于「美」「崇高」，要求对这些思想家所辨认出的占主导地位的审美性质进行分析。</li>
</ol>
<blockquote>
<p>什么是审美性质？</p>
<p>审美性质就是能提供审美满足的性质，如美、崇高、生动…</p>
</blockquote>
<h4 id="8-3-1-威廉·荷加兹"><a href="#8-3-1-威廉·荷加兹" class="headerlink" title="8.3.1 威廉·荷加兹"></a>8.3.1 威廉·荷加兹</h4><blockquote>
<p>荷加兹从简化视觉的美的问题开始。他认为，我们所见到的实体与形状的美，可以被归结为各种各样的线条的美，而如果我们能够对线条的美加以分析，就能对所有视觉的美进行解释。线条的美是在六个特征一合适、多样性、一致性、简单性、复杂性，以及量或尺寸一的结合中产生的。</p>
<p>合适在确定美的种类时特别重要赛马的美与战马的美不同(第1章，第33页)。多样性与复杂性联系在一起，一致性与简单性被认为是它们的限制或秩序因素，量则起强化的作用。荷加兹构想和提议一种线条最适合于体现这种标准，波浪线是“美的线条”，它在三维空间中的蛇形的对应物则是“优雅的线条”，它给美增添一份优雅(第10章；第68页)。这些线条不同于那些“低劣而乏味”的线条，后者缺乏足够的多样性和复杂性（曲率），也不同于那些“粗笨而拙劣”的线条，因为它们缺少足够的一致与简单性一它们太扭曲与臃肿(第9章，第65页)。</p>
</blockquote>
<h4 id="8-3-2-埃德蒙·博克"><a href="#8-3-2-埃德蒙·博克" class="headerlink" title="8.3.2 埃德蒙·博克"></a>8.3.2 埃德蒙·博克</h4><p><strong>论崇高</strong></p>
<p>博克对美与崇高之间的区分基于他对两种令人愉悦的感觉的区分：正面的「快感」与「痛苦的去除或减少」，他将后者成为「欣喜」。</p>
<p>激情与自我保存联系时，就开启了「痛苦与危险」；当我们有痛苦与危险的观念，而又不是实际处于那种环境时，就有了欣喜，所有激发这种欣喜的对象称为「崇高」。</p>
<blockquote>
<p>任何种类的、适合于激发有关痛苦和危险观念的事物，也就是说，任何可怕的，或者与可怕的对象有关的事物，或者一种类似于恐怖的运作，都是崇高的源泉；也就是说，它能够产生心灵所能感受的最强烈的情感。</p>
</blockquote>
<p>这里区分了三个不同的概念，也对“源泉”这个术语作了限定。一个对象要激发崇高的感受，就必须或者是恐怖的，或者与实际的恐怖事物联系在一起，或者具有某些特性，事物通过它“以一种类似于恐怖的方式来运作”。恐怖性(直接的、间接的、类比的)在其痛苦由于获得了安全而被控制和减少之时，激发了崇高的感受与特殊的欣喜。</p>
<p>其次是研究这些事物的感性性质，某些性质使得对象恐怖：</p>
<ol>
<li>想要恐怖，朦胧是必要的，因为害怕会由于无知而增加。</li>
<li>力量、匮乏与空虚、以及尺度的巨大，也对崇高的激发起重要的作用。</li>
</ol>
<p>博克还指出，“眼睛并非是仅有的可产生崇高的激情的感觉器官”，还存在着高亢的音乐，“嗅觉与味觉在关于‘大’的观念中，也有一份额，但那只是很小的份额”：当然还有崇高的诗，博克在书的第5部分对此作了论述，并总结出一种理论：诗用一种情感式的语言产生其效果。</p>
<hr>
<p>社会的激情也具有两种类型：</p>
<ol>
<li>第一种是对女性美的爱，这其中混合着欲望的成分；而“美”是指“事物的这种性质将我们导向一种爱情与温柔感，或者某些其他的、最与它们相似的激情”。爱的快感是正面的。</li>
<li>第二种社会激情是同情，其本性是“将我们放在另一个人的位置上，而不管他所处的环境如何，从而以类似的方式影响我们”，所提供给我们的或者是痛感，或者是快感，或者是欣喜。</li>
</ol>
<hr>
<p><strong>论美</strong></p>
<p>美的分析与崇高的分析具有相似性：博克考察了“形体的某个或某些性质，通过它们产生爱或某种与之相类似的激情”，对女性美的反应（去除欲望）在这里可被当成范例，正像对恐怖的反应（去除畏惧）成为崇高的范例一样。</p>
<blockquote>
<p>个人猜测：</p>
<p>对恐惧感到害怕，去除畏惧之后会感到欣喜；类似的：对于女性美的爱，去除欲望成分后，「事物的这种性质（女性美）将我们导向一种爱情与温柔感，或者某些其他的、最与它们相似的激情”。爱的快感是正面的。」</p>
</blockquote>
<p>博克经过仔细的分析，批驳了对这个问题的两个熟悉的回答：美在于“各部分间的比例”—对植物与动物考察发现，对于美来说不存在任何比例的组合是充分和必要的：<strong>美是由合适所产生，或由合适而构成。导致美的性质是小、光滑、逐渐的变化、精巧。</strong>博克附带对两种与美不同的审美性质作了简短的分析，这两种性质就是优美性和高雅。他还略微提到了触觉的美和声音的美。<strong>最后的结论是，美与崇高在许多情况下是对立的，但是，一个复杂的艺术作品可以包含二者，尽管不大可能二者都很强，因为一部作品会强调其中一个方面。</strong></p>
<p>博克带来了一种重要的，在美学史上曾带有几分新意的思想：对审美欣赏的解释要在生理学层面寻找。</p>
<hr>
<p>向浪漫主义的过度：</p>
<p>对审美感受的心理学研究以及对崇高的热情，给予新古典主义批评的最后一击。确定的规则与典范让位于对个人的、人际间的以及培养成的趣味的强调。伴随着对更强的更少的受控制的情感的欢迎，出现了对<strong>天才</strong>的赞美。这是一种浪漫主义以前的对想象或直觉的真理的强调，被看作是某种凌驾于理性之上的东西。</p>
<hr>
<h4 id="8-3-3-一些琐碎的思想"><a href="#8-3-3-一些琐碎的思想" class="headerlink" title="8.3.3 一些琐碎的思想"></a>8.3.3 一些琐碎的思想</h4><p>详见P173-178</p>
<hr>
<h4 id="8-3-4-阿奇博尔德·艾利森"><a href="#8-3-4-阿奇博尔德·艾利森" class="headerlink" title="8.3.4 阿奇博尔德·艾利森"></a>8.3.4 阿奇博尔德·艾利森</h4><p>艾利森的第一个主要论题是趣味的快感，即对自然或艺术中的美和崇高的欣赏，<strong>发生在“当想象被用来处理一个有规则的情感观念的序列之时”。那么，第一个论点是显示，一个对象要想被审美地欣赏，就必定要引发一连串联想的观念。这个论点是归纳性的，既彻底又精确。</strong>首先，“当我们感到自然景色的美或者崇高一春天早晨的欢乐色调”等时，“我们在心灵之中意识到了各种各样的意象，这与对象本身所能呈现给我们的眼晴的完全不同”。其次，当对象引发联想链的能力受到阻碍之时，例如我们关注悲伤之事或实际事务之时，或者当我们扮演着批评家而非欣赏者的角色之时，或者当我们想象能力非常有限之时，就不会感觉到审美欣赏。第三，审美欣赏的强度因对象所激发的联想的数量和多样性的不同而不同。</p>
<p>想象序列是审美欣赏的必要条件，却不是充分条件：观念还必须具有“情感上的生产性”；并且该序列本身必须具有一个单一的“联系原理”以便使整个的序列结合在一起，而不只是由相互分离的联系环节连接(1，ⅱ)。这里，细致的归纳命题再次被提取出来，以证明两点：“实际上，只有对某种简单的情感具有生产性，对象或对象中的性质才能被感受为美的或崇高的”(1，ⅱ，2;1,81)一包括任何简单的情感一并且，在成功的艺术作品之中，存在着一个占主导地位的性质或情感，这使得它们成为一个整体。结论是，“快感…它陪伴着趣味的情感，不可被看是简单的，而应被看成是复杂的快感”(I,结论；I,169).<br>随之而来的是“物质的性质本身不被认为是崇高的或美的，但只是这样一种性质一由于我们本性的构造，适合于产生愉悦或有趣的情感一的符号或表现”。艾利森并不否认，色彩与声音本身，甚至荷加兹的曲线，可以产生“使人愉快的感觉”，但他坚持认为，色彩的美来自于它们的表现性，而它们的表现性来自于联想。“例如，紫色获得一种高贵的性质是由于偶然地与国王的衣服联系起来的结”。并且，他通过一种机智的实验性比较，指出甚至荷加兹的原理也不是根本性的，因为当他的线条是美的时候，它们的美不是纯粹形式的，而要依赖于表现。</p>
<p>艾利森体系放弃了为美的感觉条件发现一个纯粹的形式，并为美的不确定范围打开了可能。</p>
<p>从艾利森的体系下，可以衍生出一些批评的原理：因为联想序列的连续提供真正的审美快感，「连续」使得艺术作品的结构变得十分重要。例如，这个原理会支持戏剧中的「三一律」的任何一条都十分重要。</p>
<h2 id="Ch-9-德国唯心主义"><a href="#Ch-9-德国唯心主义" class="headerlink" title="Ch 9 德国唯心主义"></a>Ch 9 德国唯心主义</h2><h3 id="9-1-康德"><a href="#9-1-康德" class="headerlink" title="9.1 康德"></a>9.1 康德</h3><p>Immanuel Kant （1724年4月22日—1804年2月12日）</p>
<p>康德希望提供一种关于审美判断的理论为显然具有主体间有效性提供证明，避开怀疑主义与相对主义的诱惑。他是第一位使得审美理论变成一个哲学体系的组成部分的现代哲学家。</p>
<p>在探讨了前两个《批判》中的既有经验的，也有先天的各种各样的命题之后，康德发现，在他手中仍留存着两类相当令人困惑的命题，它们在认识论中的地位还没有得到澄清。这就是审美判断（特别是关于崇高的判断和关于美的判断），和审目的判断（关于目的的判断）。第三个《批判》就承担了这项任务，即通过对判断的能力(Urteilskraft)本身的进一步考察来研究这些问题。</p>
<p>在纯粹理性批判中，审美判断的官能被解释为特殊的感觉-直觉，而被归入知性（Verstand）下。</p>
<hr>
<h4 id="9-1-1-审美判断-趣味判断"><a href="#9-1-1-审美判断-趣味判断" class="headerlink" title="9.1.1 审美判断/趣味判断"></a>9.1.1 审美判断/趣味判断</h4><p>康德改造了「趣味(Geschmack)判断」这个来自经验主义者的重要概念，使之成为他的美学体系的基石。他从对两种判断的区分开始：</p>
<p>有两种判断，分别是审美判断，和逻辑判断，它们的区别如下：</p>
<ol>
<li>逻辑判断(“这是红的”)表示对象的一个表象(Vorstellung)是它的属性。</li>
<li>审美判断将表象指向“主体，及其愉快与痛苦的感受”；这是一个判断，“其规定根据只能是主观的”。其次，绝大部分审美判断只是快感，或满足感的报告(“这是令人愉快的”，“这是使人感到兴奋的”)。</li>
</ol>
<p>但是，有些审美判断是趣味判断，被定义为“判断美的官能”。趣味判断的独特特征在于所报告的满足是“无利害的”。当我们从一个对象所获得的满足与它所具有的欲望，或与拥有它的欲望联系在一起时，这种满足就叫作“利害”。康德坚持说，趣味判断“只是观照性的”；它不是一种认识性的判断，因为它完全不形成概念，或与概念构成联系。对美的满足“是仅有的一种无利害和自由的满足”。</p>
<h4 id="9-1-2-审美判断为何具有普遍性？"><a href="#9-1-2-审美判断为何具有普遍性？" class="headerlink" title="9.1.2 审美判断为何具有普遍性？"></a>9.1.2 审美判断为何具有普遍性？</h4><p>如果审美满足，对美的欣赏能够追寻到普遍可能的心灵状态的话，审美判断的普遍性就能得到证实。</p>
<p>康德利用了他在《纯粹理性批判》中感性与知性的概念。具体的认识行动涉及具体的表象与具体的概念的联结它们要求想象力与理解力的确定的关系。但是，这些行动预设了一个不确定的一般关系一两种认识官能的潜在和谐。这时，<strong>当它们正如人所说的那样空闲下来，不再严肃地指向着对知识的追求，这些官能可以在某种意义上玩弄知识，欣赏着它们间的和谐，而不被束缚在具体的感觉一直觉，或者概念之上。</strong>这就形成了一种心灵的状态，在其中有着“在一个特定的表象之中的一种再现的力量与对一般认识的指称之间的自由游戏的感受”。在这种状态中，<strong>心灵在两种认识官能的和谐中取得强烈的快感或满足感。这种快感正是美的经验。</strong>我们判断为美的对象是那种其形式或秩序原理引起“更为生动的两种心理力的游戏”以及一种对它们的和谐的强烈意识。由于所有理性生物都能够获得这种心灵状态，在此情况下，美是所有人都可分享的。</p>
<p>（这种和谐从何而来呢，请见9.1.3） </p>
<h4 id="9-1-3-无关利害的快感从何而来？"><a href="#9-1-3-无关利害的快感从何而来？" class="headerlink" title="9.1.3 无关利害的快感从何而来？"></a>9.1.3 无关利害的快感从何而来？</h4><p>「没有目的的和目的性」：对象无需受到目的支配，但我们只有将它当作受目的支配才能理解它。</p>
<blockquote>
<p>但一个客体，或者一种心灵状态，甚至一个行动，尽管它们的可能性并非必然以一个目的表象为前提，却被称为合目的的，这仅仅是因为我们只有把一个按照目的的因果性，即把一个按照某种规则的表象来这样安排它们的意志假定为它们的根据，才能解释和理解它们的可能性。</p>
</blockquote>
<p>趣味判断与目的性具有密切的联系。给予我们审美满足的“只是在对象借以给予我们的那个表象中的合目的性的单纯形式，如果我们意识到这种形式的话”。<strong>表象中的形式上的合目的性激发了两种认识官能的和谐活动。</strong></p>
<p>对象的形式先验地与两种认识官能的和谐感受联系在一起；并且对这种和谐的感受恰恰就是无利害的快感本身。 </p>
<ul>
<li>这种无关利害的快感，会导致一种特别的利害关系，即一种保持它的欲望，「留连于美的观照」。</li>
<li><p>并没有一种客观的形式规则，将美的事物与不美的对象区分开，「因为审美快感既不是感性的，也不是理智的，而是其他某种东西。」</p>
</li>
<li><p>美的模态：或许没有人能保证一个趣味判断使所有其他人都同意。但是，它也许保证所有将自己的认识官能正确地与对象联系起来的人都能表示赞同。这种必然性，暗示了审美快感的「共同感」</p>
</li>
</ul>
<h4 id="9-1-4-论崇高"><a href="#9-1-4-论崇高" class="headerlink" title="9.1.4 论崇高"></a>9.1.4 论崇高</h4><p>对崇高的先验说明：崇高与美具有两点相同点：</p>
<ol>
<li>它们都是审美判断的谓词，逻辑形式上的单称判断，但却宣称具有普遍有效性。</li>
<li>它们本身都是及不依赖感性，也不依赖知性的一个确定的概念的快感。</li>
</ol>
<p>它们也有两点不同：</p>
<ol>
<li>美与对象的形式相关，因而具有限制性，崇高涉及一种无限性的经验。</li>
<li>美依赖于对象的合目的性，后者被那「可以说是强暴我们的想象力」的对象所激发。</li>
</ol>
<p>康德对崇高进行了区分，它们分别是：</p>
<ol>
<li>数学上的崇高——由极其巨大的对象打动我们所引起。</li>
<li>力学上的崇高——由对象对我们具有绝对的力量所引起。</li>
</ol>
<p>面对极其巨大的对象时，所产生的<strong>数学上的崇高</strong>：</p>
<p>当想象试图包含在单独一次直觉中的整个对象时，这个对象看上去的或被构想的尺寸将这种能力的使用绷紧到了极限。这些崇高的现象的直观带有他们无限性的理念，当这些理念被激发之时，理性要求它作为一种完成了的整体被给予，作为一个可能的经验被呈现。这正是二律背反的条件，它是不能被满足的。但是在尽最大努力去满足它之时，想象达到了它的能力的极限，在与理性的要求的比较中显示出自身的失败与不足，并使自己在对比中意识到理性本身的辉煌，所产生的感受就是崇高的感受。</p>
<p>这种崇高是我们被提醒具有一种「超越一切感官尺度的心灵官能」（即理性）时，人所具有的快感。崇高的对象尽管本身完全的无目的，但却是我们意识到「在使用我们的认识官能时有一种主观的合目的性」。理性当然没有给予我们一种超感觉的知识，只是通过要求我们的知识系统的完整性实施了一种对感官的理解力运作的调节功能，这只能通过达到事物本身来达到。我们在崇高中所赞美和欣赏的是我们身为理性存在物的伟大。</p>
<p>由对象对我们具有绝对的力量所引起的<strong>力学上的崇高</strong>，例如电闪雷鸣、飓风、火山喷发：</p>
<p>在面对向飓风一样具有绝对力量的事物时，我们意识到我们作为道德存在物的无限优越性，和我们在自然危险中，精神上的神圣不可侵犯性。因此「哪怕个人不得不屈服于那种强制力，我们作为人的人性仍然没有被贬低」。我们实际上所赞美的是我们的「目标」的崇高性。</p>
<h4 id="9-1-5-天才"><a href="#9-1-5-天才" class="headerlink" title="9.1.5 天才"></a>9.1.5 天才</h4><p>康德在对天才的分析中拾起了在他以前的一些思考，但给予它们以很大的推动：通过天才，“自然给艺术提供规则”：天才具有生产那种不可给定规则的东西的才能；独创性是他的基本属性；他不模仿，尽管他可以从例子那里得到启发；他的工作方式不可进行科学描绘。天才也是“审美理念”的官能。</p>
<p>「我把审美理念理解为想象力的那样一种表象，它引起很多的思考，却没有任何一个确定的思想，也就是任何概念能够适合于它，因而没有任何语言能够完全达到它并使它完全得到理解。」</p>
<h4 id="9-1-6-趣味的二律背反"><a href="#9-1-6-趣味的二律背反" class="headerlink" title="9.1.6 趣味的二律背反"></a>9.1.6 趣味的二律背反</h4><p>二律背反是：(1)正题：趣味判断不是基于概念；因为如果是基于概念的话，既然逻辑命题能够被用来争辩，它将允许争辩（这与上面提到的第一个命题相矛盾）。(2)反题：趣味判断是基于概念的，因为如果它不是如此的话，既然一般的同意也不能被要求，甚至争吵也不可能（并且这与第二个命题相矛盾）。</p>
<p>无疑，在这个二律背反中有人工做作的成分，正像在前面的《批判》中一样，但是，它能够帮助我们相当鲜明地突出康德美学理论的一些特征。<strong>这里的妥协在于显示出，“我们所指的这类判断的对象的概念在审美判断的两条准则中并不取同样的意思”。趣味判断不能被争辩，是因为它不是基于理解力的确定的概念；它能够被争吵是因为它基于不确定的概念，“仅仅是给对象（以及进行判断的主体）奠定基础的超感觉的（物自体）纯粹理性的概念”。</strong></p>
<h3 id="9-2-客观唯心主义"><a href="#9-2-客观唯心主义" class="headerlink" title="9.2 客观唯心主义"></a>9.2 客观唯心主义</h3><h4 id="9-2-1-席勒"><a href="#9-2-1-席勒" class="headerlink" title="9.2.1 席勒"></a>9.2.1 席勒</h4><p>弗里德里希·席勒（Friedrich Schiller，1759年11月10日—1805年5月9日）</p>
<p>席勒精读了康德的三大批判，发现了他需要解决的关于人与文化的一般问题，以及他在思考的关于自由的问题。</p>
<p>此外，席勒还提出了一个自柏拉图以来从未有人提出过的问题：在人的生活和文化中，艺术的最终作用是什么？</p>
<p>席勒说，人有两种状态，分别是（1）自然的或感性的状态，即人起初出现于其中的状态（2）理性的或道德的状态，即人处于他的自由而必须使自己进入的状态。为了在自身中获得人性（他的理性的本身），单个的人必须找到他的各种力量的和谐，而不是让一方压倒另一方。</p>
<p>但席勒环顾四周，发现缺乏这种和谐。他说，文明和文化的发展，必须有个人功能的专门化，才能与欲望的分化，需要发展人身上的各种内力，除了使这些内力彼此对立，没有别的方法。用杜威的话说就是：社会分工导致人被束缚在社会的碎片中，人也只好将自己塑造成碎片。他永远不能发展他的本质的和谐，他不是把人性印在他的天性上，而是仅仅将自己变成了他自己的职业和他的专门的知识的标志。（PS：这样的人不是完整的人，他甚至不知道自由是什么，又怎样是自己朝着自由状态下「理性的或道德的状态」前进呢？）</p>
<p>此外，人还有两种基本的内驱力，一种是感性冲动，它意味着要感知自己的生存，它将我们与大自然联系起来；「要求存在的现实性，我们的感知有内容，行动有目的」；另一种是形式冲动，人的自由的理性自我「将和谐带入到他的表现的多样性之中」。</p>
<blockquote>
<p>初读这段时，我觉得这两种内驱力与弗洛伊德的本我和超我很相似，以下是ChatGPT的解答：</p>
<p>席勒的感性冲动（Stofftrieb）与形式冲动（Formtrieb）和弗洛伊德的本我（Id）和超我（Superego）虽然有一些相似之处，但本质是不同的。</p>
<p>席勒的感性冲动与形式冲动是由精神对现实的两种不同需求所驱动的冲动。<strong>感性冲动是对物质世界的物质性和个体欲望的需求，而形式冲动则是对理想形式、完美和普遍性的追求。</strong>在席勒看来，感性冲动和形式冲动这两种冲动是不可分割的，二者相辅相成。</p>
<p>而弗洛伊德的本我和超我则是心理结构的两个重要组成部分。本我是我们总体的感性冲动和基于本能的追求，包括我们的欲望和冲动，而超我则是内化了社会性和文化性要求的内在象征和规范，是我们的道德标准和规则。弗洛伊德认为，本我和超我互为制约，在某种层面上，超我强加给本我的限制和规则可能会压抑甚至扼杀我们的本能和欲望。</p>
<p>虽然这两个理论都提到了两个相互对立的概念，但感性冲动和形式冲动更注重个体内部的体验，而本我和超我则是更多地强调社会和文化因素。因此，它们虽然有一些共通之处，但在理论框架和核心概念方面还是有所不同。</p>
<p>PS：这样看，席勒的感性冲动与形式冲动，更像我理解的现实与理想的关系。</p>
</blockquote>
<p>这两种内驱力是相互对立的（就像对理想的追求往往与现实生活的压力相冲突），那么怎样才能调和两者，回复人的天性的统一呢？</p>
<p>席勒的答案是，通过扬弃感性冲动与形式冲动，形成席勒所谓的「游戏冲动（Spieltrieb）」，游戏冲动的反应对象就是美。席勒将美描绘为「外观中的自由」，在可感的对象中的自我确定的样子（个人理解，在固定的质料中，自由地追求其理想的模样，因此看起来是美的）。</p>
<p>谈到游戏，他说<strong>游戏是一种审美标志，是更高精神上综合的暗示，因为在游戏中，自由与必然结合，进入到游戏中的人自愿地服从于规则并从中取得乐趣。</strong>「只有当人是完全意义上的人，他才游戏；只有当人游戏时，他才完全是人」因此「正是通过美，人们才可以走向自由」。</p>
<blockquote>
<p>以下仅是我个人的思考与推测：</p>
<p>美是如何起作用的呢？</p>
<p>因为美的事物是在物质世界，受质料限制，却自由地成为了其理想模样的事物。因此这会激发游戏冲动，就是自愿服从规则，并从规则/限制中逐渐实现其理想的冲动。</p>
<p>再更进一步，现实一点，我觉得有时候，无论如何，人都不可能某种特定的工作中得到快乐，自我实现的。正因此，人才需要拥有享受闲暇的人权，这样才能调和理想与现实，追求这种规律的，工作与生活分开的生活方式，才是游戏冲动。</p>
<p>也许可以说，人需要文艺作品，提醒自己保持游戏冲动，保持规律的生活下追求自由的生活方式。举一个现实点的例子，当我看到一幅美丽的插花作品时，我会想到一个整洁的房间里，摆放着这副规律的插画作品，我在这房间里，自由地阅读。这可能有些艾利森的联想主义的色彩，但这确实激发了我的游戏冲动。</p>
</blockquote>
<p>这也就回答了艺术/美的作用，通过美我们才可能的范围内实现我们作为人的理想性。</p>
<p>审美经验：最高的审美享受是精神在它的所有力量的活泼地游戏时的自由。</p>
<hr>
<p>席勒审美理论中一个能解决的矛盾：审美状态仅仅是过渡性的。他开始于这样的文化问题：人怎样才能从感性状态过渡到理性（道德）状态？他的一个主要论点是，艺术通过提供一个中间的路线或中间状态而使两者的结合成为可能。艺术部分是通过教育人们“观照”来做到这一点的，</p>
<p>艺术使反思成为可能；艺术鼓励一种对外观(Schein)的兴奋，一种从感性世界的超脱而不是对它的放弃：“因此，我们在什么地方发现有对纯粹外观作无利害关系的自由欣赏的痕迹，我们就能推断出那里人的天性已发生了这样一场变革，人身上的人性已真正开始。</p>
<p>“除了首先使人成为审美的以外，没有其他的办法使感性的人变成的理性的”。从这个观点出发，美只有一个功能，解放人，使他实现更高的自我。但是，随着这个观点的发展，以及游戏冲动变成更为具体，审美的状态出现了，它不只是通向人的更高状态的一个台阶，而是它的一个组成部分。只是在这种状态中，人的感觉与理智的方面才能保持和谐的关系，并且只是通过一种持续的美的经验，政治制度才能将自由与秩序结合起来。</p>
<p>没有人比席勒更强调对人的审美教育。</p>
<blockquote>
<p>PS：如何理解呢，想象一个被欲望支配的野蛮人，当他第一次看见一个美的作品时，他可能会想，为什么这件作品相对比其他事物能这么漂亮，我是不是也有这种改善的可能呢？这样他可能就开始了自我实现之路。</p>
</blockquote>
<h4 id="9-2-2-谢林"><a href="#9-2-2-谢林" class="headerlink" title="9.2.2 谢林"></a>9.2.2 谢林</h4><blockquote>
<p>又是一个难懂的哲学家，这本书也没有写清楚，这里只能简单摘抄几句话了。</p>
<p>谢林成为浪漫主义运动中被激活和产生影响的哲学家。</p>
<p>在此前的著作中，谢林曾提出“自然哲学”，在同时代的诗人和批评家中反响很大。他试图通过构想自然本身是思想的无意识的形式，具有进化出人的有意识的思想的能力，以排除自然与精神的对立。在他的思想发展的第二阶段，自我与自然的关系被更深刻地感受到，先验哲学的任务被看成正是要通过从理性中推导出自然的方法，在这个鸿沟间架起桥梁。</p>
<p>他说，在《先验唯心论体系》中，存在着一个后康德哲学的根本“矛盾”：<strong>要想使我们的思想成为真实的，就必须对之加以改造，以符合对象；但是，如果要有道德的追求的话，对象又必须符合思想，即服从于我们意志。不管是理论的，还是实践的（即伦理的）哲学都不能克服这个困难；所需要的是另一种展示在自然与自我之间的潜在和谐的方法。</strong>谢林假定我们在自然中发现的形式(有机体、结晶体，等等)，尽管是无意识的，却是由一个创造过程产生的，我们在自己的身上也发现了这同样的创造性；而这正是所寻求的和谐。</p>
<p>他将艺术生产构想成一种独特的过程，它开始于一种意识与无意识之间的内在矛盾，通过将智力本身客观化到了一个统一了自由与必然的产品之上而解决这个矛盾。在进行这个过程而得到（以及对其结果的观照）的满足之中，我们领悟到自我与自然的无限和谐。</p>
</blockquote>
<h4 id="9-2-3-弗里德里希·施莱尔马赫"><a href="#9-2-3-弗里德里希·施莱尔马赫" class="headerlink" title="9.2.3 弗里德里希·施莱尔马赫"></a>9.2.3 弗里德里希·施莱尔马赫</h4><p>弗里德里希 · 施莱尔马赫（Friedrich Schleiermacher）</p>
<p>他也对<strong>艺术创造的过程</strong>相当关心，并以一种彻底的情感主义的方式对此进行了阐释。照他的观点看来，艺术是自我表现，这在同时也是自我意识，是一个情感的外在化（传达不是艺术的一个本质的方面）。施莱尔马赫比其他的思想家更进一步地贯彻的这个观念，即艺术冲动具有“自由的生产性”，不受它自身以外的目的或外在的要求所召唤或强迫；在这方面，它就像做梦一样，是意象的自由生产。因此，艺术独立于道德和认识状况之外；它自成一格。</p>
<h4 id="9-2-4-黑格尔"><a href="#9-2-4-黑格尔" class="headerlink" title="9.2.4 黑格尔"></a>9.2.4 黑格尔</h4><p><strong>黑格尔的客观唯心主义</strong></p>
<p>黑格尔的哲学体系：现实是精神（Spirit）或心灵（Geist）——一个系统性的整体（a systematic whole），通过思想活动的自我展开，产生的结构和历史和其他一切事物。</p>
<p>Spirit articulates(表达清楚，详见<a href="https://www.merriam-webster.com/dictionary/articulate">Articulate</a> ) itself necessarily in certain basic categories of thought</p>
<blockquote>
<p>黑格尔认为精神是广泛而复杂的，它包含了世界的本质和人类思维的内在结构。精神通过思维来表达自己，思维是精神活动的基本形式。在这种观点下，思维范畴可以认为是精神自身在思考和理解世界时所使用的基本工具。</p>
</blockquote>
<p>在精神自我进化的途中，他必须经过「自我梳理」「异化」或「外在化」的过程，Which is Nature——the object of empirical science. 但精神最终还是在一个自我认识的过程回到了他自身，on a higher level, in three grades of self-realization-Subjective Mind(the individual self), Objective Mind, and absoluate Mind.</p>
<blockquote>
<p>ChatGPT:</p>
<p>根据黑格尔的观点，精神是与世界相互作用和发展的。在这个过程中，精神通过不断的辩证运动来认识和变化。异化或外在化是指当精神感知和经验到与自身本质有所背离的现实或对象时，它将自己投射到外部世界，并与之相对立。这种外在化可以体现为个体与社会、主体与客体之间的分离和对立。</p>
<p>这种对立状态最终会推动精神一方面超越与外部世界的对立，另一方面回归到自己内部的本质。这个回归被称为”合一”，也就是通过对立的消解和超越，精神重新与自己内在的本质融为一体。</p>
<hr>
<p>根据黑格尔的观点，精神的自我实现经历了三个等级：主观精神（个体自我）、客观精神和绝对精神，它们代表了精神发展的不同阶段和层次。</p>
<ol>
<li>主观精神（Subjective Mind）：这个等级关注的是个体的主观经验和自我意识。个体意识、感知、情感、欲望和理性等都属于主观精神的范畴。在这个阶段，个体通过思考和内省来探索自己的内在世界，并通过感受和经验来与外部世界互动。</li>
<li>客观精神（Objective Mind）：这个等级涉及到社会和文化等客观存在形式。客观精神包括了法律、道德、伦理、社会制度、艺术和宗教等社会文化的范畴。在这个阶段中，精神通过参与社会和文化实践的过程中来实现自身。个体与社会规范和价值体系的共同性建立了联系，并且通过参与这些共同实践来找到个人自由和实现个人的目标。</li>
<li>绝对精神（Absolute Mind）：这个等级是精神自我实现的最高阶段，也是个体和社会的统一。绝对精神是对主观精神和客观精神的整合，代表了全面而完整的精神体验。它涵盖了哲学、科学、艺术等领域的综合，并追求对真理和普遍意义的认识。在绝对精神中，个体和社会的目标、价值和意义达到了最高的和谐一致。</li>
</ol>
<hr>
<p>“精神”是一个既超越了个人的主观经验，也超越了客观的社会和历史条件的存在。它既包含个体的内在精神世界，也涵盖了社会和文化范畴的客观规范和价值。</p>
</blockquote>
<p>我们通过思想的范畴（The categories of thought）去把握绝对。绝对（Absolute）也通过思想的范畴与自己无限的内容相协调，这些无限的内容根据其丰富性可以从单纯的存在到被黑格尔成为「理念，Idee」的东西。</p>
<p>所有这些endless variety concepts in which thought can articulate itself 被分为两种，一种是“Abstract universals”，另一种是“Concrete universals”。前者为了普普通通的目的，将物体根据commonly shared universals分组或分类。后者则部分地把握了absolute。</p>
<p>在《逻辑学》的最后一个部分，观念以其全部地意义展现自身，成为理念，被定义为「自在自为的真理，是观念和客观性的绝对统一」。为了理解这样的统一，我们必须记住：从绝对的观点看，我们所作出的在我们的思想与我们所想到的对象之间的必要的区分，只有在哲学智慧的最低等的阶段才是有效的；归根结底，真理是绝对所具有的关于它自己的知识。观念变得越丰富，越具体，它就越是趋向于现实；在理念中，并且最为特别的是在绝对的理念中，观念与真实是结合在一起的。</p>
<p><strong>黑格尔的美学</strong></p>
<p>艺术基本的与本质的功能就是：「揭示在艺术的感性或物质的外形下的真理，其他一切可能的功能都对之具有从属性。这种揭示就是美——理念的感性显现」</p>
<p>那么，每一件艺术品，在它获得美之时，都涉及质料和内容，感性的显示与所体现的思想的协调。因此，作品的优秀“就将依赖于观念与外形在一个精心设置的融合中亲近与联合的程度”。以这种方式发现其充足的感性实现的理念，艺术地体现的理念，被黑格尔称为“理想”</p>
<p>黑格尔很清楚地说明：“艺术美高于大自然的美”,并且，这是他对美学的进步所作的重要贡献之一。自然美上面有着理念的印记，但却远比直接来自于人的精神的作品要模糊而低下。“比起艺术的产品来，心灵更难打破大自然和日常世界的坚硬的外壳以达到理念。”人的艺术创造抓住了精神的价值，并以“更大的纯洁和清晰性”俘获了它们。“并且，由于这个原因，艺术作品具有比任何大自然的产物更高的等级。”</p>
<p>在他的最终估价中，黑格尔使艺术与宗教和哲学一起，成为三种理解绝对的方式，也是绝对理念的三种自我展现的方式。他说，在艺术中，我们以其“直接性”而把握精神。</p>
<p>按照他的理论，既然在每一件艺术品中，总是有感性材料与精神的内容，在这两个方面之间可以区分出三个基本的关系。在以早期和东方文化为特征的象征型艺术中，理念为媒介所压倒，媒介尽力要表现它却不能成功。在古典型艺术中，理念与媒介处在完美的平衡之中。在浪漫型艺术中，理念统治着媒介而精神化已完成。与这些区分相适应，还有进一步的，更精细地发展了的，对各门艺术本身的按层次的分析(见Ⅱ和V)。建筑是象征型艺术的范例；雕塑是古典型艺术的范例；而浪漫型艺术冲动在三种艺术中表现得最为充分，依据从感性媒介向纯粹思想的自由的进步阶梯而划分绘画，它由于仅有二维而物质性少于雕塑；音乐，它脱离了空间；以及诗，它最接近理念。</p>
<h2 id="Ch-10-浪漫主义"><a href="#Ch-10-浪漫主义" class="headerlink" title="Ch 10 浪漫主义"></a>Ch 10 浪漫主义</h2><p>浪漫主义是19世纪前期占统治地位的思想潮流。但是「浪漫主义」这个词并没有确定和标准的意思，尽管在今天比在浪漫主义者自身那里要明确一点。</p>
<h3 id="10-1-浪漫主义的特点"><a href="#10-1-浪漫主义的特点" class="headerlink" title="10.1 浪漫主义的特点"></a>10.1 浪漫主义的特点</h3><p>浪漫主义是一个内涵丰富的思想潮流，在这本书中，作者认为对本书的读者来说，只需要关注浪漫主义的三个特征：</p>
<ol>
<li>浪漫主义的来临涉及一些基本价值的改变，包括对艺术作品，特别是文学，的性质的估价。观看新的审美图景的眼睛被打开了，人们对于诗中所要求的东西的新理解，也带来了对诗的重新评价。</li>
<li>浪漫主义的一个重要因素是他的认识论，这是一种情感直觉主义，被看成是取代或纠正此前占统治地位的理性主义或经验主义。</li>
<li>浪漫主义根据一些过去不被强调的思想范畴来思考现实和艺术，例如柯尔津治关于心灵的有机体理论。</li>
</ol>
<p>下面的内容是作者对浪漫主义的补充：</p>
<ol>
<li><p>在艺术的创造与欣赏中，感受到的性质被给予了更多的关注，甚至古典的秩序和平和中的形式与对称也被牺牲了。在审美的理论中，它意味着几样东西。好的或伟大的艺术的范围被拓宽，将这样一些作品包括在内，这些作品在形式上的相对放松被认为由个人情感的更具刺激性和更加个人化的展现所抵消；这条途径是由18世纪的“崇高”所准备的。<strong>艺术生产逐渐被构想成本质上是一种自我表现的动作；而批评家们，随着时间的推移，越来越关心艺术家的真诚性，关心他们的传记的细节，关心他们的内在精神生活。</strong> </p>
</li>
<li><p>【浪漫主义的诗】在18世纪7o年代，J.G.祖尔策(J.G.Slzr)在他的美学百科全书式的四卷本著作③中，曾写道：“诗人是…通过他的对象放入一种激情，或者至少某种情绪；他不能抵抗表述他的感受的强烈欲望；他被陶醉”</p>
<p>在浪漫主义的诗的观点中，这一信条占据了核心和首要的地位。模仿论被放到了一边，或降居从属的地位，取而代之的是一种表现论。诗人的心灵状态，他的情感的自发性和强烈性，成为关注的焦点。华兹华斯在18o0年所发表的《抒情歌谣集》序言中说，「所有的好诗都是强有力的感受的自发地流淌」。</p>
<p>与亚里士多德的「疏泄」的对比：亚里士多德的“疏泄”(katharsis)理论（正如人们一般所理解的）是一种情感主义的理论，但是，关注这样一个对比是很重要的：在浪漫主义者看来，诗首先是诗人的疏泄，然后才是为读者疏泄。雪莱说，诗人是一个被人无意听到的夜莺，“他们坐在黑暗之中，用甜美的声音排遣自己的孤独”</p>
</li>
<li><p>【文学/诗与音乐的类比】一个有趣的标志是从文艺复兴到18世纪晚期的美学家的心灵中如此重要的诗与画的类比一诗画一律原理，这时（首先在德国）让位于一种新的类比关系：人们越来越感到，音乐才是诗的真正的姐妹，因为音乐是诗所要表达的感受，特别是渴望的感受的最完整、最纯粹，也最突出的表现。</p>
</li>
<li><p>【浪漫主义更加关注艺术家】情感表现理论给浪漫主义的艺术方法带来了一个根本的转向：这时，至关重要的不再是作品本身，而是它后面的人。卡莱尔给这种新的观点提供了最简明的陈述：莎士比亚的作品“是许多扇窗户，通过这些窗户我们可以瞥见他的内心世界”。（请注意）不是（像文艺复兴时期的画家那样打开）一扇窗户，我们通过它可以看到世界，或者现象背后的另一个世界，甚至普遍的人的本性；而是这样的窗户，我们从中看到创造者个人的内在生活和个性。</p>
</li>
<li><p>【浪漫主义对艺术批评的影响】这种将诗归结为感受的做法，可能会导致这样的结论：理性的批评是不可能的；瓦肯罗德尔指出，对作品只可能或只适合于在过程中感受它。“在感受着的心与调查研究之间存在着一个永远敌意的鸿沟。感受只能被感受所把握和理解”。这也许会导致弗里德里希·施莱格尔的早期观点，<strong>即只有诗人才能懂诗，批评家的艺术判断应该本身就是一件艺术品</strong>。</p>
<p>此外，诗人的真诚也被看作诗重要的批评标准「华兹华斯认为，诗人真诚是非常重要的；基布尔将真诚性看成是批评评价的基本标准」。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>美学</tag>
      </tags>
  </entry>
</search>
