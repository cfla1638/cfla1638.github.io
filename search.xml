<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ OOP</title>
    <url>/2022/09/29/C-OOP/</url>
    <content><![CDATA[<h1 id="C-OOP"><a href="#C-OOP" class="headerlink" title="C++ OOP"></a>C++ OOP</h1><h2 id="C-的类"><a href="#C-的类" class="headerlink" title="C++ 的类"></a>C++ 的类</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。</p>
<p>在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用</p>
<p><strong>this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。</strong></p>
<h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层<code>const</code>的的this指针。</p>
<p>由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。</p>
<p>为了解决这个问题，我们可以将成员函数声明成<code>const</code> </p>
<p>例如，像下面这样，在参数列表后添加上<code>const</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，这个this指针，既是顶层<code>const</code> (this指针所固有的属性)，又是底层<code>const</code> （我们声明的结果）</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>P241, P250，P545</p>
</blockquote>
<p>想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部</p>
<p>由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置</p>
<p>可以将一个类声明成另一个类的友元</p>
<blockquote>
<p> 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员</p>
</blockquote>
<p>可以将一个类的成员函数声明成另一个类的友元函数</p>
<p>友元声明是单向的，友元声明不具有传递性</p>
<p>关于友元的作用域：P252</p>
<p>友元关系是不能继承的</p>
<ul>
<li>基类的友元在访问派生类时没有特殊性。</li>
<li>派生类的友元也不能访问基类的私有成员</li>
</ul>
<h3 id="类的类型成员"><a href="#类的类型成员" class="headerlink" title="类的类型成员"></a>类的类型成员</h3><p>类的成员不只可以有变量和函数，还可以有类型</p>
<p>类内定义的类型也有访问权限的限制</p>
<p>用来定义类型的成员必须先定义再使用</p>
<blockquote>
<p>原因：// TODO</p>
</blockquote>
<h3 id="类的内联函数"><a href="#类的内联函数" class="headerlink" title="类的内联函数"></a>类的内联函数</h3><blockquote>
<p>内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销</p>
<p>内联函数会在编译时，被编译器展开</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp; <span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>max(), min() 之类的函数特别适合被定义为内联函数</p>
</blockquote>
<ul>
<li>定义在类内部的成员函数，它们默认是内联函数</li>
<li>可以在类内声明时使用<code>inline</code>，同时在类外定义函数时也同时使用<code>inline</code> ，但最好是只在类外部定义函数时使用<code>inline</code> 声明。</li>
</ul>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><blockquote>
<p>from effective c++</p>
<p>编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为<code>mutable</code> </p>
</blockquote>
<p>如果在定义类的成员时，使用<code>mutable</code> 关键字，那么，即使这个对象被声明成<code>const</code> ，我们依然可以改变这个成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">     public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">inc</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line">    private:</span><br><span class="line">    mutable <span class="type">size_t</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">A::inc</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回-this-左值"><a href="#返回-this-左值" class="headerlink" title="返回*this 左值"></a>返回*this 左值</h3><p>当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值</p>
<p>我们可以根据this指针是否具有底层<code>const</code> 来对函数进行重载</p>
<blockquote>
<p>底层const的重载见：P206</p>
<p>P247</p>
</blockquote>
<h3 id="类的前向声明"><a href="#类的前向声明" class="headerlink" title="类的前向声明"></a>类的前向声明</h3><p>可以使用类似这种形式声明类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。</p>
<p>前向声明可以放在类的头文件中，从而减少依赖。</p>
<h3 id="类的名字查找"><a href="#类的名字查找" class="headerlink" title="类的名字查找"></a>类的名字查找</h3><ul>
<li><p>我们可以在成员函数的任意地方使用类的成员</p>
<blockquote>
<p>原因在于编译器如何处理类：</p>
<ol>
<li>编译所有的成员声明</li>
<li>编译函数体</li>
</ol>
</blockquote>
</li>
<li><p>如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。</p>
</li>
<li><p>在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用<code>typedef</code> 或使用<code>using symbol = type</code>）不能再类中重定义。</p>
</li>
<li><p>成员函数的名字查找规则</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在成员函数内查找名字（成员函数体定义的名字，形参的名字）</span><br><span class="line"><span class="bullet">2.</span> 在类作用域内查找名字</span><br><span class="line"><span class="bullet">3.</span> 在成员函数定义之前的作用域内继续查找</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。</p>
</li>
</ul>
<h3 id="类的隐式类型转换"><a href="#类的隐式类型转换" class="headerlink" title="类的隐式类型转换"></a>类的隐式类型转换</h3><blockquote>
<p>P263 隐式的类类型转换 P514 重载类型转换运算符</p>
</blockquote>
<ul>
<li><p>如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换</p>
<p>这种类型转换只允许一步类型转换</p>
</li>
<li><p>一直类的隐式类型转换：</p>
<p>使用关键字<code>explicit</code> </p>
<p>该关键字只能在类内声明中使用，不能在类外重复</p>
<p>该关键字只能用于接受一个值的构造函数前面</p>
</li>
</ul>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0</p>
<p>类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的</p>
<p>由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似</p>
<ul>
<li>在<code>.h</code> 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理</li>
<li>我们可以使用类的静态成员作为成员函数的默认实参</li>
</ul>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><blockquote>
<p>类的初始化、对象拷贝、移动、销毁</p>
<p>由以下六个函数决定：</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
<p>后五个称为类的拷贝控制操作</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>C++ Primer P235、P257、P551、P689</p>
</blockquote>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下</p>
<ol>
<li>如果存在类内的初始值，用它来初始化成员</li>
<li>否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数）</li>
</ol>
<p>如果出现以下情况，编译器无法为类构造合成的默认构造函数</p>
<ol>
<li><p>类有定义一个构造函数</p>
<blockquote>
<p>遇到这种情况，可以使用 <code>类名() = defalut</code> 来给予类一个默认的构造函数</p>
</blockquote>
</li>
<li><p>类存在一个成员，这个成员没有默认的构造函数</p>
</li>
</ol>
<h4 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s) : <span class="built_in">BookNo</span>(s) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</p>
<p>（重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化</p>
<p>由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 没有默认构造函数</span></span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> num) : elem(num) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> elem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    B(<span class="type">int</span> num) : elem_int(num) &#123;&#125;  <span class="comment">// 错误，因为A没有默认构造函数，所以必须对它进行列表初始化</span></span><br><span class="line">private:</span><br><span class="line">    A elem_A;</span><br><span class="line">    <span class="type">int</span> elem_int;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。</p>
<p>（重要）列表初始化的初始化顺序</p>
<p>列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非委托构造函数要使用的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price) : </span><br><span class="line">          <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt * price) &#123;&#125;</span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) : <span class="built_in">Sales_data</span>() &#123;<span class="built_in">read</span>(is, *<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体</p>
<h4 id="默认构造函数被调用的时机"><a href="#默认构造函数被调用的时机" class="headerlink" title="默认构造函数被调用的时机"></a>默认构造函数被调用的时机</h4><blockquote>
<p>C++ Primer P262</p>
</blockquote>
<p>默认初始化</p>
<ol>
<li>在块作用域内不适用任何初始值定义一个非静态变量</li>
<li>一个类类型本身含有类成员，并且使用合成的默认构造函数时</li>
<li>没有在列表初始化中被显示初始化时</li>
</ol>
<p>值初始化</p>
<ol>
<li>数组初始化时，提供的值小于数组的大小</li>
<li>不适用初始值定义一个局部静态变量</li>
<li>使用<code>T()</code> 这种表达式来显示请求值初始化</li>
</ol>
<h4 id="继承体系中的合成的默认构造函数"><a href="#继承体系中的合成的默认构造函数" class="headerlink" title="继承体系中的合成的默认构造函数"></a>继承体系中的合成的默认构造函数</h4><ul>
<li><p>派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。</p>
</li>
<li><p>继承直接基类的构造函数，使用<code>using</code> 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数</p>
</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。</p>
<blockquote>
<p>拷贝构造函数的形式通常是 <code>ClassType(const ClassType &amp;)</code> </p>
<p>拷贝构造函数通常不应该是explicit的</p>
</blockquote>
<h4 id="合成的拷贝构造函数"><a href="#合成的拷贝构造函数" class="headerlink" title="合成的拷贝构造函数"></a>合成的拷贝构造函数</h4><p>如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数</p>
<p>对于内置类型，合成的拷贝构造函数会直接拷贝</p>
<p>对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数</p>
<p>对于数组，合成的拷贝构造函数会逐个拷贝它的元素</p>
<blockquote>
<p> <strong>一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别：</strong></p>
<blockquote>
<p>几种初始化的区别：<a href="https://blog.csdn.net/qq_38231713/article/details/106291397">https://blog.csdn.net/qq_38231713/article/details/106291397</a></p>
</blockquote>
<p> 默认初始化：对象可能产生未定义的值，出现场景：</p>
<ol>
<li>块作用域内不使用任何初始值定义一个非静态变量；</li>
<li><p>类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员</p>
<ul>
<li>如果存在类内初始值，用它来初始化成员</li>
<li>否则，默认初始化该成员</li>
</ul>
<p>值初始化：对象的值是确定（预设）的，出现场景：</p>
</li>
<li><p>数组初始化时，初始值数量小于数组的长度。</p>
</li>
<li><p>不使用初始值定义一个静态变量（带有初始值0）</p>
</li>
<li><p>使用类似<code>classType()</code> 形式表达式显示请求值初始化</p>
</li>
<li><p>只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化</p>
<p><code>vector&lt;int&gt; vec(10);</code> 值初始化为0 </p>
<p>直接初始化：使用<code>classType()</code> 初始化对象</p>
<p>拷贝初始化：使用<code>classType foo = classType()</code> 初始化对象</p>
</li>
</ol>
<ul>
<li>不光在使用 = 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化<ol>
<li>将参数作为实参传递给非引用类型的形参</li>
<li>从返回类型为非引用的函数返回一个对象</li>
<li>使用花括号列表初始化数组或聚合类</li>
<li>初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数）</li>
</ol>
</li>
</ul>
<p> <strong>二、不同的初始化方式会调用那种构造函数</strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/sksukai/article/details/104741675/">https://blog.csdn.net/sksukai/article/details/104741675/</a></p>
</blockquote>
<p> 当定义类时，会有直接初始化和拷贝初始化两种区别</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">foo var1;      <span class="comment">// 直接初始化，使用默认构造函数</span></span><br><span class="line"><span class="function">foo <span class="title">var2</span><span class="params">(<span class="number">1</span>)</span></span>;    <span class="comment">// 直接初始化，使用一个参数的构造函数</span></span><br><span class="line">foo var3 = <span class="number">50</span>;    <span class="comment">// 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3</span></span><br><span class="line">foo var4 = <span class="built_in">foo</span>(<span class="number">50</span>); <span class="comment">// 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数</span></span><br><span class="line">foo var5 = var3;  <span class="comment">// 拷贝初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="继承体系中的拷贝构造函数"><a href="#继承体系中的拷贝构造函数" class="headerlink" title="继承体系中的拷贝构造函数"></a>继承体系中的拷贝构造函数</h4><p>我们需要使用基类的拷贝构造函数显示的初始化基类的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">derived</span>(<span class="type">const</span> derived &amp;d) : <span class="built_in">base</span>(d)    <span class="comment">// 显式的使用基类的拷贝构造函数+</span></span><br><span class="line">    &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>可能会误以为拷贝初始化<code>classType obj = ori;</code> 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数</p>
<p>当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符</p>
<p>此外我们还可以定义两种赋值运算符</p>
<ol>
<li>移动赋值运算符</li>
<li>其他类型到此类型的赋值运算符</li>
</ol>
<p>但这个运算符是最常用的运算符</p>
</blockquote>
<p>拷贝赋值运算符的形式通常是<code>classType operator=(const classType &amp;)</code> 因为他是一个成员函数，因此它的左侧成员自动绑定</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝</p>
<h4 id="继承体系中的拷贝赋值运算符"><a href="#继承体系中的拷贝赋值运算符" class="headerlink" title="继承体系中的拷贝赋值运算符"></a>继承体系中的拷贝赋值运算符</h4><p>派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classType &amp; classType::<span class="keyword">operator</span>=(<span class="type">const</span> classType &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);  <span class="comment">// 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    派生类成员的赋值操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>释放对象使用的资源，销毁对象的非static成员</p>
<p>析构函数的形式是<code>~classType()</code> 没有返回值，不接受参数</p>
<p>不能被重载，对于任意一个类有且只有一个析构函数</p>
<blockquote>
<p>析构函数不能是删除的</p>
</blockquote>
<p>析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员</p>
<ul>
<li><p>继承体系中的析构函数</p>
<p>派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。</p>
<p>对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。</p>
</li>
</ul>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h3 id="类的拷贝控制成员被默认定义为删除的"><a href="#类的拷贝控制成员被默认定义为删除的" class="headerlink" title="类的拷贝控制成员被默认定义为删除的"></a>类的拷贝控制成员被默认定义为删除的</h3><blockquote>
<p>P450、P476、P553、P751</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><p>类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符，</p>
<blockquote>
<p>派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见</p>
</blockquote>
</li>
<li><p>动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定</p>
<blockquote>
<p>基类通过在成员函数前加上<code>virtual</code> 关键字使得函数执行运行时动态绑定。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数</p>
<p>关键字<code>virtual</code> 只能出现在类内声明语句中，而不能出现在定义语句中</p>
<p>没有用<code>virtual</code> 声明的函数，其解析发生在编译时，而非运行时</p>
</blockquote>
</li>
<li><p>访问控制：</p>
<p>如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为<code>protected</code> </p>
</li>
</ul>
<ul>
<li><p>派生类的构造函数</p>
<p>派生类必须使用基类的构造函数初始化其基类的部分</p>
</li>
<li><p>防止继承 定义类的时候使用<code>final</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123;<span class="comment">/* ... */</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><ul>
<li><p>纯虚函数</p>
<p>通过在函数声明的分号前添加 = 0 即可声明这个函数为纯虚函数</p>
<p>纯虚函数只是提供了一个接口，无需定义纯虚函数</p>
</li>
<li><p>含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象</p>
</li>
</ul>
<h3 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h3><ul>
<li>派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员</li>
<li>基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响<ol>
<li>若基类的访问说明符</li>
<li>派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高）</li>
</ol>
</li>
<li>对于派生类成员来说，它可以访问基类的<code>public</code> 和<code>private</code> 部分</li>
</ul>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以在派生类中使用<code>using</code> 声明改变它继承自基类的成员的可访问性</p>
<p>但<code>using</code>声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。</p>
<h3 id="struct-和-class的区别"><a href="#struct-和-class的区别" class="headerlink" title="struct 和 class的区别"></a>struct 和 class的区别</h3><ol>
<li>struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数</li>
<li>在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数</li>
<li>他们的可访问性：<ol>
<li>struct的默认成员都是public，class的默认成员都是private</li>
<li>struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承</li>
</ol>
</li>
</ol>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul>
<li><p>每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。</p>
<p>当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。</p>
</li>
</ul>
<ul>
<li><p>一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。</p>
<p>如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。</p>
<p>与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。</p>
<blockquote>
<p>编译器解析类的函数调用的过程：</p>
<p>例如<code>obj.func()</code></p>
<ol>
<li><p>确定obj的静态类型，去对应的类的作用域内查找该名称</p>
</li>
<li><p>如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。</p>
</li>
<li><p>如果找到了该名子，编译器进行类型检查，看这次调用是否合法。</p>
</li>
<li><p>如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。</p>
<p>否则直接进行函数调用。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li>声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。</li>
<li><p>因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。</p>
</li>
<li><p>成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。</p>
<p>如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用<code>using</code> 声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">(<span class="type">char</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> base::func;</span><br><span class="line">    <span class="comment">// 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span>) <span class="keyword">override</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>BallMove:基于Qt的GUI小项目</title>
    <url>/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="BallMove-基于Qt的GUI小项目"><a href="#BallMove-基于Qt的GUI小项目" class="headerlink" title="BallMove:基于Qt的GUI小项目"></a>BallMove:基于Qt的GUI小项目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在暑假学科目二的时候，看着 <a href="https://www.devbean.net/2012/08/qt-study-road-2-catelog/">Qt学习之路2</a> 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。</p>
<p>今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。</p>
<p>这个项目基于<code>QGraphicsScene + QGraphicsItem + QGraphicsView</code>， 模拟了一个小球在现实世界中的运动。</p>
<p>项目地址：<a href="https://github.com/cfla1638/BallMove">cfla1638/BallMove</a> </p>
<h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p><strong>功能</strong>：实现了实心球的运动。</p>
<p>考虑的因素有：</p>
<ol>
<li>用户给予的加速度</li>
<li>重力</li>
<li>摩擦力</li>
<li>空气阻力</li>
</ol>
<p><strong>细节：</strong></p>
<p>该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg / m^3^ 。</p>
<p>重力加速度为 9.8 m/s^2^ 。</p>
<p>静摩擦系数为 0.3。</p>
<p>空气阻力使用公式：F = 1/2 <em> CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 </em> 0.04^2^ 。</p>
<p>尺寸换算：1m = 250px。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>Qt的绘制系统由<code>QGraphicsScene + QGraphicsItem + QGraphicsView</code> 相互配合使用。</p>
<p><code>QGraphicsScene</code> 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。</p>
<p><code>QGraphicsItem</code> 是在<code>QGraphicsScene</code> 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到<code>QGraphicsScene</code>，进行显示和管理。</p>
<p><code>QGraphicsView</code> 提供了一个观察的视角，配合<code>QGraphicsScene</code> 进行显示。这个类可以被设为<code>QMainWindow</code> 的<code>CentralWidget</code>。</p>
</li>
<li><p>只有<code>QObject</code> 的子类可以使用信号槽的机制</p>
</li>
<li><p><code>QTimer</code>类提供计时器功能，使用<code>timer.start(sec)</code> 功能开始计时，这里timer是一个<code>QTimer</code>类的一个对象，每经过sec时间后，timer就会发出一个<code>timeout()</code> 信号。</p>
</li>
<li><p>想要实现物体的运动，就要让物体的位置在每一帧里进行改变/刷新（本程序的帧率是120），而<code>QGraphicsScene</code> 提供一个<code>advance()</code> 函数，该函数会调用所有在场景里的<code>QGraphicsItem</code> 对象的<code>advance()</code> 函数，因此我们只要每经过 1000 / 120 毫秒 就调用一次<code>QGraphicsScene::advance()</code> 函数，就可以进行场景刷新，从而实现物体的运动。</p>
</li>
<li><p>每个<code>QGraphicsItem::advance(int phase)</code> 都会被一个<code>QGraphicsScene::advance()</code> 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase = 0。第二次<code>QGraphicsScene::advance()</code> 将phase  = 1 传入函数并调用。</p>
<p>基于此，我们只需要在phase = 1是进行处理，phase = 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。</p>
</li>
<li><p>Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在<code>QGraphicsScene</code> 中的全局坐标系，它记录了每个<code>QGraphicsItem</code> 的位置。第二个是每个<code>QGraphicsItem</code> 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。</p>
</li>
<li><p>每个继承了<code>QGraphicsItem</code> 的类都要重载以下四个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(<span class="type">int</span> phase)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>boundingRect()</code> 返回一个包裹住<code>QGraphicsItem</code>  对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。</p>
<p><code>shape()</code> 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。</p>
<p><code>void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr)</code> </p>
<p>该函数一般由<code>QGraphicsScene</code> 自动调用，绘制该项目。</p>
<p>这个函数一般这样写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();    <span class="comment">// 保存画笔状态</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置新的画笔状态</span></span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);     <span class="comment">// 设置反走线（抗锯齿）</span></span><br><span class="line">    painter-&gt;<span class="built_in">fillPath</span>(<span class="built_in">shape</span>(), Qt::blue);  <span class="comment">// 绘制图型</span></span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();    <span class="comment">// 还原画笔状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。</p>
<p><code>painter-&gt;fillPath(shape(), Qt::blue);</code> 这一行绘制我们在<code>shape()</code> 中返回的图型，在此之前我们可以设置画笔的状态。</p>
</li>
<li><p>编写头文件的建议</p>
<p>如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。</p>
<p>为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。</p>
<p>即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。</p>
</li>
</ol>
<h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><p>首先来看一下运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208220742986.png" alt="image-20220822074244433"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象</span><br><span class="line">另外，这棵树也为我们展示了本项目的设计思路。</span><br><span class="line">└─MainWindow</span><br><span class="line">    ├─Controller</span><br><span class="line">    │  ├─Ball</span><br><span class="line">    │  ├─Balldata</span><br><span class="line">    │  ├─Ground</span><br><span class="line">    │  └─QGraphicsScene - Reference</span><br><span class="line">    ├─QGraphicsScene</span><br><span class="line">    └─QGraphicsView</span><br></pre></td></tr></table></figure>
<p>自下而上，首先来看Controller下的三个类，</p>
<p>Controller下有三个类，分别是Ball, Balldata, Ground，他们都是<code>QGraphicsItem</code> 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。</p>
<p>这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。</p>
<p>值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。</p>
<p>接着是Controller类。</p>
<p>顾名思义，Controller类是我们程序的控制器。</p>
<p>Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。</p>
<p>最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。</p>
<p>当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的<code>QMainWindow::show()</code> 和 <code>QApplication :: exec()</code> 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。</p>
<h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>首先看一下我们的文件结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BallMove</span><br><span class="line">     - BallMove.pro</span><br><span class="line">    Headers</span><br><span class="line">     - ball.h</span><br><span class="line">     - balldata.h</span><br><span class="line">     - constants.h</span><br><span class="line">     - controller.h</span><br><span class="line">     - ground.h</span><br><span class="line">     - mainwindow.h</span><br><span class="line">    Sources</span><br><span class="line">     - ball.cpp</span><br><span class="line">     - balldata.cpp</span><br><span class="line">     - controller.cpp</span><br><span class="line">     - ground.cpp</span><br><span class="line">     - main.cpp</span><br><span class="line">     - mainwindow.cpp</span><br></pre></td></tr></table></figure>
<h3 id="Ball类的实现"><a href="#Ball类的实现" class="headerlink" title="Ball类的实现"></a>Ball类的实现</h3><p>首先看一下ball类的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> : <span class="keyword">public</span> QGraphicsItem</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ball</span>(qreal x, qreal y);</span><br><span class="line"></span><br><span class="line">    <span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(<span class="type">int</span> phase)</span></span>;</span><br><span class="line">    <span class="function">QPointF <span class="title">getPos</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">pos</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> forceCount = <span class="number">4</span>;</span><br><span class="line">    qreal a[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">    qreal vx = <span class="number">0</span>;</span><br><span class="line">    qreal vy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先我们来看Ball类的私有变量：</p>
<p>由于我们运动的平面是二维的，因此我们使用一个二维数组<code>qreal a[2][4]</code> 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即<code>a[xAxis][AirResistance]</code> 。如果想要引用y方向的重力加速度，就使用<code>a[yAxis][Gravity]</code> 。</p>
<p><code>qreal vx, vy</code> 即小球的x方向速度，和y方向的速度。</p>
<p><code>int forceCount</code> 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。</p>
<p>接着我们来看一下Ball类中声明的函数:</p>
<p>第一个函数<code>getPos()</code>很好理解，即返回小球在全局坐标系中的坐标。</p>
<p>接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：<code>paint() shape() advance()</code></p>
<p><code>boundingRect()</code> </p>
<p><code>boundingRect</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QRectF <span class="title">Ball::boundingRect</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QRectF</span>(-BALL_SIZE * <span class="number">2</span>, -BALL_SIZE * <span class="number">2</span>, BALL_SIZE * <span class="number">4</span>, BALL_SIZE * <span class="number">4</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。</p>
<p><code>BALL_SIZE</code> 定义在constants.h 代表小球的直径。</p>
<p><code>shape()</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPainterPath <span class="title">Ball::shape</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.<span class="built_in">addEllipse</span>(<span class="built_in">QPointF</span>(<span class="number">0</span>, <span class="number">0</span>), BALL_SIZE / <span class="number">2</span>, BALL_SIZE / <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。</p>
<p><code>paint()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionGraphicsItem *option, QWidget *widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter-&gt;<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);     <span class="comment">// 设置反走线（抗锯齿）</span></span><br><span class="line">    painter-&gt;<span class="built_in">fillPath</span>(<span class="built_in">shape</span>(), Qt::blue);</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">restore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。</p>
<p><code>advance()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ball::advance</span><span class="params">(<span class="type">int</span> phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只有phase为1时进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!phase) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算合力</span></span><br><span class="line">    qreal sumAx = <span class="number">0</span>, sumAy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; forceCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumAx += a[xAxis][i];</span><br><span class="line">        sumAy += a[yAxis][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sumAx) vx += (sumAx / FRAME_RATE);</span><br><span class="line">    <span class="keyword">if</span> (sumAy) vy += (sumAy / FRAME_RATE);</span><br><span class="line"></span><br><span class="line">    qreal x = <span class="built_in">fmod</span>(<span class="built_in">pos</span>().<span class="built_in">rx</span>() + vx / FRAME_RATE, <span class="number">1000</span>), y = <span class="built_in">fmod</span>(<span class="built_in">pos</span>().<span class="built_in">ry</span>() + vy / FRAME_RATE, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理小球越界</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; BALL_SIZE / <span class="number">2</span>) y = BALL_SIZE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新位置</span></span><br><span class="line">    <span class="built_in">setPos</span>(<span class="built_in">QPointF</span>(x, y));</span><br><span class="line">    <span class="built_in">update</span>();       <span class="comment">// 更新显示小球</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。</p>
<p>在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。</p>
<p>需要注意，一、因为我们的速度、加速度定义为m/s和m/s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。</p>
<p>二、在设置了小球的位置之后，需要使用<code>update()</code> 函数更新小球的位置。</p>
<h3 id="constants-h-参数存储文件"><a href="#constants-h-参数存储文件" class="headerlink" title="constants.h 参数存储文件"></a>constants.h 参数存储文件</h3><p>constants.h 文件中存放了项目的各种参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME_RATE = <span class="number">120</span>;         <span class="comment">// 帧率：120帧  帧率过低时碰撞会穿透地面</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BALL_SIZE = <span class="number">20</span>;           <span class="comment">// 球的直径：20px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 400 对应 112 重力</span></span><br><span class="line"><span class="comment">// 3000 对应 2450 重力</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> X_SPEED = <span class="number">1500</span>;           <span class="comment">// 左右键给球的加速度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Y_SPEED = <span class="number">3000</span>;           <span class="comment">// 上下键给球的加速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRICTION = <span class="number">735</span>;           <span class="comment">// 摩擦力大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRICTION_SENSITIVITY = <span class="number">2</span>;         <span class="comment">// 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 112 对应1.75 米的人</span></span><br><span class="line"><span class="comment">// 2450 对应 8cm 的实心球</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GRAVITY = <span class="number">2450</span>;           <span class="comment">// 重力大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> M = <span class="number">2.1038</span>;            <span class="comment">// 小球质量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Directions</span>&#123;xAxis, yAxis&#125;;      <span class="comment">// x, y轴方向</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Force</span>&#123;User, Gravity, Friction, AirResistance&#125;;         <span class="comment">// 力的四个维度，用户给出的力，重力，摩擦力，空气阻力</span></span><br></pre></td></tr></table></figure>
<p>需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。</p>
<h3 id="Balldata-amp-ground"><a href="#Balldata-amp-ground" class="headerlink" title="Balldata &amp; ground"></a>Balldata &amp; ground</h3><p>这两个类都继承了<code>QGraphicsItem</code> 和Ball类类似，因此我们不在赘述。</p>
<h3 id="Controller类"><a href="#Controller类" class="headerlink" title="Controller类"></a>Controller类</h3><p>首先看一下Controller类的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span> : QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Controller</span>(QGraphicsScene &amp; scene, QObject * parent = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gravity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawLineOfTrack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *atched, QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleKeyPressed</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleKeyReleased</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line"></span><br><span class="line">    QTimer timer;</span><br><span class="line">    Ball * ball;</span><br><span class="line">    QGraphicsScene &amp; scene;</span><br><span class="line">    Ground * ground;</span><br><span class="line">    ballData * data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Controller类有以下几点功能：</p>
<ul>
<li><p>处理键盘事件：如上下左右移动，打开/关闭 轨迹显示，清屏。</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *atched, QEvent *event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleKeyPressed</span><span class="params">(QKeyEvent * event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleKeyReleased</span><span class="params">(QKeyEvent * event)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制程序的开始与结束</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制程序的一步步地推进，即让小球动起来。</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他功能</p>
<p>相关地函数有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">track</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gravity</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawLineOfTrack</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里我们只介绍<code>advance()</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Controller::advance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scene.<span class="built_in">advance</span>();                        <span class="comment">// 首先调用场景的advance()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取碰撞信息</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> lastStatus = <span class="literal">false</span>;         <span class="comment">// 上一帧是否碰撞</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> nowStatus = <span class="literal">false</span>;          <span class="comment">// 当前是否处于碰撞</span></span><br><span class="line">    nowStatus = ball-&gt;<span class="built_in">collidesWithItem</span>(ground);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (nowStatus == <span class="literal">true</span> &amp;&amp; lastStatus == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ball-&gt;a[yAxis][Gravity] = <span class="number">0</span>;        <span class="comment">// 碰撞时重力与支持力抵消</span></span><br><span class="line">        ball-&gt;vy = -(ball-&gt;vy * <span class="number">0.667</span>);     <span class="comment">// 回弹 2/3 的速度</span></span><br><span class="line">        ball-&gt;a[yAxis][User] = <span class="number">0</span>;           <span class="comment">// 竖直方向速度为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理摩擦力</span></span><br><span class="line">    <span class="keyword">if</span> (nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[xAxis][Friction] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有碰撞的时候</span></span><br><span class="line">    <span class="keyword">if</span> (!nowStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 摩擦力置零</span></span><br><span class="line">        ball-&gt;a[xAxis][Friction] = <span class="number">0</span>;</span><br><span class="line">        ball-&gt;a[yAxis][Gravity] = GRAVITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理空气阻力</span></span><br><span class="line">    qreal sumV = <span class="built_in">pow</span>(ball-&gt;vx, <span class="number">2</span>) + <span class="built_in">pow</span>(ball-&gt;vy, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(sumV) &gt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qreal airSum = <span class="number">0.0009744</span> * sumV / <span class="number">250</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumV == <span class="number">0</span>) sumV = <span class="number">1</span>;</span><br><span class="line">        ball-&gt;a[xAxis][AirResistance] = (<span class="built_in">fabs</span>(ball-&gt;vx) / (<span class="built_in">sqrt</span>(sumV))) * airSum;</span><br><span class="line">        ball-&gt;a[yAxis][AirResistance] = (<span class="built_in">fabs</span>(ball-&gt;vy) / (<span class="built_in">sqrt</span>(sumV))) * airSum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将力换算成加速度</span></span><br><span class="line">        ball-&gt;a[xAxis][AirResistance] /= M;</span><br><span class="line">        ball-&gt;a[yAxis][AirResistance] /= M;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vx &gt; <span class="number">5</span>) ball-&gt;a[xAxis][AirResistance] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball -&gt; vx &lt; <span class="number">10</span>) ;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[xAxis][AirResistance] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ball-&gt;vy &gt; <span class="number">5</span>) ball-&gt;a[yAxis][AirResistance] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ball -&gt; vy &lt; <span class="number">10</span>) ;</span><br><span class="line">        <span class="keyword">else</span> ball-&gt;a[yAxis][AirResistance] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lastStatus = nowStatus;</span><br><span class="line">    data-&gt;<span class="built_in">update</span>();                         <span class="comment">// 更新数据显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。</p>
<p>等运动结束之后，我们使用Qt地碰撞检测函数<code>collidesWithItem()</code>看小球是否接触地面。</p>
<p>接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。</p>
<p>其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。</p>
<h3 id="MainWindow-类"><a href="#MainWindow-类" class="headerlink" title="MainWindow 类"></a>MainWindow 类</h3><p>MainWindow类的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjustViewSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initScene</span><span class="params">()</span></span>;</span><br><span class="line">    QGraphicsView * view;</span><br><span class="line">    QGraphicsScene * scene;</span><br><span class="line">    Controller * controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">      <span class="built_in">scene</span>(<span class="keyword">new</span> <span class="built_in">QGraphicsScene</span>(<span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">view</span>(<span class="keyword">new</span> <span class="built_in">QGraphicsView</span>(scene, <span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">controller</span>(<span class="keyword">new</span> <span class="built_in">Controller</span>(*scene, <span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(view);</span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">750</span>, <span class="number">750</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initScene</span>();</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">0</span>, <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">adjustViewSize</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的<code>centralWidget</code> 并调整了窗口大小。</p>
<p>在倒数第二步，调用<code>initScene</code> 对scene进行调整。</p>
<p>以上的这些步骤都不会有什么问题，只有最后一步令人困惑：</p>
<p><code>QTimer::singleShot(0, this, SLOT(adjustViewSize()));</code> </p>
<p>首先解释<code>singleShot()</code> 函数，这个函数的声明如下</p>
<p><code>void QTimer::singleShot(int msec, const QObject *receiver, const char *member)</code> </p>
<p>它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。</p>
<p>那么为什么要使用这个功能呢？</p>
<p>这里有两个解释</p>
<blockquote>
<p>那么，<code>QTimer::signleShot(0, ...)</code>意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在<code>paintEvent()</code>事件中），因此我们需要在下一次事件循环中调用<code>adjustViewSize()</code>函数。这就是为什么我们需要用<code>QTimer</code>而不是直接调用<code>adjustViewSize()</code>。如果熟悉 flash，这相当于 flash 里面的<code>callLater()</code>函数。</p>
</blockquote>
<p>这个解释来自<a href="https://www.devbean.net/2012/12/qt-study-road-2-snake-1/">《Qt学习之路2》</a> 但我并不清楚这里的 “下一次事件循环” 的意思。</p>
<p>依我的理解，应该是这个意思：某个<code>QObject</code> 发出 <code>paintEvent()</code> 事件，但对这个事件的处理比较耗时，如果此时直接调用<code>adjustViewSize()</code> ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用<code>adjustViewSize()</code> ，我们会发现视图小小的挤在屏幕的中间。</p>
<p>后来我又在网上发现了这篇博客：<a href="https://blog.csdn.net/cutemypig/article/details/122131997">QTimer::singleShot(0, this, slot函数)；</a>  ，意思和我理解的大概相似。 </p>
<p>但还是挖个坑，等我以后学精了一定回来解释清楚。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/K346K346/article/details/50568472">C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范</a> </p>
<p><a href="https://www.devbean.net/2012/12/qt-study-road-2-snake-1/">Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World</a> </p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP 读后感</title>
    <url>/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h1 id="CS-APP-读后感"><a href="#CS-APP-读后感" class="headerlink" title="CS:APP 读后感"></a>CS:APP 读后感</h1><p>这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的）</p>
<p>接下来会陆续更新各章的详细笔记 … </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目录：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第1章    计算机系统漫游</span><br><span class="line">--- 程序结构和执行</span><br><span class="line">第2章    信息的表示和处理</span><br><span class="line">第3章    程序的机械级表示</span><br><span class="line">第4章    处理器体系结构</span><br><span class="line">第5章    优化程序性能</span><br><span class="line">第6章    存储器的层次结构</span><br><span class="line">--- 在系统上运行程序</span><br><span class="line">第7章    链接</span><br><span class="line">第8章    异常控制流</span><br><span class="line">第9章    虚拟内存</span><br><span class="line">--- 程序间的交互和通信</span><br><span class="line">第10章  系统及I/O</span><br><span class="line">第11章  网络编程</span><br><span class="line">第12章  并发编程</span><br></pre></td></tr></table></figure>
<p>本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。</p>
<p>剩下的十一章是本书的正式部分，我认为本书的核心在第 7~9 章，2~6章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。</p>
<h2 id="分章介绍"><a href="#分章介绍" class="headerlink" title="分章介绍"></a>分章介绍</h2><h3 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h3><blockquote>
<p>这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。</p>
</blockquote>
<p><strong>2.1.3 寻址和字节顺序</strong>： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。</p>
<p><strong>2.16 布尔代数介绍</strong> ： 可以使用位向量来表示有限集合。</p>
<p><strong>2.2 整数表示</strong> ： 介绍了整数原码和补码的表示，以及他们之间的转换。</p>
<p><strong>2.3 整数运算</strong> ： 介绍了整数运算可能出现的错误，以及来源。</p>
<p><strong>2.4</strong> ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。</p>
<h3 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h3><blockquote>
<p>相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。</p>
<p>这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。</p>
<p>从这一张开始到最后，才是一口气看完的。</p>
</blockquote>
<p>3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了<code>objdump</code> 的使用</p>
<p>3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。</p>
<p>3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。</p>
<p>3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法</p>
<h3 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h3><blockquote>
<p>这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。</p>
</blockquote>
<h3 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h3><blockquote>
<p>呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。</p>
</blockquote>
<p>客观一点就是 普通人日常写代码小技巧</p>
<h3 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h3><blockquote>
<p>没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。</p>
</blockquote>
<h3 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h3><blockquote>
<p>含金量高的来了</p>
<p>这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld</p>
<p>7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位</p>
<p>7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表</p>
<p>7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接</p>
<p>7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方</p>
<p>动态链接：与加载的时候链接的类型</p>
<p>库打桩机制</p>
<h3 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h3><blockquote>
<p>最重要的一章之一，介绍了并发编程的基础——异常控制流</p>
<p>介绍了进程，简单带领读者入门了并发编程</p>
<p>讲了信号，有助于以后学习事件驱动的GUI编程</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>8.2 异常</p>
<p>8.3 进程</p>
<p>8.4 用C语言操作进程：fork execve</p>
<p>8.5 信号  SIGINT … </p>
<h3 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h3><blockquote>
<p>最重要的一章之一</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>本章可以分为三部分</p>
<p>第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的</p>
<p>第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve</p>
<p>第三部分介绍了一个内存分配器的实现( malloc() )</p>
<h3 id="第十章-系统级-I-O"><a href="#第十章-系统级-I-O" class="headerlink" title="第十章 系统级 I/O"></a>第十章 系统级 I/O</h3><blockquote>
<p>这一章读起来很简单，没有什么要理解的东西</p>
</blockquote>
<p>首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。</p>
<p>然后着介绍了RIO包，即包装后的IO函数。</p>
<p>本章完</p>
<h3 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h3><blockquote>
<p>这一章需要理解的地方不多，只有介绍网络编程的部分</p>
<p>第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。</p>
</blockquote>
<p>首先介绍了网络编程</p>
<p>接着介绍了Linux的套接字函数</p>
<p>最后实现了一个小web服务器</p>
<p>11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议</p>
<h3 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h3><blockquote>
<p>和上一章差不多的感觉</p>
</blockquote>
<p>本章也分为三部分</p>
<p>首先介绍了实现并发编程的三种方法</p>
<ol>
<li>进程</li>
<li>IO多路复用</li>
<li>线程</li>
</ol>
<p>之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。</p>
<p>最后介绍了并发编程容易出现的问题：死锁、访问共享变量 … </p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 用法</title>
    <url>/2023/03/09/Visual-Studio%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="引入第三方库-（以OpenCV为例）"><a href="#引入第三方库-（以OpenCV为例）" class="headerlink" title="引入第三方库 （以OpenCV为例）"></a>引入第三方库 （以OpenCV为例）</h3><p>在右侧导航栏项目名称上右键，点击属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931479.png" alt="image-20230309191119122"> </p>
<p>在VC++页面中，找到包含目录和库目录，将要引用的第三方库的<code>include</code>目录和二进制库文件分别添加到里面去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931480.png" alt="image-20230309191325578"> </p>
<p>具体地，以OpenCV 4.7为例，需要包含的目录有:</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931481.png" alt="image-20230309192108457"> </p>
<p>最后在【链接器 → 输入】里面，指定具体需要用到的库</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303091931482.png" alt="image-20230309191425790"> </p>
<h3 id="汇编语言环境-（MASM）"><a href="#汇编语言环境-（MASM）" class="headerlink" title="汇编语言环境 （MASM）"></a>汇编语言环境 （MASM）</h3><ul>
<li><p>配置汇编项目</p>
<blockquote>
<p>1.创建一个 <strong>Visual C++</strong> <strong>空工程</strong> (Empty Project), 此时先不要添加汇编源文件。</p>
<p>2.在 “解决方案浏览器” 视图中, 在项目名称上右击 —-&gt; 选择 “<strong>生成自定义</strong>“ —-&gt; 在弹出的 “Visual C++ 生成自定义项文件” 窗口中, 勾选 <code>masm(.targets, .props)</code> 项。</p>
<p>​    <img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20230319212518753.png" alt="image-20230319212518753"> </p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20230319212601616.png" alt="image-20230319212601616"> </p>
<p>3.在 “解决方案浏览器” 视图中, 在项目名称上右击 —-&gt; 选择 “属性” —-&gt; 在左侧 “配置属性” 导航中 —-&gt; 选择 “链接器” —-&gt; “系统” —-&gt; 在 “<strong>子系统</strong>“ 右侧下拉菜单中选择 “控制台(/SUBSYSTEM:CONSOLE)” (注：VS2022已自动配置)</p>
<p>4.添加汇编源代码 file.asm (添加 C++ 文件, 然后将后缀修改为 <code>.asm</code>), (这一步要放在最后, 否则可能会报错) 。</p>
<p>5.如果是64位则要在项目属性→链接器→高级→程序入口点 里填上程序入口点，一般是main</p>
</blockquote>
</li>
<li><p>引入依赖库</p>
<blockquote>
<p>1.链接器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “链接器” —-&gt; “常规” —-&gt; “附加库目录” —-&gt; “c:\Irvine”.</p>
<p>2.链接器中添加 “附加依赖项”. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “链接器” —-&gt; “输入” —-&gt; “附加依赖项” —-&gt; 主要包含库: user32.lib, Irvine32.lib, kernel32.Lib .</p>
<p>3.汇编器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —-&gt; “Microsoft Macro Assembler” —-&gt; “General” —-&gt; “Include Paths” —-&gt; 添加库目录, 如 “c:\Irvine” (注意：此选项在添加 <code>.asm</code> 源文件后才出现).</p>
</blockquote>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>注意到，参考文献 2 中 还提到了一些其他的引入第三方库的方法。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Visual Studio 下配置第三方C/C++库的方法 : <a href="https://blog.csdn.net/yangfchn/article/details/85162934">https://blog.csdn.net/yangfchn/article/details/85162934</a></p>
<p>[2] VS配置OpenCV教程（超详细） : <a href="https://blog.csdn.net/mars_xiaolei/article/details/78759041">https://blog.csdn.net/mars_xiaolei/article/details/78759041</a></p>
<p>[3] Getting Started with MASM and Visual Studio 2022 : <a href="http://www.asmirvine.com/gettingStartedVS2022/index.htm">http://www.asmirvine.com/gettingStartedVS2022/index.htm</a></p>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake学习之路</title>
    <url>/2022/10/22/cmake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="cmake-学习之路"><a href="#cmake-学习之路" class="headerlink" title="cmake 学习之路"></a>cmake 学习之路</h1><blockquote>
<p>参考链接</p>
<p><a href="https://www.zhihu.com/question/58949190/answer/999701073">CMake 如何入门？ - 知乎 (zhihu.com)</a> </p>
<p><a href="https://github.com/ttroy50/cmake-examples">ttroy50/cmake-examples: Useful CMake Examples (github.com)</a> </p>
<p><a href="https://blog.csdn.net/Kprogram/article/details/126010833">超详细的cmake入门教程【转载】_Korpse的博客-CSDN博客_cmake 教程</a> </p>
</blockquote>
<h2 id="01-basic"><a href="#01-basic" class="headerlink" title="01-basic"></a>01-basic</h2><h3 id="A-hello-cmake"><a href="#A-hello-cmake" class="headerlink" title="A-hello cmake"></a>A-hello cmake</h3><p>概念：</p>
<blockquote>
<p><code>CMakeLists.txt</code> : 存储cmake命令，当在一个文件夹中运行cmake时，cmake会寻找这个文件，如果找不到会报错。</p>
</blockquote>
<p>三个命令：</p>
<blockquote>
<p><code>cmake_minimum_required(VERSION 3.5)</code> 最小的cmake版本</p>
<p><code>project()</code> 指定项目的名称，cmake可以通过include一个项目名称来引用另一个项目，这对多项目是很方便的。另外这个命令也会创建一个名为 <code>$&#123;PROJECT_NAME&#125;</code> 的变量，它的内容就是我们指定的项目名称。</p>
<p><code>add_executable(hello_cmake hello_cmake.cpp)</code> 第一个参数是我们生成可执行文件的名称，第二个参数以后则是为了生成这个可执行文件需要的源文件列表</p>
</blockquote>
<p>两种构建方式</p>
<ol>
<li><p>In-Place Build</p>
<p>将生成的二进制文件和源文件放在一起，这样构建会比较混乱</p>
<p>在Linux上的方法是 </p>
<p><code>cmake .</code> 参数代表CMakeLists.txt 所在的位置</p>
<p><code>make</code></p>
<blockquote>
<p>注意，在window上，默认的生成器是nmake</p>
<p>要使用mingw的make应当这样：</p>
<p><code>cmake -G &quot;MinGW Makefiles&quot; .</code> 注意字符串大小写严格</p>
<p><code>cmake .</code></p>
<p><code>make</code></p>
</blockquote>
</li>
<li><p>Out-of-Source Build</p>
<p>将生成的二进制文件单独放在一个文件夹中，这样比较整洁</p>
<p>具体的方法是（Linux） </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>在 window上的方法是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="B-hello-headers"><a href="#B-hello-headers" class="headerlink" title="B hello headers"></a>B hello headers</h3><p>将头文件和源文件分离编译</p>
<p>我们有一个include目录和一个src目录</p>
<p>CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set the minimum version of CMake that can be used</span></span><br><span class="line"><span class="comment"># To find the cmake version run</span></span><br><span class="line"><span class="comment"># $ cmake --version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the project name</span></span><br><span class="line"><span class="keyword">project</span> (hello_headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a sources variable with a link to all cpp files to compile</span></span><br><span class="line"><span class="keyword">set</span>(SOURCES</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">    src/main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add an executable with the above sources</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_headers <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the directories that should be included in the build command for this target</span></span><br><span class="line"><span class="comment"># when running g++ these will be included as -I/directory/path/</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_headers</span><br><span class="line">    PRIVATE </span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 有两个需要注意的点：</p>
<ol>
<li><p>首先我们使用了set函数，将源文件甚至为了其内容，<code>add_executable()</code> 函数的第二个参数也使用该变量。</p>
</li>
<li><p>使用了<code>target_include_directories</code> 函数，这个函数的文档<a href="[target_include_directories — CMake 3.0.2 Documentation](https://cmake.org/cmake/help/v3.0/command/target_include_directories.html">在这里</a>) ，需要注意的是，这个函数必须在我们已经添加了源文件或库之后才能使用。否则会构建失败。</p>
<p>详见文档</p>
<blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>
<p>Specify include directories or targets to use when compiling a given target. The named <code>&lt;target&gt;</code> must have been created by a command such as <a href="https://cmake.org/cmake/help/v3.0/command/add_executable.html#command:add_executable"><code>add_executable()</code></a> or <a href="https://cmake.org/cmake/help/v3.0/command/add_library.html#command:add_library"><code>add_library()</code></a> and must not be an <a href="https://cmake.org/cmake/help/v3.0/prop_tgt/IMPORTED.html#prop_tgt:IMPORTED"><code>IMPORTED</code></a> target.</p>
</blockquote>
</li>
</ol>
<p>附：cmake 预先定义的一些变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Variable</th>
<th style="text-align:left">Info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CMAKE_SOURCE_DIR</td>
<td style="text-align:left">The root source directory</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_SOURCE_DIR</td>
<td style="text-align:left">The current source directory if using sub-projects and directories.</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_SOURCE_DIR</td>
<td style="text-align:left">The source directory of the current cmake project.</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_BINARY_DIR</td>
<td style="text-align:left">The root binary / build directory. This is the directory where you ran the cmake command.</td>
</tr>
<tr>
<td style="text-align:left">CMAKE_CURRENT_BINARY_DIR</td>
<td style="text-align:left">The build directory you are currently in.</td>
</tr>
<tr>
<td style="text-align:left">PROJECT_BINARY_DIR</td>
<td style="text-align:left">The build directory for the current project.</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>const 和 constexpr 的详解和区别</title>
    <url>/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="const和constexpr"><a href="#const和constexpr" class="headerlink" title="const和constexpr"></a><code>const</code>和<code>constexpr</code></h1><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p>常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式</p>
<p>常量表达式是由</p>
<ul>
<li>数据类型</li>
<li>数据初始值</li>
</ul>
<p>决定的。</p>
<p><code>int a = 1</code> a 不是一个常量表达式，因为它的数据类型不是常量</p>
<p><code>const int b = get_val()</code> b不是一个常量表达式，因为它的初始值不是常量</p>
<p>由于使用<code>const</code> 不能确定一个表达式是不是常量，因此C++11使用<code>constexpr</code> 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。</p>
<p>下面这个程序是不正确的，因为a虽然被<code>const</code> 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> i = a;</span><br><span class="line">    <span class="type">int</span> arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而只要将<code>a = b</code> 改为 <code>a = 1</code> 程序就不会报错了，因为此时a的确是一个常量表达式</p>
<h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h3><p>普通的函数不是常量表达式，但我们可以定义<code>constexpr</code> 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定</p>
<h3 id="constexpr-指针-amp-引用"><a href="#constexpr-指针-amp-引用" class="headerlink" title="constexpr 指针 &amp; 引用"></a><code>constexpr</code> 指针 &amp; 引用</h3><p><code>constexpr</code> 指向的位置必须是全局变量，静态变量，或者字面值等放在<code>.bss</code> 节<code>.data</code> 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><p><code>const</code>用来修饰变量，根据<code>const</code> 出现的位置，可以分为两种<code>const</code> ：顶层<code>const</code> 和底层<code>const</code> </p>
<p>顶层<code>const</code> 可以表示任意的对象是常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;    <span class="comment">// a不能改变，是顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;    <span class="comment">// p不能改变指向，是顶层const</span></span><br></pre></td></tr></table></figure>
<p>低层<code>const</code> 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;    <span class="comment">// 指向a的指针，不能通过这个指针修改a的值，是底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = a;    <span class="comment">// a的引用，不能通过这种方式修改a, 是底层const</span></span><br></pre></td></tr></table></figure>
<h3 id="const-与参数传递"><a href="#const-与参数传递" class="headerlink" title="const 与参数传递"></a><code>const</code> 与参数传递</h3><ul>
<li><p>在参数传递时，顶层<code>const</code>会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层<code>const</code> 后没有区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用非常量初始化底层<code>const</code> ，但不能使用常量去初始化非底层<code>const</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_1 = a;  <span class="comment">// 可以， 可以使用非常量初始化底层const</span></span><br><span class="line"><span class="type">int</span> &amp;ret_2 = b;      <span class="comment">// 不可以， 不能使用常量去初始化非底层const</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非常量的引用必须是左值，常量的引用可以是左值，也可以是右值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">1</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> &amp;b = <span class="number">2</span>;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>因此<strong>尽量将不会改变形参的函数的形参定义成底层<code>const</code></strong> ，因为这样定义我们可以使用字面量（rvalue）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>placement new</title>
    <url>/2022/12/17/placement-new/</url>
    <content><![CDATA[<h1 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h1><p>最典型的<code>placement new</code> 的签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span> * pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>placement new</code> 就得名于这个最典型的new。</p>
<p>下面这个程序将展示这种<code>placement new</code> 的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">obj</span>() &#123;num = <span class="number">233</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; num &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    obj * p = (obj *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (obj));</span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    obj * t = <span class="built_in">new</span>(p) <span class="built_in">obj</span>();       <span class="comment">// placement new : 在一片已分配但未使用的区域调用构造函数</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t;        <span class="comment">// p 和 t的值相同，说明placement new 的返回值就是p</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">411689296</span></span><br><span class="line"><span class="number">233</span></span><br><span class="line"><span class="number">0xb25fb0</span> <span class="number">0xb25fb0</span></span><br></pre></td></tr></table></figure>
<p>当最初使用malloc时，<code>obj</code>的构造函数并没有被调用，因此<code>num</code>的值是垃圾值，当使用<code>placement new</code>之后，在原位置调用了构造函数，因此<code>num</code>的值变为了233，而这个<code>placement new</code>的返回值也就是我们传入的那个<code>rawMemory</code></p>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 配置</title>
    <url>/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="ubuntu-配置"><a href="#ubuntu-配置" class="headerlink" title="ubuntu 配置"></a>ubuntu 配置</h1><p>2022/9/1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。</p>
<h2 id="VScode-下载和配置"><a href="#VScode-下载和配置" class="headerlink" title="VScode 下载和配置"></a>VScode 下载和配置</h2><p>下载的方法见官网，配置C/C++的方法网上的博客也很好搜到</p>
<p><a href="https://blog.csdn.net/qq_42911863/article/details/125619397">Linux系统VsCode 配置C/C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境</a>  </p>
<p>接下来使将<code>Open With Code</code> 添加到右键菜单</p>
<blockquote>
<p>这部分参考</p>
<p><a href="https://www.cnblogs.com/hongdoudou/p/12708510.html">ubuntu中为vscode添加右键菜单—网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com)</a></p>
<p>其中修改了一点命令，将visual-studio-code 改成了code</p>
</blockquote>
<p>去<code>$HOME/.local/share/nautilus/script/</code> 目录下新建一个文件，文件名就是显示在右键菜单上的名字。</p>
<p>接着将以下内容复制到新建的文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script opens a gnome-terminal in the directory you select.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Distributed under the terms of GNU GPL version 2 or later</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts</span></span><br><span class="line"><span class="comment"># You need to be running Nautilus 1.0.3+ to use scripts.</span></span><br><span class="line"><span class="comment"># When a directory is selected, go there. Otherwise go to current</span></span><br><span class="line"><span class="comment"># directory. If more than one directory is selected, show error.</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">destination=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="comment"># Go to file&#x27;s directory if it&#x27;s a file</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$destination</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">destination=<span class="string">&quot;`dirname &quot;</span><span class="variable">$destination</span><span class="string">&quot;`&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">zenity --error --title=<span class="string">&quot;Error - Open terminal here&quot;</span> /</span><br><span class="line">--text=<span class="string">&quot;You can only select one directory.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">destination=<span class="string">&quot;`echo &quot;</span><span class="variable">$NAUTILUS_SCRIPT_CURRENT_URI</span><span class="string">&quot; | sed &#x27;s/^file://////&#x27;`&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># It&#x27;s only possible to go to local directories</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;`echo &quot;</span><span class="variable">$destination</span><span class="string">&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">zenity --error --title=<span class="string">&quot;Error - Open terminal here&quot;</span> /</span><br><span class="line">--text=<span class="string">&quot;Only local directories can be used.&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$destination</span>&quot;</span></span><br><span class="line"><span class="built_in">exec</span> code <span class="string">&quot;<span class="variable">$destination</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后运行命令<code>chmod +x  刚才创建的文件名</code> </p>
<p>对文件或文件夹右键就可以看到刚才添加的右键菜单了。</p>
<h2 id="下拉式终端Yakuka"><a href="#下拉式终端Yakuka" class="headerlink" title="下拉式终端Yakuka"></a>下拉式终端Yakuka</h2><p>在<a href="https://snapcraft.io/yakuake">这里</a> 找到 <a href="https://snapcraft.io/install/yakuake/ubuntu">Ubuntu</a> 根据提示安装。</p>
<p>如果安装失败可能要换清华源，如下：</p>
<h2 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_49700990/article/details/122005001">https://blog.csdn.net/weixin_49700990/article/details/122005001</a></p>
</blockquote>
<p>首先使用<code>lsb_release -a</code> 查看自己的Ubuntu版本</p>
<p>我们要更改的文件是 /etc/apt/sources.list，</p>
<p>首先使用命令对这个文件进行备份 </p>
<p><code>sudo cp /etc/apt/sources.list /etc/apt/sources_save.list</code></p>
<p>接着 进入<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华源网站</a> ，找到<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">Ubuntu的源</a> ，选择合适的版本，根据提示手动替换即可。</p>
<h2 id="设置应用开机启动"><a href="#设置应用开机启动" class="headerlink" title="设置应用开机启动"></a>设置应用开机启动</h2><p>在Ubuntu自带的 “启动应用程序” 里配置</p>
<h2 id="更改磁盘大小"><a href="#更改磁盘大小" class="headerlink" title="更改磁盘大小"></a>更改磁盘大小</h2><blockquote>
<p>参考 <a href="https://blog.csdn.net/Shine_Su/article/details/124630751">https://blog.csdn.net/Shine_Su/article/details/124630751</a></p>
</blockquote>
<p>首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。</p>
<h2 id="将虚拟机的内容复制到虚拟机外"><a href="#将虚拟机的内容复制到虚拟机外" class="headerlink" title="将虚拟机的内容复制到虚拟机外"></a>将虚拟机的内容复制到虚拟机外</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/u013554213/article/details/124061526">https://blog.csdn.net/u013554213/article/details/124061526</a></p>
</blockquote>
<p>依次执行以下命令，最后重启Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除原来安装过的文件</span></span><br><span class="line">sudo apt autoremove open-vm-tools</span><br><span class="line"><span class="comment"># 输入安装命令：</span></span><br><span class="line">sudo apt install open-vm-tools</span><br><span class="line">sudo apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>
<h2 id="截图软件"><a href="#截图软件" class="headerlink" title="截图软件"></a>截图软件</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/415011610">https://zhuanlan.zhihu.com/p/415011610</a></p>
</blockquote>
<p><code>sudo apt install flameshot</code></p>
<p>查看安装路径</p>
<p><code>which flameshot</code></p>
<p>在设置中，添加键盘快捷键</p>
<p>命令是<code>/usr/bin/flameshot gui</code></p>
]]></content>
      <categories>
        <category>使用教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是启蒙运动？</title>
    <url>/2022/12/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%AF%E8%92%99%E8%BF%90%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="康德-什么是启蒙运动？"><a href="#康德-什么是启蒙运动？" class="headerlink" title="康德|什么是启蒙运动？"></a>康德|什么是启蒙运动？</h3><ul>
<li>启蒙运动就是人类脱离自己所加之于自己的不成熟状态，不成熟状态就是不经别人的引导，就对运用自己的理智无能为力。当其原因不在于缺乏理智，而在于不经别人的引导就缺乏勇气与决心去加以运用时，那么这种不成熟状态就是自己所加之于自己的了。Sapere Aude！要有勇气运用你自己的理智！这就是启蒙运动的口号。</li>
<li>懒惰和怯懦乃是何以有如此大量的人，当大自然早己把他们从外界的引导之下释放出来以后（naturalitermaiorennes）时，却仍然愿意终身处于不成熟状态之中，以及别人何以那么轻而易举地就俨然以他们的保护人自居的原因所在。处于不成熟状态是那么安逸。如果我有一部书能替我有理解，有一位牧师能替我有良心，有一位医生能替我规定食谱，等等；那么我自己就用不着操心了。只要能对我合算，我就无需去思想：自有别人会替我去做这类伤脑筋的事。</li>
<li>绝大部分的人（其中包括全部的女性）都把步入成熟状态认为除了是非常之艰辛而外并且还是非常之危险的；这一点老早就被每一个一片好心在从事监护他们的保护人关注到了。保护人首先是使他们的牲口愚蠢，并且小心提防着这些温驯的畜牲不要竟敢冒险从锁着他们的摇车里面迈出一步；然后就向他们指出他们企图单独行走时会威胁他们的那种危险。可是这种危险实际上并不那么大，因为他们跌过几交之后就终于能学会走路的；然而只要有过一次这类事例，就会使人心惊胆战并且往往吓得完全不敢再去尝试了。</li>
<li>任何一个个人要从几乎已经成为自己天性的那种不成熟状态之中奋斗出来，都是很艰难的。他甚至于已经爱好它了，并且确实暂时还不能运用他自己的理智，因为人们从来都不允许他去做这种尝试。条例和公式这类他那天分的合理运用、或者不如说误用的机械产物，就是对终古长存的不成熟状态的一副脚梏。谁要是抛开它，也就不过是在极狭窄的沟渠上做了一次不可靠的跳跃而己，因为他并不习惯于这类自由的运动。因此就只有很少数的人才能通过自己精神的奋斗而摆脱不成熟的状态，并且从而迈出切实的步伐来。</li>
<li>然而公众要启蒙自己，却是很可能的；只要允许他们自由，这还确实几乎是无可避免的。因为哪怕是在为广大人群所设立的保护者们中间，也总会发见一些有独立思想的人；他们自己在抛却了不成熟状态的羁绊之后，就会传播合理地估计自己的价值以及每个人的本分就在于思想其自身的那种精神。这里面特别值得注意的是：公众本来是被他们套上了这种羁绊的，但当他们的保护者（其本身是不可能有任何启蒙的）中竟有一些人鼓动他们的时候，此后却强迫保护者们自身也处于其中了；种下偏见是那么有害，因为他们终于报复了本来是他们的教唆者或者是他们教唆者的先行者的那些人。因而公众只能是很缓慢地获得启蒙。通过一场革命或许很可以实现推翻个人专制以及贪婪心和权势欲的压迫，但却绝不能实现思想方式的真正改革；而新的偏见也正如旧的一样，将会成为驾驭缺少思想的广大人群的圈套。</li>
<li>然而，这一启蒙运动除了自由而外并不需要任何别的东西，而且还确乎是一切可以称之为自由的东西之中最无害的东西，那就是在一切事情上都有公开运用自己理性的自由。可是我却听到从四面八方都发出这样的叫喊：不许争辩！军官说：不许争辩，只许操练！税吏说：不许争辩，只许纳税。神甫说：不许争辩，只许信仰。（举世只有一位君主说：可以争辩，随便争多少，随便争什么，但是要听话！君主指普鲁士腓德烈大王）到处都有对自由的限制。</li>
<li>然则，哪些限制是有碍启蒙的，哪些不是，反而是足以促进它的呢？—我回答说：必须永远有公开运用自己理性的自由，并且唯有它才能带来人类的启蒙。私下运用自己的理性往往会被限制得很狭隘，虽则不致因此而特别妨碍启蒙运动的进步。而我所理解的对自己理性的公开运用，则是指任何人作为学者在全部听众面前所能做的那种运用。一个人在其所受任的一定公职岗位或者职务上所能运用的自己的理性，我就称之为私下的运用。</li>
<li>就涉及共同体利益的许多事物而言，则我们必须有一定的机器，共同体的一些成员必须靠它来保持纯粹的消极态度，以便他们由于一种人为的一致性而由政府引向公共的目的，或者至少也是防止破坏这一目的。在这上面确实是不容许有争辩的；而是人们必须服从。但是就该机器的这一部分同时也作为整个共同体的，乃至于作为世界公民社会的成员而论，从而也就是以一个学者的资格通过写作面向严格意义上的公众时，则他是绝对可以争辩的，而不致因此就有损于他作为一个消极的成员所从事的那种事业。因此，一个服役的军官在接受他的上级交下某项命令肘，竟抗声争辩这项命令的合目的性或者有用性，那就会非常坏事；他必须服从。但是他作为学者而对军事业务上的错误进行评论并把它提交给公众来作判断时，就不能公开地加以禁止了。公民不能拒绝缴纳规定于他的税额；对所加给他的这类赋税惹事生非地擅行责难，甚至可以当作诽谤（这可能引起普遍的反抗）而加以惩处。然而这同一个人作为一个学者公开发表自己的见解，抗议这种课税的不适宜与不正当不一样，他的行动并没有违背公民的义务。同样地，一个牧师也有义务按照他所服务的那个教会的教义向他的教义问答班上的学生们和他的会众们作报告，因为他是根据这一条件才被批准的。但是作为一个学者，他却有充分自由、甚至于有责任，把他经过深思熟虑有关那种教义的缺点的全部善意的意见以及关于更好地组织宗教团体和教会团体的建议传达给公众。这里面并没有任何可以给他的良心增添负担的东西。因为他把作为一个教会工作者由于自己职务的关系而讲授的东西，当作是某种他自己并没有自由的权力可以按照自己的心意进行讲授的东西；他是受命根据别人的指示并以别人的名义选行讲述的。他将要说：我们的教会教导这些或那些；这里就是他们所引用的论据。于是，他就从他自己不会以完全的信服而赞同、虽则他很可以使自己负责进行宣讲的那些条文中—因为并非是完全不可能其中也隐藏着真理，而且无论如何至少其中不会发见有任何与内心宗教相违背的东西，—为他的听众引绎出全部的实用价值来。因为如果他相信其中可以发见任何与内心宗教相违背的东西，那么他就不能根据良心而尽自己的职务了，他就必须辞职。一个就任的宣教师之向他的会众运用自己的理性，纯粹是一种私下的运用；因为那往往只是一种家庭式的聚会，不管是多大的聚会；而在这方面他作为一个牧师是并不自由的，而且也不能是自由的，因为他是在传达别人的委托。反之，作为一个学者通过自己的著作而向真正的公众亦即向全世界讲话时，则牧师在公开运用他的理性上便享有无限的自由可以使用他自己的理性，并以他自己本人的名义发言。因为人民（在精神事务上）的保护者而其本身居然也不成熟，那便可以归结为一种荒谬性，一种永世长存的荒谬性了。</li>
<li>然则一种牧师团体、一种教会会议或者一种可敬的教门法院（就象他们在荷兰人中间所自称的那样），是不是有权宣誓他们自己之间对某种不变的教义负有义务，以便对其每一个成员并且由此也就是对全体人民进行永不中辍的监护，甚至于使之永恒化呢？我要说：这是完全不可能的。这样一项向人类永远封锁住了任何进一步启蒙的契约乃是绝对无效的，哪怕它被最高权力、被国会和最庄严的和平条约所确认。一个时代决不能使自己负有义务并从而发誓，要把后来的时代置于一种决没有可能扩大自己的（尤其是十分迫切的）认识、清除错误以及一般地在启蒙中继续进步的状态之中。这会是一种违反人性的犯罪行为，人性本来的天职恰好就在于这种进步；因此后世就完全有权拒绝这种以毫无根据而且是犯罪的方式所采取的规定。</li>
<li>凡是一个民族可以总结为法律的任何东西，其试金石都在于这样一个问题：一个民族是不是可以把这样一种法律加之于其自身？它可能在一个有限的短时期之内就好像是在期待着另一种更好的似的，为的是好实行一种制度，使得每一个公民而尤其是牧师都能有自由以学者的身份公开地，也就是通过著作，对现行组织的缺点发表自己的言论。这种新实行的制度将要一直延续下去，直到对这类事情性质的洞见已经是那么公开地到来并且得到了证实，以致于通过他们联合（即使是并不一致）的呼声而可以向王位提出建议，以便对这一依据他们更好的洞见的概念而结合成另一种已经改变了的宗教组织加以保护，而又不致于妨碍那些仍愿保留在旧组织之中的人们。但是统一成一个固定不变的、没有人能够（哪怕在一个人的整个一生中）公开加以怀疑的宗教体制，从而也就犹如消灭了人类朝着改善前进的整整一个时代那样，并由此给后代造成损害，使得他们毫无收获，—这却是绝对不能容许的。一个人确实可以为了他本人并且也只是在一段时间之内，推迟对自己有义务加以认识的事物的启蒙；然而迳行放弃它，那就无论是对他本人，而更其是对于后代，都可以说是违反而且践踏人类的神圣权利了。</li>
<li>而人民对于他们本身都不能规定的事，一个君主就更加不可以对他的人民规定了；因为他的立法威望全靠他把全体人民的意志结合为他自己的意志。只要他注意使一切真正的或号称的改善都与公民秩序结合在一起，那么此外他就可以把他的臣民发觉对自己灵魂得教所必须做的事情留给他们自己去做；这与他无关，虽则他必须防范任何人以强力妨碍别人根据自己的全部才能去做出这种决定并促进这种得救。如果他干预这种事，要以政府的监督来评判他的臣民借以亮明他们自己的见识的那些作品；以及如他凭自己的最高观点来这样做，而使自己受到Caesarnon estt supragrammaticos（凯撒并不高于文法学家）的这种责难；那就会有损于他的威严。如果他把自己的最高权力降低到竟至去支持自己国内的一些暴君对他其余的臣民实行精神专制主义的时候，那就更加每况愈下了。</li>
<li>如果现在有人问：我们目前是不是生活在一个启蒙了的时代？那么回答就是：并不是，但确实是在一个启蒙运动的时代。目前的情形是，要说人类总的说来已经处于，或者是仅仅说已经被置于，一种不需别人引导就能够在宗教的事情上确切地而又很好地使用自己的理智的状态了，则那里面还缺乏许多东西。可是现在领域已经对他们开放了，他们可以自由地在这上面工作了，而且对普遍启蒙的、或者说对摆脱自己所加给自己的不成熟状态的障碍也逐渐地减少了；关于这些我们都有着明确的信号。就这方面考虑，这个时代乃是启蒙的时代，或者说乃是腓德烈的世纪。</li>
<li>一个不以如下说法为与自己不相称的国君：他认为自己的义务就是要在宗教事务方面决不对人们加以任何规定，而是让他们有充分的自由，但他又甚至谢绝宽容这个高傲的名称；这位国君本人就是启蒙了的，并且配得上被天下后世满怀感激之忱尊之为率先使得人类，至少从政权方面而言，脱离了不成熟状态，并使每个人在任何有关良心的事务上都能自由地运用自身所固有的理性。在他的治下，可敬的牧师们可以以学者的身份自由地并且公开地把自己在这里或那里偏离了既定教义的各种判断和见解都提供给全世界来检验，而又无损于自己的职责：至于另外那些不受任何职责约束的人，那就更加是如此了。这种自由精神也要向外扩展，甚至于扩展到必然会和误解了其自身的那种政权这一外部阻碍发生冲突的地步。因为它对这种政权树立了一个范例，即自由并不是一点也不关怀公共的安宁和共同体的团结一致的。只有当人们不再有意地想方设法要把人类保持在野蛮状态的时候，人类才会由于自己的努力而使自己从其中慢慢地走出来。</li>
<li>我把启蒙运动的重点，亦即人类摆脱他们所加之于其自身的不成熟状态，主要是放在宗教事务方面，因为我们的统治者在艺术和科学方面并没有向他们的臣民尽监护之责的兴趣；何况这一不成熟状态既是一切之中最有害的而又是最可耻的一种。但是，一个庇护艺术与科学的国家首领，他的思想方式就要更进一步了，他洞察到：即使是在他的立法方面，容许他的臣民公开运用他们自身的理性，公开向世上提出他们对于更好地编篡法律、甚至于是直言无讳地批评现行法律的各种见解，那也不会有危险的。在这方面，我们有着一个光辉的典范，我们所尊敬的这位君主（指普鲁士腓德烈大王）就是没有别的君主能够超越的。</li>
<li>但是只有那位其本身是启蒙了的、不怕幽灵的而同时手中又掌握着训练精良的大量军队可以保障公共安宁的君主，才能够说出一个自由国家所不敢说的这种话：可以争辩，随便争多少，随便争什么；但是必须听话。这就标志着人间事务的一种可惊异的、不能意料的进程；正犹如当我们对它从整体上加以观察时，其中就几乎一切都是悖论那样。程度更大的公民自由仿佛是有利于人民精神的自由似的，然而它却设下了不可逾越的限度；反之，程度较小的公民自由却为每个人发挥自己的才能开辟了余地。因为当大自然在这种坚硬的外壳之下打开了为她所极为精心照料着的幼芽时，也就是要求思想自由的倾向与任务时，它也就要逐步地反作用于人民的心灵面貌（从而他们慢慢地就能掌握自由）；并且终于还会反作用于政权原则，使之发见按照人的尊严—人并不仅仅是机器而已—去看待人，也是有利于政权本身的。</li>
<li>1784年9月30日，于普鲁士哥尼斯堡（刘伟录自《历史理性批判文集》）</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>动态数组,二维数组,指针</title>
    <url>/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="动态数组、二维数组、指针"><a href="#动态数组、二维数组、指针" class="headerlink" title="动态数组、二维数组、指针"></a>动态数组、二维数组、指针</h1><p>本文会讲：</p>
<ul>
<li>二维数组的存储形式</li>
<li>数组类型为什么会退化？</li>
<li>二维数组的动态分配</li>
</ul>
<h2 id="1-二维数组的存储形式"><a href="#1-二维数组的存储形式" class="headerlink" title="1 二维数组的存储形式"></a>1 二维数组的存储形式</h2><p>以下这个程序可以很好的说明二维数组的存储形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = i * <span class="number">10</span> + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的运行结果是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">32</span>      </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DD0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">000000000064F</span>DD0</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">000000000064F</span>DD8</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">000000000064F</span>DE0</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DD4</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DDC</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DE4</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE8</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DEC</span><br></pre></td></tr></table></figure>
<p>可以看出，二维数组是连续储存的，有<code>&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0]</code> ，以此类推。</p>
<p>我们可以这样表示二维数组</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-数组类型为什么会退化？"><a href="#2-数组类型为什么会退化？" class="headerlink" title="2 数组类型为什么会退化？"></a>2 数组类型为什么会退化？</h2><p>有的时候会出现这种情况：</p>
<p>在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？</p>
<p>详见：<a href="https://www.zhihu.com/question/464844221/answer/1940453834">https://www.zhihu.com/question/464844221/answer/1940453834</a></p>
<h2 id="3-动态分配二维数组"><a href="#3-动态分配二维数组" class="headerlink" title="3 动态分配二维数组"></a>3 动态分配二维数组</h2><h3 id="3-1-第一种方法"><a href="#3-1-第一种方法" class="headerlink" title="3.1 第一种方法"></a>3.1 第一种方法</h3><p>先申请一维数组，在将该一维数组强制转换成二维数组</p>
<p>前置知识：</p>
<p>一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息</p>
<p>二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型，</p>
<p>即<code>int q[][4]</code> 和<code>int (*q)[4]</code> 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于<code>q += 2 * 4 * sizeof(int)</code></p>
<p>直接贴代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="type">int</span> (*b)[<span class="number">4</span>] = (<span class="type">int</span> (*)[<span class="number">4</span>])a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。</p>
<p>我们用<code>int (*b)[4]</code> 声明了一个指向 四个元素的数组 的指针。</p>
<p>然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。</p>
<p>这样动态分配的指针和直接<code>int b[2][4]</code> 是一样的。</p>
<p>下面我们使用 1 中的方法对这个数组进行仔细检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        b[i] = i;</span><br><span class="line">    <span class="type">int</span> (*a)[<span class="number">2</span>] = (<span class="type">int</span> (*)[<span class="number">2</span>])b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span>       </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span>      </span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span>      </span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">02</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">03</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">04</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">05</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">06</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">07</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">00000000009</span>C1420</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">00000000009</span>C1428</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">00000000009</span>C1430</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">2</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">4</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1424</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C142C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1434</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1438</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C143C</span><br></pre></td></tr></table></figure>
<p>可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。</p>
<p>这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 </p>
<h3 id="3-2-第二种方法："><a href="#3-2-第二种方法：" class="headerlink" title="3.2 第二种方法："></a>3.2 第二种方法：</h3><blockquote>
<p>参考: <a href="https://blog.csdn.net/morewindows/article/details/7664479#">https://blog.csdn.net/morewindows/article/details/7664479#</a> 我这里将原文的int 替换成了size_t</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C语言中动态的申请二维数组 malloc free</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//动态申请二维数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T** <span class="title">malloc_Array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="built_in">sizeof</span>(T);</span><br><span class="line">  <span class="type">int</span> point_size = <span class="built_in">sizeof</span>(T*);</span><br><span class="line">  <span class="comment">//先申请内存，其中point_size * row表示存放row个行指针</span></span><br><span class="line">  T **arr = (T **) <span class="built_in">malloc</span>(point_size * row + size * row * col);</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;	</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, point_size * row + size * row * col);</span><br><span class="line">    T *head = (T*)((<span class="type">size_t</span>)arr + point_size * row);    <span class="comment">// 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好</span></span><br><span class="line">    <span class="keyword">while</span> (row--)</span><br><span class="line">      arr[row] = (T*)((<span class="type">size_t</span>)head + row * col * size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T**)arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_Aarray2D</span><span class="params">(<span class="type">void</span> **arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  C语言中动态的申请二维数组 malloc free\n&quot;</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入行列(以空格分开): &quot;</span>);</span><br><span class="line">  <span class="type">int</span> nRow, nCol;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;nRow, &amp;nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//动态申请连续的二维数组</span></span><br><span class="line">  <span class="type">int</span> **p = <span class="built_in">malloc_Array2D</span>&lt;<span class="type">int</span>&gt;(nRow, nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//为二维数组赋值	</span></span><br><span class="line">  <span class="type">int</span> i, j;	</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      p[i][j] = i + j;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//输出二维数组	</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p[i][j]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free_Aarray2D</span>((<span class="type">void</span>**)p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，原作者对指针的操作让我叹为观止。</p>
<p>但是，用这种方法创作出来的二维数组和直接<code>int b[2][4]</code> 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-3-第三种方法"><a href="#3-3-第三种方法" class="headerlink" title="3.3 第三种方法"></a>3.3 第三种方法</h3><blockquote>
<p>参考：<a href="https://blog.csdn.net/houqd2012/article/details/8146070">https://blog.csdn.net/houqd2012/article/details/8146070</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。</p>
<p>我们使用 1 中的程序对这个数组进行详细的检查。代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span></span><br><span class="line"></span><br><span class="line">a:      <span class="number">0000000000701420</span></span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">0000000000701450</span></span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">0000000000701458</span></span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">0000000000701460</span></span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">0000000000701468</span></span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">0000000000701420</span></span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">0000000000701428</span></span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">0000000000701430</span></span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">0000000000701438</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">0000000000701450</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">0000000000701454</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">0000000000701458</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000070145</span>C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">0000000000701460</span></span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">0000000000701464</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">0000000000701468</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000070146</span>C</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接<code>int b[2][4]</code> 得到的二维数组，还是不一样的。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-4-总结-：-下标运算符"><a href="#3-4-总结-：-下标运算符" class="headerlink" title="3.4 总结 ： 下标运算符"></a>3.4 总结 ： 下标运算符</h3><p>首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。</p>
<p>下标运算符是左结合的，我们引用二维数组，通常是这样的    <code>arr[i][j]</code> 但其实也可以这样 <code>(arr[i])[j]</code> 这两种形式是等价的。</p>
<p>下面我们详细地描述下标运算符 </p>
<p><code>ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType))</code></p>
<p>可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型<code>int **</code>, 也可以是数组类型 <code>int (*)[]</code>，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。</p>
<p>首先我们来看内置的数组类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<p>一个内置数组类型表示为<code>int a[5][5]</code> ，但拎出来a，他的类型是 <code>int (*)[5]</code> 所以<code>arr[1]</code> 其实是指<code>a[1][0]</code> 这个位置。<code>a[1]</code> 的类型是<code>int *</code> 所以<code>(a[1])[1]</code> 的类型就是<code>int</code></p>
<p>接下来我们看动态分配二维数组的第一种方法：</p>
<p>这种方法一开始申请了一个一维数组<code>int *a = (int *)malloc(2 * 4 * sizeof(int))</code> a的类型是<code>int *</code></p>
<p>接下来我们使用强制类型转换，将a由<code>int *</code> 转换为<code>int (*)[4]</code> ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。</p>
<p>接下类我们看动态分配二维数组的第二种方法：</p>
<p>首先我们将这种方法分配的图画出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209061948605.png" alt="image-20220906194800829">  </p>
<p>设行数为row，列数为col，假设二维数组存储的类型为 int</p>
<p>第二种方法申请了 <code>row * sizeof(int *) + row * col * sizeof(int)</code> 字节的空间。</p>
<p>这个表达式的前一项<code>row * sizeof(int *)</code> 代表a[0] a[1] a[2] 的空间，后一项<code>row * col * sizeof(int)</code> 指的是连续的二维数组的存储空间。</p>
<p>这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。</p>
<p>需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是<code>int **</code> 而不是<code>int (*)[col]</code> ，也决不能是<code>int (*)[col]</code> 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？</p>
<p>首先a的类型时<code>int **</code> ，a[1]，代表a之后一个指针大小位置的内容，即</p>
<p><code>*((size_t)a + 1 * sizeof(int *))</code>，就是a[1] [0]的地址，而<code>(a[1])[0]</code> 就是a[1] [0]的内容。</p>
<p>为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是<code>int **</code> </p>
<p>第三种二维数组的分析与第二种类似，这里我们给出它的表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209062002932.png" alt="image-20220906200208361"> </p>
<h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><p>我们使用一个程序来展示 <code>int (*)[col]</code> 类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> a[][<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_3</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>])</span>  <span class="comment">// 指向数组的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*a)[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> q[<span class="number">4</span>][<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      q[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">  func_1(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  func_2(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> p[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  func_3(&amp;p);		<span class="comment">// 因为是指向数组的指针，p必须要取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一篇文章 ：<a href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></p>
<p>这篇文章里对指针类型的分析很好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line">Int (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于英文论文作者名称中逗号与句号的使用</title>
    <url>/2023/03/06/%E5%85%B3%E4%BA%8E%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E5%90%8D%E7%A7%B0%E4%B8%AD%E9%80%97%E5%8F%B7%E4%B8%8E%E5%8F%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Q : 论文作者名称中句号和逗号的意义是什么</p>
<p>A : </p>
<blockquote>
<p>你好，这是必应。😊</p>
<p><a href="https://www.zhihu.com/question/456669273">论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。一般来说，句号用于分隔作者的名和姓，逗号用于分隔多个作者</a><a href="https://www.zhihu.com/question/456669273">1</a>。例如：</p>
<p>张三.李四,王五.赵六.</p>
<p>表示有两个作者，分别是张三和王五，他们的名字是李四和赵六。</p>
<p><a href="https://www.xiegelunwen.com/article/chachong/05f0411947871274.html">如果你想了解更多关于参考文献著录规则的信息，你可以查看GB/T 7714—2015《信息与文献：参考文献著录规则》</a><a href="https://www.xiegelunwen.com/article/chachong/05f0411947871274.html">2</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/98524815">论文中作者顺序也有一定的含义，通常反映了作者对论文的贡献大小</a><a href="https://zhuanlan.zhihu.com/p/98524815">3</a>。例如：</p>
<p>张三.李四,王五.赵六*,刘七.钱八.</p>
<p>表示第一个作者是张三，最后一个作者是刘七，通讯作者（负责联系编辑和审稿人）是王五。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 我指的是英文，例如 Howard, J., Hyman, A.A.: ‘Dynamics and mechanics of the microtubule plus end’Nature, 2003, 422, (6933), pp. 753–758.</p>
<p>A : </p>
<blockquote>
<p>原来如此，你是指英文论文的作者名称。😊</p>
<p><a href="https://zhuanlan.zhihu.com/p/272715312">英文论文的作者名称中句号和逗号的意义也可能因不同的引用格式而有所不同。一般来说，句号用于缩写作者的名字，逗号用于分隔多个作者</a><a href="https://zhuanlan.zhihu.com/p/272715312">1</a>。例如：</p>
<p>Howard, J., Hyman, A.A.</p>
<p>表示有两个作者，分别是Howard和Hyman，他们的名字缩写为J和A.A.</p>
<p><a href="https://zhuanlan.zhihu.com/p/272715312">不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者</a><a href="https://zhuanlan.zhihu.com/p/272715312">1</a><a href="https://zhuanlan.zhihu.com/p/349018810">2</a><a href="https://zhuanlan.zhihu.com/p/129904989">3</a>。例如：</p>
<p>Howard, J., Hyman, A.A., &amp; Smith, P.</p>
<p>表示有三个作者，分别是Howard、Hyman和Smith。</p>
<p>Howard, J., et al.</p>
<p>表示有多个作者，只列出了第一个作者Howard。</p>
<p>你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。</p>
</blockquote>
<p>Q : Howard, J 代表一个人，为什么它的名字中间还有逗号呢？</p>
<p>A : </p>
<blockquote>
<p>Howard, J 代表一个人，但是它的名字是由两部分组成的，姓和名。在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。例如：</p>
<p>Howard, J.</p>
<p>表示作者的姓是Howard，名是J开头的单词，比如John或James。</p>
<p>你明白了吗？</p>
</blockquote>
<p>Q : 所以姓和名之间要用逗号分隔，此外，多个人名中间也需要使用逗号分隔，我理解的正确吗</p>
<p>A : </p>
<blockquote>
<p>是的，你理解的正确。😊</p>
<p>姓和名之间要用逗号分隔，多个人名中间也需要使用逗号分隔。这样做可以清楚地表达作者的身份和数量。例如：</p>
<p>Howard, J., Hyman, A.A., Smith, P.</p>
<p>表示有三个作者，分别是Howard、Hyman和Smith。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 请问 Smith, P. 这个名字，他最后的句号代表什么呢？</p>
<p>A : </p>
<blockquote>
<p>Smith, P. 这个名字，最后的句号是用来表示作者的名字是缩写的。如果作者的名字不是缩写的，就不需要最后的句号。例如：</p>
<p>Smith, Peter</p>
<p>表示作者的名字是Peter，不是缩写的。</p>
<p>Smith, P.</p>
<p>表示作者的名字是P开头的单词，比如Paul或Patrick，是缩写的。</p>
<p>你还有什么问题吗？</p>
</blockquote>
<p>Q : 你可以总结一下我们这次的对话，最好有所有的细节，我想保存这次对话，以便于下次查阅，谢谢！</p>
<p>A : </p>
<blockquote>
<p>好的，我很乐意为你总结我们这次的对话。😊</p>
<p>我们这次的对话主要是关于论文作者名称中句号和逗号的意义。以下是我们讨论的要点：</p>
<ul>
<li>论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。</li>
<li>一般来说，句号用于分隔或缩写作者的名和姓，逗号用于分隔多个作者。</li>
<li>不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者。</li>
<li>你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。</li>
<li>在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。</li>
<li>如果没有下一个作者，就不需要最后一个逗号。如果作者的名字不是缩写的，就不需要最后一个句号。</li>
</ul>
<p>我希望这次总结能够帮助你更好地理解论文作者名称中句号和逗号的意义。如果你还有其他问题，请随时提出。🙏</p>
</blockquote>
<p>关于复姓</p>
<p>Q : 对于复姓的中国作者，他们的名称应该怎样书写呢，例如欧阳 洪，其中欧阳是姓氏，洪是名称。读音是Ouyang Hong</p>
<p>A：</p>
<blockquote>
<p><a href="https://www.wikiwand.com/en/Chinese_compound_surname">对于复姓的中国作者，他们的名称应该按照复姓的拼音和名称的首字母写出，复姓用连字符连接。例如，欧阳 洪的引文格式应该是 Ouyang-H., 或者 Ouyang-Hong</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
  </entry>
  <entry>
    <title>在vscode配置cmake</title>
    <url>/2022/11/14/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEcmake/</url>
    <content><![CDATA[<h1 id="在vscode中配置cmake"><a href="#在vscode中配置cmake" class="headerlink" title="在vscode中配置cmake"></a>在vscode中配置cmake</h1><h2 id="配置includePath"><a href="#配置includePath" class="headerlink" title="配置includePath"></a>配置includePath</h2><p>vscode的静态语法检查是 intellisense 完成的，想要使它能搜寻到指定的includePath需要这要做：</p>
<ol>
<li>ctrl p，输入c/c++ edit configurations(JSON)，这会在本地的<code>./vscode/</code>下创建<code>c_cpp_properties.json</code> 在includePath里面添加上自己的include path即可</li>
</ol>
<h2 id="配置generator"><a href="#配置generator" class="headerlink" title="配置generator"></a>配置generator</h2><p>首先 ctrl+p，输入settings.json，点击 “首选项：打开工作区设置(JSON)”。</p>
<p>此操作会创建 <code>./vscode/settings.json</code> 在此文件中加入<code>&quot;cmake.generator&quot; : &quot;MinGW Makefiles&quot;</code> 根据不同的系统，配置不同的generator。</p>
<h2 id="配置debugger"><a href="#配置debugger" class="headerlink" title="配置debugger"></a>配置debugger</h2><p>在侧边栏 调试 中点击创建 “launch.json” 或直接创建launch.json 只要是带有调试信息的可执行文件，都可以调试</p>
]]></content>
  </entry>
  <entry>
    <title>存储器层次结构 - CS:APP 第六章</title>
    <url>/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="存储器层次结构-CS-APP-第六章"><a href="#存储器层次结构-CS-APP-第六章" class="headerlink" title="存储器层次结构 - CS:APP 第六章"></a>存储器层次结构 - CS:APP 第六章</h1><p>本章的主要内容有四：</p>
<ol>
<li>介绍存储技术 </li>
<li>介绍存储器的层次结构思想</li>
<li>特别介绍高速缓存的原理和细节</li>
<li>使用局部性优化程序的性能</li>
</ol>
<p>本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。</p>
<h2 id="1-存储器的层次结构"><a href="#1-存储器的层次结构" class="headerlink" title="1 存储器的层次结构"></a>1 存储器的层次结构</h2><p>根据我们的经验观察，读取速度越快的存储器/存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。</p>
<p>因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。</p>
<p>但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。</p>
<blockquote>
<p>存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">L0  寄存器</span><br><span class="line">L1  L1高速缓存 SRAM</span><br><span class="line">L2  L2高速缓存 SRAM</span><br><span class="line">L3  L3高速缓存 SRAM</span><br><span class="line">L4  主存 DRAM</span><br><span class="line">L5  本地二级存储（本地磁盘）</span><br><span class="line">L6  远程二级缓存（分布式文件系统、二级服务器）</span><br></pre></td></tr></table></figure>
<p>下面我们介绍它们的存在基础，存储技术。</p>
<h2 id="2-存储技术"><a href="#2-存储技术" class="headerlink" title="2 存储技术"></a>2 存储技术</h2><p>我们要介绍的存储技术如下</p>
<ul>
<li>随机存储器RAM<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>非易失性存储器 ROM<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
<li>SSD （基于闪存，固态硬盘就是使用SSD技术）</li>
</ul>
</li>
<li>磁盘</li>
</ul>
<h3 id="2-1-随机访问存储器"><a href="#2-1-随机访问存储器" class="headerlink" title="2.1 随机访问存储器"></a>2.1 随机访问存储器</h3><p>随机存储器分为两种材类：SRAM和DRAM</p>
<p>SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。</p>
<p>DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。</p>
<h4 id="2-1-1-DRAM-内存的工作原理"><a href="#2-1-1-DRAM-内存的工作原理" class="headerlink" title="2.1.1 DRAM / 内存的工作原理"></a>2.1.1 DRAM / 内存的工作原理</h4><p>内存由若干个DRAM芯片构成，被称作内存模块(memory module)</p>
<p>每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。</p>
<p>每个超单元内存储若干个位，一般是一字节八位。　</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">内存/主存</span><br><span class="line">|</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br></pre></td></tr></table></figure>
<p>首先介绍DRAM 芯片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041151521.png" alt="image-20220904115118409"> </p>
<p>DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c = d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。</p>
<p>我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。</p>
<p>接下来看一下工作流程：</p>
<p>首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。</p>
<p>接着介绍内存模块：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041158562.png" alt="image-20220904115757187"> </p>
<p>一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 </p>
<h3 id="2-2-磁盘-amp-ROM"><a href="#2-2-磁盘-amp-ROM" class="headerlink" title="2.2 磁盘 &amp; ROM"></a>2.2 磁盘 &amp; ROM</h3><p>ROM可分为</p>
<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
</ul>
<p>我们不多介绍，只需要知道他们的名字和依赖关系即可</p>
<p>磁盘：通常指的是机械硬盘，也不过多介绍。</p>
<h2 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3 高速缓存"></a>3 高速缓存</h2><p>首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍：</p>
<blockquote>
<ul>
<li><p>对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。</p>
</li>
<li><p>而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。</p>
</li>
<li>数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。</li>
</ul>
</blockquote>
<p>以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。</p>
<p>令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。</p>
<p>这句话暂且悬置。</p>
<p>当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。</p>
<p>但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。</p>
<h3 id="3-1-高速缓存的结构"><a href="#3-1-高速缓存的结构" class="headerlink" title="3.1 高速缓存的结构"></a>3.1 高速缓存的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042138819.png" alt="image-20220904213832532"> </p>
<p>一个计算机存储器的地址有m位，他被分为三部分：</p>
<ul>
<li>高t位是标记位</li>
<li>中间s位是组索引位</li>
<li>低b位是组偏移位。</li>
</ul>
<p>高速缓存被组织为这样的结构：</p>
<ul>
<li><p>高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1</p>
</li>
<li><p>每个组中最多有2^t^ 个高速缓存行</p>
</li>
<li>每个高速缓存行也由三部分组成<ul>
<li>一位有效位，标记着这个高速缓存行是否有效</li>
<li>t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行</li>
<li>2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用</li>
</ul>
</li>
</ul>
<h3 id="3-2-高速缓存的工作原理"><a href="#3-2-高速缓存的工作原理" class="headerlink" title="3.2 高速缓存的工作原理"></a>3.2 高速缓存的工作原理</h3><p>当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。</p>
<p>确定是否命中有三个步骤：</p>
<ol>
<li>组选择</li>
<li>行匹配</li>
<li>字抽取</li>
</ol>
<ol>
<li><p>组选择</p>
<p>回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。</p>
</li>
<li><p>行匹配</p>
<p>如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。</p>
<p>如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。</p>
</li>
</ol>
<p>   补充 : </p>
<p>   我们先回忆一下地址的构成</p>
<p>   标记位 t + 索引位 s + 偏移位b</p>
<p>   假设有一个四位的地址，t = 1，s = 2，b = 1</p>
<p>   这四位地址的所有组合如下：</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042239062.png" alt="image-20220904223950779"> </p>
<p>   我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。</p>
<p>   我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。</p>
<p>   这样我们较低层的 0、4 映射到了较高层的0组，</p>
<p>   1、5映射到了1，</p>
<p>   2、6映射到了2，</p>
<p>   3、7映射到了3</p>
<p>   一个组中可以有最多2^t^ 行，如果我们一组中只有一行。</p>
<p>   如果我们首先引用了块0，那么块0每放在较高层的组0，</p>
<p>   接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。</p>
<p>   通过上面的例子，我想说明两点</p>
<p>   一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。</p>
<p>   二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？</p>
<p>   注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。</p>
<p>   其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。</p>
<ol>
<li>字抽取</li>
</ol>
<p>只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。</p>
<h2 id="4-虚拟内存"><a href="#4-虚拟内存" class="headerlink" title="4 虚拟内存"></a>4 虚拟内存</h2><p>从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。</p>
<blockquote>
<p>虚拟内存提供三个重要的能力：</p>
<ol>
<li>它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。</li>
<li>它位每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol>
</blockquote>
<p>从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。</p>
<p>虚拟内存的存在基础：</p>
<p>同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。</p>
<h3 id="4-1-虚拟内存原理"><a href="#4-1-虚拟内存原理" class="headerlink" title="4.1 虚拟内存原理"></a>4.1 虚拟内存原理</h3><p>首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: </p>
<blockquote>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
</blockquote>
<p>真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。</p>
<p>我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。</p>
<h3 id="4-2-虚拟内存的结构"><a href="#4-2-虚拟内存的结构" class="headerlink" title="4.2 虚拟内存的结构"></a>4.2 虚拟内存的结构</h3><p>在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。</p>
<p>页表：每个进程都有一个页表，页表将虚拟页映射到物理页。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209051937453.png" alt="image-20220905193713696"> </p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>
<h3 id="4-3-虚拟内存的地址翻译"><a href="#4-3-虚拟内存的地址翻译" class="headerlink" title="4.3 虚拟内存的地址翻译"></a>4.3 虚拟内存的地址翻译</h3><p>下面简单概括以下虚拟内存的地址翻译：</p>
<ol>
<li>处理器产生一个虚拟地址，并将它传送给MMU</li>
<li>MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3</li>
<li>由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4</li>
<li>现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。</li>
</ol>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220905200451112.png" alt="image-20220905200451112"> </p>
<p>下面我们介绍虚拟地址翻译中的一些细节：</p>
<ol>
<li><p>什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？</p>
<p>要解答这个问题，首先我们要介绍虚拟地址的格式。</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。</p>
</li>
<li><p>PTE 是什么，它的结构是什么？</p>
<p>PTE 是页表条目，他的结构是这样的</p>
<p>| SUP 有效位 | READ 有效位 | WRITE 有效位 | PPN 物理页号 (Physical Page Number) |<br>| ————— | —————- | —————— | —————————————————- |</p>
<p>前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。</p>
<p>PPN 物理页号是什么呢？</p>
<p>让我们回忆以下我们在介绍高速缓存时用到的物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052139387.png" alt="image-20220905213937545"> </p>
<p>如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。</p>
<p>而标记位和组索引合起来就是PPN。</p>
<p>而块偏移和虚拟地址的虚拟页偏移VPO是一样的</p>
<p>因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052144414.png" alt="image-20220905214401855"> </p>
<ol>
<li><p>快表TLB的工作原理是什么？</p>
<p>快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址：</p>
<p>虚拟地址由VPN和VPO组成</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>而虚拟页号VPN又可以分为两部分：</p>
<p>| VPN           | VPN           | VPO  |<br>| ——————- | ——————- | —— |<br>| TLB标记(TLBT) | TLB索引(TLBI) | VPO  |</p>
<p>TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。</p>
<p>接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-高速缓存系统和虚拟内存系统的对比"><a href="#5-高速缓存系统和虚拟内存系统的对比" class="headerlink" title="5 高速缓存系统和虚拟内存系统的对比"></a>5 高速缓存系统和虚拟内存系统的对比</h2><p>高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统</p>
<p>虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统</p>
<p>存储在某个存储层，在存储层之间传输的单元叫做块(block)</p>
<p>在高速缓存SRAM中，它叫做高速缓存行，或者行</p>
<p>在主存DRAM中，它叫做块(block)</p>
<p>在虚拟内存系统中，它叫做页(page)</p>
<p>调度策略</p>
<p>高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小</p>
<p>DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大</p>
<h2 id="6-技术总结"><a href="#6-技术总结" class="headerlink" title="6 技术总结"></a>6 技术总结</h2><p>在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。</p>
<p>有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。</p>
<p>我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052218205.png" alt="image-20220905221756883"> </p>
<p>B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n = m + o。</p>
<p>现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052220108.png" alt="image-20220905222017878"> </p>
<p>由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？</p>
<p>我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t = m - i 位来作为标记，区分一组中的不同块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052224081.png" alt="image-20220905222457743"></p>
<p>通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 </p>
<p>为什么使用中间位作为索引？</p>
<p>如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。</p>
<p>接下来我们概括一下内存系统：</p>
<p>一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。</p>
<p>如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。</p>
<h2 id="7-术语索引"><a href="#7-术语索引" class="headerlink" title="7 术语索引"></a>7 术语索引</h2><p>主存储器(main memory 主存) : 即通常理解的使用DRAM内存。</p>
<p>块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)</p>
<p>VM (Virtual Memory) 虚拟内存</p>
<p>VA(Virtual Address) 虚拟地址</p>
<p>MMU(Memory Management Unit)：内存管理单元，一种硬件</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>页表 ：一个数据类型位PTE的数组</p>
<p>PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型</p>
<p>页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging)</p>
<p>缺页：DRAM缓存不命中称为page fault</p>
<p>内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566</p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程 - CS:APP 第十二章</title>
    <url>/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="并发编程-CS-APP-第十二章"><a href="#并发编程-CS-APP-第十二章" class="headerlink" title="并发编程 - CS:APP 第十二章"></a>并发编程 - CS:APP 第十二章</h1><p>本章主要内容：</p>
<ul>
<li>实现并发程序的三种方法：<ol>
<li>fork() 进程</li>
<li>I/O 多路复用</li>
<li>使用线程</li>
</ol>
</li>
<li>使用信号量同步线程</li>
<li>线程安全问题</li>
</ul>
<h2 id="使用进程进行并发编程"><a href="#使用进程进行并发编程" class="headerlink" title="使用进程进行并发编程"></a>使用进程进行并发编程</h2><p><code>fork()</code> &amp; <code>execve</code> </p>
<p>优点：进程模型清晰，有独立的地址空间</p>
<p>缺点：不方便进程之间共享信息</p>
<p>基于进程的并发echo服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;args error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d connected\n&quot;</span>, getpid());</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            echo(connfd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d close connection\n&quot;</span>, getpid());</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>可以使用<code>select()</code> 函数显示等待一个进程有一个IO事件发生。</p>
<p>例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。</p>
<p>只要有一个IO事件发生，程序的逻辑流就会改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果fdset中的描述符准备好读或者写，就返回</span></span><br><span class="line"><span class="comment">返回值：返回已准备好的描述符数目，若出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset);</span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    fd_set read_set;</span><br><span class="line">    fd_set ready_set;</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="type">int</span> maxi;</span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];</span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE];</span><br><span class="line">&#125;pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pool.nready);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(connfd &gt; p-&gt;maxfd)</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi) </span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：编码特别复杂</p>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程是运行在进程上下文中的逻辑流</p>
<p>运行在同一个进程里的线程共享</p>
<ul>
<li>虚拟地址空间</li>
</ul>
<p>有自己独立的</p>
<ul>
<li>栈、栈指针、PC、通用目的寄存器和条件码</li>
</ul>
<p>线程之间是对等的，没有和进程一样有父子之分</p>
<p>进程有两种状态：可结合的和分离的</p>
<ul>
<li>可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收</li>
<li>分离的：不能被其他线程杀死，内存资源结束时由系统自动释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> * attr, func *f, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自己的tid</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止 tid</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞，等待tid终止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当这个线程第一次被调用时，执行 init_routine()，用于初始化</span></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误</p>
<blockquote>
<p>对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。</p>
</blockquote>
<p>想要实现互斥的访问，我们可以使用信号量机制</p>
<p>信号量：</p>
<p>信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它：</p>
<ul>
<li>P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。</li>
<li>V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。</li>
</ul>
<p>P中测试和加一的操作是不可分割的</p>
<p>V中测试和加以的操作也是不可分割的</p>
<p>如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。</p>
<p>互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。</p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><blockquote>
<p>生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。</p>
<p>因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。</p>
</blockquote>
<p>基于生产者消费者的sbuf包：</p>
<p><code>sbuf.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">int</span> n;    <span class="comment">// 缓冲区长度</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队列头</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;  <span class="comment">// 对缓冲区的互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> slots;  <span class="comment">// 控制生产者的信号量</span></span><br><span class="line">    <span class="type">sem_t</span> items;  <span class="comment">// 控制消费者的信号量</span></span><br><span class="line">&#125;<span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>sbuf.c</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放缓冲区空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区插入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);  <span class="comment">// 如果缓冲区已满，想要插入的线程会阻塞在这里</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁加锁</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;    <span class="comment">// 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);  <span class="comment">// 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);  <span class="comment">// 如果缓冲区为空，想要取出的线程会阻塞</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n];    <span class="comment">// 因为信号量的机制，我们不用担心从空缓冲区里取出数据</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);</span><br><span class="line">    V(&amp;sp-&gt;slots);  <span class="comment">// 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于预线程化的并发服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt;</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        echo_cnt(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="四个种不安全的函数"><a href="#四个种不安全的函数" class="headerlink" title="四个种不安全的函数"></a>四个种不安全的函数</h3><ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数（依赖前次调用结果的函数）</li>
<li>返回指向静态变量指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入的函数"><a href="#可重入的函数" class="headerlink" title="可重入的函数"></a>可重入的函数</h3><p>通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集</p>
<p>定义：当它被多个线程使用时，不会引用任何共享数据</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件</p>
<p>给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>异常控制流 - CS:APP 第8章</title>
    <url>/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="异常控制流-CS-APP-第8章"><a href="#异常控制流-CS-APP-第8章" class="headerlink" title="异常控制流 - CS:APP 第8章"></a>异常控制流 - CS:APP 第8章</h1><blockquote>
<p>这一章更多的是实践，理论的部分实在不多</p>
</blockquote>
<p>本文将介绍：</p>
<ol>
<li>常见的异常</li>
<li>(Linux)部分并发编程</li>
</ol>
<p>一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。</p>
<h2 id="异常及其分类"><a href="#异常及其分类" class="headerlink" title="异常及其分类"></a>异常及其分类</h2><ol>
<li><p>中断 (interrupt) : 异步发生，是来自处理器外部I/O设备的信号的结果</p>
</li>
<li><p>陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过<code>syscall</code> 指令，造成一个到异常处理程序的陷阱。</p>
<p>系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式</p>
</li>
<li><p>故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页</p>
</li>
<li><p>终止 (abort)：不可恢复的错误。</p>
</li>
</ol>
<h2 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h2><p>进程的定义：一个执行中的程序实例</p>
<p>进程提供给程序两个抽象的概念：</p>
<ol>
<li>一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。</li>
</ol>
<p>区分并发和并行：</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>获取进程id</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在linux上，pid_t 被定义为 int</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程pid</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 获得父进程pid</span></span><br></pre></td></tr></table></figure>
<p>进程只有三种状态：</p>
<ol>
<li>运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。</li>
<li>暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。)</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：<ol>
<li>收到一个信号，该信号的默认行为是终止进程</li>
<li>从主程序返回</li>
<li>调用exit函数。</li>
</ol>
</li>
</ol>
<p>创建进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）</span></span><br><span class="line"><span class="comment">子进程与父进程的虚拟地址空间相同，文件描述符相同</span></span><br><span class="line"><span class="comment">该函数返回两次：</span></span><br><span class="line"><span class="comment">在父进程中返回创建子进程的pid</span></span><br><span class="line"><span class="comment">在子进程中返回0</span></span><br><span class="line"><span class="comment">可以依此区分两个进程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>回收僵死进程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pid 等待集合</span></span><br><span class="line"><span class="comment">  pid &gt; 0 一个单独的子进程</span></span><br><span class="line"><span class="comment">  pid = -1 父进程的所有子进程</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">statusp 导致返回的状态信息</span></span><br><span class="line"><span class="comment">options 选项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return :</span></span><br><span class="line"><span class="comment">成功回收：回收进程的pid</span></span><br><span class="line"><span class="comment">WNOHANG 返回0</span></span><br><span class="line"><span class="comment">其他错误 -1 (例如没有子进程)：</span></span><br><span class="line"><span class="comment">如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD</span></span><br><span class="line"><span class="comment">如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">典型用法：waitpid(-1, NULL, 0);</span></span><br><span class="line"><span class="comment">挂起该进程，等待该进程的子进程终止，回收该僵死进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">// 等价于waitpid(-1, &amp;statusp, 0);</span></span><br></pre></td></tr></table></figure>
<p>让进程休眠：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">// 挂起进程secs秒，如果因为信号中断则会提前返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// 挂起进程，因为进程中断会提前返回</span></span><br></pre></td></tr></table></figure>
<p>加载并运行程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename 可执行文件路径，argv参数列表，envp环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">execve调用一次，从不返回，除非找不到可执行文件文件</span></span><br><span class="line"><span class="comment">argv/envp 指向以NULL结尾的指针数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特别强调：</span></span><br><span class="line"><span class="comment">通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种软件层次的异常</p>
<p>发送信号的两个原因：</p>
<ol>
<li>内核检测到一个系统事件，如子进程终止，发送SIGCHLD</li>
<li>一个进程显式地调用了kill函数，向某个进程发送了信号</li>
</ol>
<p>一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此：</p>
<blockquote>
<p>当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。</p>
</blockquote>
<p>为了能方便向大量进程发送信号，Linux提供了进程组这个概念。</p>
<p>进程组相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;    <span class="comment">// 设置pid的进程组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果pid为0，则设置当前的进程</span></span><br><span class="line"><span class="comment">如果pgid为0，则用pid指定的PID作为进程组id</span></span><br><span class="line"><span class="comment">setpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>发送信号</p>
<ol>
<li><p><code>/bin/kill</code> 程序可以手动发送信号</p>
</li>
<li><p>在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。</p>
</li>
<li>kill函数</li>
<li>alarm函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// secs秒后，发送一个SIGALRM信号给调用进程</span></span><br></pre></td></tr></table></figure>
<p>接受处理信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, sighandler handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：</span></span><br><span class="line"><span class="comment">1. 如果handler是SG_IGN,那么忽略类型为signum的信号。</span></span><br><span class="line"><span class="comment">2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。</span></span><br><span class="line"><span class="comment">3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>阻塞 &amp; 解除阻塞信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, sigset *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于sigprocmask的how，有三个选项：</span></span><br><span class="line"><span class="comment">SIG_BLOCK    将set中的信号添加到阻塞集合</span></span><br><span class="line"><span class="comment">SIG_UNBLOCK    将set中的信号从阻塞信号中删除</span></span><br><span class="line"><span class="comment">SIG_SETMASK    将block = set</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>非本地跳转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retrval)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="附：Linux-配置CSAPP库"><a href="#附：Linux-配置CSAPP库" class="headerlink" title="附：Linux 配置CSAPP库"></a>附：Linux 配置CSAPP库</h2><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435">https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/76930507">https://zhuanlan.zhihu.com/p/76930507</a></p>
<p><a href="https://blog.csdn.net/jakejohn/article/details/79825086">https://blog.csdn.net/jakejohn/article/details/79825086</a></p>
<p>第三版CSAPP库 代码下载：<a href="http://csapp.cs.cmu.edu/3e/code.html">http://csapp.cs.cmu.edu/3e/code.html</a></p>
</blockquote>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到     <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>抢占(preempted) 暂时挂起</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>挂起(suspended) </p>
<p>阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>数字在计算机中的表示</title>
    <url>/2023/03/10/%E6%95%B0%E5%AD%97%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h2><h3 id="无符号数的原码"><a href="#无符号数的原码" class="headerlink" title="无符号数的原码"></a>无符号数的原码</h3><p>即无符号数的二进制表示。</p>
<p>无符号数原码表示的范围从0到2^n^ -1，即{0，1}^w^ → {0，1，…，2^w^ -1}</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>定义</strong></p>
<p>最高有效位权重被解释为负权，其他有效位权重为正权，对于向量$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$ </p>
<p>函数B2T~w~ (Binary to Two’s-complement)为</p>
<p>$B2T_w = -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p><strong>补码快速求相反数的方法及证明</strong></p>
<p>所有位全为1的补码的值为-1</p>
<blockquote>
<p>已知 $2^0+2^1+2^2+…+2^n=2^{n+1}-1$ </p>
<p>故$-2^{w-1}+\sum_{i=0}^{w-2}x_i2^i=-2^{w-1}+2^{w-1}-1=-1$ </p>
</blockquote>
<p>推论 快速求一个以补码表示的二进制数的相反数 </p>
<blockquote>
<p>$\bar{x}$ 为一个二进制数的反码</p>
<p>因为 x 与$\bar{x}$ 相加是一个所有位全为1的补码</p>
<p>故，$x+\bar{x}=-1$ </p>
<p>故，$-x=\bar{x}+1$ </p>
<p>结论：要快速求一个补码二进制数的相反数，只需求这个二进制数的反码（包括符号位，或者说补码并没有符号位一说），再加一</p>
</blockquote>
<p><strong>w位补码能表示的范围</strong></p>
<p>一个w位二进制补码的范围：$[-2^{w-1},2^{w-1}-1]$ </p>
<p>以一字节为例，最小的数是 1000 0000 = -128，最大的数是 0111 1111 = 127</p>
<p>最小的负数的相反数是它本身：</p>
<p>$-(-128) = -(1000 0000)=(0111 1111)+1 = (1000 0000)= -128$ </p>
<p><strong>符号扩展</strong></p>
<p>对于一个4位补码， 1001 ，其值为 -7，如果将其扩展到8为，应使用符号扩展：</p>
<p>即 1111 1001 其值为 -7</p>
<blockquote>
<p>符号扩展不改变补码值的证明</p>
<p>对于正数显然成立，对于负数</p>
<p>w位补码为其值为$2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p>符号扩展k位后，w+k位补码的值为</p>
<p>$-2^{w+k-1}+\sum_{i=w}^{w+k-2}2^i+2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$ </p>
<p>$=-2^{w+k-1}+\sum_{i=w}^{w+k-2}2^i+2\times 2^{w-1}-2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$</p>
<p>$=2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$</p>
</blockquote>
<h3 id="原码和补码的相互转换"><a href="#原码和补码的相互转换" class="headerlink" title="原码和补码的相互转换"></a>原码和补码的相互转换</h3><ul>
<li>原码转换成补码<br>正数原码转补码：正数的补码，与原码相同，例如，10的原码为00001010，补码也是00001010<br>负数原码转补码：负数的补码：符号位不变，其余各位按位取反，取反后整体加1<br>例如：-10的原码为10001010，符号位不变：1  0001010，其余位按位取反：1  1110101，取反后整体加1：11110101 + 1 = 11110110</li>
<li>补码转换成原码<br>正数补码转原码：补码的符号位为0，表示该补码的原码是一个正数，所以补码就是该数的原码，例如：补码为00001010，它的符号位是0，代表它是一个正数的补码，正数的原码就是补码，反正也成立，所以它的原码是00001010<br>负数原码转补码：补码的符号位为1，表示该补码的原码是一个负数，所以可以这样求负数的原码，符号位不变，其余各位按位取反，然后再整体加1，例如：补码：11110110，符号位不变：1 1110110，其余位按位取反：1 0001001，取反后整体加1：10001001 + 1 = 10001010</li>
</ul>
<h2 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h2><h3 id="浮点数的一般表示"><a href="#浮点数的一般表示" class="headerlink" title="浮点数的一般表示"></a>浮点数的一般表示</h3><blockquote>
<p>参考：</p>
<p><a href="https://baike.baidu.com/item/纯小数补码/6480944">纯小数补码_百度百科 (baidu.com)</a> </p>
<p><a href="https://blog.csdn.net/weixin_44069475/article/details/122560674">纯小数补码学习_小数的补码_月老吃面包的博客-CSDN博客</a> </p>
<p><a href="https://www.jianshu.com/p/4f8a1dc94e4f">浮点数的一般表示 - 简书 (jianshu.com)</a> </p>
<p>一般会用补码表示浮点数的尾数，但网络上关于纯小数补码表示的讲解甚少。上课的时候老师也讲的不是很明白，因此花了好长时间查找资料。（百度还是比Bing能搜出来更有用的东西的！）</p>
</blockquote>
<p>浮点数一般表示方法如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符</th>
<th>阶码</th>
<th>数符</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>阶码和尾数既可以用原码也可以用补码表示。</p>
<blockquote>
<p>补充：有符号定点小数的表示</p>
<p>有符号定点小数有一个符号位，小数点隐含在符号位之后，小数点之后的数叫做尾数。有符号定点小数既可以用原码表示，也可以用补码表示。原码情况下，通常表示为<code>s.010101...</code> 其中s为符号位，010101…为尾数。</p>
<hr>
<p>至于有符号定点小数的补码表示，首先要介绍补码的原理与作用，才能更好地理解有符号定点小数的补码表示。下面首先讨论有符号整数的补码表示</p>
<p>在介绍补码概念之前，先介绍一下“模”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+12-2(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。若用一般公式可表示为：a-b=a-b+mod=a+mod-b。对“模”而言，2和10互为补数。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性，共同的特点是两者相加等于模。</p>
<p>补码的作用是化减法为加法：对于任何一个有模（mod）的计量系统，都可以化减法为加法。例如，将处在6点的钟表时针向后拨2点（减二），也可以将它向前拨10点（加十）。之所以可以这么做，就是因为-2与10关于12同余。对于一个n为二进制的计量系统，它的模（mod）为 2^n^ 。</p>
<p>补码的原理是数学上的同余关系，若 (a - b) / m能够得到一个整数，或者说 (a - b) 能够被 m 整除，就说 a 与 b关于m同余，记作<code>a≡b(mod m)</code>。对于n 位定点整数（以n = 4为例），负数的原码关于其补码关于2^n^ 同余，例如原码<code>1011</code> (十进制下为-3)，其补码<code>1101</code> （按照原码的解释方法，其真值为13），它们关于 2^4^ 同余（<code>13-(-3)=16</code>,16可以被2^4^ 整除）。</p>
<p>这也是为什么要取一个负数的补码，需要对它除了符号位以外的数按位取反再加1。（为什么补码的取法是按位取反再加一，以四位二进制数为例，四位二进制数的模为16，即<code>1111 + 0001</code>，<code>-0011</code> 表示-3。根据同余的定义，<code>(a-b)/m</code> 是一个整数，我们假设它为1，则有<code>a-b=m</code> ，则有<code>xxxx - (-0011)= 1111 + 0001</code>） 即，<code>xxxx = 1111-0011 + 0001</code> 而<code>1111-0011</code>的作用就是按位取反，因此补码的计算方法为对符号位意外的数按位取反再加一。补码的计算方法也可以简述为进制能表示的最大的数减去原码再加一）</p>
<hr>
<p>以上的讨论都是基于定点整数，下面我们来讨论有符号定点小数的补码表示</p>
<hr>
<p>定点纯小数计量系统的模为1，因此对于一个负数-x以及它的补码xc，有<code>xc - (-x) = mod, xc = mod - x = 1 - x</code> ，因此要求一个负小数的补码，可以将这个数在十进制下加一，再转换成二进制原码。例如-7/8，加1为1/8，1/8 转换成二进制得到 1001。</p>
<p>另一种更直接的获得负小数补码的方式是，将除符号位以外的位，按位取反，再加上 “1”。这里的“1”，并不是数值上的1，而是在最低位加1。例如，要求<code>-7/8</code>的补码，首先将其转化为原码表示，即<code>1111</code> (或写成<code>1.111</code>，有符号定点小数的小数点隐含在符号位之后) 。要求其补码，将处符号位以外的数按位取反，得到<code>1000</code> （或写成<code>1.000</code>）,再在最低为加1，得到<code>1001</code>(或写成<code>1.001</code>) </p>
<hr>
<p>对于一个负小数的补码  $sd_1d_2d_3…d_i$  或写成 $s.d_1d_2d_3…d_i$，它的每一个位可以这样解释，符号位解释为 s×-2^0^ （即s×1），数值位解释为 $d_i\times 2^{-i} (i=1,2,3,…) $。</p>
<p>它的真值为  $s\times (-2^0) + \sum_{i=1}^{n}d_i\times2^{-i} $ </p>
<hr>
<p>对于n+1位有符号定点小数（n=8）</p>
<p>原码表示的最大和最小定点小数</p>
<p>最大正数<code>0.1111 1111</code> ：1-2^-n^ </p>
<p>最小正数<code>0.0000 0000</code> : 0</p>
<p>最大负数<code>1.0000 0000</code> : 0</p>
<p>最小负数<code>1.1111 1111</code> ：-(1-2^-n^ ) </p>
<p>补码表示的最大和最小顶点小数</p>
<p>最大正数<code>0.1111 1111</code> ：1-2^-n^ </p>
<p>最小正数<code>0.0000 0000</code> : 0</p>
<p>最大负数<code>1.1111 1111</code>：-(1-2^-n^)  </p>
<p>最小负数<code>1.0000 0000</code> ：-1 </p>
</blockquote>
<p>浮点数的阶码和尾数，既可以使用原码表示，也可以使用补码表示。</p>
<p>例如，浮点数 <code>25.125</code>，其原码的二进制表示为$11001.001 = 1.1001001 × 2^4$ </p>
<p>如果用16位来表示这个浮点数，它的存储方式如下（阶码、尾数均为原码表示）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符（1bit）</th>
<th>阶码 (5bit)</th>
<th>数符(1bit)</th>
<th>尾数(9bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0 0100</td>
<td>1</td>
<td>1 0010 0100</td>
</tr>
</tbody>
</table>
</div>
<p>为了提高精度，充分利用尾数的每一位，规格化浮点数应运而生。规格化浮点数的特点是尾数位最高有效位应为1。这样可以提高数据表示的精度，避免尾数位的浪费。</p>
<p>例如，对于原码表示的浮点数，<code>1.100</code>为规格化浮点数，因为其尾数位最高位为1。</p>
<p>对于补码表示的浮点数，<code>0.100</code>，它为规格化浮点数，因为其尾数位最高位为1。</p>
<p>但对于用补码表示的负小数，情况则不同。例如<code>1.110</code>它就不是规格化浮点数，其最高位虽然是1，但负数从原码转换成补码中，有一个按位取反的操作，在按位取反时，0变成了1。因此，对于补码<code>1.110</code>其转换成原码为<code>1.010</code> 显然它不是规格化浮点数。综上，对于用补码表示的负小数，其尾数为的最高有效位应该为0。</p>
<p>对上面的规则进行归纳，可得到对于规格化浮点数的如下规则：</p>
<blockquote>
<p>当尾数为原码时，最高有效位必须为1</p>
<p>当尾数为补码时，尾数的最高位必须与符号位相反。即对于正数，最高有效位必须为1，对于负数，最高有效位必须为0。因为在负数的补码中，数值位的0相当于原码的1的作用。</p>
</blockquote>
<p>获得规格化浮点数的方法：</p>
<ul>
<li>左规，尾数左移一位，阶码-1</li>
<li>右规，尾数右移一位，阶码+1</li>
</ul>
<p>例如，浮点数 <code>25.125 = 1.1001001 × 2^4</code> 将其右规后，得到<code>0.11001001 × 2^5</code> </p>
<p>表示为（阶码、尾数均为原码表示）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶符（1bit）</th>
<th>阶码 (5bit)</th>
<th>数符(1bit)</th>
<th>尾数(9bit)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0 0101</td>
<td>0</td>
<td>1 1001 0010</td>
</tr>
</tbody>
</table>
</div>
<h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><blockquote>
<p>IEEE 读作 eye-triple-ee</p>
</blockquote>
<p>IEEE 754是一种表示浮点数的标准，它以这种格式表示浮点数</p>
<p>$V=(-1)^s\times M\times 2^E$ </p>
<p>其中s表示符号位</p>
<p>M，表示尾数；E表示阶码。</p>
<p>在IEEE 754中，有三种浮点数，分别是32位的单精度浮点数 float，和64位双精度浮点数double，以及80位浮点数，这里只介绍float 和double。</p>
<p>float 有1位符号位，8位阶码，23位尾数，</p>
<p>double 有1位符号位，11位阶码，52位尾数。</p>
<p>IEEE 754 有三种浮点数 它们分别是：规格化数，非规格化数和特殊值。</p>
<h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><blockquote>
<p>规格化数的定义是浮点数的一种表示方式，使得尾数的最高有效位总是1。这样可以省略这一位，增加尾数的精度。规格化数有一个隐含的整数位1，所以尾数的范围是[1, 2)。</p>
</blockquote>
<p>在规格化数中，阶码不能全为0，也不能全为1。例如，有4位阶码，那么最小的阶码位0001，最大的阶码为1110。</p>
<p>指数 E的计算方式如下，在规格化数中，E = e - Bias，其中 e 是阶码的值，Bias是偏置值，对于一个k位长度的阶码，Bias的大小等于$2^{k-1}-1$。</p>
<p>M的大小位1 + 尾数表示的值。通过省略前置的1，可以多获得一个位来表示尾数，这个被省略的1也叫做隐含的1。 </p>
<p>对于一个32位浮点数</p>
<p>绝对值最小的规格化数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>阶码</th>
<th>尾数</th>
<th>val</th>
</tr>
</thead>
<tbody>
<tr>
<td>绝对值最小的规格化数</td>
<td>0</td>
<td>0000 0001</td>
<td>0000 0000</td>
<td>$2^{1-127}\times1.0=2^{-126}$</td>
</tr>
<tr>
<td>绝对值最大的规格化数</td>
<td>0</td>
<td>1111 1110</td>
<td>1111 1111 1111 1111 1111 111</td>
<td>$2^{254-127}\times1.9999 = 2^{127}\times 1.9999$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><blockquote>
<p>根据我从网络上找到的信息，非规格化数是一种特殊的浮点数，它的指数位全为0，尾数位前没有隐含的1。非规格化数用于表示0和非常靠近0的数²³。</p>
</blockquote>
<p>非规格化数的阶码全为0，此时 E = 1 - Bias, M = 尾数表示的二进制数</p>
<p>非规格化数的左右有2：</p>
<ol>
<li>表示0，规格化数的M处于 1~2之间，无法表示 0，而非规格化数只要令尾数为0，就可以表示0了。注意，非规格化数有+0.0与-0.0。</li>
<li>非规格化数可以相对均匀地表示十分接近于0的数。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>阶码</th>
<th>尾数</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>绝对值最小的非规格化数</td>
<td>0</td>
<td>0000 0000</td>
<td>0000 0000 0000 0000 0000 000</td>
<td>0</td>
</tr>
<tr>
<td>绝对值最大的非规格化数</td>
<td>0</td>
<td>0000 0000</td>
<td>1111 1111 1111 1111 1111 111</td>
<td>$2^{1-127}\times0.9999=2^{-126}\times0.9999$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><h4 id="关于增长的均匀"><a href="#关于增长的均匀" class="headerlink" title="关于增长的均匀"></a>关于增长的均匀</h4><p>对于规格化数，其尾数每增长1，尾数绝对值增长<code>(0.0000 0000 0000 0000 0000 001)B</code> 而当尾数到达1，则会进位。实际的值的大小 = 尾数乘以2^E^ ，随着E的增长，浮点数的值的增长速度也会变快，但E不变时，浮点数的增长就是均匀的。  </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="C-语言中的右移操作"><a href="#C-语言中的右移操作" class="headerlink" title="C 语言中的右移操作"></a>C 语言中的右移操作</h3><p><code>x &gt;&gt; k</code> 右移，分为逻辑右移和算数右移，</p>
<p>逻辑右移在高有效位端补k个0，用于无符号数；</p>
<p>算数右移在最高有效位端补k个最高有效位的值，用于有符号数。</p>
<h3 id="New-Bing-关于纯小数的补码表示"><a href="#New-Bing-关于纯小数的补码表示" class="headerlink" title="New Bing 关于纯小数的补码表示"></a>New Bing 关于纯小数的补码表示</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202303121314551.png" alt="image-20230312131442881"> </p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>数字逻辑课程</title>
    <url>/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数字逻辑"><a href="#数字逻辑" class="headerlink" title="数字逻辑"></a>数字逻辑</h1><h2 id="第一章-逻辑代数基础"><a href="#第一章-逻辑代数基础" class="headerlink" title="第一章 逻辑代数基础"></a>第一章 逻辑代数基础</h2><h3 id="1-1-布尔代数"><a href="#1-1-布尔代数" class="headerlink" title="1.1 布尔代数"></a>1.1 布尔代数</h3><p>也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。</p>
<p>· + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。</p>
<blockquote>
<p>虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。</p>
</blockquote>
<p>· 即合取，可以像乘号一样省略。</p>
<p>逻辑代数公理：</p>
<ol>
<li><p>0 - 1 律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + 0 = A</span><br><span class="line">A + 1 = 1</span><br><span class="line">A · 0 = 0</span><br><span class="line">A · 1 = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>重叠律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + A = A</span><br><span class="line">A · A = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>互补律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A + ┐A = 1</span><br><span class="line">A · ┐A = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>对合律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">┐┐A = A</span><br></pre></td></tr></table></figure>
</li>
<li><p>交换律</p>
</li>
<li><p>结合律</p>
</li>
<li><p>分配律</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">A · (B + C) = AB + AC  与对或的分配</span><br><span class="line">A + BC = (A + B)(A + C) 或对与的分配</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1-2-逻辑函数"><a href="#1-2-逻辑函数" class="headerlink" title="1.2 逻辑函数"></a>1.2 逻辑函数</h3><p><strong>定义:</strong> 从n个逻辑变量到01的映射。记为F = f(A1, A2, A3 … )</p>
<p>逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式）</p>
<h4 id="1-2-1-三种表示法："><a href="#1-2-1-三种表示法：" class="headerlink" title="1.2.1 三种表示法："></a>1.2.1 三种表示法：</h4><ol>
<li><p>逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成</p>
</li>
<li><p>真值表</p>
</li>
<li><p>卡诺图</p>
<p>用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。</p>
<blockquote>
<p>挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。</p>
</blockquote>
</li>
</ol>
<h4 id="1-2-2-两种标准形式"><a href="#1-2-2-两种标准形式" class="headerlink" title="1.2.2 两种标准形式"></a>1.2.2 两种标准形式</h4><p><strong>最小项表达式：</strong>也叫积之和范式 或 主析取范式</p>
<p>最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。</p>
<p>最小项的表示：</p>
<p>对于n个变量而言，可以构成2的n次方个最小项。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。</p>
<blockquote>
<p>对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 m~i~ 来表示这个最小项表达式。</p>
<p>Q：为什么要使用1代表原变量，用0代表反变量？</p>
<p>A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi = 1，而且这是唯一的。</p>
<p>例如m6 = AB┐C，其顺序为110B = 6D，令对应的逻辑变量为1或0，则m6 = 1 · 1 · (┐0) = 1</p>
</blockquote>
<p>例如，最小项表达式 AB, 转换成二进制即11，表示为m3。</p>
<p>最小项表达式A┐B，转换成二进制即10，表示为m2。</p>
<p>最小项的性质：</p>
<ul>
<li>对于任意一个最小项，只有一组变量取值可以使其值为1</li>
<li>任意两个最小项之积为0</li>
<li>n个变量的所有2^n^ 个最小项之和为1</li>
</ul>
<p>将任意表达式转换为最小项表达式：</p>
<p>利用公式<code>A = A(B + ┐B)</code> </p>
<p>最小项表达式的性质：</p>
<ul>
<li>性质1：若m~i~是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi=1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。</li>
<li>性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F=F1+F2 将包括 F1 和 F2 中的所有最小项， G=F1·F2 将包括 F1 和 F2 中的公有最小项。 </li>
<li>性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成</li>
</ul>
<blockquote>
<p>思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式</p>
<p>使用归谬法证明</p>
</blockquote>
<p><code>第一次课到此结束</code> </p>
<p><strong>最大项表达式：</strong> 也叫和之积范式或主合取范式</p>
<p>定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。</p>
<p>举例：</p>
<p>二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B)</p>
<p>三变量最大项表达式：</p>
<p>最大项表达式的三条性质类似最小项表达式的三条性质：</p>
<ol>
<li>对于任意一个最大项，只有一组变量取值可使其值为0。</li>
<li>任意两个最大项 Mi 和 Mj 之和必为1。</li>
<li>n 变量的所有2^n^ 个最大项之积必为0。</li>
</ol>
<p>最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。</p>
<p>任意逻辑表达式转换成最大项表达式：</p>
<p>先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。</p>
<blockquote>
<p>类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。</p>
<p>AB + A┐B, 而这种表达式被称为 “与 - 或”表达式</p>
</blockquote>
<p>最大项表达式的性质也与最小项表达式类似：</p>
<ul>
<li>性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi=0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 </li>
<li>性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F=F1+F2将包括F1和F2中的公有最大项， G=F1·F2将包括F1和F2中的所有最大项。 </li>
<li>性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。</li>
</ul>
<h4 id="1-2-3-逻辑函数的三种表示法的关系"><a href="#1-2-3-逻辑函数的三种表示法的关系" class="headerlink" title="1.2.3 逻辑函数的三种表示法的关系"></a>1.2.3 逻辑函数的三种表示法的关系</h4><p>用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。</p>
<p>同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。</p>
<p>从上一节的学习，我们知道逻辑函数有三种表示法：</p>
<blockquote>
<ol>
<li><p>逻辑表达式</p>
</li>
<li><p>真值表</p>
</li>
<li><p>卡诺图</p>
</li>
</ol>
</blockquote>
<p>首先，逻辑表达式形式都可以化成标准形式。</p>
<p>接着我们来看真值表与逻辑表达式的关系（最大/小项表达式也是逻辑表达式）：</p>
<p>还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。</p>
<p>最大项表达式与最小项表达式恰恰相反：</p>
<p>最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。</p>
<p>最后我们来看一下卡诺图与真值表的关系：</p>
<p>卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">——————————————</span><br><span class="line">A  B	|	F</span><br><span class="line">——————————————</span><br><span class="line">0  0	|	0</span><br><span class="line">0  1	|	1</span><br><span class="line">1  0	|	1</span><br><span class="line">1  1	|	0</span><br><span class="line">——————————————</span><br></pre></td></tr></table></figure>
<p>它是一维的 线性的。</p>
<p>而卡诺图则二维的：</p>
<p>将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241752070.png" alt="image-20220824175139560"> </p>
<p>将项的组合换成数字的组合，我们得到卡诺图的简化形式</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241752221.png" alt="image-20220824175241939"> </p>
<p>需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。</p>
<p>下面给出一个逻辑函数的卡诺图表示的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208241754925.png" alt="image-20220824175443316"> </p>
<blockquote>
<p>补充：格雷码</p>
<p><a href="https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858">https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858</a></p>
<p>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。</p>
<p><strong>递归生成码表</strong></p>
<p>这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造：</p>
<ol>
<li>1位格雷码有两个码字</li>
<li>(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0</li>
<li>(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] </li>
<li>n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>2位格雷码</th>
<th>3位格雷码</th>
<th>4位格雷码</th>
<th>4位自然二进制码</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>000</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>01</td>
<td>001</td>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>11</td>
<td>011</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>10</td>
<td>010</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td></td>
<td>110</td>
<td>0110</td>
<td>0100</td>
</tr>
<tr>
<td></td>
<td>111</td>
<td>0111</td>
<td>0101</td>
</tr>
<tr>
<td></td>
<td>101</td>
<td>0101</td>
<td>0110</td>
</tr>
<tr>
<td></td>
<td>100</td>
<td>0100</td>
<td>0111</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1100</td>
<td>1000</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1101</td>
<td>1001</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1111</td>
<td>1010</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1110</td>
<td>1011</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1010</td>
<td>1100</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1011</td>
<td>1101</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1001</td>
<td>1110</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1000</td>
<td>1111</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p><code>第二次课结束</code> </p>
<h3 id="1-3-主要定理-amp-常用公式"><a href="#1-3-主要定理-amp-常用公式" class="headerlink" title="1.3 主要定理 &amp; 常用公式"></a>1.3 主要定理 &amp; 常用公式</h3><h4 id="1-3-1个主要定理"><a href="#1-3-1个主要定理" class="headerlink" title="1.3.1个主要定理"></a>1.3.1个主要定理</h4><p><strong>德摩根律：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282109984.png" alt="image-20220828210855685"> </p>
<ul>
<li>当变量个数较少的时候，可以使用真值表法证明。</li>
<li>当变量较多的时候，使用数学归纳法证明。</li>
</ul>
<p><strong>香农定理：</strong> 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220828211532973.png" alt="image-20220828211532973"> </p>
<p>注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。</p>
<p><strong>对偶定理:</strong> </p>
<p>对偶函数的定义：</p>
<blockquote>
<p>将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数</p>
<p>设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) </p>
<p>则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) = f (x1, x2, … , xn, 1, 0, ·, 1) </p>
</blockquote>
<p>对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282126050.png" alt="image-20220828212559479"> </p>
<p>两个推论：</p>
<ol>
<li>原函数与其对偶函数互为对偶函数。</li>
<li>两个相等的函数（f = g）的对偶函数必定相等（f ‘ = g ‘）</li>
</ol>
<p>自对偶函数：一个函数的对偶函数等于它自己。</p>
<p><strong>展开定理：</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282130528.png" alt="image-20220828213000128"></p>
<p>两个推理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208282130610.png" alt="image-20220828213053195"> </p>
<p>展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16</p>
<h4 id="1-3-2-5个常用公式"><a href="#1-3-2-5个常用公式" class="headerlink" title="1.3.2 5个常用公式"></a>1.3.2 5个常用公式</h4><ol>
<li><p>AB + A┐B = A</p>
<p>在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。</p>
</li>
<li><p>A + AB = A</p>
<p>在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。</p>
<p>还可以写成ABC + ABCDE = ABC</p>
</li>
<li><p>A + ┐AB = A + B</p>
<p>在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。</p>
<p>┐C + CE = ┐C + E</p>
</li>
<li><p>AB + ┐AC + BC = AB + ┐AC</p>
<p>包含律</p>
<p>在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。</p>
<p>AB + ┐AC + BCDE = AB + ┐AC</p>
</li>
<li><p>┐(A┐B + ┐AB) = ┐A┐B + AB</p>
<p>两个变量的异或的反   是  两个变量的同或</p>
</li>
</ol>
<p>上面5个公式的对偶形式也是成立的</p>
<h4 id="1-3-3-异或的性质"><a href="#1-3-3-异或的性质" class="headerlink" title="1.3.3 异或的性质"></a>1.3.3 异或的性质</h4><p>A ⊕A = 0</p>
<p>A⊕┐A = 1</p>
<p>A⊕0 = A</p>
<p>A⊕1 = ┐ A   重要</p>
<p>A⊕┐ B = A ⊙ B = A⊕B⊕1</p>
<p>A⊕B = B⊕A 交换律</p>
<p>A⊕(B⊕C) = （A⊕B) ⊕C 结合律</p>
<p>A(B⊕C) = AB⊕AC  分配律</p>
<p><code>第三次课到此结束</code></p>
<h4 id="1-3-4-应用"><a href="#1-3-4-应用" class="headerlink" title="1.3.4 应用"></a>1.3.4 应用</h4><p>一、转化称其他形式（详见P20）</p>
<ol>
<li><p>“与或” 表达式转 “或与”表达式</p>
<p>法一：分配律</p>
<p>法二：展开定理</p>
</li>
<li><p>“与或” 表达式 转 “与非 - 与非” 表达式</p>
<blockquote>
<p>“与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式</p>
</blockquote>
<p>或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可</p>
<p>因此我们的步骤是：两次取反，内层非用德摩根律断开</p>
</li>
<li><p>“与或” 表达式 转 “或非 - 或非” 表达式</p>
<blockquote>
<p> “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式</p>
</blockquote>
<p>首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开</p>
</li>
</ol>
<p>二、最大项表达式和最小项表达式的关系</p>
<p>┐mi = Mi 或 mi = ┐Mi</p>
<p>mi’ = Mj，且i + j = 2 ** n - 1</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208292300304.png" alt="image-20220829230044488"> </p>
<p>原函数</p>
<p>​    — 变换 —&gt;</p>
<p>最小项表达式</p>
<p>​    — 一次取反 —&gt;</p>
<p>符号错开，但保持最小项表达式，反函数的最小项表达式</p>
<p>或</p>
<p>或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式</p>
<p>​    — 二次取反 —&gt;</p>
<p>原函数的最大项表达式（和原函数最小项表达式符号错开）</p>
<p>将最大项表达式或最小项表达式变成对偶函数：</p>
<p>首先将最大项变成最小项，或最小项变成最大项</p>
<p>其次将序号变成互补的序号</p>
<h3 id="1-4-逻辑函数的化简"><a href="#1-4-逻辑函数的化简" class="headerlink" title="1.4 逻辑函数的化简"></a>1.4 逻辑函数的化简</h3><blockquote>
<p>逻辑函数最简式的定义：</p>
<ol>
<li>该式中乘积项最少</li>
<li>该式中的乘积项不能再用变量更少的乘积项代替</li>
</ol>
</blockquote>
<p>化简方法:</p>
<ol>
<li>代数方法</li>
<li>卡诺图法</li>
<li>列表化简法</li>
</ol>
<h4 id="1-4-1-卡诺图法"><a href="#1-4-1-卡诺图法" class="headerlink" title="1.4.1 卡诺图法"></a>1.4.1 卡诺图法</h4><p><code>第四次课到此结束</code> </p>
<p>基本原理：ABC + ┐ABC = (A + ┐A)BC = BC</p>
<p>反映在卡诺图上，就是相邻的两个格可以构成一个圈。</p>
<blockquote>
<p>n变量的卡诺图，任何2^m^ 个标1的相邻单元可以形成一个圈，改圈所代表的乘积项由n-m个变量组成，可以消去m个变量。</p>
</blockquote>
<p>名词解释：</p>
<p>蕴含项：最小项，以及2^m^ 个相邻单元所形成的圈组成的项。</p>
<p>素项：不是其他蕴含项子集的蕴含项。</p>
<p>实质素项：包含某一最小项，该最小项只被该素项包含。</p>
<p>化简方法：</p>
<ol>
<li><p>作出卡诺图，找出全部素项</p>
</li>
<li><p>找出全部实质素项</p>
</li>
<li><p>若有未被覆盖的最小项，找出一个可以包含该最小项的蕴含项，将其添加到实质素项集合中。</p>
<p>得到的集合，写成代数形式，即是化简结果。</p>
</li>
</ol>
<h2 id="第二章-组合电路的分析"><a href="#第二章-组合电路的分析" class="headerlink" title="第二章 组合电路的分析"></a>第二章 组合电路的分析</h2><h3 id="2-1-各种门电路"><a href="#2-1-各种门电路" class="headerlink" title="2.1 各种门电路"></a>2.1 各种门电路</h3><p>或门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201250943.png" alt="image-20220920125054365"> </p>
<p>与门<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251279.png" alt="image-20220920125108982"></p>
<p>非门<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251712.png" alt="image-20220920125121515"></p>
<p>与非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201251840.png" alt="image-20220920125145303"></p>
<p>或非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201252721.png" alt="image-20220920125247085"></p>
<p>与或非门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201252761.png" alt="image-20220920125206325"></p>
<p>异或门</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220920125225775.png" alt="image-20220920125225775"></p>
<p>三态门</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201254104.png" alt="image-20220920125344236"></p>
<p>三态门真值表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
<th>A</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>任意</td>
<td>高阻抗</td>
</tr>
</tbody>
</table>
</div>
<p><code>第五次课结束</code></p>
<h3 id="2-2-门电路的主要参数以及组合电路的分析方法"><a href="#2-2-门电路的主要参数以及组合电路的分析方法" class="headerlink" title="2.2 门电路的主要参数以及组合电路的分析方法"></a>2.2 门电路的主要参数以及组合电路的分析方法</h3><p>门电路的主要参数：</p>
<ul>
<li><p>标称逻辑电平：表示逻辑值01的理想电平</p>
</li>
<li><p>扇入系数：门电路允许的输入端数目</p>
<p>若使用的输入端数目比扇入系数小，则多余的输入端再不改变电路逻辑功能的情况下接高电平或低电平</p>
</li>
<li><p>扇出系数：一个门电路输出端所连接的下一级输入端的个数</p>
</li>
<li><p>平均时延</p>
</li>
</ul>
<p>组合电路的分析方法：</p>
<ol>
<li>给定组合线路</li>
<li>列写逻辑表达式</li>
<li>列真值表</li>
<li>指出线路的逻辑功能</li>
<li>对线路进行评价和改进</li>
</ol>
<h3 id="2-3-全加器"><a href="#2-3-全加器" class="headerlink" title="2.3 全加器"></a>2.3 全加器</h3><p>符号表示：</p>
<ul>
<li>A 被加数</li>
<li>B 加数</li>
<li>C~i-1~ 低位向高位的进位</li>
<li>S 和</li>
</ul>
<p>全加器的逻辑符号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201303019.png" alt="image-20220920130348535"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209201304218.png" alt="image-20220920130415100"></p>
<p>S = A⊕B⊕C~i-1~</p>
<p>​    = ∑(1, 2, 4, 7)</p>
<p>C = AB+(A⊕B)C~i-1~<br>    = AB+(A+B)C~i-1~ </p>
<p>​    = ∑(3, 5, 6, 7)</p>
<h3 id="2-4-译码器"><a href="#2-4-译码器" class="headerlink" title="2.4 译码器"></a>2.4 译码器</h3><p>几种常见的十进制数在二进制下的编码：</p>
<ul>
<li><p>8421码：顾名思义，就是十进制数转直接转换成二进制数（范围是0000-1001）</p>
</li>
<li><p>格雷码：相邻的格雷码只有一个位不同</p>
<p>8421转格雷码：G~i~=B⊕B~i+1~ (i &lt;= n-1);  G~i~ = B~i~ (i = n)</p>
</li>
<li><p>余三码：8421码+3得到余三码（范围是0011-1100）</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>十进制数</th>
<th>8421</th>
<th>格雷码</th>
<th>余三码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
<td>0011</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
<td>0100</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0011</td>
<td>0101</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0010</td>
<td>0110</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>0111</td>
<td>1000</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>0101</td>
<td>1001</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>0100</td>
<td>1010</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1100</td>
<td>1011</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1101</td>
<td>1100</td>
</tr>
</tbody>
</table>
</div>
<p><code>第五次课结束</code> </p>
<p>不同的译码器：</p>
<p>三位译八位译码器（多一译码）：从三位二进制数中，翻译出他们的最小项表达式。</p>
<blockquote>
<p>高电平译重：翻译出来的那个最小项的电平是高电平</p>
<p>低电平译重：翻译出来的最小项的电平是低电平</p>
<p>如果使用与非门实现译码器，使用低电平译重可以节省非门</p>
</blockquote>
<h3 id="2-5-格雷码转8421码："><a href="#2-5-格雷码转8421码：" class="headerlink" title="2.5.格雷码转8421码："></a>2.5.格雷码转8421码：</h3><p>利用异或的性质，一个逻辑表达式异或同一个逻辑表达式两次，等于原逻辑表达式</p>
<p>已知从8421码到格雷码的转换有：</p>
<p>G0 = B0 ⊕ B1</p>
<p>G1 = B1 ⊕ B2</p>
<p>G2 = B2 ⊕ B3</p>
<p>G3 = B3</p>
<p>则根据异或的性质</p>
<blockquote>
<ol>
<li><p>B3 = G3                    已知</p>
</li>
<li><p>G2 = B2 ⊕ B3         已知</p>
</li>
<li><p>G2 = B2 ⊕ G3        （2）</p>
</li>
<li>G3 ⊕ G2 = B2 ⊕ G3 ⊕ G3    两边同时异或G3</li>
<li>B2 = G2 ⊕ G3        异或的性质，消去两个G3</li>
</ol>
</blockquote>
<p>于是我们有：</p>
<p>从格雷码到8421码：</p>
<p>B3 = G3    </p>
<p>B2 = G2 ⊕ G3 </p>
<p>B1 = G1 ⊕ G2 ⊕ G3 </p>
<p>B0 = G0 ⊕ G1 ⊕ G2 ⊕ G3 </p>
<h3 id="2-6-奇偶校验器"><a href="#2-6-奇偶校验器" class="headerlink" title="2.6 奇偶校验器"></a>2.6 奇偶校验器</h3><p>分为奇校验和偶校验：</p>
<p>我们有一个n位二进制数和一个校验位p</p>
<p>奇校验：n位二进制数和p中，1的个数是奇数</p>
<p>偶校验：n位二进制数和p中，1的个数是偶数</p>
<p>奇偶校验的原理：</p>
<p>n个二进制数异或，如果他们中1的数目是奇数，则结果为1</p>
<blockquote>
<p>这个原理可以使用数学归纳法证明</p>
</blockquote>
<p>一个逻辑变量异或1等于它的非</p>
<p>一个逻辑变量异或0等于它本身</p>
<p>下面以奇校验为例：</p>
<p>生成校验位:</p>
<p>p = B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ 1</p>
<p>校验</p>
<p>is_valid = B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ P</p>
<p>偶校验</p>
<p>p = B8 ⊕B4 ⊕B2 ⊕B1</p>
<p>校验</p>
<p>is_valid = B8 ⊕B4 ⊕B2 ⊕B1⊕p⊕1</p>
<h2 id="第三章-组合线路的设计"><a href="#第三章-组合线路的设计" class="headerlink" title="第三章 组合线路的设计"></a>第三章 组合线路的设计</h2><p>设计流程：</p>
<ol>
<li>确定逻辑功能</li>
<li>列真值表（也就得到了最小项表达式）</li>
<li>根据卡诺图化简逻辑表达式</li>
<li>按照设计要求变换逻辑表达式</li>
<li>考虑工程问题</li>
</ol>
<h3 id="3-1-逻辑函数的变换"><a href="#3-1-逻辑函数的变换" class="headerlink" title="3.1 逻辑函数的变换"></a>3.1 逻辑函数的变换</h3><p>与或变与非：</p>
<ol>
<li>两次取反，中间DM断开</li>
<li>对F的反函数，三次取反（可以理解为四次取反，怎样好用用那个）</li>
</ol>
<p>与或非：</p>
<ol>
<li>两次取反，不断开</li>
<li>对反函数一次取反</li>
</ol>
<p>或非</p>
<ol>
<li><p>首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开</p>
</li>
<li><p>首先将原函数转换成其对偶函数，再将对偶函数化成最小项表达式，两次取反转换成与非形式</p>
<p>在进行一次对偶，变回原函数，得到或非形式</p>
</li>
</ol>
<p><code>第六次课结束</code> </p>
<h3 id="3-2-利用任意项的线路设计"><a href="#3-2-利用任意项的线路设计" class="headerlink" title="3.2 利用任意项的线路设计"></a>3.2 利用任意项的线路设计</h3><p>任意项定义：是的约束方程推的逻辑值为0的最小项，也称无关项。</p>
<blockquote>
<p>任意项再当前约束条件下的逻辑值必定为0，因此我们将任意项和原函数进行或运算，不影响原函数的取值。</p>
</blockquote>
<p>任意项在卡诺图或真值表中，用φ表示，将它在卡诺图中画出来可以方便形成更大的圈，从而简化得到的逻辑表达式。但我们使用真值表化简带有任意项的逻辑函数时，不必考虑任意项是否被圈全部包含，只需要考虑逻辑函数的最小项。</p>
<h3 id="3-3-多输出函数的线路设计（需要考虑共享项）"><a href="#3-3-多输出函数的线路设计（需要考虑共享项）" class="headerlink" title="3.3 多输出函数的线路设计（需要考虑共享项）"></a>3.3 多输出函数的线路设计（需要考虑共享项）</h3><p>当我们有多个逻辑函数，共享输入时，我们需要从全局出发考虑，看是否有可以共享的项目，从而减少要使用的逻辑器件。</p>
<p>考虑共享项的最小覆盖修改原则：</p>
<ol>
<li><p>若F~i~的一个素项B~k~也是F~j~的一个素项，则B~k~不作修改，除非修改后能减少总圈数。</p>
</li>
<li><p>若B~i~、B~j~分别是F~i~、F~j~的素项，且B~i~、B~j~都包含一个蕴涵项B~k~,在选取B~k~后，B~i~、B~j~中余下的最小项均分别包含在F~i~、F~j~其它素项中，则在F~i~、F~j~中改选B~k~ </p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202210031001060.png" alt="image-20221003100116410"> </p>
</li>
<li><p>F~i~的一个素项B~i~，中的一些最小项分别被F~j~, F~j+1~, … , F~j+m~中的素项B~j~, B~j+1~ , … , B~j+m~覆盖，且B~j~, B~j+1~, … , B~j+m~  ⊆ B, 若在F~i~中选取B~j~,B~j+1~, …, B~j+m~ 后，B~i~中余下的最小项均包含在的其它素项中，则将B~i~改选为B~j~, B~j+1~, …, B~j+m~ </p>
<p>示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202210031008326.png" alt="image-20221003100828764"></p>
</li>
</ol>
<p><code>第七次课到此结束</code> </p>
<h3 id="3-4-应用MSI功能块的组合线路设计"><a href="#3-4-应用MSI功能块的组合线路设计" class="headerlink" title="3.4 应用MSI功能块的组合线路设计"></a>3.4 应用MSI功能块的组合线路设计</h3><p>SSI：小规模集成电路</p>
<p>MSI：中规模集成电路</p>
<ul>
<li><p>利用数据多路选择器进行设计</p>
<p>首先要知道数据多路选择器的原理</p>
<p>f = a~0~┐x~0~┐x~1~ +  a~1~┐x~0~x~1~ + a~2~x~0~┐x~1~ + a~3~x~0~x~1~ </p>
<p>设计步骤：</p>
<ol>
<li><p>首先，对于给定n变量的逻辑函数，我们选择N = 2^n-1^ 路数据选择器</p>
</li>
<li><p>选定n-1个变量作为地址输入，作为数据选择器的控制端，根据选择的地址输入，确定数据选择器输入端的各表达式输入</p>
<p>对于如何确定数据选择器输入端的各表达式，我们可以使用代数方法得到，也可以使用卡诺图方法得到。</p>
</li>
</ol>
</li>
<li><p>利用译码器进行线路设计</p>
<p>将对应逻辑表达式转换为最小项表达式，直接将译码出来的最小项用或门连接（高电平译中）或用与非门连接（低电平译中），输出即可。</p>
</li>
</ul>
<p><code>第八次课到此结束</code> </p>
<h2 id="第四章-时序电路的分析"><a href="#第四章-时序电路的分析" class="headerlink" title="第四章 时序电路的分析"></a>第四章 时序电路的分析</h2><h3 id="4-1-触发器的外特性"><a href="#4-1-触发器的外特性" class="headerlink" title="4.1 触发器的外特性"></a>4.1 触发器的外特性</h3><h4 id="4-1-1-基本触发器"><a href="#4-1-1-基本触发器" class="headerlink" title="4.1.1 基本触发器"></a>4.1.1 基本触发器</h4><p>基本触发器通过其电路的设计，可以具有存储二进制位的功能，其电路就是存储器，而不是有单独的存储器。</p>
<p>基本触发器有两个稳态，分别表示0和1。当基本触发器（R~D~ ，S~D~）输入 1，1时，基本触发器里存储的位被保持输出，当输入0，1时，基本触发器被置零，当输入1，0时，基本触发器被置一，当输入0，0时不能确定输出的是当前存储的状态，还是其他状态。因此不能输入0。</p>
<p>基本触发器的R~D~ 和S~D~ 端都是低电平有效，R端是Reset重置，置零端，S端是Set，置一端。</p>
<p>基本触发器的特征表达式</p>
<p>┐R~D~┐ S~D~ = 0 (R~D~ 和S~D~ 不能同时为0)</p>
<p>Q^n+1^  = ┐S~D~ + R~D~ Q</p>
<h4 id="4-1-2-RS触发器"><a href="#4-1-2-RS触发器" class="headerlink" title="4.1.2 RS触发器"></a>4.1.2 RS触发器</h4><blockquote>
<p>电位触发，高电位时触发</p>
</blockquote>
<p>五个输入端，R~D~ , S~D~ ，R, S, CP</p>
<p>CP只有在为1时才有效，CP为0时保持。</p>
<p>特征方程：</p>
<p>Q^n+1^ = S + ┐RQ</p>
<h4 id="4-1-3-D-触发器"><a href="#4-1-3-D-触发器" class="headerlink" title="4.1.3 D 触发器"></a>4.1.3 D 触发器</h4><blockquote>
<p>边缘触发器，正跳变触发</p>
<p>关于电位触发和边缘触发：</p>
<p>边缘触发：输出不能迟于触发信号到达，但触发信号已到达，输入信号就可以撤下来</p>
<p>电位触发：输入信号可以迟于触发电位到达，但在触发电位变回非触发电位前，输入信号不能改变</p>
</blockquote>
<p>Q^n+1^ = D</p>
<h4 id="4-1-4-JK-触发器"><a href="#4-1-4-JK-触发器" class="headerlink" title="4.1.4 JK 触发器"></a>4.1.4 JK 触发器</h4><blockquote>
<p>边缘触发器，负跳变触发</p>
</blockquote>
<p>Q^n+1^ = J ┐Q^n^  + ┐K Q^n^ </p>
<p>当J，K同为0时，输出Q</p>
<p>当J，K同为1时，输出┐Q</p>
<p>当J，K相异时，输出 J</p>
<h4 id="4-1-5-T触发器"><a href="#4-1-5-T触发器" class="headerlink" title="4.1.5 T触发器"></a>4.1.5 T触发器</h4><blockquote>
<p>边缘触发器，负跳变触发</p>
</blockquote>
<p>Q^n+1^ = T┐Q^n^ + ┐TQ^n^ </p>
<p>当T为0时，输出Q</p>
<p>当T为1时，输出┐Q</p>
<p><code>第九次课到此结束</code></p>
<h3 id="4-2-时序电路的分析方法"><a href="#4-2-时序电路的分析方法" class="headerlink" title="4.2 时序电路的分析方法"></a>4.2 时序电路的分析方法</h3><ol>
<li><p>列些输出函数和控制函数表达式</p>
<blockquote>
<p>输出函数：线路的外输出函数（z）</p>
<p>控制函数：向存储元件的输入</p>
</blockquote>
</li>
<li><p>建立次态表达式及状态转移表</p>
</li>
<li><p>建立状态表及状态图</p>
</li>
<li><p>画波形图（optional）</p>
</li>
<li><p>说明时序线路的功能</p>
</li>
</ol>
<p>异步电路分析：</p>
<ol>
<li>写出输出函数和控制函数和每个触发器的CP端</li>
<li>建立次态表达式，次态表达式要将CP写进去，注意，不同触发器CP为一的条件不同</li>
<li>建立状态转移，如果输入信号是脉冲信号，那么输入信号为一代表打一个脉冲，而非输入信号恒唯一。</li>
<li>建立状态表和状态图</li>
<li>画波形图</li>
<li>说明时序电路功能</li>
</ol>
<p><code>第十&amp;十一次课到此结束</code></p>
<h3 id="4-3-同步时序电路的设计"><a href="#4-3-同步时序电路的设计" class="headerlink" title="4.3 同步时序电路的设计"></a>4.3 同步时序电路的设计</h3><p>同步时序电路设计的一般步骤：</p>
<ol>
<li>根据问题的描述，建立原始的状态表</li>
<li>使用隐含表法（下三角矩阵）化简原始状态表</li>
<li>对最简状态表进行编码，建立编码状态表</li>
<li>画出真值表（包括外部输入，现态，次态，控制函数，输出）</li>
<li>根据真值表写出触发器的控制函数</li>
<li>设计组合线路，考虑工程问题</li>
</ol>
<h4 id="4-3-1-关于状态的化简"><a href="#4-3-1-关于状态的化简" class="headerlink" title="4.3.1 关于状态的化简"></a>4.3.1 关于状态的化简</h4><p>两个状态可以合并的条件：</p>
<ol>
<li>在所有不同的输入下，输出均相同且满足以下条件<ol>
<li>两个次态完全相同</li>
<li>两个次态为其现态的交错</li>
<li>两个次态的某一后续状态对可以合并</li>
<li>两个次态为状态对封闭链中的一个状态对。</li>
</ol>
</li>
</ol>
<p><code>本课程结束</code> </p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>模板与泛型编程 - C++</title>
    <url>/2022/10/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-C/</url>
    <content><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><p>模板的定义以关键字<code>template</code> 开始，它的形式如下</p>
<p><code>template &lt;typename T, typename T1, ...&gt;</code> ，尖括号括起来的部分叫做模板参数列表，我们使用模板时，显示或隐式地将模板实参绑定到模板参数列表上。</p>
<p><code>typename</code> 关键字也可以用<code>class</code> 关键字代替，在模板参数列表中，它们是等价的。</p>
<p><strong>模板参数：</strong></p>
<p><code>T</code>  叫做模板类型参数。</p>
<blockquote>
<p>也可以定义非类型的模板参数，它必须是整形或指向对象的或函数的指针或者左值引用，整形必须是一个常量表达式，指针或者引用必须要具有静态生存期。总而言之，它必须能够在编译期间被确定。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>模板编译：</strong></p>
<p>编译器遇到模板的定义时，并不会生成代码，只有在使用模板时，编译器才会生成代码。</p>
<blockquote>
<p>建议：函数模板和类模板成员函数的定义通常放在头文件中</p>
<p>当我们使用一个函数时，我们只需要它的声明，它的定义可以由链接器在链接期间与其他文件链接。</p>
<p>而模板通常在使用时就要实例化，生成代码，因此，模板的声明和定义最好都放在头文件中。</p>
</blockquote>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板通常是使用隐式模板实参推断，编译器会用函数的实参推断模板实参。</p>
<p>在函数模板中，模板类型参数 <code>T</code> 可用于指定返回类型或函数的参数类型，也可以在函数体内声明变量和进行类型转换。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>编译器不能为类模板推断模板类型参数，我们必须显式指明。</p>
<p><strong>类模板的成员函数：</strong></p>
<p>在类内部定义的成员函数隐式<code>inline</code> </p>
<p>在类模板外部定义成员函数：</p>
<p>必须以template + 模板参数列表开始，因为不同类型的模板实例对应不同的成员函数</p>
<p><strong>类模板的模板实例化：</strong></p>
<p>只有程序用到类模板时，才会实例化它。如果没有用到某个成员函数，只用到了这个类，那么这个成员函数也不会被实例化。</p>
<p><strong>简化模板类名</strong></p>
<p>模板名不是类型，只有提供模板实参，模板名才能称为类名。因此我们在使用模板类型时，必须提供模板实参。</p>
<p>但在类模板的作用域内，我们可以只是用模板名，而省略模板实参。</p>
<blockquote>
<p>在类模板的定义外，只有遇到类名之后，我们才进入类的作用域。在此之前，例如我们想要是使用模板类型作为返回值，都不能省略模板实参</p>
</blockquote>
<p><strong>类模板和友元</strong> </p>
<p>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有的模板实例，</p>
<p>如果友元自身是模板，则友元可以授予模板的所有实例，也可以授予部分实例。</p>
<p><strong>模板类型的静态成员</strong></p>
<p>对于每个类型的模板实例，都有一个静态成员。</p>
<p><strong>默认模板实参</strong></p>
<p>可以像函数形参一样，提供一个默认参数。</p>
<p>对于类模板，就算我们需要使用默认模板实参，我们也不能省略尖括号。</p>
<p><code>templateType&lt;&gt; foo;        // 使用默认模板实参</code> </p>
<p><strong>成员模板</strong> </p>
<p>可以将类模板或普通类的成员函数声明称模板</p>
<p>普通类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">mem</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">base</span>(It begin, It end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板作用域"><a href="#模板作用域" class="headerlink" title="模板作用域"></a>模板作用域</h3><p>模板参数遵循普通的作用域规则，一个模板参数的可用范围在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明相同的名字。</p>
<blockquote>
<p>使用类的类型和类的静态成员：</p>
<p>当我们模板使用<code>classType::name</code> 引用类的类型或静态成员，会导致语义不明（因为只有用到模板是才会生成代码，错误检查不会立即发生）</p>
<p>我们必须使用<code>typename</code> 关键字显式声明这是一个类内定义的类型</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>两个独立编译的源文件使用相同的模板，并提供了相同的模板实参，每个文件中就都会有一个模板的实例。在一个大型工程中，会造成很大空间浪费。</p>
<p>因此我们需要显式控制模板实例化</p>
<p>形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> chass&lt;string&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>对于传递给模板类型参数的实参，编译器可以选择对实参进行类型转换，也可以不进行类型转换直接生成新的模板。</p>
<blockquote>
<p>对于非类型的参数，会进行</p>
</blockquote>
<p>只有在一下两种情况会进行类型转换，其他的情况都会生成新的模板</p>
<ul>
<li>非const转换成const，顶层const会被忽略</li>
<li>数组或函数指针：数组可以转换成指针（即使它们的大小不同，但引用不可以，因为对不同长度的数组的引用不是同一个类型），，函数可以转换成函数指针</li>
</ul>
<p>特殊情况：因为模板不会进行算数转换，如果一个函数的两个参数使用一个模板形参。即使，传递的实参可以转换成一个类型，调用也会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T &amp;, <span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="type">long</span> lint = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">cmp</span>(<span class="number">123</span>, lint);    <span class="comment">// 错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<p>这是我们可以这样处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T1 &amp;, <span class="type">const</span> T2 &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数模板显式指定模板参数"><a href="#函数模板显式指定模板参数" class="headerlink" title="函数模板显式指定模板参数"></a>函数模板显式指定模板参数</h3><p>放在函数名之后，模板名之前，靠右的模板参数如果可以通过实参推断出来，则可以省略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">cmp</span><span class="params">(<span class="type">const</span> T2 &amp;, <span class="type">const</span> T3 &amp;)</span></span>;</span><br><span class="line"><span class="built_in">cmp</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">20</span>, <span class="number">30</span>);    <span class="comment">// T1被显式指定，T2、T3自动推断</span></span><br></pre></td></tr></table></figure>
<p>显式指定参数之后，模板函数即可执行正常的类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> T &amp;, <span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="type">long</span> lint = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">cmp</span>(<span class="number">123</span>, lint);    <span class="comment">// 错误，类型不匹配</span></span><br><span class="line"><span class="built_in">cmp</span>&lt;<span class="type">long</span>&gt;(<span class="number">123</span>, lint);  <span class="comment">// 正确，显式指定模板类型参数之后就可以执行正常的类型转换了。</span></span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h3><p>当返回类型需要传入的实参，经过<code>decltype</code> 推断后得出时，我们遇到了一个问题，在写返回类型时，形参还没有被创建。</p>
<p>针对这种情况，我们可以使用尾置返回类型，将返回类型放在参数列表后面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>省略608 - 613 关于右值引用 和 转发</code></p>
<h2 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h2><blockquote>
<p>C++ Primer P614 - P617</p>
</blockquote>
<p>重载规则：</p>
<ol>
<li>对于一个调用，其候选包括所有的模板实参推断和非模板函数</li>
<li>如果有一个函数（不论是模板还是非模板），提供比其他类型的函数更好的匹配，选择它</li>
<li>如果有多个函数提供同样好的匹配，则<ol>
<li>如果同样好的函数中，有一个时非模板函数，选择它</li>
<li>如果都是模板函数，则选择更加特例化的哪一个模板函数</li>
<li>否则，调用有歧义</li>
</ol>
</li>
</ol>
<h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>模板函数的特例化：必须为模板函数的每一个模板参数提供模板实参，不能部分特例化，因此，函数模板特例化必须以<code>template&lt;&gt;</code> 开始。</p>
<p>模板特例化本质上是接管了编译器的工作，特例化的函数也是一个模板实例而不是一个重载函数。</p>
<p>类模板特例化</p>
<p>特例化方法与函数模板特例化无异，但类模板特例化可以部分特例化，详见P628。</p>
<blockquote>
<p>感觉我也不会用到多少这东西。</p>
</blockquote>
]]></content>
      <categories>
        <category>琐碎记录</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课程</title>
    <url>/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h2><h3 id="1-1-顺序实现"><a href="#1-1-顺序实现" class="headerlink" title="1.1 顺序实现"></a>1.1 顺序实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OK = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ERROR = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> OVERFLOW = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LIST_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LIST_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    ElemType * elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function">Status <span class="title">insert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入的合法范围为 1 &lt;= i &lt;= length + 1, 插入在length + 1时，需要另外申请空间，等价于append</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若已满，重新分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.listsize) &#123;</span><br><span class="line">        ElemType * newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem, (L.listsize + LIST_INCREMENT) * <span class="built_in">sizeof</span> (ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += LIST_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位移</span></span><br><span class="line">    ElemType * pos = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (ElemType * rear = &amp;(L.elem[L.length - <span class="number">1</span>]); rear &gt;= pos; rear--)</span><br><span class="line">        *(rear + <span class="number">1</span>) = * rear;</span><br><span class="line">    * pos = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    ElemType * pos = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">    e = * pos;</span><br><span class="line">    ElemType * rear = &amp;(L.elem[L.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (pos++; pos &lt;= rear; pos++)</span><br><span class="line">        * (pos - <span class="number">1</span>) = * pos;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-链式实现"><a href="#1-2-链式实现" class="headerlink" title="1.2 链式实现"></a>1.2 链式实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> * next;</span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">// 由于头节点的存在，计数器从0开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找第i - 1个结点，也就是待插入节点的前驱节点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)    <span class="comment">// i超出表长+1(append), 或i为负数</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = L;     <span class="comment">// 指向头节点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到待删除结点的前驱</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  <span class="comment">// 这里的第一个测试条件是p-&gt;next是因为下面要引用p-&gt;next,如果测试条件是p的话，下面会报段错误</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待删除结点的位置超出表厂或者为负数</span></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || j &gt; i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法创建单链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入 1 2 3 4 5</span></span><br><span class="line"><span class="comment"> * 建好的单链表为 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));   <span class="comment">// 为头节点分配空间</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));  <span class="comment">// 分配新节点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;          <span class="comment">// 插入</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法创建单链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输入 1 2 3 4 5</span></span><br><span class="line"><span class="comment"> * 建好的单链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList_L_tail</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    <span class="keyword">auto</span> r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-循环链表"><a href="#1-3-循环链表" class="headerlink" title="1.3 循环链表"></a>1.3 循环链表</h3><ul>
<li>表中最后一个结点的指针域指向第一个节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> seqNumber;      <span class="comment">// 存储每个人的编号</span></span><br><span class="line">    <span class="type">int</span> psd;            <span class="comment">// 存储每个人的密码</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> * next;</span><br><span class="line">&#125;Node, * NodePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    NodePtr rear;       <span class="comment">// 存储循环链表的尾指针</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;CirLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">empty</span><span class="params">(<span class="type">const</span> CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(CirLinkedList * L, <span class="type">int</span> sq, <span class="type">int</span> psd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NodePtr p = (NodePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    p-&gt;seqNumber = sq;</span><br><span class="line">    p-&gt;psd = psd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(L)) &#123;    <span class="comment">// 不想单链表一样有头节点，因此插入第一个元素时需要特殊处理</span></span><br><span class="line">        L-&gt;rear = p;</span><br><span class="line">        p-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;next = L-&gt;rear-&gt;next;</span><br><span class="line">        L-&gt;rear-&gt;next = p;</span><br><span class="line">        L-&gt;rear = p;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt, psd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入表长:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入元素%d的密码:&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;psd);</span><br><span class="line">        <span class="built_in">append</span>(L, i + <span class="number">1</span>, psd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">const</span> CirLinkedList * L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>(L)) <span class="keyword">return</span> ;</span><br><span class="line">    NodePtr p = (L-&gt;rear)-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p-&gt;seqNumber);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = L-&gt;rear-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p-&gt;psd);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(CirLinkedList * L, NodePtr *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NodePtr prev = L-&gt;rear, t = *p;</span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != (*p))</span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    prev-&gt;next = (*p)-&gt;next;</span><br><span class="line">    *p = prev;</span><br><span class="line">    <span class="keyword">if</span> (t == L-&gt;rear) L-&gt;rear = prev;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>)</span><br><span class="line">        *p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不设头节点，存储尾指针，尾指针指向循环链表的最后一个结点，尾指针的next指向头节点</li>
</ul>
<h3 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> * prior, * next;</span><br><span class="line">&#125;DuLNode, * DuLinkList</span><br></pre></td></tr></table></figure>
<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2. 栈和队列"></a>2. 栈和队列</h2><h3 id="2-1-顺序栈"><a href="#2-1-顺序栈" class="headerlink" title="2.1 顺序栈"></a>2.1 顺序栈</h3><ul>
<li>空栈：<code>S.base == S.Top</code></li>
<li>栈长：<code>S.Top - S.base</code></li>
<li>栈满：<code>S.top – S.base &gt;= S.stacksize</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序栈的课本典型实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STACK_INIT_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> STACK_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    SElemType * base;</span><br><span class="line">    SElemType * top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="built_in">sizeof</span> (SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base == S.top)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理栈满的情况 栈的有效范围是 0 ~ stacksize - 1</span></span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base + S.stacksize) &#123;    <span class="comment">// S.base + S.stacksize 刚好是尾后指针</span></span><br><span class="line">        S.base = (SElemType *)<span class="built_in">realloc</span>(S.base, (S.stacksize + STACK_INCREMENT) * <span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(S.top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(--S.top);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">const</span> SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.base - S.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-链栈"><a href="#2-2-链栈" class="headerlink" title="2.2 链栈"></a>2.2 链栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="title class_">SNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SNode</span> *next;</span><br><span class="line">&#125;SNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line">    p = (LinkStack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = p; <span class="comment">//头插栈顶元素</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//若栈不空，则删除栈顶元素，用e返回其值，并返回OK；</span></span><br><span class="line">  <span class="comment">//否则返回ERROR	</span></span><br><span class="line">  <span class="keyword">if</span>(S-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR;  <span class="comment">//栈空</span></span><br><span class="line">  p = S-&gt;next;</span><br><span class="line">  e = p-&gt;data;</span><br><span class="line">  S-&gt;next = p-&gt;next; </span><br><span class="line">  <span class="built_in">free</span>(p); <span class="comment">//删除栈顶元素</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-栈的应用"><a href="#2-3-栈的应用" class="headerlink" title="2.3 栈的应用"></a>2.3 栈的应用</h3><ul>
<li>数制转换</li>
<li>括号匹配</li>
<li>迷宫问题</li>
<li>表达式求值</li>
</ul>
<h3 id="2-4-循环队列"><a href="#2-4-循环队列" class="headerlink" title="2.4 循环队列"></a>2.4 循环队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxQSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType * base;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队头元素的下标</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队尾元素的下标</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断队空：<code>Q.front == Q.rear</code></li>
<li>判断队满：<code>(Q.rear + 1) % MaxQSize == Q.front</code> 也可以用 变量记录当前队列长度</li>
<li>求队长：<code>(Q.rear - Q.front + MaxQSize) % MaxQSzie</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = (QElemType *)<span class="built_in">malloc</span>(MaxQSize * <span class="built_in">sizeof</span> (QElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Q.base)</span><br><span class="line">        <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxQSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxQSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxQSize;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">const</span> SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MaxQSize) % MaxQSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-链队列"><a href="#2-5-链队列" class="headerlink" title="2.5 链队列"></a>2.5 链队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;OK, ERROR, OVERFLOW&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> * next;</span><br><span class="line">&#125;QNode, * QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插入到rear</span></span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">auto</span> p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要特判只有一个元素的时候，此时被释放的结点为rear,必须改变rear的指向，是指与front相同</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front) &#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h2><p>树的度：结点拥有的子树个数</p>
<p>叶子节点或终端结点：度为0的结点</p>
<p>层次：树的根为第一层，根的孩子为第二层</p>
<p>深度：树中结点的最大层次。</p>
<h3 id="3-1-二叉树的性质"><a href="#3-1-二叉树的性质" class="headerlink" title="3.1 二叉树的性质"></a>3.1 二叉树的性质</h3><ol>
<li><p>二叉树的第i层至多有2^i-1^ 个结点</p>
</li>
<li><p>深度为k的二叉树至多有2^k^ -1个结点</p>
</li>
<li><p>对任何一棵二叉树，若它含有n~0~ 个叶子结点、n~2~ 个度（出度）为 2 的结点，则必存在关系式：n~0~ = n2+1。</p>
<blockquote>
<p>推论：适用于Huffman树</p>
<p>对于有n~0~ 个结点的Huffman树，它的总结点数为n~0~ + n~2~ = 2n~0~ -1</p>
</blockquote>
</li>
<li><p>具有n个结点的完全二叉树的深度为 <code>floor(log2 n) + 1</code></p>
<blockquote>
<p>ceil()向上取整，floor向下取整</p>
</blockquote>
</li>
<li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p>
<ol>
<li><p>若 i = 1，则该结点是二叉树的根，无双亲，</p>
<p>否则，编号为<code>floor(i/2)</code> 的结点为其双亲结点；</p>
</li>
<li><p>若 2i &gt; n，则该结点无左孩子，</p>
<p>否则，编号为 2i 的结点为其左孩子结点；</p>
</li>
<li><p>若 2i+1 &gt; n，则该结点无右孩子结点，<br>  否则，编号为2i+1 的结点为其右孩子结点。</p>
</li>
<li>具有n个结点的<strong>完全二叉树</strong>有<code>ceil(n/2)</code>个叶子结点</li>
<li><strong>完全二叉树</strong>最后一个非终端结点的编号为<code>floor(n/2)</code> </li>
</ol>
</li>
</ol>
<h3 id="3-2-二叉树的链式存储"><a href="#3-2-二叉树的链式存储" class="headerlink" title="3.2 二叉树的链式存储"></a>3.2 二叉树的链式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125; *Tree, Node;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNodeCnt = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按先序遍历顺序创建二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(Tree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> Node;</span><br><span class="line">        T-&gt;val = ch;</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-二叉树的遍历"><a href="#3-3-二叉树的遍历" class="headerlink" title="3.3 二叉树的遍历"></a>3.3 二叉树的遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreorderTraverse</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderTraverse</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;left);</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InorderTraverse</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostorderTraverse</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">PostorderTraverse</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PostorderTraverse</span>(T-&gt;right);</span><br><span class="line">        cout &lt;&lt; T-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> myqueue::queue;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> ;</span><br><span class="line">    queue&lt;Tree&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Tree t = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left) Q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) Q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先序遍历非递归思路：</p>
<p>从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，访问所遇结点，并依次把所遇结点进栈，当左子树为空时，从栈顶退出某结点，并将指针指向该结点的右孩子。如此重复，直到栈为空或指针为空止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree cur = T;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 当未走到最左边的结点时，继续向左走，同时访问结点</span></span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            stack[top++] = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">// 访问右子树</span></span><br><span class="line">            cur = stack[--top];</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序非递归思路</p>
<p>从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，把依次遇到的结点进栈待左子树为空时,从栈中退出结点并访问,然后再转向它的右子树。如此重复，直到栈空或指针为空止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree cur = T;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stack[top++] = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack[--top];</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序非递归思路</p>
<p>利用栈来实现二叉树的后序遍历要比前序和中序遍历复杂得多，在后序遍历中，</p>
<ol>
<li><p>当搜索指针指向某一个结点时，不能马上进行访问，而先要遍历左子树，所以此结点应先进栈保存，</p>
</li>
<li><p>当遍历完它的左子树后，再次回到该结点，还不能访问它，</p>
</li>
<li><p>还需先遍历其右子树,所以该结点还必须再次进栈，</p>
</li>
<li><p>只有等它的右子树遍历完后，再次退栈时，才能访问该结点。</p>
</li>
<li><p>为了区分同一结点的两次进栈，引入一个栈次数的标志，一个元素第一次进栈标志为0，第二次进标志为1，并将标志存入另一个栈中，当从标志栈中退出的元素为1时，访问结点。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostorderTraverseNonRec</span><span class="params">(<span class="type">const</span> Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree stack[MaxNodeCnt];</span><br><span class="line">    <span class="type">int</span> cnt[MaxNodeCnt], top = <span class="number">0</span>, tc;</span><br><span class="line">    Tree cur = T, tt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || top != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack[top] = cur;</span><br><span class="line">            cnt[top++] = <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tt = stack[top - <span class="number">1</span>];</span><br><span class="line">            tc = cnt[--top];</span><br><span class="line">            <span class="keyword">if</span> (tc) &#123;</span><br><span class="line">                cout &lt;&lt; tt-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack[top] = tt;</span><br><span class="line">                cnt[top++] = tc + <span class="number">1</span>;</span><br><span class="line">                cur = tt-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4-二叉树遍历的应用"><a href="#3-4-二叉树遍历的应用" class="headerlink" title="3.4 二叉树遍历的应用"></a>3.4 二叉树遍历的应用</h3><ul>
<li>求树的叶子节点个数</li>
<li>求树的深度</li>
<li>复制二叉树</li>
</ul>
<h3 id="3-5-线索化："><a href="#3-5-线索化：" class="headerlink" title="3.5 线索化："></a>3.5 线索化：</h3><p>可以以线性的方式访问二叉树结构</p>
<h4 id="3-5-1-中序线索树"><a href="#3-5-1-中序线索树" class="headerlink" title="3.5.1 中序线索树"></a>3.5.1 中序线索树</h4><blockquote>
<p>对于中序线索树，我们约定：</p>
<p>它有两个存储左右子树标记的域，如果左子树的标记为0，那么它存储的是其左孩子，如果左子树的标记为1，那么它存储的是其中序遍历时的直接前驱.</p>
<p>如果右子树的标记为0，它存储的是其右孩子。如果右子树的标记为1，那么它存储的是中序遍历时的直接后继。</p>
</blockquote>
<ul>
<li><p>求中序线索树的前驱：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">如果 左标记为1</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">直接返回其左孩子</span></span><br><span class="line"><span class="attribute">否则</span><span class="punctuation">:</span></span><br><span class="line">  返回其左子树的最右下的结点</span><br></pre></td></tr></table></figure>
</li>
<li><p>求中序线索树的后继：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">如果 右标记为1</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">返回其右孩子</span></span><br><span class="line"><span class="attribute">否则</span><span class="punctuation">:</span></span><br><span class="line">  返回其右子树的最左下的孩子</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历中序线索树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (BiThrTree p = T-&gt;lchild; p != T; p = <span class="built_in">in_suss</span>(p))</span><br><span class="line">    <span class="built_in">visit</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找后继的函数</span></span><br><span class="line"><span class="function">BiThrTree <span class="title">in_succ</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;RTag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BiThrTree q;</span><br><span class="line">        <span class="keyword">for</span> (q = p-&gt;rchild; q-&gt;LTag == <span class="number">0</span>; q = q-&gt;lchild)</span><br><span class="line">            ;  <span class="comment">// 找到右子树的最左下的孩子</span></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒序遍历</span></span><br><span class="line"><span class="keyword">for</span> (BiThrTree p = T-&gt;rchild; p != T; p = <span class="built_in">in_pre</span>(p))</span><br><span class="line">    <span class="built_in">visit</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找前驱</span></span><br><span class="line"><span class="function">BiThrTree <span class="title">in_pre</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;LTag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BiThrTree q;</span><br><span class="line">        <span class="keyword">for</span> (q = p-&gt;lchild; q-&gt;LTag == <span class="number">0</span>; q = q-&gt;rchild)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T, <span class="type">void</span> (*Visit)(TElemType e))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = T-&gt;lchild;           <span class="comment">// p = first_node</span></span><br><span class="line">  <span class="keyword">while</span> (p != T) &#123;     		<span class="comment">// 空树或遍历结束时，p==T</span></span><br><span class="line">        <span class="comment">// case 1: </span></span><br><span class="line">      <span class="keyword">while</span> (p-&gt;LTag==Link)</span><br><span class="line">            p = p-&gt;lchild;    <span class="comment">//第一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">Visit</span>(p-&gt;data))</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// case 2:</span></span><br><span class="line">      <span class="keyword">while</span> (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">          <span class="built_in">Visit</span>(p-&gt;data);      <span class="comment">// 访问后继结点</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;rchild;           <span class="comment">// p进至其右子树根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// InOrderTraverse_Thr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>建立中序线索树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">BiTNode *Pre = <span class="keyword">new</span> BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化带头结点二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderThreading</span><span class="params">(BiTree &amp;Thrt, BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thrt = <span class="keyword">new</span> BiTNode; <span class="comment">//建立头结点</span></span><br><span class="line">  Thrt-&gt;LTag = <span class="number">0</span>;		<span class="comment">//头结点有左孩子，若树非空，则其左孩子为树根</span></span><br><span class="line">  Thrt-&gt;RTag = <span class="number">1</span>;		<span class="comment">//头结点右孩子为右线索</span></span><br><span class="line">  Thrt-&gt;right = Thrt; <span class="comment">//初始化时右孩子指向自己</span></span><br><span class="line">  <span class="keyword">if</span> (!T)				<span class="comment">//如果树为空则左孩子也指向自己</span></span><br><span class="line">    Thrt-&gt;left = Thrt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Thrt-&gt;left = T;</span><br><span class="line">    Pre = Thrt;</span><br><span class="line">    <span class="built_in">InThreading</span>(T);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成在线索化中未完成的那部分事情</span></span><br><span class="line">    Pre-&gt;right = Thrt;		<span class="comment">// 最后一个结点的后继指向头节点</span></span><br><span class="line">    Pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">    Thrt-&gt;right = Pre;		<span class="comment">// 头节点的右指针为最后一个结点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一个算法，中序线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThreading</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (T) <span class="comment">//根节点非空</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">InThreading</span>(T-&gt;left); <span class="comment">//左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;left)		  <span class="comment">// T的左孩子为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      T-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">      T-&gt;left = Pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      T-&gt;LTag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Pre-&gt;right) <span class="comment">// T的右孩子为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      Pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">      Pre-&gt;right = T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Pre-&gt;RTag = <span class="number">0</span>;</span><br><span class="line">    Pre = T;</span><br><span class="line">    <span class="built_in">InThreading</span>(T-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-一般的树和森林的表示："><a href="#1-3-一般的树和森林的表示：" class="headerlink" title="1.3 一般的树和森林的表示："></a>1.3 一般的树和森林的表示：</h3><p>三种表示法：</p>
<ol>
<li><p>父亲表示法（并查集的实现方法）</p>
</li>
<li><p>孩子表示法</p>
</li>
<li><p>孩子表示法（将一般的树或森林转换成二叉树）</p>
<p>让二叉树结点的左孩子指向这个一般的树的第一个孩子，右孩子指向下一个兄弟</p>
</li>
</ol>
<h3 id="1-4-一般的树和森林的遍历："><a href="#1-4-一般的树和森林的遍历：" class="headerlink" title="1.4 一般的树和森林的遍历："></a>1.4 一般的树和森林的遍历：</h3><p>二叉树：</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>一般的树</p>
<ul>
<li>先根遍历（先遍历根，再从左到右依次遍历子树） 先序遍历</li>
<li>后根遍历 （遍历一个树的根时，先左到右依次遍历该树的子树）中序遍历</li>
<li>层次遍历 层次遍历</li>
</ul>
<p>森林</p>
<ul>
<li>先序遍历（即从左到右对森林中的每一棵树进行先根遍历） 先序遍历</li>
<li>中序遍历（从左到右对森立中的每一棵树进行后根遍历） 中序遍历</li>
</ul>
<h3 id="1-5-Huffman树"><a href="#1-5-Huffman树" class="headerlink" title="1.5 Huffman树"></a>1.5 Huffman树</h3><ul>
<li>路径长度l：路径上的分支数目</li>
<li>树的带权路径长度WPL = 求和(k = 1, n) w~k~ l~k~ </li>
</ul>
<h2 id="4-图"><a href="#4-图" class="headerlink" title="4. 图"></a>4. 图</h2><h3 id="4-1-术语"><a href="#4-1-术语" class="headerlink" title="4.1 术语"></a>4.1 术语</h3><ul>
<li><p>弧：有向边</p>
</li>
<li><p>网：弧或边带权的图成为有向网或无向网</p>
</li>
<li><p>完全图，有向完全图，稀疏图，稠密图</p>
<p>设图有n个结点，e条边</p>
<p>含有e = <code>n(n-1)/2</code>条边的无向图成为完全图</p>
<p>含有e = <code>n(n-1)</code> 条弧的有向图成为有向完全图</p>
<p>若边或弧的个数e，<code>e&lt;nlogn</code> 则成为稀疏图，否则成为稠密图</p>
</li>
<li><p>结点的度 = 入度 + 出度</p>
</li>
<li><p>简单路径：顶点不重复的路径</p>
</li>
<li><p>简单回路：除起点终点，顶点不重复的回路</p>
</li>
<li><p>图中任意两个顶点之间都有路径可以联通则成为<strong>连通图</strong>（有向图 / 无向图）</p>
</li>
<li><p>无向图中，极大连通子图称为<strong>连通分量</strong></p>
</li>
<li><p>有向图中，任意两点都有路径可以连通，即为<strong>强连通图</strong>，否则，各强连通子图成为<strong>强连通分量</strong> </p>
<p>有向图的底图连通即为<strong>弱连通图</strong></p>
</li>
<li><p>假设一个连通图有 n 个顶点和 e 条边，其中 n-1 条边和 n 个顶点构成一个极小连通子图，称该极小连通子图为此连通图的<strong>生成树</strong> </p>
</li>
</ul>
<h3 id="4-2-图的遍历"><a href="#4-2-图的遍历" class="headerlink" title="4.2 图的遍历"></a>4.2 图的遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  visited[v] = TRUE;</span><br><span class="line">    <span class="built_in">VisitFunc</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> w : G.Adj)</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">          <span class="built_in">DFS</span>(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-最小生成树"><a href="#4-3-最小生成树" class="headerlink" title="4.3 最小生成树"></a>4.3 最小生成树</h3><ul>
<li><p>Prim算法</p>
<p>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在待添加的顶点w 和已经在生成树上的顶点v之间必定存在一条边<strong>，</strong>并且该边的权值在所有连通顶点v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n个顶点为止。</p>
</li>
<li><p>Kruskal算法</p>
<p>具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。</p>
</li>
</ul>
<h3 id="4-4-重连通图和关节点"><a href="#4-4-重连通图和关节点" class="headerlink" title="4.4 重连通图和关节点"></a>4.4 重连通图和关节点</h3><ul>
<li>重连通图：若从一个连通图中删去<strong>任何</strong>一个顶点及其相关联的边，他仍为一个连通图的话，则该连通图为重（双）连通图。 </li>
<li>若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为<strong>关节点</strong>。没有关节点的连通图即为重连通图</li>
<li>如何判断关节点？<ul>
<li>若生成树的根结点，有两个或两个以上的分支，则此顶点(生成树的根)必为关节点；</li>
<li>对生成树上的任意一个“顶点”，若其某棵子树的根或子树中的其它“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点。 </li>
</ul>
</li>
</ul>
<h3 id="4-5-拓扑排序"><a href="#4-5-拓扑排序" class="headerlink" title="4.5 拓扑排序"></a>4.5 拓扑排序</h3><ol>
<li>从有向图中选取一个没有前驱的顶点，并输出之；</li>
<li>从有向图中删去此顶点以及所有以它为尾的弧；</li>
</ol>
<p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p>
<h2 id="5-查找"><a href="#5-查找" class="headerlink" title="5. 查找"></a>5. 查找</h2><ul>
<li><p>评价指标 ASL</p>
<p>ASL = 求和(i=1, n) C~i~ × P~i~ </p>
<p>C~i~查找到第i条记录时，K与关键字的比较次数</p>
<p>P~i~ 查找第i条记录的概率</p>
</li>
</ul>
<h3 id="5-1-顺序查找表"><a href="#5-1-顺序查找表" class="headerlink" title="5.1 顺序查找表"></a>5.1 顺序查找表</h3><ul>
<li>查找成功ASL = n(n+1)/2 * (1 / n) = n+1/2</li>
<li>查找失败的ASL = n+1</li>
<li>平均 = (3/4)(n+1)</li>
</ul>
<h3 id="5-2-折半查找"><a href="#5-2-折半查找" class="headerlink" title="5.2 折半查找"></a>5.2 折半查找</h3><ul>
<li>折半查找判定树</li>
<li>查找失败并不会多查找一次</li>
</ul>
<p>课本上的典型实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">1</span>, high = ST.length;</span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; ST[mid].key)</span><br><span class="line">      high = mid - <span class="number">1</span>; <span class="comment">//在左区间继续查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (K &gt; ST[mid].key)</span><br><span class="line">      low = mid + <span class="number">1</span>; <span class="comment">//在右区间继续查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">//查找成功的出口</span></span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//查找失败的出口</span></span><br><span class="line">&#125;<span class="comment">//Search_Bin</span></span><br></pre></td></tr></table></figure>
<p>yxc的二分一般实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="5-3-分块索引"><a href="#5-3-分块索引" class="headerlink" title="5.3 分块索引"></a>5.3 分块索引</h3><h3 id="5-4-二叉排序树"><a href="#5-4-二叉排序树" class="headerlink" title="5.4 二叉排序树"></a>5.4 二叉排序树</h3><ul>
<li>二叉排序树的中序遍历序列是一个有序序列</li>
<li>和折半查找判定树类似，查找失败也不会增加比较次数</li>
</ul>
<ul>
<li><p>二叉排序树的删除</p>
<ol>
<li><p>设待删除的结点为p，若p的度为0，直接删除</p>
</li>
<li><p>若p的度为1，则直接用其孩子替换它</p>
</li>
<li><p>若p的度为2，方法1：</p>
<p>将p的右孩子交给其中序前驱，p的左孩子交给其双亲，删除p</p>
</li>
<li><p>用p的中序前驱（后继）替换它，然后删除其中序前驱。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>AVL树</p>
<p>插入：四种旋转</p>
<p>删除：</p>
<ul>
<li>要删除的结点为叶子结点，直接删除它，并自下而上调整AVL树。</li>
<li>要删除的结点只有左孩子，用其左孩子替换该节点，并删除其左孩子。因为AVL树的性质，左右子树高度只差不超过1，因此左孩子一定是叶子结点，这种情况便转换为了第一种情况。</li>
<li>要删除的结点只有右孩子，和只有左孩子的情况相同。</li>
<li>要删除的结点既有左孩子，也有右孩子，此时只需寻找其中序遍历的前驱节点或后继结点，用它们替换该结点，在删除它的中序前驱结点或后继结点，而它的中序前驱后后继必定是叶子结点，该情况也转换为了第一种情况。</li>
</ul>
</li>
</ul>
<h3 id="5-5-哈希表"><a href="#5-5-哈希表" class="headerlink" title="5.5 哈希表"></a>5.5 哈希表</h3><p>构造哈希函数的方法：</p>
<ul>
<li>直接定址法</li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
<li>除留余数法</li>
<li>随机数法</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li><p>开放定址法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hi = (H(key) + di) mod m</span><br><span class="line"></span><br><span class="line"><span class="bullet"> -</span> i = 1, 2, 3, ..., k (k &lt;= m - 1)</span><br><span class="line"><span class="bullet"> -</span> H(key) hash值</span><br><span class="line"><span class="bullet"> -</span> di 增量序列</span><br><span class="line"><span class="bullet"> -</span> m 哈希表的容量</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123446806.png" alt="image-20221226123446806"></p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123504750.png" alt="image-20221226123504750">  </p>
</li>
<li><p>拉链法</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226123407144.png" alt="image-20221226123407144"> </p>
</li>
<li><p>再哈希法</p>
</li>
<li><p>建立公共溢出区法</p>
<p>查找成功失败的ASL</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20221226122114871.png" alt="image-20221226122114871">  </p>
</li>
</ul>
<h2 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h2><ul>
<li><p>插入排序</p>
<p>直接插入排序</p>
<p>折半插入排序</p>
<p>2路插入排序</p>
<p>希尔排序</p>
</li>
<li><p>交换排序</p>
<p>冒泡排序</p>
<p>快速排序</p>
</li>
<li><p>选择排序</p>
<p>选择排序</p>
<p>堆排序</p>
</li>
<li><p>归并排序</p>
</li>
<li><p>基数排序</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>模电课程 - 大学课程</title>
    <url>/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="电工学"><a href="#电工学" class="headerlink" title="电工学"></a>电工学</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>基尔霍夫电压定理</p>
<p>基尔霍夫电流定理</p>
<p>结点电压法：<a href="https://zhuanlan.zhihu.com/p/341727367">第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com)</a> </p>
<p>回路电流法：</p>
<p>叠加定理：<a href="https://baijiahao.baidu.com/s?id=1662486398509859685&amp;wfr=spider&amp;for=pc">电学基础理论之叠加定理 (baidu.com)</a> </p>
<p>戴维南等效电路</p>
<p>二极管：</p>
<p>正向压降 ： 正向通过后，电压的减小量。</p>
<p>二极管的功能：</p>
<ol>
<li><p>钳位</p>
<p><a href="https://baike.baidu.com/item/钳位二极管/6307364?fr=aladdin">钳位二极管_百度百科 (baidu.com)</a> </p>
</li>
<li><p>隔离</p>
</li>
<li><p>稳压 ： 见下面稳压二极管视频</p>
</li>
</ol>
<p>稳压二极管：</p>
<blockquote>
<p>详见视频： <a href="https://www.bilibili.com/video/BV1qY4y1t7sc">https://www.bilibili.com/video/BV1qY4y1t7sc</a></p>
<p>详见P15页笔记</p>
</blockquote>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li><p>电压源</p>
<p>理想的电压源内阻为0，输出电压<code>U = E - IR0</code>, R0 = 0，因此输出电压恒定不变。当内阻远小于外电阻时，可近似看作理想电压源。</p>
</li>
<li><p>电流源</p>
<p>理想电流源的内阻为无穷大，因此输出的电流I = I~S~ - U / R ，恒定不变。</p>
</li>
</ul>
<h2 id="第十四章-半导体器件"><a href="#第十四章-半导体器件" class="headerlink" title="第十四章 半导体器件"></a>第十四章 半导体器件</h2><h3 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h3><ul>
<li><p>导通电压：</p>
<p>硅管：0.5V</p>
<p>锗管：0.1V</p>
</li>
<li><p>正向压降</p>
<p>硅管：0.6 ~ 0.8 V</p>
<p>锗管：0.2 ~ 0.3 V</p>
</li>
<li><p>主要参数</p>
<p>最大整流电流 I~OM~ : 长时间使用所允许通过的最大正向平均电流</p>
<p>反向工作峰值电压 U~RWM~ : 保证二极管不被击穿而给出的反向峰值电压，一般是反向击穿电压的1/2或2/3。</p>
<p>反向峰值电流 I~RM~ ：在U~RWM~ 下的电流</p>
</li>
<li><p>作用</p>
<ol>
<li>整流</li>
<li>限伏/钳位</li>
<li>隔离：两个二极管并联，某个二极管的电压高，则它优先导通。因而电压低的那一个二极管被隔离了。</li>
</ol>
</li>
</ul>
<h3 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h3><ol>
<li>使用稳压二极管时一定要有限流电阻R，不然二极管必定会被烧坏。</li>
<li>稳压二极管的工作原理：当电源电压升高，使得稳压二极管两侧电压有升高的趋势时，此时稳压二极管的电阻升高，电流增大，引起干路限流电阻的电流增加，限流电阻的电阻不变，因此限流电阻的分压增大，抵消了电源增加的电压。</li>
<li>在分析使用稳压二极管之前，假设二极管尚未反向导通，先判断二极管两侧的电压，只有二极管反向击穿时，才能有稳压的效果。</li>
</ol>
<h3 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h3><ul>
<li>放大区，I~E~ = I~C~ + I~B~ , I~C~ = β I~B~ ，发射结正偏，集电结反偏。</li>
<li>截止区，I~C~ = 0, U~CE~ = U~CC~ ， 约等于断开，此时 I~B~ = 0或以下</li>
<li>饱和区，此时I~B~ 和I~C~ 关系很小，I~C~ = U~CC~ / R~C~ , U~CE~ = 0, 相当于短路</li>
<li><p>如何判断三极管的工作状态？</p>
<ol>
<li>求出 I~C~ ~Maximun~  = (Vcc - U~CE~)  / R~C~</li>
<li>求出 I~B~ </li>
<li>若βI~B~ &gt; I~CMaximun~ 饱和</li>
<li>否则处于放大区</li>
</ol>
</li>
<li><p>参数</p>
<p>硅管 U~BE~ = 0.6 ~ 0.7 V    </p>
<p>β 杠 ： 静态电流放大系数</p>
<p>β：动态电流放大系数</p>
<p>I~CBO~ </p>
<p>I~CEO~ </p>
<p>I~CM~ 集电极允许的最大电流，超过它放大系数将会下降</p>
<p>U~（BR）CEO~ </p>
</li>
</ul>
<ul>
<li>如果U~CE~ 固定，那么随着I~B~ 的增加，三极管的工作状态会慢慢从放大状态转为过饱和状态。</li>
</ul>
<h2 id="第十五章-基本放大电路"><a href="#第十五章-基本放大电路" class="headerlink" title="第十五章 基本放大电路"></a>第十五章 基本放大电路</h2><p>放大电路的输入电阻：输入电路的等效负载电阻</p>
<p>放大电路的输出电阻：输出电路的等效内阻</p>
<h3 id="共发射极放大电路（固定偏置放大电路）"><a href="#共发射极放大电路（固定偏置放大电路）" class="headerlink" title="共发射极放大电路（固定偏置放大电路）"></a>共发射极放大电路（固定偏置放大电路）</h3><p>(名字来源：因为偏置电路是固定的)</p>
<p>输入: U~I~或者I~B~ 或U~BE~ </p>
<p>输出：U~O~ (U~CE~ 的交流分量 阻容耦合)</p>
<p>静态值是指</p>
<ul>
<li>I~B~</li>
<li>I~C~</li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~</li>
</ul>
<p>静态值的直接求解法：</p>
<ul>
<li>I~B~ ： (U~CC~ - U~BE~ ) / R~B~ </li>
<li>I~C~ ： βI~B~ </li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~ : U~CC~ - R~C~ I~C~ </li>
</ul>
<p>静态值得图解法：</p>
<ul>
<li>三极管的输出特性曲线是I~C~ - U~CE~ (y - x) 因此，只要求出I~C~ = f(U~CE~ ) 即可</li>
<li>由U~CE~ =  U~CC~ - R~C~ I~C~ 因此只要求出U~CC~ 和 R~C~ 即可</li>
</ul>
<p>偏置电路是指产生偏流I~B~ 的电路，偏置电阻是指限流I~B~的电阻 </p>
<h3 id="非线性失真"><a href="#非线性失真" class="headerlink" title="非线性失真"></a>非线性失真</h3><p>原因：静态工作点不合适 或 信号太大</p>
<p>分类</p>
<ul>
<li>截止失真 : 静态工作点位置太低，输入产生的I~B~ 在负半周截止了，导致输出的IC也截止了（负半周），导致U~CE~ 的正半周截止了</li>
<li>饱和失真 ： 静态工作点位置太高，输出的I~C~ 在正半周饱和，导致输出的U~CE~ 在负半周失真。</li>
</ul>
<p>什么可以影响静态工作点：</p>
<p>最直接的因素是I~C~，可以影响I~C~的因素都可以影响静态工作点 </p>
<h3 id="静态工作点的稳定"><a href="#静态工作点的稳定" class="headerlink" title="静态工作点的稳定"></a>静态工作点的稳定</h3><h4 id="分压式偏置放大电路"><a href="#分压式偏置放大电路" class="headerlink" title="分压式偏置放大电路"></a>分压式偏置放大电路</h4><h3 id="射级输出器"><a href="#射级输出器" class="headerlink" title="射级输出器"></a>射级输出器</h3><p>输入电阻大：对内阻高的信号源很有意义</p>
<p>输出电阻小：具有恒压输出的特性，带负载能力较强</p>
<p>一般用于多级放大电路的输入级或输出级或者多级之间的缓冲级/隔离级</p>
<h2 id="第十六章-集成运算放大器"><a href="#第十六章-集成运算放大器" class="headerlink" title="第十六章 集成运算放大器"></a>第十六章 集成运算放大器</h2><h3 id="集成运放的组成"><a href="#集成运放的组成" class="headerlink" title="集成运放的组成"></a>集成运放的组成</h3><ul>
<li><p>输入极</p>
<p>输入极要求输入电阻高，静态电流小，差模放大倍数高，抑制零点漂移和共模干扰信号强，输入极都采用差分放大电路。</p>
</li>
<li><p>中间级</p>
<p>进行电压放大，要求电压放大倍数高，一般采用共发射极放大电路</p>
</li>
<li><p>输出级</p>
<p>要求输出电阻低，带负载能力强，一般由互补功率放大电路或射级输出器构成</p>
</li>
<li><p>偏置电路</p>
<p>为上述个电路提供稳定合适的偏置电流，决定各级的静态工作点，一般由各种恒流源电路组成。</p>
</li>
</ul>
<h3 id="理想运放"><a href="#理想运放" class="headerlink" title="理想运放"></a>理想运放</h3><p>开环电压放大倍数 ∞</p>
<p>差模输入电阻 ∞</p>
<p>开环输出电阻 0</p>
<ul>
<li><p>工作在线性区</p>
<p>虚断：由于差模输入电阻为∞，可以认为两个输入端的电流 i~+~ = i~-~  = 0</p>
<p>虚短：由于开环电压放大倍数 ∞，可以认为 u~+~ = u~-~ </p>
<ul>
<li>虚地，如果由于虚短，如果两个输入端有一个接地，相当于另一个也接地</li>
</ul>
</li>
<li><p>工作在饱和区</p>
<p>虚断：仍然存在</p>
<p><del>虚短</del>：此时工作在饱和区，不能满足在线性区的放大关系，因此，两个输入端的电压不必相等，虚短不存在</p>
<p>u+ &gt; u- : uo = + Uo(sat)</p>
<p>u+ &lt; u- : uo = - Uo(sat)</p>
</li>
</ul>
<h3 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h3><ul>
<li><p>反向比例运算</p>
<p>运放工作在线性区</p>
<p>只要运放的开环放大倍数很高，比例运算的放大能力就只与外接电阻有关</p>
<p>这个放大倍数就是闭环放大倍数</p>
<p>Uo = -(R~F~ / R1) U1</p>
</li>
<li><p>正向比例运算</p>
<p>电压从正向端输入</p>
<p>放大比例也只与外接电阻有关</p>
<p>Uo = (1 + R~F~ / R1) U1</p>
</li>
<li><p>加法运算</p>
<p>Uo = -[(R~F~/R~11~)U~11~ + (R~F~/R~12~)U~12~ + (R~F~/R~13~)U~13~]</p>
<p>Uo = -(R~F~ / R1)(U11 + U12 + U13)</p>
</li>
<li><p>减法运算</p>
<p>Uo = (1 + R~F~ / R~1~ ) (R~3~ / (R1 + R2)) U12 - R~F~ / R~1~ U11</p>
<p>当R1 = R2, R2 = R~F~ </p>
<p>Uo = R~F~ / R~1~(U12 - U11)</p>
<p>当 R1 = R2 = R2 = R~F~ </p>
<p>Uo = U12 - U11</p>
</li>
</ul>
<h2 id="第十七章-电子电路中的反馈"><a href="#第十七章-电子电路中的反馈" class="headerlink" title="第十七章 电子电路中的反馈"></a>第十七章 电子电路中的反馈</h2><p>反馈的模态判断：</p>
<p>反馈信号与输入信号在</p>
<ul>
<li>相同端子上（并联）<ul>
<li>极性相同：正反馈</li>
<li>极性相反：负反馈</li>
</ul>
</li>
<li>相异端子上（串联）<ul>
<li>极性相同：负反馈</li>
<li>极性相反：正反馈</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何判断反馈是电压反馈还是电流反馈？</p>
<p>将输出电压U~O~ 置零，看是否还存在反馈？</p>
<ul>
<li>存在：电流反馈</li>
<li>不存在：电压反馈</li>
</ul>
</li>
<li><p>负反馈对输入输出电阻的影响：</p>
<p>电压负反馈使得输出有电压源的特性，因此电压负反馈可以降低输出电阻ro</p>
<p>电流负反馈使得输出有电流源的特性，因此电流负反馈可以增高输出电阻ro</p>
<p>串联反馈可以增大输入电阻ri</p>
<p>并联反馈可以减小输入电阻ri</p>
</li>
<li><p>负反馈可以减小波形失真，但不能完全消除波形失真</p>
</li>
<li><p>引入负反馈之后可以降低放大倍数</p>
</li>
<li><p>引入负反馈可以提高放大倍数的稳定性</p>
</li>
</ul>
<h2 id="第十八章-直流稳压电源"><a href="#第十八章-直流稳压电源" class="headerlink" title="第十八章 直流稳压电源"></a>第十八章 直流稳压电源</h2><h3 id="整流"><a href="#整流" class="headerlink" title="整流"></a>整流</h3><ul>
<li><p>单相半波整流</p>
<p>变压器的输出（整流电路输入的交流电压，变压器的二次电压）为 u = √2Usin wt (U为交流电压的有效值，也叫变压器的二次电压有效值)</p>
<p>整流电压的平均值 U~O~ = 0.45U</p>
<p>整流电流（负载电流）的平均值 I~O~ = U~O~ / R~L~ = 0.45U/R~L~ </p>
<p>整流元件截止时的最高反向电压 U~RM~ = √2U (并不是元件能承受的最大电压，元件能承受的最大反向电压要看元件自己的参数)</p>
</li>
<li><p>单相全波整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~ </p>
<p>I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = 2√2U</p>
</li>
<li><p>三相半波</p>
<p>U~O~ = 1.17U</p>
<p>I~O~ =  1.17U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45U</p>
</li>
<li><p>单向桥式整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~</p>
<p>每个二极管中流过的平均电流 I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = √2U</p>
<blockquote>
<p>变压器的变比K = 交流电源电压 / 二次电压有效值</p>
<p>变压器容量 S = UI = 变压器二次电压有效值 * 变压器二次电流有效值</p>
</blockquote>
</li>
<li><p>三相桥式整流</p>
<p>U~O~ = 2.34U</p>
<p>I~O~ = 2.34U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45 U</p>
</li>
</ul>
<h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><ul>
<li><p>电容滤波器</p>
<p>U~O~ = 1.2U</p>
<p>对滤波电容，一般要求</p>
<p>R~L~ C &gt;= (3~5)T/2</p>
</li>
<li><p>电感电容滤波（LC滤波）</p>
<p>适用于电流较大、要求输出电压脉动很小的场合，用于高频时更加合适</p>
</li>
</ul>
<h3 id="直流稳压电源"><a href="#直流稳压电源" class="headerlink" title="直流稳压电源"></a>直流稳压电源</h3><ul>
<li><p>稳压二极管稳压电路</p>
<p>一般交流电压经过整流（桥式整流）和滤波之后，得到的直流电仍存在波动，此时需要进行稳压</p>
<p>引起负载电压变化的原因有二：</p>
<ol>
<li>交流电源电压的变化</li>
<li>负载电流的变化</li>
</ol>
<p>可以对负载电阻，先串联一个保护电阻，在并联一个稳压二极管，稳压二极管通过提高或减小电流，是的保护电阻承担增大或减少的电压。</p>
<p>选取稳压二极管时，一般取：</p>
<ul>
<li><p>U~Z~ = U~O~ （U~Z~ 为稳压二极管的稳定电压，Uo为输出的负载电压）</p>
</li>
<li><p>I~ZM~ = (1.5~3) I~OM~ （I~ZM~ 为最大稳压电流，I~OM~ 为负载电流的最大值） </p>
</li>
<li>U~1~ = (2~3) U~O~ (其中U~1~ 是经过整流 滤波后的输出电压，也就是稳压部分的输入电压，即需要被稳压的部分)</li>
</ul>
</li>
<li><p>集成三端稳压电源</p>
<p>W78XX（输出固定正电压），W79XX（输出固定负电压），W117/217/317（输出电压可调）</p>
<p>有三个引脚，分别是输入端I，输出端O，地段GND</p>
<p>使用时需要在其输入端，输出端，地段并联一个电容</p>
</li>
</ul>
<p>  几种典型的电路：</p>
<ol>
<li>正负电压同时输出的电路</li>
<li>输出电压可调的电路<ol>
<li>用集成运放 + W78XX/W79XX</li>
<li>用W117/217/317</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>网络编程 - CS:APP 第十一章</title>
    <url>/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="网络编程-CS-APP-第十一章"><a href="#网络编程-CS-APP-第十一章" class="headerlink" title="网络编程 - CS:APP 第十一章"></a>网络编程 - CS:APP 第十一章</h1><p>客户端和服务器都是进程，而不是机器或主机。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32位IP地址，使用网络字节顺序（大端法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。</p>
<p>字节顺序和主机顺序的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to net</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// net to host</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;  <span class="comment">// net to host</span></span><br></pre></td></tr></table></figure>
<p>点分IP地址与32位IP地址的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点分十进制转换成32位地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">得到的32位地址也要转换成本地顺序</span></span><br><span class="line"><span class="comment">返回：若成功返回1，串非法返回0，错误返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位地址转换成点分十进制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用该函数之前，要将32位IP地址转换成网络顺序</span></span><br><span class="line"><span class="comment">把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中</span></span><br><span class="line"><span class="comment">返回：若成功返回指向点分十进制地址的指针，出错返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>附</p>
<ol>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将十六进制字符串转换成十进制数：</span></span><br><span class="line">使用<span class="built_in">sscanf</span>(str, <span class="string">&quot;%x&quot;</span>, &amp;num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用32位IP地址时，可以直接使用<code>in_addr</code>结构而不是<code>in_addr</code>结构里的<code>s_addr</code></p>
</li>
</ol>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>是一组绝大多数操作系统都定义的函数，可以实现网络应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209231151155.png" alt="image-20220923115128790"></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个结构体所占字节数相同，可以互相转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;  <span class="comment">// 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6)</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;    <span class="comment">// 端口号，使用网络字节顺序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IP地址结构</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">// 填充0，为了满足struct sockaddr的大小</span></span><br><span class="line">&#125;;    <span class="comment">// 这个结构体一共占16个字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="socket-通用"><a href="#socket-通用" class="headerlink" title="socket() 通用"></a>socket() 通用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使套接字称为一个连接的结点</span></span><br><span class="line"><span class="comment">返回一个还不能用于读写的描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使称为一个连接点</span></span><br><span class="line">clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="connect-客户端"><a href="#connect-客户端" class="headerlink" title="connect() 客户端"></a>connect() 客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="bind-服务器"><a href="#bind-服务器" class="headerlink" title="bind()  服务器"></a>bind()  服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="listen-服务器"><a href="#listen-服务器" class="headerlink" title="listen() 服务器"></a>listen() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="accept-服务器"><a href="#accept-服务器" class="headerlink" title="accept() 服务器"></a>accept() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功返回非负连接描述符， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>服务器：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>bind()</code> 成为一个服务器套接字</li>
<li>调用<code>listen()</code> 转换成监听描述符</li>
<li>调用<code>accept()</code> ，阻塞程序，等待客户端连接，返回连接描述符</li>
</ol>
<p>客户端：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>connect()</code>， 连接服务器</li>
</ol>
<h3 id="套接字地址和主机名服务名的转换"><a href="#套接字地址和主机名服务名的转换" class="headerlink" title="套接字地址和主机名服务名的转换"></a>套接字地址和主机名服务名的转换</h3><p>首先了解，域名和IP地址是等价的，服务名和端口号是等价的</p>
<p>例如localhost和127.0.0.1是等价的，http和80是等价的</p>
<h4 id="从-字符串主机名服务名信息-到-二进制套接字地址信息"><a href="#从-字符串主机名服务名信息-到-二进制套接字地址信息" class="headerlink" title="从 字符串主机名服务名信息 到 二进制套接字地址信息"></a>从 字符串主机名服务名信息 到 二进制套接字地址信息</h4><blockquote>
<p>为什么要使用这个函数？</p>
<p>域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">host: 域名或点分十进制IP地址</span></span><br><span class="line"><span class="comment">service: 服务名或端口号</span></span><br><span class="line"><span class="comment">hints: 可选 传递设置</span></span><br><span class="line"><span class="comment">result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放返回的链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo, *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将错误代码转换成错误信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getaddrinfo</code> 使用的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;</span><br><span class="line">    <span class="type">int</span> ai_family;</span><br><span class="line">    <span class="type">int</span> ai_socktype;</span><br><span class="line">    <span class="type">int</span> ai_protocol;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ai_canonname;</span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从-二进制套接字地址信息-到-字符串主机名服务名信息"><a href="#从-二进制套接字地址信息-到-字符串主机名服务名信息" class="headerlink" title="从 二进制套接字地址信息 到 字符串主机名服务名信息"></a>从 二进制套接字地址信息 到 字符串主机名服务名信息</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen,</span></span><br><span class="line"><span class="params">               <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, </span></span><br><span class="line"><span class="params">               <span class="type">char</span> *service, <span class="type">size_t</span> servlen,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="辅助简化函数"><a href="#辅助简化函数" class="headerlink" title="辅助简化函数"></a>辅助简化函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> clientfd, rc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;  <span class="comment">/* Open a connection */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV;  <span class="comment">/* ... using a numeric port arg. */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;  <span class="comment">/* Recommended for connections */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (%s:%s): %s\n&quot;</span>, hostname, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Walk the list for one that we can successfully connect to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Connect to the server */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(clientfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Connect failed, try another */</span>  <span class="comment">//line:netp:openclientfd:closefd</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_clientfd: close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* All connects failed */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* The last connect succeeded */</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="type">const</span> <span class="type">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* No address worked */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echoserver.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received:%s\n&quot;</span>, buf);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE,</span><br><span class="line">        client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>protocol family 协议簇：一组相关联的协议</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>系统级I/O - CS:APP 第十章</title>
    <url>/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="系统级I-O-CS-APP-第十章"><a href="#系统级I-O-CS-APP-第十章" class="headerlink" title="系统级I/O - CS:APP 第十章"></a>系统级I/O - CS:APP 第十章</h1><p>Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。</p>
<p>在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul>
<li><p>定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。</p>
</li>
<li><p>Linux Shell 创建的进程会打开三个文件：</p>
<p>0：标准输入；也可以使用定义在<code>unistd.h</code> 中的<code>STDIN_FILENO</code> 来显示表述</p>
<p>1：标准输出；<code>STDOUT_FILENO</code></p>
<p>2：标准错误；<code>STDERR_FILENO</code> </p>
</li>
<li><p>EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;= m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。</p>
</li>
</ul>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul>
<li>普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。</li>
<li>目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是<code>.</code> 和<code>..</code> 分别代表自己和上层目录。</li>
<li>套接字 socket ：用来和其他进程进行跨网络通信的文件。</li>
</ul>
<h2 id="系统级IO函数"><a href="#系统级IO函数" class="headerlink" title="系统级IO函数"></a>系统级IO函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开和关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flags: 文件的打开方式</span></span><br><span class="line"><span class="comment">O_RDONLY   只读</span></span><br><span class="line"><span class="comment">O_WRONLY  只写</span></span><br><span class="line"><span class="comment">O_RDWR    可读可写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">O_CREAT   如果文件不存在，创建</span></span><br><span class="line"><span class="comment">O_TRUNC    如果文件已存在，截断它（即覆盖原文件）</span></span><br><span class="line"><span class="comment">O_APPEND  添加到文件末尾</span></span><br><span class="line"><span class="comment">不同的flag可以使用管道符| 连接使用 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mode:</span></span><br><span class="line"><span class="comment">一般为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回-1，EOF返回0，出错返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回写的字节数，出错返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>ssize_t</code> ：signed size type</p>
<p>read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n</p>
<p>可能会返回不足值得情况：</p>
<ul>
<li>读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。</li>
<li>从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li>
<li>读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。</li>
</ul>
<h2 id="RIO包函数"><a href="#RIO包函数" class="headerlink" title="RIO包函数"></a>RIO包函数</h2><p>RIO(Robust I/O)：用于网络编程中，会自动处理不足值的情况。</p>
<h3 id="总览："><a href="#总览：" class="headerlink" title="总览："></a>总览：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带缓冲区的版本</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替read</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带缓冲区的版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;  <span class="comment">// 带缓冲区的rio_readn</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>带缓冲区和不带缓冲区的优劣：</p>
<p>带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。</p>
<p>不带缓冲区：比较快速，方便在网络上进行数据传输（臆断）</p>
</blockquote>
<h3 id="不带缓冲区的函数"><a href="#不带缓冲区的函数" class="headerlink" title="不带缓冲区的函数"></a>不带缓冲区的函数</h3><h3 id="rio-readn"><a href="#rio-readn" class="headerlink" title="rio_readn()"></a>rio_readn()</h3><p>用来代替<code>read</code> 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// 整个程序中，还没有被读取的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// 单次调用read 函数所读取的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// read 函数发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)     <span class="comment">// interrupted by a sig handler return</span></span><br><span class="line">                nread = <span class="number">0</span>;      <span class="comment">// call read again</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;      <span class="comment">// 这个程序读取的所有字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-writen"><a href="#rio-writen" class="headerlink" title="rio_writen()"></a>rio_writen()</h3><p>用来代替<code>write</code> 的函数，无缓冲区，绝对不可能返回不足值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;    <span class="comment">// 整个程序中，还没有被写入的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nwritten;    <span class="comment">// 单词write函数写入的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;  <span class="comment">// 下一个将被写入的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)    <span class="comment">// 被一个信号处理程序返回打断</span></span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带缓冲区的函数"><a href="#带缓冲区的函数" class="headerlink" title="带缓冲区的函数"></a>带缓冲区的函数</h3><p>缓冲区的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192  <span class="comment">// 缓冲区的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;        <span class="comment">// 与缓冲区关联的文件描述符</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;      <span class="comment">// 缓冲区中的未读字节数</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;    <span class="comment">// 下一个未读字节地址</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];    <span class="comment">// 缓冲区</span></span><br><span class="line">&#125;<span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>
<p>初始化缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> rio_</span><br></pre></td></tr></table></figure>
<h3 id="rio-read"><a href="#rio-read" class="headerlink" title="rio_read()"></a>rio_read()</h3><p>带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数</p>
<p>该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。</p>
<p>该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;  <span class="comment">// 本次调用函数读取的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 如果缓冲区为空，重新填满缓冲区</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)    <span class="comment">// 被信号打断，自动重启</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// EOF</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">// 重置bufptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)    <span class="comment">// 缓冲区字节数不够</span></span><br><span class="line">        cnt = rp-&gt;rio_cnt;      <span class="comment">// 返回不足值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readlineb"><a href="#rio-readlineb" class="headerlink" title="rio_readlineb()"></a>rio_readlineb()</h3><p>读取一行，最多读取maxlen-1个字节，最后一个字节要填充<code>&#39;\0&#39;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, rc;    <span class="comment">// n 程序读取字节数， rc 单次rio_read 的返回值</span></span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;    <span class="comment">// c一个临时变量，用于逐个读取，测试是否为换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;  <span class="comment">// 正常</span></span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;  <span class="comment">// 返回不足值</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// EOF，什么字节也没读取，直接返回0</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">// EOF, 但已经读取了一些字节，需要处理后返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *bufp = <span class="number">0</span>;      <span class="comment">// 最后一位用 &#x27;\0&#x27; 填充</span></span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readnb"><a href="#rio-readnb" class="headerlink" title="rio_readnb()"></a>rio_readnb()</h3><p>rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// bytes that has not been read</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// read() func had read nread bytes</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)   <span class="comment">// someting wrong</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>stat()</code> 函数以文件名作为输入，填写<code>struct stat *buf</code>  </p>
<p>我们只对<code>struct stat</code> 的一些条目感兴趣：</p>
<ul>
<li><p><code>buf-&gt;st_size</code> 文件的大小</p>
</li>
<li><p><code>buf-&gt;st_mode</code> 使用在<code>sys/stat.h</code> 的三个宏可以判断文件类型：</p>
<p><code>S_ISREG(mode)</code> 这是一个普通文件吗？</p>
<p><code>S_ISDIR(mode)</code> 这是一个目录文件吗？</p>
<p><code>S_ISSOCK(mode)</code> 这是一个网络套接字吗？</p>
</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent * <span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;      <span class="comment">// inode number 文件位置</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];    <span class="comment">// Filename		文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO重定位"><a href="#IO重定位" class="headerlink" title="IO重定位"></a>IO重定位</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>西方哲学史 希尔贝克</title>
    <url>/2023/01/22/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2%20%E5%B8%8C%E5%B0%94%E8%B4%9D%E5%85%8B/</url>
    <content><![CDATA[<h1 id="《西方哲学史》希尔贝克-读书笔记"><a href="#《西方哲学史》希尔贝克-读书笔记" class="headerlink" title="《西方哲学史》希尔贝克 读书笔记"></a>《西方哲学史》希尔贝克 读书笔记</h1><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>在这里记录一下自己感兴趣的问题：</p>
<ol>
<li><p>是否存在普遍的善和正当的价值规范存在</p>
<p>智者派的相对主义</p>
<p>苏格拉底的驳斥</p>
<p>柏拉图的理念论</p>
</li>
</ol>
<p>从这里记录一下自己的想法：</p>
<ol>
<li><p>很多哲学家都强调过一些东西：</p>
<p>比如苏格拉底强调要通过开放性的对话获得对真正自我的洞见</p>
<p>康德说要运用理性是自己摆脱不成熟状态</p>
<p>罗素说要告诉自己事实是什么</p>
<p>他们的意思都大体相同，都是在强调通过理性形成自己的观点。</p>
</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="苏格拉底"><a href="#苏格拉底" class="headerlink" title="苏格拉底"></a>苏格拉底</h2><ul>
<li><p>苏格拉底感兴趣的是 认识论 和 伦理-政治问题</p>
</li>
<li><p>在<strong>认识论</strong>上，苏格拉底认为的知识可由粗略的三分法来表述</p>
<blockquote>
<ol>
<li>有关是什么的知识</li>
<li>对于应当是什么的知识</li>
<li>对真正自我的洞见（即通过理性的信服而不是通过修辞术的说服）</li>
</ol>
</blockquote>
<p>要如何获得第三种知识，苏格拉底赞同一种开放性的对话方法，在公开讨论中，让讨论的各方充分地了解论题，得到自己信服的观点。</p>
</li>
<li><p>在<strong>伦理政治问题</strong>上，驳斥怀疑论，承认有普遍的善和正当的价值规范存在</p>
<p>知识即美德，拥有知识就回去行善，就会导向幸福。</p>
<blockquote>
<p>即使苏格拉底得不出一个确定的哲学答案，但他仍在努力寻求答案，仍在赋予道德一个特定的认识论基础</p>
</blockquote>
<p>我的理解是，苏格拉底想要在认识论上为道德奠定一个基础，即一个拥有“对真正自我的洞见”的人不去行善，是不可思议的。</p>
</li>
</ul>
<h2 id="柏拉图"><a href="#柏拉图" class="headerlink" title="柏拉图"></a>柏拉图</h2><ul>
<li><p>本体论，理念论，认为理念是客观存在的第一实体</p>
</li>
<li><p>认识论，回忆说，灵魂通过可感现象的刺激回忆起前世对理念的知识。但柏拉图认为对理念的洞见只有少数人才能达到。</p>
</li>
<li><p>在伦理学上，由于理念论的存在，存在客观存在的善的理念，因此道德具有稳固的基础，即存在普遍的善和正当的价值规范。</p>
<p>一个行为之所以是善的，是因为它分有了善的理念，而善的理念还与智慧、勇敢和节制有关，理念和理念之间交织在一起。</p>
</li>
<li><p>政治上，柏拉图怀疑人们的知善能力，认为必须由「专家」们执政，因此有了三种社会层次——生产者、管理者和统治者。（理想国）</p>
</li>
<li><p>艺术上，柏拉图认为艺术作品不能「为艺术而艺术」，理念之间是相互联系的，善、美的理念交织在一起，艺术不能脱离道德，艺术不是道德中立的。</p>
<p>柏拉图认为艺术的本质是复制和摹仿，理念是可感事物的原型，它是复制可感事物的艺术品的原型，因此艺术家应该努力复制理念。艺术家可以不只受可感事物的激发，而直接被理念激发，这样艺术家就成了传递理念的媒介。</p>
</li>
</ul>
<h2 id="亚里士多德"><a href="#亚里士多德" class="headerlink" title="亚里士多德"></a>亚里士多德</h2><ul>
<li><p>本体论（形而上学），</p>
<p>实体与属性论，亚里士多德认为只有个别的事物是存在的，即「实体」。颜色，形状等都是作为实体的属性，离开了实体，属性无法独立存在。属性分为本质属性和非本质属性，根据这两种属性之间的划分，形成了「种的概念」，属性和种是相对存在的。</p>
<p>四因说，亚里士多德将世界上事物变化与运动背后的原因归纳为四大类，即质料因、形式因、动力因、目的因。</p>
<p>潜能 - 现实，变化是潜能的现实化</p>
<p>分级的有机世界观，从纯质料到达纯现实，从无机物到人。在亚里士多德的世界观中，每一种事物都倾向于以最好的方式去实现自己的潜能，万事万物都有一种「向上」的渴望。但是每一个种在宇宙中都有既定的位置。</p>
</li>
<li><p>认识论</p>
<p>获取知识的第一步是用我们的感官来经验个别事物，第二步是从偶然性中抽象出本质和共相。</p>
<p>亚里士多德把知识的获取过程看成一个从感觉经验到本质洞见的过程。</p>
<p>亚里士多德区分了三种学科：</p>
<p>理论科学：目的是确定真理。如自然哲学、数学、形而上学。</p>
<p>实践科学：通过获得性的伦理能力导向明智的行动。如政治学。</p>
<p>创制科学：生产某物，具有创造性。如诗学和修辞学。</p>
</li>
<li><p>伦理学，亚里士多德认为人如同一粒种子，具有可实现的潜力（理性），人要经历社会化的三个阶段（家庭、村落、城邦），在共同体中找到自己的位置。</p>
</li>
<li><p>政治上，支持平等原则。收集了158中城邦材料，讨论其中最好的形式：必须要听取民众的意见，必须要依法治国。</p>
<p>结论是：有限民主是最好的国家政体。这一国家由法律治理，而且是「混合政体」：在量上实行民主制原则，质上实行贵族制原则。</p>
</li>
<li><p>艺术上，亚里士多德认为，艺术是自身产生愉悦的模仿。艺术同样具有道德上的功能，具有净化或纯化的作用。</p>
<p>关于艺术在道德上的功能的两种解释：</p>
<blockquote>
<ol>
<li>艺术的净化作用在于它能使我们「释放情绪」。通过体验戏剧中的英雄、恶棍和崇高的感情，我们释放出被压抑和控制不住的情感，这样就恢复和谐，并重新开始过依照「中道」理想的生活。</li>
<li>艺术的净化作用在于，我们人可以通过艺术来得到教化，使精神升华。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="希腊化-罗马时期"><a href="#希腊化-罗马时期" class="headerlink" title="希腊化 - 罗马时期"></a>希腊化 - 罗马时期</h2><ul>
<li>希腊化时期人民对政治感到无能为力，这种无能为力在思想上表现在：回避对社会进行哲学思辨，而关注如何确保个人的幸福。希腊化时期有一种从关心共同体中的人向关心孤立的、私人的个体的普遍转向。</li>
<li>对于希腊人，法律仅仅适用于地方共同体中的人。到了希腊化时期，出现了一种把法律当作不分国家，不分地位人人适用的普遍法则的观点。（自然法）</li>
<li>「政治」词义的转变，在古希腊，政治指调节一个城邦的地方共同体中的公共活动的理性讨论，在希腊化时期，它主要指统治一个帝国的一般的法律原则。</li>
</ul>
<h3 id="伊壁鸠鲁主义"><a href="#伊壁鸠鲁主义" class="headerlink" title="伊壁鸠鲁主义"></a>伊壁鸠鲁主义</h3><ul>
<li><p>伊壁鸠鲁主义是一种受谨慎和深思熟虑影响的快乐哲学，它可以被概括如下</p>
<blockquote>
<ol>
<li>存在着唯一的善是快乐</li>
<li>要确保最大的快乐，我们必须只享受我们能支配的快乐。</li>
</ol>
</blockquote>
</li>
<li><p>伊壁鸠鲁主义的快乐不是一时的感性欲望，伊壁鸠鲁主义者强调那些更精致、更稳定的快乐形式，如友谊、文采。</p>
</li>
</ul>
<h3 id="犬儒学派"><a href="#犬儒学派" class="headerlink" title="犬儒学派"></a>犬儒学派</h3><ul>
<li>犬儒们从社会中抽身，过着一种简单地、半原始的生活</li>
<li>犬儒主义教导境遇不利者要满足于他们所拥有的东西，即使他们一无所有。</li>
</ul>
<h3 id="希腊斯多葛学派"><a href="#希腊斯多葛学派" class="headerlink" title="希腊斯多葛学派"></a>希腊斯多葛学派</h3><ul>
<li><p>幸福观（同苏格拉底和柏拉图）：一个人幸福的唯一条件是他或她过有德性的生活，而美德是以知识为基础的。</p>
<blockquote>
<p>补充：美德 arete，与英语中的virtue一词相似</p>
<p>arete，美德意味着一个人在社会中实现他的真正潜能，因此是积极美德。（消极美德：不去作恶）</p>
<p>这种美德是道德上的优秀也是指一个人尽可能好地履行被赋予地职能或角色的优秀。教师的优秀体现在教的好，铁匠的优秀体现在能制作出好的工具，人的美德在于尽其所能，实现人之为人的真正潜能。</p>
</blockquote>
</li>
<li><p>宿命论，万物都受逻各斯或神的引导，人的任务是去学会对发生的一切事情都愉快地接受，在命运的判决面前，一个人应该显示出斯多葛式的平静。 或者说 人应该去支配自己能够支配的东西，如自己的内心。</p>
</li>
<li></li>
</ul>
<h3 id="希腊-希腊化时期的斯多葛学派"><a href="#希腊-希腊化时期的斯多葛学派" class="headerlink" title="希腊 - 希腊化时期的斯多葛学派"></a>希腊 - 希腊化时期的斯多葛学派</h3><ul>
<li>成为了中产阶级的意识形态，强调责任与品格，重视一种适用于所有人的自然法。</li>
</ul>
<h3 id="罗马的斯多葛学派"><a href="#罗马的斯多葛学派" class="headerlink" title="罗马的斯多葛学派"></a>罗马的斯多葛学派</h3><ul>
<li><p>历史观，对世界历史持有一种循环的观点（宿命论的），任何事物都会像四季那样重复自身，万物都重复自己，那么我们就无法改善这个世界，我们只能尽可能地忍受。</p>
</li>
<li><p>个人，个人不再是群体的有机部分，而是普遍法典和政府体制下的一个人。</p>
</li>
<li><p>法律的来源，对斯多葛学派来说，每个人心中都存在一团「圣火」，他们从普遍理性中引出自然法。（即自然法基于普遍理性）</p>
<blockquote>
<p>「完善的法律要到智者的灵魂之中去找」 西塞罗</p>
</blockquote>
</li>
<li><p>自然法，法律的-政治的法则的基础在于一个普遍的自然法则（自然法），自然法适用于所有人。</p>
</li>
</ul>
<h2 id="霍布斯"><a href="#霍布斯" class="headerlink" title="霍布斯"></a>霍布斯</h2><ul>
<li><p>自然哲学：彻底机械唯物主义</p>
</li>
<li><p>政治哲学：</p>
<p>观点：</p>
<p>建立一个可以确保和平与秩序的政府，权力必须集于一身，不论是国王的政府还是议会的政府，都要确保和平与秩序。</p>
<p>研究方法：功能主义的分析与综合</p>
<p>霍布斯用一种功能主义的方法去理解社会，他考察社会各部分的功能，然后将他们组合到一起。霍布斯的方法，不是一种还原论，他不认为整体的功能是部分的组合。</p>
<p>研究历程：</p>
<p>首先考虑政府的作用，用一个思想实验来说明政府的功能，如果没有政府，人们将生活在一种一切人反对一切人的战争的自然状态。由于个人自我保存的需要，一个建立在一种受理性承认的社会契约的基础上的国家出现了。这个国家的政府通过确保和平与秩序而获得合法性，它拥有所有的权力，当政府不能确保和平与秩序时，它也就失去了合法性。</p>
<p><strong>（个人感想）</strong>霍布斯的说明是功能主义的，他说社会契约创造的国家政府使人们远离自然状态，并不是说真的存在自然状态，只是在功能主义的思想实验中，如果没有政府，可能会存在一切人对一切人的战争。</p>
<p>正如作者在洛克一节中补充道：</p>
<blockquote>
<p>自然状态学说并不是一种关于国家起源的学说，并不是关于国家实际上如何产生的学说，而是一种说明国家是什么，并为国家提供合法性的学说。</p>
</blockquote>
</li>
<li><p>资本主义的发展与意识形态之间的联系：</p>
<p>早期的资本主义：生存斗争非常艰苦，需要一个专制君主（霍布斯的观点）</p>
<p>比较成形的资本主义：市民阶级有必要关注专制君主和相对不可侵犯的权利。</p>
<p>完全形成的私人资本主义和自由放任的自由主义：出现了关注快乐的功利主义。</p>
</li>
<li><p>关于自由和自由主义</p>
<p>自由主义（liberalism）和自由主义者（liberalist）:其基本概念是个人、契约和国家</p>
<p>自由气度（liberality）和自由派人士（liberal）：倾向于宽容和司法自由的正面的道德的态度。</p>
<p>洛克既是自由主义者又是自由派人士，霍布斯可有说是自由主义者但不是自由派人士。</p>
<blockquote>
<p><strong>自由并不是一个独立成立的概念，一种关于自由的哲学必须预设了一个讨论有关什么是自由的、以什么方式它是自由的学说。</strong></p>
<p>对于自由主义者来说，自由地主体是被理解为自我满足的、理性的、自私自利地行动着地个人，因此我们把自由主义定义为一种形式地个人主义的时候，并不是随心所欲的。</p>
<p>理解自由主义，是离不开它所预设的社会哲学或存在论的——同样，理解任何其他有关自由的学说，也离不开与之伴随的有关什么是自由的、相对于什么而自由的学说。</p>
</blockquote>
<p>通常人们用<strong>自由主义</strong>这个术语来表示这样一些政治-经济理论，他们把自由看作一个基本价值，把个人的开明的自利看作是基础的驱动力，而把国家的任务看作是为独立的行动者确保和平与秩序。</p>
</li>
</ul>
<h2 id="笛卡尔"><a href="#笛卡尔" class="headerlink" title="笛卡尔"></a>笛卡尔</h2><p>唯理论 </p>
<ul>
<li>有条理的怀疑，确定什么是逻辑上可怀疑的。</li>
<li>我思故我在，是笛卡尔的出发点，他认为自己拥有一个关于完美存在的观念，而关于完美存在的观念不能是由不完美的存在（自己）引起的，因此只能是由上帝引起的。</li>
<li>这样笛卡尔为之前那些原则上可错的知识进行了平反，他们有了一个牢固的基础。</li>
</ul>
<p>心物二元论：物质实体和精神实体都是存在的，他们相互影响，在松果体交互。</p>
<h2 id="斯宾诺莎"><a href="#斯宾诺莎" class="headerlink" title="斯宾诺莎"></a>斯宾诺莎</h2><ul>
<li><p>斯宾诺莎在认识论上是一个唯理论者，在道德理论上与斯多葛学派相近，在自然理论上与泛神论有联系。</p>
</li>
<li><p>在认识论上，斯宾诺莎预设了我们拥有清晰的直觉（清晰而确定的知识）。有三种认识的道路，其中借助逻辑推理的方式获得知识是可靠的。</p>
</li>
<li><p>在本体论上（斯宾诺莎在他的《伦理学》中阐述），斯宾诺莎以一种几何学、唯理论的方式进行思考，它首先设定了一些公理，然后从这些公理出发去演绎。</p>
<p>斯宾诺莎对实体的定义（公理）是：「实体，我理解为在自身内并通过自身而被认识的东西。」，即实体是独立的，不依赖他物而存在的。</p>
<p>根据这个定义，如果存在两个以上的实体，那么第一个实体和第二个实体之间的关系就会被包括到我们对实体的理解中，这样实体就不是独立存在的了，这与我们所定义的实体的概念相悖，因此只有一个实体，实体是一，也是无限。</p>
<p>如果存在一个神的话，神不可能是有别于实体的东西，因此实体就是神。（我的理解是，如果一个人信仰存在神的话，它可以把实体理解为神）</p>
</li>
<li><p>实体，属性和样式</p>
<p>实体可以有无限多的显现方式，它向我们现行的方式就是两种属性——思维的属性和广延的属性，而一本书可以是广延属性之下的样式，一个人的思想可以是思想属性下的样式。（关于样式，我认为可以这样理解，想象实体是一个巨大的球体，而上边有很多纹路，即样式，我们用不同的属性去观察实体上的样式，用广延的属性去观察，我们看到了人的形体，用思维的属性去观察，我们看到了人的思想）</p>
</li>
<li><p>关于自由</p>
<p>斯宾诺莎认为，一个人根本上是与实体统一的，因此说一个人相对于实体而自由或者受实体强制是毫无意义的。</p>
</li>
</ul>
<h2 id="莱布尼茨"><a href="#莱布尼茨" class="headerlink" title="莱布尼茨"></a>莱布尼茨</h2><blockquote>
<p>莱布尼茨说表面上给人印象是物质的、被动的那些东西，本质上确实能动的力量。我们简短地看看莱布尼茨是如何设法在机械论的，唯理论的宇宙地下建立一个非唯物主义的，目的论的「底层」的。</p>
</blockquote>
<ul>
<li><p>单子论</p>
<p>单子是宇宙建立于其上的基本元素，单子是存在等级的，每个单子都不受其他单子影响。</p>
<p>前定和谐：上帝确保了单子的和谐运行（一种目的论的解释）</p>
</li>
<li><p>「所有可能世界中最好的世界」</p>
</li>
</ul>
<h2 id="洛克"><a href="#洛克" class="headerlink" title="洛克"></a>洛克</h2><ul>
<li><p>认识论</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208111207303.png" alt="洛克的经验主义认识论"></p>
<ul>
<li><p>唯理论者认为清晰的概念使我们洞察实在的本质。从洛克到康德，标准的论证是说，对概念的洞见并不必然提供对实在的洞见。</p>
</li>
<li><p>洛克在进行思考前的预设：要做一个理性的人，就意味着去追求真理的意思，追求真理就预设了某种思想自由和宽容，即别人也可能是正确的，我们也能从他们那里学到什么。这样讨论就预设了一种非独断的、开放的态度。</p>
</li>
<li><p>洛克面临着一个关于还原的问题：知识是经验的总和呢，还是不仅仅是这种总和呢？ </p>
<p>如果我们回答说知识可以还原到经验的部分，我们会得到一种彻底的经验论立场，即知识可以被完全地、充分地分析为简单地直觉观念。</p>
<p>如果我们回答说知识的构成开始于简单的直觉观念，那我们的意思是说知识仍然包含着某种与这些观念之和有质的区别的东西。</p>
<p>洛克很有可能是第二种立场。</p>
</li>
</ul>
</li>
<li><p>政治理论</p>
<p><strong>概括：</strong> 洛克的政治理论延续了霍布斯的传统，从自然状态开始，通过社会契约来维护政府的合法性。</p>
<p><strong>背景</strong></p>
<p>洛克是资本主义这样一个时期中的自由主义的思想代表，在这个时期，市民阶级不需要一个绝对君主（霍布斯）来约束贵族，统一民族国家，而希望废除绝对君主制、直接支配政府。</p>
<p>洛克思想的前提：1. 资源足够每个人所用，私人财产是个人劳动的结果。2. 当人们在谈论人民，<strong>谈论个人的时候，他们所指的一般是中产阶级或贵族。</strong> </p>
<p><strong>内容</strong></p>
<p>洛克的自然状态：洛克的自然状态不同于霍布斯的自然状态（比霍布斯的自然状态要发达），在这里每个人都是平等与自由的，这意味着我们自由地支配着我们自己的身体和我们用我们身体所取得地任何东西。洛克区分了社会和国家，社会是一种自发地有规律地运作，国家则是一种政治安排。在洛克的自然状态中，人们已经订立了一种引进货币的「默许和自愿的同一」，已经产生了土地的不公平分配，人们可以用货币，正当的取得东西，不再有自然的限度。</p>
<p>有两个理由让我们离开这种自然状态：1.每个人都确保对声明感兴趣。2.拥有财产的人确保对这种财产感兴趣，因此每个人都对这样一种社会契约感兴趣。</p>
<p>由此，在人们签订的社会契约下，产生了国家。对洛克来说，</p>
<blockquote>
<ol>
<li>国家首先确保私有财产。</li>
<li>洛克支持这样一种经济制度，国家保护私有财产，对其他国家实行贸易保护主义政策，但不对贸易和产业实行监督和控制。</li>
<li>洛克反对专制主义，认为主权在共同体的公民那里，既然公民们已经批准了社会契约，他们就必须接受多数人的意志。</li>
<li>洛克关心限制统治者的权利，支持政府中的权力分立原则。</li>
</ol>
</blockquote>
<p><strong>关于经济不平等</strong></p>
<p>洛克认为，在人们签订社会契约之前，人们已经订立了一种引进货币的「默许和自愿的同意」，经济不平等就已经出现了，这时候政治意义上的社会还没有建立，人们仍处在自然状态。没有理由因为随着货币的引入而产生的物质不平等去责怪政治意义上的社会。即，对于经济不平等，洛克归结为由于大众自由地达成的一个自愿的同意。</p>
</li>
</ul>
<h2 id="贝克莱"><a href="#贝克莱" class="headerlink" title="贝克莱"></a>贝克莱</h2><ul>
<li><p>贝克莱从经验主义的认识论出发，拒绝了物质是某种不同于性质的东西的观点，即洛克的第一性质和第二性质都是依赖感知他们的主体，这样贝克莱把通常的物质观诠释为诸多感觉印象的一种集合，当我们谈论实在时，我们谈论的是不依赖我们意志出现的感觉印象。</p>
</li>
<li><p>「存在」就是「被感知」：不可能被感知的就不存在，某物存在就是某物可能被感知。</p>
</li>
<li><p>引入上帝，到达有神论：贝克莱不认为存在依赖于我们的感觉印象，他认为存在就是被感知这个原则，预设了有某人在感知着，这个某人就是上帝。上帝确保了经验的规则性、有序性，事件之间的必然联系的根源在于上帝。</p>
<p>上帝在贝克莱这里起的作用，大致相当于物质在洛克那里起的作用，以及物自体在康德那里起的作用。</p>
</li>
<li><p>评价（希尔贝克）：贝克莱从经验主义的认识论出发，达到了一种关于存在之形式的二元论，意识和印象，理解者和被理解者。</p>
<p>贝克莱从概念唯名论出发拒绝了哲学的物质观念，像马和人类这样的词是作为简略语，但不意味着像马和房子这样的普遍概念存在着。</p>
<p>（所以什么是「存在着」呢？）</p>
</li>
</ul>
<h2 id="休谟"><a href="#休谟" class="headerlink" title="休谟"></a>休谟</h2><ul>
<li><p>认识论：彻底的/激进的经验主义立场</p>
<p>关于知识的起源：休谟在印象和观念之间做出了区分，印象包括外在知觉和内在知觉，观念被视作建立在这些印象之上的心灵图像。</p>
<p>休谟认为存在两种知识：</p>
<ol>
<li>逻辑知识，它涉及的是概念之间的关系，它们是「分析的」</li>
<li>经验知识，它的基础是简单地感觉印象。它们是「综合的」</li>
</ol>
<p>休谟认为关键的是，观念有没有正当的「谱系」，即有没有可能把观念回溯到印象</p>
</li>
<li><p>对物质实体、精神实体、因果性的批判</p>
<p>对于物质实体，我们把稳定的印象群成为实体，我们对这些性质群「背后」所存在的任何基础性的物质实体是没有经验的，因此，休谟认为物质实体的观念是一种站不住脚的形而上学的观念。</p>
<p>对于精神实体，我们能把握的仅仅是内部印象，这些印象常常以确定的、比较稳定的方式成群出现。因此我们谈论一个处在「背后」，并将这些内在印象连接在一起的自我，实际上只是一种形而上学的幻觉。</p>
<p>对于因果性，休谟认为，原因的概念具有以下特征1. 相继性2. 接触性 3.必然性，我们能经验到原因的相继性和接触性，但我们通过经验无法保证原因的必然性。</p>
</li>
<li><p>休谟并没有说在原因和结果之间没有必然联系，他只是说我们不可能知道这样一种必然性。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟内存视角下的Linux进程 &amp; 动态内存分配 - CS:APP 第九章</title>
    <url>/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="虚拟内存视角下的Linux进程-amp-动态内存分配"><a href="#虚拟内存视角下的Linux进程-amp-动态内存分配" class="headerlink" title="虚拟内存视角下的Linux进程 &amp; 动态内存分配"></a>虚拟内存视角下的Linux进程 &amp; 动态内存分配</h1><h2 id="Linux的虚拟内存系统"><a href="#Linux的虚拟内存系统" class="headerlink" title="Linux的虚拟内存系统"></a>Linux的虚拟内存系统</h2><p>Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分：</p>
<ul>
<li>进程虚拟内存部分</li>
<li>内核虚拟内存部分</li>
</ul>
<p>进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>用户栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rsp →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>共享库的内存映射区域</td>
</tr>
<tr>
<td>brk →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>运行时的堆（通过malloc分配的）</td>
</tr>
<tr>
<td></td>
<td>未初始化的数据(.bss)</td>
</tr>
<tr>
<td></td>
<td>已初始化的数据(.data)</td>
</tr>
<tr>
<td>0x400000 →</td>
<td>代码(.text)</td>
</tr>
</tbody>
</table>
</div>
<p>内核虚拟内存可分为两部分：</p>
<ul>
<li>内核中的代码和数据及数据结构</li>
<li>被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>与进程相关的数据结构（页表、task和mm结构、内核栈）</th>
<th>每个进程都不相同</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理内存</td>
<td>每个进程都相同</td>
</tr>
<tr>
<td>内核代码和数据</td>
<td>每个进程都相同</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171118039.png" alt="image-20220917111815524"></p>
<h2 id="Linux如何组织虚拟内存"><a href="#Linux如何组织虚拟内存" class="headerlink" title="Linux如何组织虚拟内存"></a>Linux如何组织虚拟内存</h2><p>Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段</p>
<p>这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap）</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171117123.png" alt="image-20220917111745313"></p>
<h2 id="用户级内存映射"><a href="#用户级内存映射" class="headerlink" title="用户级内存映射"></a>用户级内存映射</h2><p>Linux 可以使用<code>mmap</code>函数来创建新的虚拟内存，并将对象映射到这些区域中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prot:</span></span><br><span class="line"><span class="comment">PROT_EXEC  该页面的区域可以被执行</span></span><br><span class="line"><span class="comment">PROT_READ  该页面区域可读</span></span><br><span class="line"><span class="comment">PROT_WRITE  ... 可写</span></span><br><span class="line"><span class="comment">PROT_NONE  ... 不能被访问</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">flags:</span></span><br><span class="line"><span class="comment">MAP_ANON    被映射的对象是一个匿名对象</span></span><br><span class="line"><span class="comment">MAP_PRIVATE    是一个私有对象，使用写时复制机制</span></span><br><span class="line"><span class="comment">MAP_SHARE    是一个共享对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">// 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误</span></span><br></pre></td></tr></table></figure>
<p>例子：将任意磁盘文件赋值到<code>stdout</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmapcopy</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bufp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load to virtual memory</span></span><br><span class="line">    bufp = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    Write(STDOUT_FILENO, bufp, size);   <span class="comment">// write to stdout</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open file </span></span><br><span class="line">    fd = Open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    fstat(fd, &amp;stat);   <span class="comment">// get detailed message of file</span></span><br><span class="line">    mmapcopy(fd, stat.st_size);     <span class="comment">// call mmapcopy</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理部分笔记</title>
    <url>/2023/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h2><p><strong>☆海明码是什么？</strong></p>
<blockquote>
<p>海明码是一种可以对数据校验，并至多可以校正一位出错的校验方法。</p>
<p>海明码有以下特点：</p>
<ul>
<li>海明码使用多重奇偶校验</li>
<li>海明码可以校正一位出错，并且可以指出出错的位置。</li>
<li>即使，校验位出错，对海明码的校验也没有影响。</li>
<li>海明码的校验位长度有规定。</li>
</ul>
</blockquote>
<p>海明码有n位数据和k位校验码组成n+k位，即p = n + k。海明码可生成k位的指示码$G_kG_{k-1}…G_1$ </p>
<p><strong>☆ 海明码的生成：</strong> </p>
<p>假如有4个要传输的数据位，即n=4。</p>
<p>海明码的校验位数k与数据位数n需满足：$2^k\ge n+1$（稍后解释） ，因此k取3。</p>
<p>于是我们有4位数据位，3位校验位，共七位。将3位校验位放到第2^i-1^ （i=1,2,3,…）位置上，数据位放到校验位的空隙中。如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>待定</td>
<td>待定</td>
<td>1</td>
<td>待定</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>接着计算校验位 k1, k2, k3</p>
<p>根据使用的校验方式不同，选择不同的校验方式（奇校验 / 偶校验），以偶校验为例：</p>
<p>$k_1=p_3\oplus p_5\oplus p_7=0$ </p>
<p>$k_2=p_3\oplus p_6\oplus p_7=1$</p>
<p>$k_1=p_5\oplus p_6\oplus p_7=0$ </p>
<p>这样我们得到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>k~1~ (001) 是 3 (011), 5 (101), 7 (111) 的偶校验位</p>
<p>k~2~ (010)是 3 (011), 6 (110), 7 (111) 的偶校验位</p>
<p>k~3~ (100) 是 5 (101), 6 (110), 7 (111) 的偶校验位</p>
<p>每个校验位的生成方法可归纳如下：首先校验位和数据位的索引变化成二进制形式，因为校验位只出现在2^i-1^ （i=1,2,3）的位置，因此校验位索引的二进制形式只有一个位置是1。对于其他的数据位，如果其索引的二进制形式的某个位置为1，且这个位置与某个校验位索引为1的位置相同，那么这个数据位就要参与这个校验位的生成。</p>
<p><strong>☆ 海明码的检验与校正：</strong> </p>
<p>当我们收到一个带海明校验的数据，我们对所有的校验位进行校验，并将得到的结果作为指示位$G_kG_{k-1…G_1}$。</p>
<p>对于上面的例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引（从1开始）</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位/校验位(k表示校验位，n表示数据位)</td>
<td>k1</td>
<td>k2</td>
<td>n1</td>
<td>k3</td>
<td>n2</td>
<td>n3</td>
<td>n4</td>
</tr>
<tr>
<td>实际数据</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>$G_1 = k_1\oplus p_3\oplus p_5\oplus p_7=0$</p>
<p>$G_2 = k_2\oplus p_3\oplus p_6\oplus p_7=0$</p>
<p> $G_3 = k_3\oplus p_5\oplus p_6\oplus p_7=0$ </p>
<p>由于$G_3 G_2 G_1=000$ ，因此数据无误。</p>
<p>若第六位出错，$G_3 G_2 G_1=110$ 刚好指出了错误的位置，我们只要将第六位取反即可纠正。</p>
<p><strong>☆ 海明码的原理^[1]^：</strong> </p>
<ul>
<li><p>海明码由n位数据位和k位校验位组成，校验位可以指出数据出现错误的地方。</p>
<p>k位校验位可以表示 2^k^ 中状态，因此若要能指出每一位可能发生错误的地方，2^k^ &gt;= n</p>
<p>又因为，校验位必须还可以表示数据没有出错的情况，因此校验位还要多出一个状态。</p>
<p>综上，校验位数k和海明码数n需满足 2^k^ &gt;= n+1</p>
</li>
<li><p>海明码是如何分布的，为什么是这样分布的？</p>
<p>海明校验码的k个校验位$k_1,k_2,…k_i,…,k_n$ 的第i位（i = 1, 2, …, n）分别分布在第2^i-1^ 位上。</p>
<p>这是因为，当k = 3时，有一位校验位传输出错的话，则校验位与数据为进行奇偶校验的结果有3中，001，010，100，如果想要处理这种情况，只要令校验位位于001，010，100的位置就可以了。</p>
</li>
<li><p>海明码如何能指出错误的位置，为什么？</p>
<p>对于一个三位校验指示码$G_3G_2G_1$ ，</p>
<p>| 1    | 2    | 3    | 4    | 5    | 6    | 7    |<br>| —— | —— | —— | —— | —— | —— | —— |<br>| k1   | k2   | n1   | k3   | n2   | n3   | n4   |</p>
<p>G1等于1意味着001，011，111，101，必然有一个出错，因此$G_1=p_1\oplus p_3\oplus p_5\oplus p_7$ 。</p>
<p>同理，G2等于1意味着010，011，110，111，必有一个出错 ，即$G_2=p_2\oplus p_3\oplus p_6\oplus p_7$ </p>
<p>$G_3=p_4\oplus p_5\oplus p_6\oplus p_7$ </p>
<p>因此当n1出错时，G1=1,G2=1,G3=0，即011B = 3D，可以指出错误的位。</p>
<p>（参考文献 1 解释得更加详细！）</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 海明校验码是怎么实现的？: <a href="https://www.zhihu.com/question/29169628/answer/837787585">https://www.zhihu.com/question/29169628/answer/837787585</a> (这个讲得很好，循序渐进)</p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
  </entry>
  <entry>
    <title>配置博客</title>
    <url>/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="博客配置-amp-使用教程"><a href="#博客配置-amp-使用教程" class="headerlink" title="博客配置 &amp; 使用教程"></a>博客配置 &amp; 使用教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。</p>
<p>本文章记录了配置博客和使用博客的一些细节，供以后的我参考。</p>
<p>持续更新中 ……</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><p>调试：</p>
<p><code>hexo server --debug</code> 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面</p>
</li>
</ul>
<ul>
<li><p>修改/发布博客 进行更新：</p>
<p><code>hexo clean</code> 清理缓存和public文件夹</p>
<p><code>hexo g</code> generate，生成静态页面，该操作之后即可在本地预览。</p>
<p><code>hexo d</code>  deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。</p>
</li>
</ul>
<ul>
<li><p>发布博客</p>
<p><code>hexo new [layout] [title]</code> 使用layout，在_post/title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。</p>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>可以在 <code>_config.yml</code> 里配置Hexo，在 <code>_config.nexmoe.yml</code> 里配置nexmoe主题。</li>
</ul>
<p><strong>_config.yml :</strong></p>
<ol>
<li><p>配置 网站的标题、副标题、关键词、作者、语言、时区<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208211114450.png" alt="image-20220821111147069"> </p>
</li>
<li><p>部署设置，其中repository可以填ssh的链接（执行<code>git clone</code> 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。<img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208211114595.png" alt="image-20220821111400429"> </p>
</li>
</ol>
<p><strong>_config.nexmoe.yml：</strong></p>
<ol>
<li>网站的默认头图，头像，图标等均在这里配置。</li>
<li>如果要使用本地相对路径，<code>./</code> 的绝对路径即博客根目录下的source文件夹。</li>
</ol>
<h2 id="front-matter"><a href="#front-matter" class="headerlink" title="front-matter"></a>front-matter</h2><p>在这里可以配置文件的变量。</p>
<p>hexo 的文档：<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter | Hexo</a></p>
<p>nexmoe 的私有 front-matter 文档：<a href="https://docs.nexmoe.com/v3.2/article/front-matter.html">Front-matter | Hexo Theme Nexmoe</a> </p>
<ol>
<li><p>如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">--</span><br><span class="line">title: <span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span></span><br><span class="line">others...</span><br><span class="line"></span><br><span class="line"><span class="section">cover: 图片链接</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置分类和标签要像这样配置：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="bullet">-</span> Games</span><br></pre></td></tr></table></figure>
<p>其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见<a href="https://hexo.io/zh-cn/docs/front-matter#分类和标签">这里</a> </p>
</li>
</ol>
<h2 id="widgets"><a href="#widgets" class="headerlink" title="widgets"></a>widgets</h2><ol>
<li>关于 “文件归档”：<a href="https://docs.nexmoe.com/v3.2/article/archive.html">归档页面 | Hexo Theme Nexmoe</a> </li>
<li>关于 “关于博客”：是<code>./</code> 目录下的一个markdown文件，与其他博文相同。</li>
<li>其他部件可以在<code>_config.nexmoe.yml</code> 里配置</li>
</ol>
<h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 <a href="https://valine.js.org/">Valine</a> ，使用方法非常简单，按照Valine的官方手册一步步操作即可。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">iconfont-阿里巴巴矢量图标库</a> </p>
<h2 id="使用mathjax渲染inline-latex"><a href="#使用mathjax渲染inline-latex" class="headerlink" title="使用mathjax渲染inline latex"></a>使用mathjax渲染inline latex</h2><p><a href="https://blog.csdn.net/weixin_43318626/article/details/89407031">(1条消息) 在HEXO博客中使用LaTeX公式的简单方法_Loy_Fan的博客-CSDN博客</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo参考文档</a> </p>
<p><a href="https://docs.nexmoe.com/v3.2/">Nexmoe 参考文档</a> </p>
<p><a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe">nexmoe GitHub地址</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a> </p>
<p><a href="https://benn314.github.io/2022/11/22/Hexo-Next主题配置教程/">Hexo-Next主题配置教程 | Ben’s Blog (benn314.github.io)</a> （2023/3/23添加）</p>
]]></content>
      <categories>
        <category>使用教程</category>
      </categories>
  </entry>
  <entry>
    <title>链接 - CS:APP 第七章</title>
    <url>/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>本文将介绍：</p>
<ul>
<li>编译的过程</li>
<li>三种目标文件</li>
<li>三种链接和链接的过程</li>
</ul>
<h2 id="1-编译的过程"><a href="#1-编译的过程" class="headerlink" title="1 编译的过程"></a>1 编译的过程</h2><ol>
<li><p>源文件（.c /.cpp）经过翻译，形成可重定位目标文件（.o）</p>
<p>具体过程：</p>
<p>预处理</p>
<p><code>cpp main.c -o main.i</code> 或 <code>gcc -E -o main.c main.c</code> </p>
<p>编译器 ：翻译成汇编语言</p>
<p><code>cc1 或 cc main.i -o main.s</code> 或 <code>gcc -S -o main.s main.c</code></p>
<p>汇编器 ：形成可重定位目标文件</p>
<p><code>as [args] -o main.o</code> 这中间参数很多，</p>
<p>如果向直接到这一步可以使用 <code>gcc -c -o main.o main.c</code> </p>
</li>
<li><p>链接器 链接形成可执行目标文件</p>
<p><code>ld -o prog main.o other.o</code> 或 <code>gcc -o prog main.o other.o</code> </p>
</li>
</ol>
<p>如果想要一步一步生成<code>.i</code> <code>.s</code> <code>.o</code> 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。</p>
<p>除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 <code>-E</code> <code>-S</code> <code>-c</code> 参数进行编译。</p>
<blockquote>
<p>顺带一提，在bash中，可以通过 <code>echo $?</code> 来展示上一次程序退出的返回值</p>
</blockquote>
<h2 id="2-三种目标文件"><a href="#2-三种目标文件" class="headerlink" title="2 三种目标文件"></a>2 三种目标文件</h2><p>首先，什么是目标文件？</p>
<blockquote>
<p>计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。</p>
<p>——360百科</p>
</blockquote>
<p>目标文件可以分为三类：</p>
<ol>
<li>可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。</li>
<li>可执行目标文件 ： 可以被复制到内存中执行。</li>
<li>共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接</li>
</ol>
<p>window系统使用<code>PE portable Executable</code> 格式</p>
<p>Linux使用 <code>Executable and Linkable Format, ELF</code>格式  </p>
<h3 id="2-1-可重定位目标文件格式"><a href="#2-1-可重定位目标文件格式" class="headerlink" title="2.1 可重定位目标文件格式"></a>2.1 可重定位目标文件格式</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209091204533.png" alt="image-20220909120357886"> </p>
<p>可重定位目标文件 以ELF头开始，通过<code>readelf -a main.o</code> 我们可以看到ELF头的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              <span class="number">2</span> 补码，小端序 (little endian)</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          <span class="number">0</span></span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  版本:                              <span class="number">0x1</span></span><br><span class="line">  入口点地址：               <span class="number">0x0</span></span><br><span class="line">  程序头起点：          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  标志：             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">13</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。</p>
<p>我倾向于认为这是节头部表的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000025</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">00000358</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000068</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000000</span>c  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.gnu.propert NOTE             <span class="number">0000000000000000</span>  <span class="number">000000</span>a8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">8</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>c8</span><br><span class="line">       <span class="number">0000000000000038</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000388</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">00000000000001</span>c8  <span class="number">0000000000000018</span>          <span class="number">11</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000002</span>c8</span><br><span class="line">       <span class="number">0000000000000090</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">12</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000003</span>a0</span><br><span class="line">       <span class="number">000000000000006</span>c  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。</p>
<p>一个典型的ELF可重定位目标文件包含下面的节：</p>
<p><code>.text</code> : 已编译的机器代码</p>
<p><code>.rodata</code> : read only data 只读数据，如printf的格式字符串</p>
<p><code>.data</code> : 已初始化的全局和静态变量</p>
<p><code>.bss</code> : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节）</p>
<p><code>.symtab</code> ：符号表</p>
<p><code>rel.text</code> ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量</p>
<p><code>.rel.data</code></p>
<p><code>.debug</code> ：调试信息</p>
<p><code>.line</code> ：调试时的行号</p>
<p><code>strtab</code> ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字</p>
<h4 id="2-1-1-符号表"><a href="#2-1-1-符号表" class="headerlink" title="2.1.1 符号表"></a>2.1.1 符号表</h4><p>符号表的条目格式是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;    <span class="comment">// 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>,  <span class="comment">// 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ...</span></span><br><span class="line">       binding:<span class="number">4</span>;	<span class="comment">// 全局变量还是本地变量 GLOBAL OR LOCAL</span></span><br><span class="line">    <span class="type">char</span> reserved;  <span class="comment">// 保留的，未使用</span></span><br><span class="line">    <span class="type">short</span> section;  <span class="comment">// 在ubuntu 上的名字是Ndx,指明该符号是在那个section的</span></span><br><span class="line">    <span class="type">long</span> value;    <span class="comment">// 距离节section 起始位置的字节偏移</span></span><br><span class="line">    <span class="type">long</span> size;    <span class="comment">// 该符号最小的大小</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure>
<p>对于section 字段，在<code>ubuntu</code> 的<code>readelf</code> 命令中，显示为 Ndx。</p>
<p>该字段有三个伪节，他们分别是 <code>UNDEF</code> <code>COMMON</code> <code>ABS</code> 。</p>
<p><code>ABS</code> ：代表不改被重定位的符号</p>
<p><code>UNDEF</code> ：代表未定义的符号，即在本模块引用却在其他模块定义的符号</p>
<p><code>COMMON</code> ：还未被分配位置的未初始化的数据目标</p>
<p><code>COMMON</code> 和 <code>.bss</code> 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到<code>COMMON</code> 和<code>.bss</code></p>
<p><code>COMMON</code> ：未初始化的全局变量</p>
<p><code>.bss</code> ：未初始化的静态变量，以及初始化为0的全局或静态变量</p>
<p>下面我们通过一个程序来展示以下ubuntu 中的符号表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_not_init;</span><br><span class="line"><span class="type">int</span> global_init = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> global_init_zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_not_init;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init_zero = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们生成可重定位的目标文件<code>gcc -c main.c</code> </p>
<p>接着使用<code>readelf -a main.o</code> 读取elf，即可查看符号表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.c</span><br><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.o</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x0</span><br><span class="line">  程序头起点：          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1040 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000025  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000358</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000068</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000078</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000078</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  000000a8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000388</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000100</span><br><span class="line">       00000000000001c8  0000000000000018          11    12     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  000002c8</span><br><span class="line">       0000000000000090  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  000003a0</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in this file.</span><br><span class="line"></span><br><span class="line">本文件中没有程序头。</span><br><span class="line"></span><br><span class="line">There is no dynamic section in this file.</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000014  000c00000002 R_X86_64_PC32     0000000000000000 array - 4</span><br><span class="line">000000000019  001200000004 R_X86_64_PLT32    0000000000000000 sum - 4</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class="line"></span><br><span class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 19 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    3 stat_init.1921</span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">     7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">    12: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_not_init</span><br><span class="line">    14: 0000000000000008     4 OBJECT  GLOBAL DEFAULT    3 global_init</span><br><span class="line">    15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">    16: 0000000000000000    37 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    18: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum</span><br><span class="line"></span><br><span class="line">No version information found in this file.</span><br><span class="line"></span><br><span class="line">Displaying notes found in: .note.gnu.property</span><br><span class="line">  所有者            Data size   Description</span><br><span class="line">  GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0</span><br><span class="line">      Properties: x86 feature: IBT, SHSTK</span><br></pre></td></tr></table></figure>
<p>符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量<code>global_not_init</code> 在COMMON 伪节，已经初始化了的全局变量<code>global_init</code>和静态变量<code>stat_init</code>都在<code>.data</code> 节，而初始化为0的全局变量<code>global_init_zero</code> 和没有初始化的静态变量<code>stat_not_init</code> 和初始化为0的静态变量<code>stat_init_zero</code> 在<code>.bss</code> 节</p>
<p>根据这三行的<code>value</code> 字段我们还可以看到这三个变量在<code>.bss</code> 节的存储顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">   7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br></pre></td></tr></table></figure>
<p>另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_init_zero<span class="number">.1920</span></span><br><span class="line">   <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_not_init<span class="number">.1919</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意观察两个静态变量多了两个后辍</p>
</blockquote>
<p>这样做其实是为了区分在同一个模块中同名的两个静态变量</p>
<p>如下面程序的这个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。</p>
<h3 id="2-2-可执行目标文件格式"><a href="#2-2-可执行目标文件格式" class="headerlink" title="2.2 可执行目标文件格式"></a>2.2 可执行目标文件格式</h3><p>下面是典型的ELF 可执行目标文件</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220910192419982.png" alt="image-20220910192419982"></p>
<p>在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过<code>readelf</code> 来看一下这个段头部表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span></span><br><span class="line">               <span class="number">0x0000000000000498</span> <span class="number">0x0000000000000498</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000401000</span> <span class="number">0x0000000000401000</span></span><br><span class="line">               <span class="number">0x0000000000000205</span> <span class="number">0x0000000000000205</span>  R E    <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000402000</span> <span class="number">0x0000000000402000</span></span><br><span class="line">               <span class="number">0x0000000000000120</span> <span class="number">0x0000000000000120</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002e50</span> <span class="number">0x0000000000403e50</span> <span class="number">0x0000000000403e50</span></span><br><span class="line">               <span class="number">0x00000000000001e0</span> <span class="number">0x00000000000001e8</span>  RW     <span class="number">0x1000</span> </span><br></pre></td></tr></table></figure>
<p> 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。</p>
<blockquote>
<p>ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。</p>
</blockquote>
<p>加载可执行文件：</p>
<p>在shell中输入 <code>./prog</code> 后：</p>
<ol>
<li>shell调用fork() 函数，创建子进程</li>
<li>子进程调用execve()，execve调用加载器，加载prog程序</li>
<li>加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址)</li>
<li>_start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数</li>
</ol>
<h3 id="2-3-可共享目标文件格式"><a href="#2-3-可共享目标文件格式" class="headerlink" title="2.3 可共享目标文件格式"></a>2.3 可共享目标文件格式</h3><h2 id="3-三种链接和链接的过程"><a href="#3-三种链接和链接的过程" class="headerlink" title="3 三种链接和链接的过程"></a>3 三种链接和链接的过程</h2><p>三种链接：</p>
<ol>
<li>静态链接</li>
<li>动态链接库</li>
<li>程序运行时链接共享库</li>
</ol>
<h3 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1 静态链接"></a>3.1 静态链接</h3><p>静态链接的两个过程</p>
<ol>
<li>符号解析</li>
<li>重定位</li>
</ol>
<h4 id="3-1-1-符号解析"><a href="#3-1-1-符号解析" class="headerlink" title="3.1.1 符号解析"></a>3.1.1 符号解析</h4><p>链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p>
<p>对于局部符号，它不会出现在符号表中。</p>
<p>对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。</p>
<p>唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。</p>
<p>对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。</p>
<p>而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。</p>
<p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量 (在COMMON伪节)</p>
<p>接着使用以下规则来处理这些符号：</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果一个强符号与多个弱符号同名，选择强符号</li>
<li>若有多个弱符号同名，从这些弱符号中任选一个。</li>
</ol>
<blockquote>
<p>这三个规则很容易造成一些不易察觉的运行时错误。</p>
<p>为什么会有.COMMON伪节？</p>
<p>如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。</p>
<p>而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节</p>
</blockquote>
<p>以上讲的是几个.o 文件的链接，他们都是<code>目标文件</code> </p>
<p>接下来我们讲与静态库的链接，其中会有<code>存档文件</code> 这个概念，注意区别</p>
<blockquote>
<p>静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是  .a</p>
<p>在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。</p>
</blockquote>
<p>生成静态库：</p>
<p>首先编译：<code>gcc -c addvec.c multvec.c</code></p>
<p>接着生成静态库：<code>ar rcs libvector.a addvec.o multvec.o</code> </p>
<p>得到静态库 <code>libvector.a</code>，存档文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101743742.png" alt="image-20220910174348618"> </p>
<p>(重要) 链接器如何使用静态库来解析引用：</p>
<blockquote>
<p>链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。</p>
<ul>
<li>对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。</li>
<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义<br>的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m<br>加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成<br>员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E<br>中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。</li>
<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错<br>误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>
</ul>
</blockquote>
<p>注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。</p>
<p>因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。</p>
<p>但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的</p>
<p>如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B</p>
<p>假如有这样的依赖关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101815751.png" alt="image-20220910181532038"></p>
<p>我们要写成<code>gcc A.o B.a C.a B.a -o prog</code>  因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。</p>
<h4 id="3-1-2-重定位"><a href="#3-1-2-重定位" class="headerlink" title="3.1.2 重定位"></a>3.1.2 重定位</h4><p>《深入理解计算机系统》原书第三版 P 478 7.7</p>
<h3 id="3-2-动态链接库"><a href="#3-2-动态链接库" class="headerlink" title="3.2 动态链接库"></a>3.2 动态链接库</h3><p>静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。</p>
<p>所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。</p>
<p>创建动态库 <code>gcc -shared -fpic -o libvector.so addvec.c multvec.c</code> </p>
<p>与动态库链接：</p>
<p><code>gcc -o prog main.c ./libvector.so</code></p>
<p>与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。</p>
<p>下面是动态链接库的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209112059039.png" alt="image-20220911205952800"> </p>
<blockquote>
<p>一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章)</p>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到 <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
</blockquote>
<h3 id="3-3-程序运行时链接共享库"><a href="#3-3-程序运行时链接共享库" class="headerlink" title="3.3 程序运行时链接共享库"></a>3.3 程序运行时链接共享库</h3><p>可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7.11 load and link shared library from an application</span></span><br><span class="line"><span class="comment">// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * handle;  <span class="comment">// shared lib handle</span></span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">void</span> (*multvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">char</span> * error;   <span class="comment">// point to error massages string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load shared library</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search the symbol &quot;multvec&quot; from the shared library</span></span><br><span class="line">    multvec = dlsym(handle, <span class="string">&quot;multvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = (dlerror())) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute the function</span></span><br><span class="line">    multvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unload the shared library</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="名词索引"><a href="#名词索引" class="headerlink" title="名词索引"></a>名词索引</h2><p>ELF-64 目标文件格式</p>
<p>PIC(Position-Independent Code) 位置无关代码</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
  </entry>
</search>
