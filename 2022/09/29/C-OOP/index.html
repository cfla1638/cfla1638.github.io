<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>C++ OOP - cfla&#39;s blog</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/icon.png" type="image/png" />
    <meta name="description" content="C++ OOPC++ 的类this 指针调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。 在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用 this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。 常量成员函数即使this指针是隐式的，但初始化this指针也要遵循初始化规">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ OOP">
<meta property="og:url" content="https://cfla1638.github.io/2022/09/29/C-OOP/index.html">
<meta property="og:site_name" content="cfla&#39;s blog">
<meta property="og:description" content="C++ OOPC++ 的类this 指针调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。 在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用 this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。 常量成员函数即使this指针是隐式的，但初始化this指针也要遵循初始化规">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-29T07:48:03.000Z">
<meta property="article:modified_time" content="2022-10-08T08:47:52.272Z">
<meta property="article:author" content="cfla">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/justifiedGallery/justifiedGallery.min.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1671460338218">
    
    <link rel="stylesheet" href="/css/style.css?v=1671460338218">
    
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/cfla1638/Img/202208202227586.png)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="cfla" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208202220895.jpg" alt="cfla"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="cfla">
            <img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202208202220895.jpg" alt="cfla" alt="cfla">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>22</div>
        <div><span>标签</span>5</div>
        <div><span>分类</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/Archives.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CS-APP/">CS:APP</a>
          <span class="category-list-count">8</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/使用教程/">使用教程</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/大学课程/">大学课程</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/文章收藏/">文章收藏</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/琐碎记录/">琐碎记录</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/项目/">项目</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/" style="font-size: 10px;">读后感</a>
    </div>
    
  </div>

    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">22</span></li></ul>
    </div>
  </div>



    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2022/12/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%AF%E8%92%99%E8%BF%90%E5%8A%A8/">什么是启蒙运动？</a>
          </li>
        
          <li>
            <a href="/2022/12/17/placement-new/">placement new</a>
          </li>
        
          <li>
            <a href="/2022/11/14/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEcmake/">在vscode配置cmake</a>
          </li>
        
          <li>
            <a href="/2022/10/22/cmake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">cmake学习之路</a>
          </li>
        
          <li>
            <a href="/2022/10/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-C/">模板与泛型编程 - C++</a>
          </li>
        
      </ul>
    </div>
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 cfla
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: NaN%;"> 
              <img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209291550710.jpg" alt="C++ OOP" loading="lazy">
              <h1>C++ OOP</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年09月29日</a>
</div>

      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    
        <a><i class="nexmoefont icon-areachart"></i>约5.7k字</a>
        <a><i class="nexmoefont icon-time-circle-fill"></i>预计需要20分钟</a>
    
</div>

      <h1 id="C-OOP"><a href="#C-OOP" class="headerlink" title="C++ OOP"></a>C++ OOP</h1><h2 id="C-的类"><a href="#C-的类" class="headerlink" title="C++ 的类"></a>C++ 的类</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。</p>
<p>在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用</p>
<p><strong>this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。</strong></p>
<h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层<code>const</code>的的this指针。</p>
<p>由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。</p>
<p>为了解决这个问题，我们可以将成员函数声明成<code>const</code> </p>
<p>例如，像下面这样，在参数列表后添加上<code>const</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_a</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;;<br>    <br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，这个this指针，既是顶层<code>const</code> (this指针所固有的属性)，又是底层<code>const</code> （我们声明的结果）</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>P241, P250，P545</p>
</blockquote>
<p>想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部</p>
<p>由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置</p>
<p>可以将一个类声明成另一个类的友元</p>
<blockquote>
<p> 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员</p>
</blockquote>
<p>可以将一个类的成员函数声明成另一个类的友元函数</p>
<p>友元声明是单向的，友元声明不具有传递性</p>
<p>关于友元的作用域：P252</p>
<p>友元关系是不能继承的</p>
<ul>
<li>基类的友元在访问派生类时没有特殊性。</li>
<li>派生类的友元也不能访问基类的私有成员</li>
</ul>
<h3 id="类的类型成员"><a href="#类的类型成员" class="headerlink" title="类的类型成员"></a>类的类型成员</h3><p>类的成员不只可以有变量和函数，还可以有类型</p>
<p>类内定义的类型也有访问权限的限制</p>
<p>用来定义类型的成员必须先定义再使用</p>
<blockquote>
<p>原因：&#x2F;&#x2F; TODO</p>
</blockquote>
<h3 id="类的内联函数"><a href="#类的内联函数" class="headerlink" title="类的内联函数"></a>类的内联函数</h3><blockquote>
<p>内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销</p>
<p>内联函数会在编译时，被编译器展开</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> string &amp; <span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>max(), min() 之类的函数特别适合被定义为内联函数</p>
</blockquote>
<ul>
<li>定义在类内部的成员函数，它们默认是内联函数</li>
<li>可以在类内声明时使用<code>inline</code>，同时在类外定义函数时也同时使用<code>inline</code> ，但最好是只在类外部定义函数时使用<code>inline</code> 声明。</li>
</ul>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><blockquote>
<p>from effective c++</p>
<p>编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为<code>mutable</code> </p>
</blockquote>
<p>如果在定义类的成员时，使用<code>mutable</code> 关键字，那么，即使这个对象被声明成<code>const</code> ，我们依然可以改变这个成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>     public:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<br>    private:<br>    mutable <span class="hljs-type">size_t</span> cnt;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">A::inc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><br>&#123;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="返回-this-左值"><a href="#返回-this-左值" class="headerlink" title="返回*this 左值"></a>返回*this 左值</h3><p>当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值</p>
<p>我们可以根据this指针是否具有底层<code>const</code> 来对函数进行重载</p>
<blockquote>
<p>底层const的重载见：P206</p>
<p>P247</p>
</blockquote>
<h3 id="类的前向声明"><a href="#类的前向声明" class="headerlink" title="类的前向声明"></a>类的前向声明</h3><p>可以使用类似这种形式声明类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br></code></pre></td></tr></table></figure>

<p>这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。</p>
<p>前向声明可以放在类的头文件中，从而减少依赖。</p>
<h3 id="类的名字查找"><a href="#类的名字查找" class="headerlink" title="类的名字查找"></a>类的名字查找</h3><ul>
<li><p>我们可以在成员函数的任意地方使用类的成员</p>
<blockquote>
<p>原因在于编译器如何处理类：</p>
<ol>
<li>编译所有的成员声明</li>
<li>编译函数体</li>
</ol>
</blockquote>
</li>
<li><p>如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。</p>
</li>
<li><p>在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用<code>typedef</code> 或使用<code>using symbol = type</code>）不能再类中重定义。</p>
</li>
<li><p>成员函数的名字查找规则</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在成员函数内查找名字（成员函数体定义的名字，形参的名字）<br><span class="hljs-bullet">2.</span> 在类作用域内查找名字<br><span class="hljs-bullet">3.</span> 在成员函数定义之前的作用域内继续查找<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。</p>
</li>
</ul>
<h3 id="类的隐式类型转换"><a href="#类的隐式类型转换" class="headerlink" title="类的隐式类型转换"></a>类的隐式类型转换</h3><blockquote>
<p>P263 隐式的类类型转换 P514 重载类型转换运算符</p>
</blockquote>
<ul>
<li><p>如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换</p>
<p>这种类型转换只允许一步类型转换</p>
</li>
<li><p>一直类的隐式类型转换：</p>
<p>使用关键字<code>explicit</code> </p>
<p>该关键字只能在类内声明中使用，不能在类外重复</p>
<p>该关键字只能用于接受一个值的构造函数前面</p>
</li>
</ul>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0</p>
<p>类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的</p>
<p>由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似</p>
<ul>
<li>在<code>.h</code> 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理</li>
<li>我们可以使用类的静态成员作为成员函数的默认实参</li>
</ul>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><blockquote>
<p>类的初始化、对象拷贝、移动、销毁</p>
<p>由以下六个函数决定：</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
<p>后五个称为类的拷贝控制操作</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>C++ Primer P235、P257、P551、P689</p>
</blockquote>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下</p>
<ol>
<li>如果存在类内的初始值，用它来初始化成员</li>
<li>否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数）</li>
</ol>
<p>如果出现以下情况，编译器无法为类构造合成的默认构造函数</p>
<ol>
<li><p>类有定义一个构造函数</p>
<blockquote>
<p>遇到这种情况，可以使用 <code>类名() = defalut</code> 来给予类一个默认的构造函数</p>
</blockquote>
</li>
<li><p>类存在一个成员，这个成员没有默认的构造函数</p>
</li>
</ol>
<h4 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">BookNo</span>(s) &#123;&#125;<br></code></pre></td></tr></table></figure>



<p>当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</p>
<p>（重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化</p>
<p>由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 没有默认构造函数</span><br>public:<br>    A(<span class="hljs-type">int</span> num) : elem(num) &#123;&#125;<br>private:<br>    <span class="hljs-type">int</span> elem = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    B(<span class="hljs-type">int</span> num) : elem_int(num) &#123;&#125;  <span class="hljs-comment">// 错误，因为A没有默认构造函数，所以必须对它进行列表初始化</span><br>private:<br>    A elem_A;<br>    <span class="hljs-type">int</span> elem_int;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。</p>
<p>（重要）列表初始化的初始化顺序</p>
<p>列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非委托构造函数要使用的构造函数</span><br>    <span class="hljs-built_in">Sales_data</span>(std::string s, <span class="hljs-type">unsigned</span> cnt, <span class="hljs-type">double</span> price) : <br>          <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt * price) &#123;&#125;<br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Sales_data</span>() : <span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::string s) : <span class="hljs-built_in">Sales_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::istream &amp;is) : <span class="hljs-built_in">Sales_data</span>() &#123;<span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体</p>
<h4 id="默认构造函数被调用的时机"><a href="#默认构造函数被调用的时机" class="headerlink" title="默认构造函数被调用的时机"></a>默认构造函数被调用的时机</h4><blockquote>
<p>C++ Primer P262</p>
</blockquote>
<p>默认初始化</p>
<ol>
<li>在块作用域内不适用任何初始值定义一个非静态变量</li>
<li>一个类类型本身含有类成员，并且使用合成的默认构造函数时</li>
<li>没有在列表初始化中被显示初始化时</li>
</ol>
<p>值初始化</p>
<ol>
<li>数组初始化时，提供的值小于数组的大小</li>
<li>不适用初始值定义一个局部静态变量</li>
<li>使用<code>T()</code> 这种表达式来显示请求值初始化</li>
</ol>
<h4 id="继承体系中的合成的默认构造函数"><a href="#继承体系中的合成的默认构造函数" class="headerlink" title="继承体系中的合成的默认构造函数"></a>继承体系中的合成的默认构造函数</h4><ul>
<li><p>派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。</p>
</li>
<li><p>继承直接基类的构造函数，使用<code>using</code> 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数</p>
</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。</p>
<blockquote>
<p>拷贝构造函数的形式通常是 <code>ClassType(const ClassType &amp;)</code> </p>
<p>拷贝构造函数通常不应该是explicit的</p>
</blockquote>
<h4 id="合成的拷贝构造函数"><a href="#合成的拷贝构造函数" class="headerlink" title="合成的拷贝构造函数"></a>合成的拷贝构造函数</h4><p>如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数</p>
<p>对于内置类型，合成的拷贝构造函数会直接拷贝</p>
<p>对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数</p>
<p>对于数组，合成的拷贝构造函数会逐个拷贝它的元素</p>
<blockquote>
<p> <strong>一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别：</strong></p>
<blockquote>
<p>几种初始化的区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38231713/article/details/106291397">https://blog.csdn.net/qq_38231713/article/details/106291397</a></p>
</blockquote>
<p> 默认初始化：对象可能产生未定义的值，出现场景：</p>
<ol>
<li>块作用域内不使用任何初始值定义一个非静态变量；</li>
<li>类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员</li>
</ol>
<ul>
<li>如果存在类内初始值，用它来初始化成员</li>
<li>否则，默认初始化该成员</li>
</ul>
<p> 值初始化：对象的值是确定（预设）的，出现场景：</p>
<ol>
<li><p>数组初始化时，初始值数量小于数组的长度。</p>
</li>
<li><p>不使用初始值定义一个静态变量（带有初始值0）</p>
</li>
<li><p>使用类似<code>classType()</code> 形式表达式显示请求值初始化</p>
</li>
<li><p>只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化</p>
</li>
</ol>
<p>   <code>vector&lt;int&gt; vec(10);</code> 值初始化为0 </p>
<p> 直接初始化：使用<code>classType()</code> 初始化对象</p>
<p> 拷贝初始化：使用<code>classType foo = classType()</code> 初始化对象</p>
<ul>
<li>不光在使用 &#x3D; 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化<ol>
<li>将参数作为实参传递给非引用类型的形参</li>
<li>从返回类型为非引用的函数返回一个对象</li>
<li>使用花括号列表初始化数组或聚合类</li>
<li>初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数）</li>
</ol>
</li>
</ul>
<p> <strong>二、不同的初始化方式会调用那种构造函数</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sksukai/article/details/104741675/">https://blog.csdn.net/sksukai/article/details/104741675/</a></p>
</blockquote>
<p> 当定义类时，会有直接初始化和拷贝初始化两种区别</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">foo var1;      <span class="hljs-comment">// 直接初始化，使用默认构造函数</span><br><span class="hljs-function">foo <span class="hljs-title">var2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">// 直接初始化，使用一个参数的构造函数</span><br>foo var3 = <span class="hljs-number">50</span>;    <span class="hljs-comment">// 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3</span><br>foo var4 = <span class="hljs-built_in">foo</span>(<span class="hljs-number">50</span>); <span class="hljs-comment">// 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数</span><br>foo var5 = var3;  <span class="hljs-comment">// 拷贝初始化，调用拷贝构造函数</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="继承体系中的拷贝构造函数"><a href="#继承体系中的拷贝构造函数" class="headerlink" title="继承体系中的拷贝构造函数"></a>继承体系中的拷贝构造函数</h4><p>我们需要使用基类的拷贝构造函数显示的初始化基类的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>    <span class="hljs-built_in">derived</span>(<span class="hljs-type">const</span> derived &amp;d) : <span class="hljs-built_in">base</span>(d)    <span class="hljs-comment">// 显式的使用基类的拷贝构造函数+</span><br>    &#123;<span class="hljs-comment">/*...*/</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>可能会误以为拷贝初始化<code>classType obj = ori;</code> 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数</p>
<p>当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符</p>
<p>此外我们还可以定义两种赋值运算符</p>
<ol>
<li>移动赋值运算符</li>
<li>其他类型到此类型的赋值运算符</li>
</ol>
<p>但这个运算符是最常用的运算符</p>
</blockquote>
<p>拷贝赋值运算符的形式通常是<code>classType operator=(const classType &amp;)</code> 因为他是一个成员函数，因此它的左侧成员自动绑定</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝</p>
<h4 id="继承体系中的拷贝赋值运算符"><a href="#继承体系中的拷贝赋值运算符" class="headerlink" title="继承体系中的拷贝赋值运算符"></a>继承体系中的拷贝赋值运算符</h4><p>派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">classType &amp; classType::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> classType &amp; rhs)<br>&#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs);  <span class="hljs-comment">// 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    派生类成员的赋值操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>释放对象使用的资源，销毁对象的非static成员</p>
<p>析构函数的形式是<code>~classType()</code> 没有返回值，不接受参数</p>
<p>不能被重载，对于任意一个类有且只有一个析构函数</p>
<blockquote>
<p>析构函数不能是删除的</p>
</blockquote>
<p>析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员</p>
<ul>
<li><p>继承体系中的析构函数</p>
<p>派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。</p>
<p>对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。</p>
</li>
</ul>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h3 id="类的拷贝控制成员被默认定义为删除的"><a href="#类的拷贝控制成员被默认定义为删除的" class="headerlink" title="类的拷贝控制成员被默认定义为删除的"></a>类的拷贝控制成员被默认定义为删除的</h3><blockquote>
<p>P450、P476、P553、P751</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><p>类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符，</p>
<blockquote>
<p>派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见</p>
</blockquote>
</li>
<li><p>动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定</p>
<blockquote>
<p>基类通过在成员函数前加上<code>virtual</code> 关键字使得函数执行运行时动态绑定。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数</p>
<p>关键字<code>virtual</code> 只能出现在类内声明语句中，而不能出现在定义语句中</p>
<p>没有用<code>virtual</code> 声明的函数，其解析发生在编译时，而非运行时</p>
</blockquote>
</li>
<li><p>访问控制：</p>
<p>如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为<code>protected</code> </p>
</li>
<li><p>派生类的构造函数</p>
<p>派生类必须使用基类的构造函数初始化其基类的部分</p>
</li>
<li><p>防止继承 定义类的时候使用<code>final</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDerived</span> <span class="hljs-keyword">final</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><ul>
<li><p>纯虚函数</p>
<p>通过在函数声明的分号前添加 &#x3D; 0 即可声明这个函数为纯虚函数</p>
<p>纯虚函数只是提供了一个接口，无需定义纯虚函数</p>
</li>
<li><p>含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象</p>
</li>
</ul>
<h3 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h3><ul>
<li>派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员</li>
<li>基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响<ol>
<li>若基类的访问说明符</li>
<li>派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高）</li>
</ol>
</li>
<li>对于派生类成员来说，它可以访问基类的<code>public</code> 和<code>private</code> 部分</li>
</ul>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以在派生类中使用<code>using</code> 声明改变它继承自基类的成员的可访问性</p>
<p>但<code>using</code>声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。</p>
<h3 id="struct-和-class的区别"><a href="#struct-和-class的区别" class="headerlink" title="struct 和 class的区别"></a>struct 和 class的区别</h3><ol>
<li>struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数</li>
<li>在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数</li>
<li>他们的可访问性：<ol>
<li>struct的默认成员都是public，class的默认成员都是private</li>
<li>struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承</li>
</ol>
</li>
</ol>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul>
<li><p>每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。</p>
<p>当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。</p>
</li>
<li><p>一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。</p>
<p>如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。</p>
<p>与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。</p>
<blockquote>
<p>编译器解析类的函数调用的过程：</p>
<p>例如<code>obj.func()</code></p>
<ol>
<li><p>确定obj的静态类型，去对应的类的作用域内查找该名称</p>
</li>
<li><p>如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。</p>
</li>
<li><p>如果找到了该名子，编译器进行类型检查，看这次调用是否合法。</p>
</li>
<li><p>如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。</p>
<p>否则直接进行函数调用。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。</p>
</li>
<li><p>因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。</p>
</li>
<li><p>成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。</p>
<p>如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用<code>using</code> 声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>, <span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> base::func;<br>    <span class="hljs-comment">// 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>cfla<br>
        <strong>本文链接：</strong><a href="https://cfla1638.github.io/2022/09/29/C-OOP/" title="https:&#x2F;&#x2F;cfla1638.github.io&#x2F;2022&#x2F;09&#x2F;29&#x2F;C-OOP&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;cfla1638.github.io&#x2F;2022&#x2F;09&#x2F;29&#x2F;C-OOP&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/">琐碎记录</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/C-C/" rel="tag">C/C++</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <div class="valine"></div>
<script src='https://cdn.jsdelivr.net/npm/valine'></script>
<script>
    // 使用方法 https://valine.js.org/quickstart.html
    new Valine({
        el: '.valine',
        appId: '04Cb1hKhS46C40AAoWX7DdEw-gzGzoHsz',
        appKey: 'qp0Ojo0wkFhB7QKVLOS13J5m'
    })
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-OOP"><span class="toc-number">1.</span> <span class="toc-text">C++ OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">C++ 的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">常量成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">1.1.3.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">类的类型成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">类的内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">可变数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-this-%E5%B7%A6%E5%80%BC"><span class="toc-number">1.1.7.</span> <span class="toc-text">返回*this 左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.8.</span> <span class="toc-text">类的前向声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.9.</span> <span class="toc-text">类的名字查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.10.</span> <span class="toc-text">类的隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.1.11.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">合成的默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">构造函数的初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">默认构造函数被调用的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">继承体系中的合成的默认构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">合成的拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">继承体系中的拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">拷贝赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">合成的拷贝赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">继承体系中的拷贝赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">移动构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E8%A2%AB%E9%BB%98%E8%AE%A4%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%88%A0%E9%99%A4%E7%9A%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">类的拷贝控制成员被默认定义为删除的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">纯虚函数和抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protected"><span class="toc-number">1.3.2.</span> <span class="toc-text">Protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E4%B8%AA%E5%88%AB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">改变个别成员的可访问性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E5%92%8C-class%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">struct 和 class的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">类的作用域</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    
<script src="/lib/mdui_043tiny/mdui.js"></script>
<script src="/lib/jquery.min.js"></script>
<script src="/lib/justifiedGallery/jquery.justifiedGallery.min.js"></script>
<script src="/lib/fancybox/fancybox.umd.js"></script>


 

<script async src="/js/app.js?v=1671460338222"></script>


	<script async src="/js/search.js?v=1671460338222"></script>


<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
