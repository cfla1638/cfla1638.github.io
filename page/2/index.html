<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cfla1638.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cfla&#39;s blog">
<meta property="og:url" content="https://cfla1638.github.io/page/2/index.html">
<meta property="og:site_name" content="cfla&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cfla">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cfla1638.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cfla's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cfla's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/29/C-OOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/29/C-OOP/" class="post-title-link" itemprop="url">C++ OOP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-29 15:48:03" itemprop="dateCreated datePublished" datetime="2022-09-29T15:48:03+08:00">2022-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 16:47:52" itemprop="dateModified" datetime="2022-10-08T16:47:52+08:00">2022-10-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">琐碎记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-OOP"><a href="#C-OOP" class="headerlink" title="C++ OOP"></a>C++ OOP</h1><h2 id="C-的类"><a href="#C-的类" class="headerlink" title="C++ 的类"></a>C++ 的类</h2><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。</p>
<p>在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用</p>
<p><strong>this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。</strong></p>
<h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层<code>const</code>的的this指针。</p>
<p>由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。</p>
<p>为了解决这个问题，我们可以将成员函数声明成<code>const</code> </p>
<p>例如，像下面这样，在参数列表后添加上<code>const</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_a</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;;<br>    <br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时，这个this指针，既是顶层<code>const</code> (this指针所固有的属性)，又是底层<code>const</code> （我们声明的结果）</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><blockquote>
<p>P241, P250，P545</p>
</blockquote>
<p>想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部</p>
<p>由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置</p>
<p>可以将一个类声明成另一个类的友元</p>
<blockquote>
<p> 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员</p>
</blockquote>
<p>可以将一个类的成员函数声明成另一个类的友元函数</p>
<p>友元声明是单向的，友元声明不具有传递性</p>
<p>关于友元的作用域：P252</p>
<p>友元关系是不能继承的</p>
<ul>
<li>基类的友元在访问派生类时没有特殊性。</li>
<li>派生类的友元也不能访问基类的私有成员</li>
</ul>
<h3 id="类的类型成员"><a href="#类的类型成员" class="headerlink" title="类的类型成员"></a>类的类型成员</h3><p>类的成员不只可以有变量和函数，还可以有类型</p>
<p>类内定义的类型也有访问权限的限制</p>
<p>用来定义类型的成员必须先定义再使用</p>
<blockquote>
<p>原因：// TODO</p>
</blockquote>
<h3 id="类的内联函数"><a href="#类的内联函数" class="headerlink" title="类的内联函数"></a>类的内联函数</h3><blockquote>
<p>内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销</p>
<p>内联函数会在编译时，被编译器展开</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> string &amp; <span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>max(), min() 之类的函数特别适合被定义为内联函数</p>
</blockquote>
<ul>
<li>定义在类内部的成员函数，它们默认是内联函数</li>
<li>可以在类内声明时使用<code>inline</code>，同时在类外定义函数时也同时使用<code>inline</code> ，但最好是只在类外部定义函数时使用<code>inline</code> 声明。</li>
</ul>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><blockquote>
<p>from effective c++</p>
<p>编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为<code>mutable</code> </p>
</blockquote>
<p>如果在定义类的成员时，使用<code>mutable</code> 关键字，那么，即使这个对象被声明成<code>const</code> ，我们依然可以改变这个成员变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>     public:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<br>    private:<br>    mutable <span class="hljs-type">size_t</span> cnt;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">A::inc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><br>&#123;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="返回-this-左值"><a href="#返回-this-左值" class="headerlink" title="返回*this 左值"></a>返回*this 左值</h3><p>当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值</p>
<p>我们可以根据this指针是否具有底层<code>const</code> 来对函数进行重载</p>
<blockquote>
<p>底层const的重载见：P206</p>
<p>P247</p>
</blockquote>
<h3 id="类的前向声明"><a href="#类的前向声明" class="headerlink" title="类的前向声明"></a>类的前向声明</h3><p>可以使用类似这种形式声明类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br></code></pre></td></tr></table></figure>
<p>这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。</p>
<p>前向声明可以放在类的头文件中，从而减少依赖。</p>
<h3 id="类的名字查找"><a href="#类的名字查找" class="headerlink" title="类的名字查找"></a>类的名字查找</h3><ul>
<li><p>我们可以在成员函数的任意地方使用类的成员</p>
<blockquote>
<p>原因在于编译器如何处理类：</p>
<ol>
<li>编译所有的成员声明</li>
<li>编译函数体</li>
</ol>
</blockquote>
</li>
<li><p>如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。</p>
</li>
<li><p>在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用<code>typedef</code> 或使用<code>using symbol = type</code>）不能再类中重定义。</p>
</li>
<li><p>成员函数的名字查找规则</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在成员函数内查找名字（成员函数体定义的名字，形参的名字）<br><span class="hljs-bullet">2.</span> 在类作用域内查找名字<br><span class="hljs-bullet">3.</span> 在成员函数定义之前的作用域内继续查找<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。</p>
</li>
</ul>
<h3 id="类的隐式类型转换"><a href="#类的隐式类型转换" class="headerlink" title="类的隐式类型转换"></a>类的隐式类型转换</h3><blockquote>
<p>P263 隐式的类类型转换 P514 重载类型转换运算符</p>
</blockquote>
<ul>
<li><p>如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换</p>
<p>这种类型转换只允许一步类型转换</p>
</li>
<li><p>一直类的隐式类型转换：</p>
<p>使用关键字<code>explicit</code> </p>
<p>该关键字只能在类内声明中使用，不能在类外重复</p>
<p>该关键字只能用于接受一个值的构造函数前面</p>
</li>
</ul>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0</p>
<p>类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的</p>
<p>由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似</p>
<ul>
<li>在<code>.h</code> 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理</li>
<li>我们可以使用类的静态成员作为成员函数的默认实参</li>
</ul>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><blockquote>
<p>类的初始化、对象拷贝、移动、销毁</p>
<p>由以下六个函数决定：</p>
<ul>
<li>构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
<p>后五个称为类的拷贝控制操作</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>C++ Primer P235、P257、P551、P689</p>
</blockquote>
<ul>
<li>构造函数没有返回值</li>
<li>构造函数可以重载</li>
<li>构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。</li>
</ul>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下</p>
<ol>
<li>如果存在类内的初始值，用它来初始化成员</li>
<li>否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数）</li>
</ol>
<p>如果出现以下情况，编译器无法为类构造合成的默认构造函数</p>
<ol>
<li><p>类有定义一个构造函数</p>
<blockquote>
<p>遇到这种情况，可以使用 <code>类名() = defalut</code> 来给予类一个默认的构造函数</p>
</blockquote>
</li>
<li><p>类存在一个成员，这个成员没有默认的构造函数</p>
</li>
</ol>
<h4 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">BookNo</span>(s) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</p>
<p>（重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化</p>
<p>由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 没有默认构造函数</span><br>public:<br>    A(<span class="hljs-type">int</span> num) : elem(num) &#123;&#125;<br>private:<br>    <span class="hljs-type">int</span> elem = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    B(<span class="hljs-type">int</span> num) : elem_int(num) &#123;&#125;  <span class="hljs-comment">// 错误，因为A没有默认构造函数，所以必须对它进行列表初始化</span><br>private:<br>    A elem_A;<br>    <span class="hljs-type">int</span> elem_int;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。</p>
<p>（重要）列表初始化的初始化顺序</p>
<p>列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非委托构造函数要使用的构造函数</span><br>    <span class="hljs-built_in">Sales_data</span>(std::string s, <span class="hljs-type">unsigned</span> cnt, <span class="hljs-type">double</span> price) : <br>          <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt * price) &#123;&#125;<br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Sales_data</span>() : <span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::string s) : <span class="hljs-built_in">Sales_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::istream &amp;is) : <span class="hljs-built_in">Sales_data</span>() &#123;<span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体</p>
<h4 id="默认构造函数被调用的时机"><a href="#默认构造函数被调用的时机" class="headerlink" title="默认构造函数被调用的时机"></a>默认构造函数被调用的时机</h4><blockquote>
<p>C++ Primer P262</p>
</blockquote>
<p>默认初始化</p>
<ol>
<li>在块作用域内不适用任何初始值定义一个非静态变量</li>
<li>一个类类型本身含有类成员，并且使用合成的默认构造函数时</li>
<li>没有在列表初始化中被显示初始化时</li>
</ol>
<p>值初始化</p>
<ol>
<li>数组初始化时，提供的值小于数组的大小</li>
<li>不适用初始值定义一个局部静态变量</li>
<li>使用<code>T()</code> 这种表达式来显示请求值初始化</li>
</ol>
<h4 id="继承体系中的合成的默认构造函数"><a href="#继承体系中的合成的默认构造函数" class="headerlink" title="继承体系中的合成的默认构造函数"></a>继承体系中的合成的默认构造函数</h4><ul>
<li><p>派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。</p>
</li>
<li><p>继承直接基类的构造函数，使用<code>using</code> 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数</p>
</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。</p>
<blockquote>
<p>拷贝构造函数的形式通常是 <code>ClassType(const ClassType &amp;)</code> </p>
<p>拷贝构造函数通常不应该是explicit的</p>
</blockquote>
<h4 id="合成的拷贝构造函数"><a href="#合成的拷贝构造函数" class="headerlink" title="合成的拷贝构造函数"></a>合成的拷贝构造函数</h4><p>如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数</p>
<p>对于内置类型，合成的拷贝构造函数会直接拷贝</p>
<p>对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数</p>
<p>对于数组，合成的拷贝构造函数会逐个拷贝它的元素</p>
<blockquote>
<p> <strong>一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别：</strong></p>
<blockquote>
<p>几种初始化的区别：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38231713/article/details/106291397">https://blog.csdn.net/qq_38231713/article/details/106291397</a></p>
</blockquote>
<p> 默认初始化：对象可能产生未定义的值，出现场景：</p>
<ol>
<li>块作用域内不使用任何初始值定义一个非静态变量；</li>
<li><p>类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员</p>
<ul>
<li>如果存在类内初始值，用它来初始化成员</li>
<li>否则，默认初始化该成员</li>
</ul>
<p>值初始化：对象的值是确定（预设）的，出现场景：</p>
</li>
<li><p>数组初始化时，初始值数量小于数组的长度。</p>
</li>
<li><p>不使用初始值定义一个静态变量（带有初始值0）</p>
</li>
<li><p>使用类似<code>classType()</code> 形式表达式显示请求值初始化</p>
</li>
<li><p>只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化</p>
<p><code>vector&lt;int&gt; vec(10);</code> 值初始化为0 </p>
<p>直接初始化：使用<code>classType()</code> 初始化对象</p>
<p>拷贝初始化：使用<code>classType foo = classType()</code> 初始化对象</p>
</li>
</ol>
<ul>
<li>不光在使用 = 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化<ol>
<li>将参数作为实参传递给非引用类型的形参</li>
<li>从返回类型为非引用的函数返回一个对象</li>
<li>使用花括号列表初始化数组或聚合类</li>
<li>初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数）</li>
</ol>
</li>
</ul>
<p> <strong>二、不同的初始化方式会调用那种构造函数</strong></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sksukai/article/details/104741675/">https://blog.csdn.net/sksukai/article/details/104741675/</a></p>
</blockquote>
<p> 当定义类时，会有直接初始化和拷贝初始化两种区别</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">foo var1;      <span class="hljs-comment">// 直接初始化，使用默认构造函数</span><br><span class="hljs-function">foo <span class="hljs-title">var2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">// 直接初始化，使用一个参数的构造函数</span><br>foo var3 = <span class="hljs-number">50</span>;    <span class="hljs-comment">// 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3</span><br>foo var4 = <span class="hljs-built_in">foo</span>(<span class="hljs-number">50</span>); <span class="hljs-comment">// 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数</span><br>foo var5 = var3;  <span class="hljs-comment">// 拷贝初始化，调用拷贝构造函数</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="继承体系中的拷贝构造函数"><a href="#继承体系中的拷贝构造函数" class="headerlink" title="继承体系中的拷贝构造函数"></a>继承体系中的拷贝构造函数</h4><p>我们需要使用基类的拷贝构造函数显示的初始化基类的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>    <span class="hljs-built_in">derived</span>(<span class="hljs-type">const</span> derived &amp;d) : <span class="hljs-built_in">base</span>(d)    <span class="hljs-comment">// 显式的使用基类的拷贝构造函数+</span><br>    &#123;<span class="hljs-comment">/*...*/</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>可能会误以为拷贝初始化<code>classType obj = ori;</code> 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数</p>
<p>当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符</p>
<p>此外我们还可以定义两种赋值运算符</p>
<ol>
<li>移动赋值运算符</li>
<li>其他类型到此类型的赋值运算符</li>
</ol>
<p>但这个运算符是最常用的运算符</p>
</blockquote>
<p>拷贝赋值运算符的形式通常是<code>classType operator=(const classType &amp;)</code> 因为他是一个成员函数，因此它的左侧成员自动绑定</p>
<h4 id="合成的拷贝赋值运算符"><a href="#合成的拷贝赋值运算符" class="headerlink" title="合成的拷贝赋值运算符"></a>合成的拷贝赋值运算符</h4><p>合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝</p>
<h4 id="继承体系中的拷贝赋值运算符"><a href="#继承体系中的拷贝赋值运算符" class="headerlink" title="继承体系中的拷贝赋值运算符"></a>继承体系中的拷贝赋值运算符</h4><p>派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">classType &amp; classType::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> classType &amp; rhs)<br>&#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs);  <span class="hljs-comment">// 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    派生类成员的赋值操作</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>释放对象使用的资源，销毁对象的非static成员</p>
<p>析构函数的形式是<code>~classType()</code> 没有返回值，不接受参数</p>
<p>不能被重载，对于任意一个类有且只有一个析构函数</p>
<blockquote>
<p>析构函数不能是删除的</p>
</blockquote>
<p>析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员</p>
<ul>
<li><p>继承体系中的析构函数</p>
<p>派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。</p>
<p>对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。</p>
</li>
</ul>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h3 id="类的拷贝控制成员被默认定义为删除的"><a href="#类的拷贝控制成员被默认定义为删除的" class="headerlink" title="类的拷贝控制成员被默认定义为删除的"></a>类的拷贝控制成员被默认定义为删除的</h3><blockquote>
<p>P450、P476、P553、P751</p>
</blockquote>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><p>类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符，</p>
<blockquote>
<p>派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见</p>
</blockquote>
</li>
<li><p>动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定</p>
<blockquote>
<p>基类通过在成员函数前加上<code>virtual</code> 关键字使得函数执行运行时动态绑定。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数</p>
<p>关键字<code>virtual</code> 只能出现在类内声明语句中，而不能出现在定义语句中</p>
<p>没有用<code>virtual</code> 声明的函数，其解析发生在编译时，而非运行时</p>
</blockquote>
</li>
<li><p>访问控制：</p>
<p>如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为<code>protected</code> </p>
</li>
</ul>
<ul>
<li><p>派生类的构造函数</p>
<p>派生类必须使用基类的构造函数初始化其基类的部分</p>
</li>
<li><p>防止继承 定义类的时候使用<code>final</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDerived</span> <span class="hljs-keyword">final</span> &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><ul>
<li><p>纯虚函数</p>
<p>通过在函数声明的分号前添加 = 0 即可声明这个函数为纯虚函数</p>
<p>纯虚函数只是提供了一个接口，无需定义纯虚函数</p>
</li>
<li><p>含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象</p>
</li>
</ul>
<h3 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h3><ul>
<li>派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员</li>
<li>基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响<ol>
<li>若基类的访问说明符</li>
<li>派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高）</li>
</ol>
</li>
<li>对于派生类成员来说，它可以访问基类的<code>public</code> 和<code>private</code> 部分</li>
</ul>
<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以在派生类中使用<code>using</code> 声明改变它继承自基类的成员的可访问性</p>
<p>但<code>using</code>声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。</p>
<h3 id="struct-和-class的区别"><a href="#struct-和-class的区别" class="headerlink" title="struct 和 class的区别"></a>struct 和 class的区别</h3><ol>
<li>struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数</li>
<li>在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数</li>
<li>他们的可访问性：<ol>
<li>struct的默认成员都是public，class的默认成员都是private</li>
<li>struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承</li>
</ol>
</li>
</ol>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><ul>
<li><p>每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。</p>
<p>当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。</p>
</li>
</ul>
<ul>
<li><p>一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。</p>
<p>如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。</p>
<p>与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。</p>
<blockquote>
<p>编译器解析类的函数调用的过程：</p>
<p>例如<code>obj.func()</code></p>
<ol>
<li><p>确定obj的静态类型，去对应的类的作用域内查找该名称</p>
</li>
<li><p>如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。</p>
</li>
<li><p>如果找到了该名子，编译器进行类型检查，看这次调用是否合法。</p>
</li>
<li><p>如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。</p>
<p>否则直接进行函数调用。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li>声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。</li>
<li><p>因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。</p>
</li>
<li><p>成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。</p>
<p>如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用<code>using</code> 声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span>, <span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> base::func;<br>    <span class="hljs-comment">// 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-type">int</span>) <span class="hljs-keyword">override</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">const 和 constexpr 的详解和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 15:40:53" itemprop="dateCreated datePublished" datetime="2022-09-26T15:40:53+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-29 15:45:33" itemprop="dateModified" datetime="2022-09-29T15:45:33+08:00">2022-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">琐碎记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="const和constexpr"><a href="#const和constexpr" class="headerlink" title="const和constexpr"></a><code>const</code>和<code>constexpr</code></h1><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p>常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式</p>
<p>常量表达式是由</p>
<ul>
<li>数据类型</li>
<li>数据初始值</li>
</ul>
<p>决定的。</p>
<p><code>int a = 1</code> a 不是一个常量表达式，因为它的数据类型不是常量</p>
<p><code>const int b = get_val()</code> b不是一个常量表达式，因为它的初始值不是常量</p>
<p>由于使用<code>const</code> 不能确定一个表达式是不是常量，因此C++11使用<code>constexpr</code> 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。</p>
<p>下面这个程序是不正确的，因为a虽然被<code>const</code> 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> i = a;<br>    <span class="hljs-type">int</span> arr[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而只要将<code>a = b</code> 改为 <code>a = 1</code> 程序就不会报错了，因为此时a的确是一个常量表达式</p>
<h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h3><p>普通的函数不是常量表达式，但我们可以定义<code>constexpr</code> 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定</p>
<h3 id="constexpr-指针-amp-引用"><a href="#constexpr-指针-amp-引用" class="headerlink" title="constexpr 指针 &amp; 引用"></a><code>constexpr</code> 指针 &amp; 引用</h3><p><code>constexpr</code> 指向的位置必须是全局变量，静态变量，或者字面值等放在<code>.bss</code> 节<code>.data</code> 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><p><code>const</code>用来修饰变量，根据<code>const</code> 出现的位置，可以分为两种<code>const</code> ：顶层<code>const</code> 和底层<code>const</code> </p>
<p>顶层<code>const</code> 可以表示任意的对象是常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-comment">// a不能改变，是顶层const</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;a;    <span class="hljs-comment">// p不能改变指向，是顶层const</span><br></code></pre></td></tr></table></figure>
<p>低层<code>const</code> 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;    <span class="hljs-comment">// 指向a的指针，不能通过这个指针修改a的值，是底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = a;    <span class="hljs-comment">// a的引用，不能通过这种方式修改a, 是底层const</span><br></code></pre></td></tr></table></figure>
<h3 id="const-与参数传递"><a href="#const-与参数传递" class="headerlink" title="const 与参数传递"></a><code>const</code> 与参数传递</h3><ul>
<li><p>在参数传递时，顶层<code>const</code>会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层<code>const</code> 后没有区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以使用非常量初始化底层<code>const</code> ，但不能使用常量去初始化非底层<code>const</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref_1 = a;  <span class="hljs-comment">// 可以， 可以使用非常量初始化底层const</span><br><span class="hljs-type">int</span> &amp;ret_2 = b;      <span class="hljs-comment">// 不可以， 不能使用常量去初始化非底层const</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>非常量的引用必须是左值，常量的引用可以是左值，也可以是右值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> &amp;b = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<p>因此<strong>尽量将不会改变形参的函数的形参定义成底层<code>const</code></strong> ，因为这样定义我们可以使用字面量（rvalue）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">并发编程 - CS:APP 第十二章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 22:10:57" itemprop="dateCreated datePublished" datetime="2022-09-25T22:10:57+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-26 14:38:29" itemprop="dateModified" datetime="2022-09-26T14:38:29+08:00">2022-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发编程-CS-APP-第十二章"><a href="#并发编程-CS-APP-第十二章" class="headerlink" title="并发编程 - CS:APP 第十二章"></a>并发编程 - CS:APP 第十二章</h1><p>本章主要内容：</p>
<ul>
<li>实现并发程序的三种方法：<ol>
<li>fork() 进程</li>
<li>I/O 多路复用</li>
<li>使用线程</li>
</ol>
</li>
<li>使用信号量同步线程</li>
<li>线程安全问题</li>
</ul>
<h2 id="使用进程进行并发编程"><a href="#使用进程进行并发编程" class="headerlink" title="使用进程进行并发编程"></a>使用进程进行并发编程</h2><p><code>fork()</code> &amp; <code>execve</code> </p>
<p>优点：进程模型清晰，有独立的地址空间</p>
<p>缺点：不方便进程之间共享信息</p>
<p>基于进程的并发echo服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br><br>    Rio_readinitb(&amp;rio, connfd);<br>    <span class="hljs-keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d bytes\n&quot;</span>, (<span class="hljs-type">int</span>)n);<br>        Rio_writen(connfd, buf, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (waitpid(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, WNOHANG) &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;args error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    Signal(SIGCHLD, sigchld_handler);<br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);<br>        <span class="hljs-keyword">if</span> (Fork() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process:%d connected\n&quot;</span>, getpid());<br>            Close(listenfd);<br>            echo(connfd);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process:%d close connection\n&quot;</span>, getpid());<br>            Close(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        Close(connfd);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>可以使用<code>select()</code> 函数显示等待一个进程有一个IO事件发生。</p>
<p>例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。</p>
<p>只要有一个IO事件发生，程序的逻辑流就会改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果fdset中的描述符准备好读或者写，就返回</span><br><span class="hljs-comment">返回值：返回已准备好的描述符数目，若出错返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set *fdset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)</span>;<br><br>FD_ZERO(fd_set *fdset);<br>FD_CLR(<span class="hljs-type">int</span> fd, fd_set *fdset);<br>FD_SET(<span class="hljs-type">int</span> fd, fd_set *fdset);<br>FD_ISSET(<span class="hljs-type">int</span> fd, fd_set *fdset);<br><br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> maxfd;<br>    fd_set read_set;<br>    fd_set ready_set;<br>    <span class="hljs-type">int</span> nready;<br>    <span class="hljs-type">int</span> maxi;<br>    <span class="hljs-type">int</span> clientfd[FD_SETSIZE];<br>    <span class="hljs-type">rio_t</span> clientrio[FD_SETSIZE];<br>&#125;pool;<br><br><span class="hljs-type">int</span> byte_cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_pool</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd, pool *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">add_client</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd, pool *p)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">check_clients</span><span class="hljs-params">(pool *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br><br>    <span class="hljs-type">static</span> pool pool;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    init_pool(listenfd, &amp;pool);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        pool.ready_set = pool.read_set;<br>        pool.nready = Select(pool.maxfd + <span class="hljs-number">1</span>, &amp;pool.ready_set, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, pool.nready);<br>        <span class="hljs-keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123;<br>            clientlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>            connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);<br>            add_client(connfd, &amp;pool);<br>        &#125;<br><br>        check_clients(&amp;pool);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_pool</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd, pool *p)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    p-&gt;maxi = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++)<br>        p-&gt;clientfd[i] = <span class="hljs-number">-1</span>;<br><br>    p-&gt;maxfd = listenfd;<br>    FD_ZERO(&amp;p-&gt;read_set);<br>    FD_SET(listenfd, &amp;p-&gt;read_set);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_client</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd, pool *p)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    p-&gt;nready--;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            p-&gt;clientfd[i] = connfd;<br>            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);<br><br>            FD_SET(connfd, &amp;p-&gt;read_set);<br><br>            <span class="hljs-keyword">if</span>(connfd &gt; p-&gt;maxfd)<br>                p-&gt;maxfd = connfd;<br>            <span class="hljs-keyword">if</span> (i &gt; p-&gt;maxi) <br>                p-&gt;maxi = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == FD_SETSIZE)<br>        app_error(<span class="hljs-string">&quot;add_client error: Too many clients&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">check_clients</span><span class="hljs-params">(pool *p)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, connfd, n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; <span class="hljs-number">0</span>; i++) &#123;<br>        connfd = p-&gt;clientfd[i];<br>        rio = p-&gt;clientrio[i];<br><br>        <span class="hljs-keyword">if</span> ((connfd &gt; <span class="hljs-number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;<br>            p-&gt;nready--;<br>            <span class="hljs-keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>                byte_cnt += n;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);<br>                Rio_writen(connfd, buf, n);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                Close(connfd);<br>                FD_CLR(connfd, &amp;p-&gt;read_set);<br>                p-&gt;clientfd[i] = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>缺点：编码特别复杂</p>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程是运行在进程上下文中的逻辑流</p>
<p>运行在同一个进程里的线程共享</p>
<ul>
<li>虚拟地址空间</li>
</ul>
<p>有自己独立的</p>
<ul>
<li>栈、栈指针、PC、通用目的寄存器和条件码</li>
</ul>
<p>线程之间是对等的，没有和进程一样有父子之分</p>
<p>进程有两种状态：可结合的和分离的</p>
<ul>
<li>可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收</li>
<li>分离的：不能被其他线程杀死，内存资源结束时由系统自动释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *(func)(<span class="hljs-type">void</span> *);<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *tid, <span class="hljs-type">pthread_attr_t</span> * attr, func *f, <span class="hljs-type">void</span> *arg)</span>;<br><br><span class="hljs-comment">// 获取自己的tid</span><br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *thread_return)</span>;<br><br><span class="hljs-comment">// 终止 tid</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span>;<br><br><span class="hljs-comment">// 阻塞，等待tid终止</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">void</span> **thread_return)</span>;<br><br><span class="hljs-comment">// 当这个线程第一次被调用时，执行 init_routine()，用于初始化</span><br><span class="hljs-type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_once</span><span class="hljs-params">(<span class="hljs-type">pthread_once_t</span> *once_control, <span class="hljs-type">void</span> (*init_routine)(<span class="hljs-type">void</span>))</span>;<br></code></pre></td></tr></table></figure>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误</p>
<blockquote>
<p>对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。</p>
</blockquote>
<p>想要实现互斥的访问，我们可以使用信号量机制</p>
<p>信号量：</p>
<p>信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它：</p>
<ul>
<li>P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。</li>
<li>V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。</li>
</ul>
<p>P中测试和加一的操作是不可分割的</p>
<p>V中测试和加以的操作也是不可分割的</p>
<p>如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。</p>
<p>互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。</p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><blockquote>
<p>生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。</p>
<p>因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。</p>
</blockquote>
<p>基于生产者消费者的sbuf包：</p>
<p><code>sbuf.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> H_SBUF</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> H_SBUF</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> *buf;  <span class="hljs-comment">// 缓冲区</span><br>    <span class="hljs-type">int</span> n;    <span class="hljs-comment">// 缓冲区长度</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 队列头</span><br>    <span class="hljs-type">int</span> rear;  <span class="hljs-comment">// 队列尾</span><br>    <span class="hljs-type">sem_t</span> mutex;  <span class="hljs-comment">// 对缓冲区的互斥锁</span><br>    <span class="hljs-type">sem_t</span> slots;  <span class="hljs-comment">// 控制生产者的信号量</span><br>    <span class="hljs-type">sem_t</span> items;  <span class="hljs-comment">// 控制消费者的信号量</span><br>&#125;<span class="hljs-type">sbuf_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p><code>sbuf.c</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    sp-&gt;buf = Calloc(n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    sp-&gt;n = n;<br>    sp-&gt;front = sp-&gt;rear = <span class="hljs-number">0</span>;<br>    Sem_init(&amp;sp-&gt;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    Sem_init(&amp;sp-&gt;slots, <span class="hljs-number">0</span>, n);<br>    Sem_init(&amp;sp-&gt;items, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 释放缓冲区空间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span><br>&#123;<br>    Free(sp-&gt;buf);<br>&#125;<br><br><span class="hljs-comment">// 向缓冲区插入数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span><br>&#123;<br>    P(&amp;sp-&gt;slots);  <span class="hljs-comment">// 如果缓冲区已满，想要插入的线程会阻塞在这里</span><br>    P(&amp;sp-&gt;mutex);  <span class="hljs-comment">// 互斥锁加锁</span><br>    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;    <span class="hljs-comment">// 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小</span><br>    V(&amp;sp-&gt;mutex);  <span class="hljs-comment">// 互斥锁解锁</span><br>    V(&amp;sp-&gt;items);  <span class="hljs-comment">// 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span><br>&#123;<br>    <span class="hljs-type">int</span> item;<br>    P(&amp;sp-&gt;items);  <span class="hljs-comment">// 如果缓冲区为空，想要取出的线程会阻塞</span><br>    P(&amp;sp-&gt;mutex);<br>    item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n];    <span class="hljs-comment">// 因为信号量的机制，我们不用担心从空缓冲区里取出数据</span><br>    V(&amp;sp-&gt;mutex);<br>    V(&amp;sp-&gt;slots);  <span class="hljs-comment">// 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基于预线程化的并发服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NTHREADS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SBUFSIZE 16</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span>;<br><br><span class="hljs-type">sbuf_t</span> sbuf;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> byte_cnt;<br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> mutex;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, listenfd, connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br><br>    sbuf_init(&amp;sbuf, SBUFSIZE);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NTHREADS; i++)<br>        Pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);<br>        sbuf_insert(&amp;sbuf, connfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span><br>&#123;<br>    Pthread_detach(pthread_self());<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> connfd = sbuf_remove(&amp;sbuf);<br>        echo_cnt(connfd);<br>        Close(connfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_echo_cnt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    Sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    byte_cnt = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br>    <span class="hljs-type">static</span> <span class="hljs-type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;<br><br>    Pthread_once(&amp;once, init_echo_cnt);<br>    Rio_readinitb(&amp;rio, connfd);<br>    <span class="hljs-keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>        P(&amp;mutex);<br>        byte_cnt += n;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);<br>        V(&amp;mutex);<br>        Rio_writen(connfd, buf, n);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="四个种不安全的函数"><a href="#四个种不安全的函数" class="headerlink" title="四个种不安全的函数"></a>四个种不安全的函数</h3><ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数（依赖前次调用结果的函数）</li>
<li>返回指向静态变量指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入的函数"><a href="#可重入的函数" class="headerlink" title="可重入的函数"></a>可重入的函数</h3><p>通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集</p>
<p>定义：当它被多个线程使用时，不会引用任何共享数据</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件</p>
<p>给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">网络编程 - CS:APP 第十一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 17:53:11" itemprop="dateCreated datePublished" datetime="2022-09-22T17:53:11+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:14:00" itemprop="dateModified" datetime="2022-09-25T22:14:00+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络编程-CS-APP-第十一章"><a href="#网络编程-CS-APP-第十一章" class="headerlink" title="网络编程 - CS:APP 第十一章"></a>网络编程 - CS:APP 第十一章</h1><p>客户端和服务器都是进程，而不是机器或主机。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_addr;  <span class="hljs-comment">// 32位IP地址，使用网络字节顺序（大端法）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。</p>
<p>字节顺序和主机顺序的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;  <span class="hljs-comment">// host to net</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>; <span class="hljs-comment">// host to net</span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;  <span class="hljs-comment">// net to host</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;  <span class="hljs-comment">// net to host</span><br></code></pre></td></tr></table></figure>
<p>点分IP地址与32位IP地址的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 点分十进制转换成32位地址</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">得到的32位地址也要转换成本地顺序</span><br><span class="hljs-comment">返回：若成功返回1，串非法返回0，错误返回-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(AF_INET, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br><br><span class="hljs-comment">// 32位地址转换成点分十进制</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在使用该函数之前，要将32位IP地址转换成网络顺序</span><br><span class="hljs-comment">把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中</span><br><span class="hljs-comment">返回：若成功返回指向点分十进制地址的指针，出错返回NULL</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(AF_INET, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>;<br></code></pre></td></tr></table></figure>
<p>附</p>
<ol>
<li><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将十六进制字符串转换成十进制数：</span><br>使用<span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%x&quot;</span>, &amp;num)<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用32位IP地址时，可以直接使用<code>in_addr</code>结构而不是<code>in_addr</code>结构里的<code>s_addr</code></p>
</li>
</ol>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>是一组绝大多数操作系统都定义的函数，可以实现网络应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209231151155.png" alt="image-20220923115128790"></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这两个结构体所占字节数相同，可以互相转换</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> sin_family;  <span class="hljs-comment">// 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6)</span><br>    <span class="hljs-type">uint16_t</span> sin_port;    <span class="hljs-comment">// 端口号，使用网络字节顺序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>  <span class="hljs-comment">// IP地址结构</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sin_zero[<span class="hljs-number">8</span>];   <span class="hljs-comment">// 填充0，为了满足struct sockaddr的大小</span><br>&#125;;    <span class="hljs-comment">// 这个结构体一共占16个字节</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span> sa_family;<br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">SA</span>;</span><br></code></pre></td></tr></table></figure>
<h3 id="socket-通用"><a href="#socket-通用" class="headerlink" title="socket() 通用"></a>socket() 通用</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使套接字称为一个连接的结点</span><br><span class="hljs-comment">返回一个还不能用于读写的描述符</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 使称为一个连接点</span><br>clientfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<h3 id="connect-客户端"><a href="#connect-客户端" class="headerlink" title="connect() 客户端"></a>connect() 客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> clientfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr * addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)</span><br><span class="hljs-comment">成功返回0， 出错返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="bind-服务器"><a href="#bind-服务器" class="headerlink" title="bind()  服务器"></a>bind()  服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr * addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)</span><br><span class="hljs-comment">成功返回0， 出错返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="listen-服务器"><a href="#listen-服务器" class="headerlink" title="listen() 服务器"></a>listen() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024</span><br><span class="hljs-comment">成功返回0， 出错返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="accept-服务器"><a href="#accept-服务器" class="headerlink" title="accept() 服务器"></a>accept() 服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> *addrlen)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">成功返回非负连接描述符， 出错返回-1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>服务器：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>bind()</code> 成为一个服务器套接字</li>
<li>调用<code>listen()</code> 转换成监听描述符</li>
<li>调用<code>accept()</code> ，阻塞程序，等待客户端连接，返回连接描述符</li>
</ol>
<p>客户端：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>connect()</code>， 连接服务器</li>
</ol>
<h3 id="套接字地址和主机名服务名的转换"><a href="#套接字地址和主机名服务名的转换" class="headerlink" title="套接字地址和主机名服务名的转换"></a>套接字地址和主机名服务名的转换</h3><p>首先了解，域名和IP地址是等价的，服务名和端口号是等价的</p>
<p>例如localhost和127.0.0.1是等价的，http和80是等价的</p>
<h4 id="从-字符串主机名服务名信息-到-二进制套接字地址信息"><a href="#从-字符串主机名服务名信息-到-二进制套接字地址信息" class="headerlink" title="从 字符串主机名服务名信息 到 二进制套接字地址信息"></a>从 字符串主机名服务名信息 到 二进制套接字地址信息</h4><blockquote>
<p>为什么要使用这个函数？</p>
<p>域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">host: 域名或点分十进制IP地址</span><br><span class="hljs-comment">service: 服务名或端口号</span><br><span class="hljs-comment">hints: 可选 传递设置</span><br><span class="hljs-comment">result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *service,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo *hints, <span class="hljs-keyword">struct</span> addrinfo **result)</span>;<br><br><span class="hljs-comment">// 释放返回的链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo, *result)</span>;<br><br><span class="hljs-comment">// 将错误代码转换成错误信息</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode)</span>;<br></code></pre></td></tr></table></figure>
<p><code>getaddrinfo</code> 使用的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> &#123;</span><br>    <span class="hljs-type">int</span> ai_flags;<br>    <span class="hljs-type">int</span> ai_family;<br>    <span class="hljs-type">int</span> ai_socktype;<br>    <span class="hljs-type">int</span> ai_protocol;<br>    <br>    <span class="hljs-type">char</span> *ai_canonname;<br>    <span class="hljs-type">size_t</span> ai_addrlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">ai_addr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">ai_next</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="从-二进制套接字地址信息-到-字符串主机名服务名信息"><a href="#从-二进制套接字地址信息-到-字符串主机名服务名信息" class="headerlink" title="从 二进制套接字地址信息 到 字符串主机名服务名信息"></a>从 二进制套接字地址信息 到 字符串主机名服务名信息</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen,</span><br><span class="hljs-params">               <span class="hljs-type">char</span> *host, <span class="hljs-type">size_t</span> hostlen, </span><br><span class="hljs-params">               <span class="hljs-type">char</span> *service, <span class="hljs-type">size_t</span> servlen,</span><br><span class="hljs-params">               <span class="hljs-type">int</span> flags)</span>;<br><br></code></pre></td></tr></table></figure>
<h2 id="辅助简化函数"><a href="#辅助简化函数" class="headerlink" title="辅助简化函数"></a>辅助简化函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open_clientfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *hostname, <span class="hljs-type">char</span> *port)</span> &#123;<br>    <span class="hljs-type">int</span> clientfd, rc;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span><br><br>    <span class="hljs-comment">/* Get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> addrinfo));<br>    hints.ai_socktype = SOCK_STREAM;  <span class="hljs-comment">/* Open a connection */</span><br>    hints.ai_flags = AI_NUMERICSERV;  <span class="hljs-comment">/* ... using a numeric port arg. */</span><br>    hints.ai_flags |= AI_ADDRCONFIG;  <span class="hljs-comment">/* Recommended for connections */</span><br>    <span class="hljs-keyword">if</span> ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;getaddrinfo failed (%s:%s): %s\n&quot;</span>, hostname, port, gai_strerror(rc));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">/* Walk the list for one that we can successfully connect to */</span><br>    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;<br>        <span class="hljs-comment">/* Create a socket descriptor */</span><br>        <span class="hljs-keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Socket failed, try the next */</span><br><br>        <span class="hljs-comment">/* Connect to the server */</span><br>        <span class="hljs-keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="hljs-number">-1</span>) <br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span><br>        <span class="hljs-keyword">if</span> (close(clientfd) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Connect failed, try another */</span>  <span class="hljs-comment">//line:netp:openclientfd:closefd</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;open_clientfd: close failed: %s\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <br>    &#125; <br><br>    <span class="hljs-comment">/* Clean up */</span><br>    freeaddrinfo(listp);<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* All connects failed */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">/* The last connect succeeded */</span><br>        <span class="hljs-keyword">return</span> clientfd;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open_listenfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *port)</span> <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-type">int</span> listenfd, rc, optval=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> addrinfo));<br>    hints.ai_socktype = SOCK_STREAM;             <span class="hljs-comment">/* Accept connections */</span><br>    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="hljs-comment">/* ... on any IP address */</span><br>    hints.ai_flags |= AI_NUMERICSERV;            <span class="hljs-comment">/* ... using port number */</span><br>    <span class="hljs-keyword">if</span> ((rc = getaddrinfo(<span class="hljs-literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Walk the list for one that we can bind to */</span><br>    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;<br>        <span class="hljs-comment">/* Create a socket descriptor */</span><br>        <span class="hljs-keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">/* Socket failed, try the next */</span><br><br>        <span class="hljs-comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span><br>        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="hljs-comment">//line:netp:csapp:setsockopt</span><br>                   (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)&amp;optval , <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>        <span class="hljs-comment">/* Bind the descriptor to the address */</span><br>        <span class="hljs-keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span><br>        <span class="hljs-keyword">if</span> (close(listenfd) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Bind failed, try the next */</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/* Clean up */</span><br>    freeaddrinfo(listp);<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* No address worked */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">/* Make it a listening socket ready to accept connection requests */</span><br>    <span class="hljs-keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="hljs-number">0</span>) &#123;<br>        close(listenfd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listenfd;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// echoclient.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> clientfd;<br>    <span class="hljs-type">char</span> *host, *port, buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;argument error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    host = argv[<span class="hljs-number">1</span>];<br>    port = argv[<span class="hljs-number">2</span>];<br><br>    clientfd = Open_clientfd(host, port);<br>    Rio_readinitb(&amp;rio, clientfd);<br><br>    <span class="hljs-keyword">while</span> (Fgets(buf, MAXLINE, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) &#123;<br>        Rio_writen(clientfd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        Rio_readlineb(&amp;rio, buf, MAXLINE);<br>        Fputs(buf, <span class="hljs-built_in">stdout</span>);<br>    &#125;<br>    Close(clientfd);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// echoserver.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br><br>    Rio_readinitb(&amp;rio, connfd);<br>    <span class="hljs-keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d bytes\n&quot;</span>, (<span class="hljs-type">int</span>)n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received:%s\n&quot;</span>, buf);<br>        Rio_writen(connfd, buf, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> listenfd, connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">clientaddr</span>;</span><br>    <span class="hljs-type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;argument error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    listenfd = Open_listenfd(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        clientlen = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);<br>        Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE,<br>        client_port, MAXLINE, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);<br>        echo(connfd);<br>        Close(connfd);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>protocol family 协议簇：一组相关联的协议</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">系统级I/O - CS:APP 第十章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-20 15:18:55" itemprop="dateCreated datePublished" datetime="2022-09-20T15:18:55+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:15:11" itemprop="dateModified" datetime="2022-09-25T22:15:11+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统级I-O-CS-APP-第十章"><a href="#系统级I-O-CS-APP-第十章" class="headerlink" title="系统级I/O - CS:APP 第十章"></a>系统级I/O - CS:APP 第十章</h1><p>Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。</p>
<p>在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul>
<li><p>定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。</p>
</li>
<li><p>Linux Shell 创建的进程会打开三个文件：</p>
<p>0：标准输入；也可以使用定义在<code>unistd.h</code> 中的<code>STDIN_FILENO</code> 来显示表述</p>
<p>1：标准输出；<code>STDOUT_FILENO</code></p>
<p>2：标准错误；<code>STDERR_FILENO</code> </p>
</li>
<li><p>EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;= m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。</p>
</li>
</ul>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul>
<li>普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。</li>
<li>目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是<code>.</code> 和<code>..</code> 分别代表自己和上层目录。</li>
<li>套接字 socket ：用来和其他进程进行跨网络通信的文件。</li>
</ul>
<h2 id="系统级IO函数"><a href="#系统级IO函数" class="headerlink" title="系统级IO函数"></a>系统级IO函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 打开和关闭文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> * filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">flags: 文件的打开方式</span><br><span class="hljs-comment">O_RDONLY   只读</span><br><span class="hljs-comment">O_WRONLY  只写</span><br><span class="hljs-comment">O_RDWR    可读可写</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">O_CREAT   如果文件不存在，创建</span><br><span class="hljs-comment">O_TRUNC    如果文件已存在，截断它（即覆盖原文件）</span><br><span class="hljs-comment">O_APPEND  添加到文件末尾</span><br><span class="hljs-comment">不同的flag可以使用管道符| 连接使用 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">mode:</span><br><span class="hljs-comment">一般为0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-comment">// 读写</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// 返回值：若成功返回-1，EOF返回0，出错返回-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// 返回值：若成功返回写的字节数，出错返回-1</span><br></code></pre></td></tr></table></figure>
<p><code>ssize_t</code> ：signed size type</p>
<p>read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n</p>
<p>可能会返回不足值得情况：</p>
<ul>
<li>读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。</li>
<li>从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li>
<li>读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。</li>
</ul>
<h2 id="RIO包函数"><a href="#RIO包函数" class="headerlink" title="RIO包函数"></a>RIO包函数</h2><p>RIO(Robust I/O)：用于网络编程中，会自动处理不足值的情况。</p>
<h3 id="总览："><a href="#总览：" class="headerlink" title="总览："></a>总览：</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不带缓冲区的版本</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;    <span class="hljs-comment">// 代替read</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;    <span class="hljs-comment">// 代替write</span><br><br><span class="hljs-comment">// 带缓冲区的版本</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rio_readinitb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> maxlen)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span>;  <span class="hljs-comment">// 带缓冲区的rio_readn</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>带缓冲区和不带缓冲区的优劣：</p>
<p>带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。</p>
<p>不带缓冲区：比较快速，方便在网络上进行数据传输（臆断）</p>
</blockquote>
<h3 id="不带缓冲区的函数"><a href="#不带缓冲区的函数" class="headerlink" title="不带缓冲区的函数"></a>不带缓冲区的函数</h3><h3 id="rio-readn"><a href="#rio-readn" class="headerlink" title="rio_readn()"></a>rio_readn()</h3><p>用来代替<code>read</code> 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;   <span class="hljs-comment">// 整个程序中，还没有被读取的字节</span><br>    <span class="hljs-type">ssize_t</span> nread;      <span class="hljs-comment">// 单次调用read 函数所读取的字节</span><br>    <span class="hljs-type">char</span> *bufp = usrbuf;<br><br>    <span class="hljs-comment">// nleft != 0</span><br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// read 函数发生错误</span><br>            <span class="hljs-keyword">if</span> (errno == EINTR)     <span class="hljs-comment">// interrupted by a sig handler return</span><br>                nread = <span class="hljs-number">0</span>;      <span class="hljs-comment">// call read again</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">// unknown error</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// EOF</span><br>        nleft -= nread;<br>        usrbuf += nread;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n - nleft;      <span class="hljs-comment">// 这个程序读取的所有字节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="rio-writen"><a href="#rio-writen" class="headerlink" title="rio_writen()"></a>rio_writen()</h3><p>用来代替<code>write</code> 的函数，无缓冲区，绝对不可能返回不足值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;    <span class="hljs-comment">// 整个程序中，还没有被写入的字节</span><br>    <span class="hljs-type">ssize_t</span> nwritten;    <span class="hljs-comment">// 单词write函数写入的字节</span><br>    <span class="hljs-type">char</span> *bufp = usrbuf;  <span class="hljs-comment">// 下一个将被写入的位置</span><br><br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR)    <span class="hljs-comment">// 被一个信号处理程序返回打断</span><br>                nwritten = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">// 未知错误</span><br>        &#125;<br>        nleft -= nwritten;<br>        bufp += nwritten;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="带缓冲区的函数"><a href="#带缓冲区的函数" class="headerlink" title="带缓冲区的函数"></a>带缓冲区的函数</h3><p>缓冲区的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RIO_BUFSIZE 8192  <span class="hljs-comment">// 缓冲区的大小</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> rio_fd;        <span class="hljs-comment">// 与缓冲区关联的文件描述符</span><br>    <span class="hljs-type">int</span> rio_cnt;      <span class="hljs-comment">// 缓冲区中的未读字节数</span><br>    <span class="hljs-type">char</span> *rio_bufptr;    <span class="hljs-comment">// 下一个未读字节地址</span><br>    <span class="hljs-type">char</span> rio_buf[RIO_BUFSIZE];    <span class="hljs-comment">// 缓冲区</span><br>&#125;<span class="hljs-type">rio_t</span>;<br></code></pre></td></tr></table></figure>
<p>初始化缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> rio_<br></code></pre></td></tr></table></figure>
<h3 id="rio-read"><a href="#rio-read" class="headerlink" title="rio_read()"></a>rio_read()</h3><p>带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数</p>
<p>该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。</p>
<p>该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_read</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">char</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> cnt;  <span class="hljs-comment">// 本次调用函数读取的字节数</span><br><br>    <span class="hljs-keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果缓冲区为空，重新填满缓冲区</span><br>        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="hljs-keyword">sizeof</span>(rp-&gt;rio_buf));<br>        <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno != EINTR)    <span class="hljs-comment">// 被信号打断，自动重启</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未知错误</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// EOF</span><br>        <span class="hljs-keyword">else</span> <br>            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="hljs-comment">// 重置bufptr</span><br>    &#125;<br><br>    cnt = n;<br>    <span class="hljs-keyword">if</span> (rp-&gt;rio_cnt &lt; n)    <span class="hljs-comment">// 缓冲区字节数不够</span><br>        cnt = rp-&gt;rio_cnt;      <span class="hljs-comment">// 返回不足值</span><br>    <span class="hljs-built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);<br>    rp-&gt;rio_bufptr += cnt;<br>    rp-&gt;rio_cnt -= cnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="rio-readlineb"><a href="#rio-readlineb" class="headerlink" title="rio_readlineb()"></a>rio_readlineb()</h3><p>读取一行，最多读取maxlen-1个字节，最后一个字节要填充<code>&#39;\0&#39;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> maxlen)</span><br>&#123;<br>    <span class="hljs-type">int</span> n, rc;    <span class="hljs-comment">// n 程序读取字节数， rc 单次rio_read 的返回值</span><br>    <span class="hljs-type">char</span> c, *bufp = usrbuf;    <span class="hljs-comment">// c一个临时变量，用于逐个读取，测试是否为换行</span><br><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">1</span>; n &lt; maxlen; n++) &#123;<br>        <span class="hljs-keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="hljs-number">1</span>)) == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 正常</span><br>            *bufp++ = c;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                n++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 返回不足值</span><br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// EOF，什么字节也没读取，直接返回0</span><br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// EOF, 但已经读取了一些字节，需要处理后返回</span><br>        &#125; <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">// 未知错误</span><br>    &#125;<br><br>    *bufp = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 最后一位用 &#x27;\0&#x27; 填充</span><br>    <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="rio-readnb"><a href="#rio-readnb" class="headerlink" title="rio_readnb()"></a>rio_readnb()</h3><p>rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp, <span class="hljs-type">void</span> *usrbuf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-type">size_t</span> nleft = n;   <span class="hljs-comment">// bytes that has not been read</span><br>    <span class="hljs-type">ssize_t</span> nread;      <span class="hljs-comment">// read() func had read nread bytes</span><br>    <span class="hljs-type">char</span> *bufp = usrbuf;<br><br>    <span class="hljs-comment">// nleft != 0</span><br>    <span class="hljs-keyword">while</span> (nleft &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">// someting wrong</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <span class="hljs-comment">// unknown error</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// EOF</span><br>        nleft -= nread;<br>        usrbuf += nread;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n - nleft;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br></code></pre></td></tr></table></figure>
<p><code>stat()</code> 函数以文件名作为输入，填写<code>struct stat *buf</code>  </p>
<p>我们只对<code>struct stat</code> 的一些条目感兴趣：</p>
<ul>
<li><p><code>buf-&gt;st_size</code> 文件的大小</p>
</li>
<li><p><code>buf-&gt;st_mode</code> 使用在<code>sys/stat.h</code> 的三个宏可以判断文件类型：</p>
<p><code>S_ISREG(mode)</code> 这是一个普通文件吗？</p>
<p><code>S_ISDIR(mode)</code> 这是一个目录文件吗？</p>
<p><code>S_ISSOCK(mode)</code> 这是一个网络套接字吗？</p>
</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-keyword">struct</span> dirent * <span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    <span class="hljs-type">ino_t</span> d_ino;      <span class="hljs-comment">// inode number 文件位置</span><br>    <span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>];    <span class="hljs-comment">// Filename		文件名</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="IO重定位"><a href="#IO重定位" class="headerlink" title="IO重定位"></a>IO重定位</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-title-link" itemprop="url">虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 11:03:22 / 修改时间：11:27:16" itemprop="dateCreated datePublished" datetime="2022-09-17T11:03:22+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟内存视角下的Linux进程-amp-动态内存分配"><a href="#虚拟内存视角下的Linux进程-amp-动态内存分配" class="headerlink" title="虚拟内存视角下的Linux进程 &amp; 动态内存分配"></a>虚拟内存视角下的Linux进程 &amp; 动态内存分配</h1><h2 id="Linux的虚拟内存系统"><a href="#Linux的虚拟内存系统" class="headerlink" title="Linux的虚拟内存系统"></a>Linux的虚拟内存系统</h2><p>Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分：</p>
<ul>
<li>进程虚拟内存部分</li>
<li>内核虚拟内存部分</li>
</ul>
<p>进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>用户栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rsp →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>共享库的内存映射区域</td>
</tr>
<tr>
<td>brk →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>运行时的堆（通过malloc分配的）</td>
</tr>
<tr>
<td></td>
<td>未初始化的数据(.bss)</td>
</tr>
<tr>
<td></td>
<td>已初始化的数据(.data)</td>
</tr>
<tr>
<td>0x400000 →</td>
<td>代码(.text)</td>
</tr>
</tbody>
</table>
</div>
<p>内核虚拟内存可分为两部分：</p>
<ul>
<li>内核中的代码和数据及数据结构</li>
<li>被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>与进程相关的数据结构（页表、task和mm结构、内核栈）</th>
<th>每个进程都不相同</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理内存</td>
<td>每个进程都相同</td>
</tr>
<tr>
<td>内核代码和数据</td>
<td>每个进程都相同</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171118039.png" alt="image-20220917111815524"></p>
<h2 id="Linux如何组织虚拟内存"><a href="#Linux如何组织虚拟内存" class="headerlink" title="Linux如何组织虚拟内存"></a>Linux如何组织虚拟内存</h2><p>Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段</p>
<p>这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap）</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171117123.png" alt="image-20220917111745313"></p>
<h2 id="用户级内存映射"><a href="#用户级内存映射" class="headerlink" title="用户级内存映射"></a>用户级内存映射</h2><p>Linux 可以使用<code>mmap</code>函数来创建新的虚拟内存，并将对象映射到这些区域中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">prot:</span><br><span class="hljs-comment">PROT_EXEC  该页面的区域可以被执行</span><br><span class="hljs-comment">PROT_READ  该页面区域可读</span><br><span class="hljs-comment">PROT_WRITE  ... 可写</span><br><span class="hljs-comment">PROT_NONE  ... 不能被访问</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">flags:</span><br><span class="hljs-comment">MAP_ANON    被映射的对象是一个匿名对象</span><br><span class="hljs-comment">MAP_PRIVATE    是一个私有对象，使用写时复制机制</span><br><span class="hljs-comment">MAP_SHARE    是一个共享对象</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length)</span>; <span class="hljs-comment">// 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误</span><br></code></pre></td></tr></table></figure>
<p>例子：将任意磁盘文件赋值到<code>stdout</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csapp.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mmapcopy</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> size)</span><br>&#123;<br>    <span class="hljs-type">char</span> *bufp;<br><br>    <span class="hljs-comment">// load to virtual memory</span><br>    bufp = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>    Write(STDOUT_FILENO, bufp, size);   <span class="hljs-comment">// write to stdout</span><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">stat</span>;</span><br>    <span class="hljs-type">int</span> fd;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// open file </span><br>    fd = Open(argv[<span class="hljs-number">1</span>], O_RDONLY, <span class="hljs-number">0</span>);<br>    fstat(fd, &amp;stat);   <span class="hljs-comment">// get detailed message of file</span><br>    mmapcopy(fd, stat.st_size);     <span class="hljs-comment">// call mmapcopy</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">异常控制流 - CS:APP 第8章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-12 09:48:49" itemprop="dateCreated datePublished" datetime="2022-09-12T09:48:49+08:00">2022-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:15:19" itemprop="dateModified" datetime="2022-09-25T22:15:19+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常控制流-CS-APP-第8章"><a href="#异常控制流-CS-APP-第8章" class="headerlink" title="异常控制流 - CS:APP 第8章"></a>异常控制流 - CS:APP 第8章</h1><blockquote>
<p>这一章更多的是实践，理论的部分实在不多</p>
</blockquote>
<p>本文将介绍：</p>
<ol>
<li>常见的异常</li>
<li>(Linux)部分并发编程</li>
</ol>
<p>一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。</p>
<h2 id="异常及其分类"><a href="#异常及其分类" class="headerlink" title="异常及其分类"></a>异常及其分类</h2><ol>
<li><p>中断 (interrupt) : 异步发生，是来自处理器外部I/O设备的信号的结果</p>
</li>
<li><p>陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过<code>syscall</code> 指令，造成一个到异常处理程序的陷阱。</p>
<p>系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式</p>
</li>
<li><p>故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页</p>
</li>
<li><p>终止 (abort)：不可恢复的错误。</p>
</li>
</ol>
<h2 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h2><p>进程的定义：一个执行中的程序实例</p>
<p>进程提供给程序两个抽象的概念：</p>
<ol>
<li>一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。</li>
</ol>
<p>区分并发和并行：</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>获取进程id</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 在linux上，pid_t 被定义为 int</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">// 获取当前进程pid</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">// 获得父进程pid</span><br></code></pre></td></tr></table></figure>
<p>进程只有三种状态：</p>
<ol>
<li>运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。</li>
<li>暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。)</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：<ol>
<li>收到一个信号，该信号的默认行为是终止进程</li>
<li>从主程序返回</li>
<li>调用exit函数。</li>
</ol>
</li>
</ol>
<p>创建进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）</span><br><span class="hljs-comment">子进程与父进程的虚拟地址空间相同，文件描述符相同</span><br><span class="hljs-comment">该函数返回两次：</span><br><span class="hljs-comment">在父进程中返回创建子进程的pid</span><br><span class="hljs-comment">在子进程中返回0</span><br><span class="hljs-comment">可以依此区分两个进程</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>回收僵死进程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *statusp, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pid 等待集合</span><br><span class="hljs-comment">  pid &gt; 0 一个单独的子进程</span><br><span class="hljs-comment">  pid = -1 父进程的所有子进程</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">statusp 导致返回的状态信息</span><br><span class="hljs-comment">options 选项</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">return :</span><br><span class="hljs-comment">成功回收：回收进程的pid</span><br><span class="hljs-comment">WNOHANG 返回0</span><br><span class="hljs-comment">其他错误 -1 (例如没有子进程)：</span><br><span class="hljs-comment">如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD</span><br><span class="hljs-comment">如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">典型用法：waitpid(-1, NULL, 0);</span><br><span class="hljs-comment">挂起该进程，等待该进程的子进程终止，回收该僵死进程</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *statusp)</span>; <span class="hljs-comment">// 等价于waitpid(-1, &amp;statusp, 0);</span><br></code></pre></td></tr></table></figure>
<p>让进程休眠：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;    <span class="hljs-comment">// 挂起进程secs秒，如果因为信号中断则会提前返回</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;      <span class="hljs-comment">// 挂起进程，因为进程中断会提前返回</span><br></code></pre></td></tr></table></figure>
<p>加载并运行程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// filename 可执行文件路径，argv参数列表，envp环境变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[], <span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">execve调用一次，从不返回，除非找不到可执行文件文件</span><br><span class="hljs-comment">argv/envp 指向以NULL结尾的指针数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">特别强调：</span><br><span class="hljs-comment">通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种软件层次的异常</p>
<p>发送信号的两个原因：</p>
<ol>
<li>内核检测到一个系统事件，如子进程终止，发送SIGCHLD</li>
<li>一个进程显式地调用了kill函数，向某个进程发送了信号</li>
</ol>
<p>一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此：</p>
<blockquote>
<p>当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。</p>
</blockquote>
<p>为了能方便向大量进程发送信号，Linux提供了进程组这个概念。</p>
<p>进程组相关：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgrp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">// 获取当前进程的进程组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;    <span class="hljs-comment">// 设置pid的进程组</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果pid为0，则设置当前的进程</span><br><span class="hljs-comment">如果pgid为0，则用pid指定的PID作为进程组id</span><br><span class="hljs-comment">setpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>发送信号</p>
<ol>
<li><p><code>/bin/kill</code> 程序可以手动发送信号</p>
</li>
<li><p>在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。</p>
</li>
<li>kill函数</li>
<li>alarm函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span>;<br><span class="hljs-comment">// secs秒后，发送一个SIGALRM信号给调用进程</span><br></code></pre></td></tr></table></figure>
<p>接受处理信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, sighandler handler)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：</span><br><span class="hljs-comment">1. 如果handler是SG_IGN,那么忽略类型为signum的信号。</span><br><span class="hljs-comment">2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。</span><br><span class="hljs-comment">3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>阻塞 &amp; 解除阻塞信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, sigset *oldset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于sigprocmask的how，有三个选项：</span><br><span class="hljs-comment">SIG_BLOCK    将set中的信号添加到阻塞集合</span><br><span class="hljs-comment">SIG_UNBLOCK    将set中的信号从阻塞信号中删除</span><br><span class="hljs-comment">SIG_SETMASK    将block = set</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>非本地跳转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> savesigs)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">longjmp</span><span class="hljs-params">(jmp_buf env, <span class="hljs-type">int</span> retval)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">siglongjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> retrval)</span>;<br></code></pre></td></tr></table></figure>
<h2 id="附：Linux-配置CSAPP库"><a href="#附：Linux-配置CSAPP库" class="headerlink" title="附：Linux 配置CSAPP库"></a>附：Linux 配置CSAPP库</h2><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435">https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76930507">https://zhuanlan.zhihu.com/p/76930507</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jakejohn/article/details/79825086">https://blog.csdn.net/jakejohn/article/details/79825086</a></p>
<p>第三版CSAPP库 代码下载：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/code.html">http://csapp.cs.cmu.edu/3e/code.html</a></p>
</blockquote>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到     <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>抢占(preempted) 暂时挂起</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>挂起(suspended) </p>
<p>阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" class="post-title-link" itemprop="url">模电课程 - 大学课程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-10 12:17:18" itemprop="dateCreated datePublished" datetime="2022-09-10T12:17:18+08:00">2022-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-20 17:56:34" itemprop="dateModified" datetime="2022-12-20T17:56:34+08:00">2022-12-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="电工学"><a href="#电工学" class="headerlink" title="电工学"></a>电工学</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>基尔霍夫电压定理</p>
<p>基尔霍夫电流定理</p>
<p>结点电压法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341727367">第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com)</a> </p>
<p>回路电流法：</p>
<p>叠加定理：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1662486398509859685&amp;wfr=spider&amp;for=pc">电学基础理论之叠加定理 (baidu.com)</a> </p>
<p>戴维南等效电路</p>
<p>二极管：</p>
<p>正向压降 ： 正向通过后，电压的减小量。</p>
<p>二极管的功能：</p>
<ol>
<li><p>钳位</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/钳位二极管/6307364?fr=aladdin">钳位二极管_百度百科 (baidu.com)</a> </p>
</li>
<li><p>隔离</p>
</li>
<li><p>稳压 ： 见下面稳压二极管视频</p>
</li>
</ol>
<p>稳压二极管：</p>
<blockquote>
<p>详见视频： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qY4y1t7sc">https://www.bilibili.com/video/BV1qY4y1t7sc</a></p>
<p>详见P15页笔记</p>
</blockquote>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li><p>电压源</p>
<p>理想的电压源内阻为0，输出电压<code>U = E - IR0</code>, R0 = 0，因此输出电压恒定不变。当内阻远小于外电阻时，可近似看作理想电压源。</p>
</li>
<li><p>电流源</p>
<p>理想电流源的内阻为无穷大，因此输出的电流I = I~S~ - U / R ，恒定不变。</p>
</li>
</ul>
<h2 id="第十四章-半导体器件"><a href="#第十四章-半导体器件" class="headerlink" title="第十四章 半导体器件"></a>第十四章 半导体器件</h2><h3 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h3><ul>
<li><p>导通电压：</p>
<p>硅管：0.5V</p>
<p>锗管：0.1V</p>
</li>
<li><p>正向压降</p>
<p>硅管：0.6 ~ 0.8 V</p>
<p>锗管：0.2 ~ 0.3 V</p>
</li>
<li><p>主要参数</p>
<p>最大整流电流 I~OM~ : 长时间使用所允许通过的最大正向平均电流</p>
<p>反向工作峰值电压 U~RWM~ : 保证二极管不被击穿而给出的反向峰值电压，一般是反向击穿电压的1/2或2/3。</p>
<p>反向峰值电流 I~RM~ ：在U~RWM~ 下的电流</p>
</li>
<li><p>作用</p>
<ol>
<li>整流</li>
<li>限伏/钳位</li>
<li>隔离：两个二极管并联，某个二极管的电压高，则它优先导通。因而电压低的那一个二极管被隔离了。</li>
</ol>
</li>
</ul>
<h3 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h3><ol>
<li>使用稳压二极管时一定要有限流电阻R，不然二极管必定会被烧坏。</li>
<li>稳压二极管的工作原理：当电源电压升高，使得稳压二极管两侧电压有升高的趋势时，此时稳压二极管的电阻升高，电流增大，引起干路限流电阻的电流增加，限流电阻的电阻不变，因此限流电阻的分压增大，抵消了电源增加的电压。</li>
<li>在分析使用稳压二极管之前，假设二极管尚未反向导通，先判断二极管两侧的电压，只有二极管反向击穿时，才能有稳压的效果。</li>
</ol>
<h3 id="三极管"><a href="#三极管" class="headerlink" title="三极管"></a>三极管</h3><ul>
<li>放大区，I~E~ = I~C~ + I~B~ , I~C~ = β I~B~ ，发射结正偏，集电结反偏。</li>
<li>截止区，I~C~ = 0, U~CE~ = U~CC~ ， 约等于断开，此时 I~B~ = 0或以下</li>
<li>饱和区，此时I~B~ 和I~C~ 关系很小，I~C~ = U~CC~ / R~C~ , U~CE~ = 0, 相当于短路</li>
<li><p>如何判断三极管的工作状态？</p>
<ol>
<li>求出 I~C~ ~Maximun~  = (Vcc - U~CE~)  / R~C~</li>
<li>求出 I~B~ </li>
<li>若βI~B~ &gt; I~CMaximun~ 饱和</li>
<li>否则处于放大区</li>
</ol>
</li>
<li><p>参数</p>
<p>硅管 U~BE~ = 0.6 ~ 0.7 V    </p>
<p>β 杠 ： 静态电流放大系数</p>
<p>β：动态电流放大系数</p>
<p>I~CBO~ </p>
<p>I~CEO~ </p>
<p>I~CM~ 集电极允许的最大电流，超过它放大系数将会下降</p>
<p>U~（BR）CEO~ </p>
</li>
</ul>
<ul>
<li>如果U~CE~ 固定，那么随着I~B~ 的增加，三极管的工作状态会慢慢从放大状态转为过饱和状态。</li>
</ul>
<h2 id="第十五章-基本放大电路"><a href="#第十五章-基本放大电路" class="headerlink" title="第十五章 基本放大电路"></a>第十五章 基本放大电路</h2><p>放大电路的输入电阻：输入电路的等效负载电阻</p>
<p>放大电路的输出电阻：输出电路的等效内阻</p>
<h3 id="共发射极放大电路（固定偏置放大电路）"><a href="#共发射极放大电路（固定偏置放大电路）" class="headerlink" title="共发射极放大电路（固定偏置放大电路）"></a>共发射极放大电路（固定偏置放大电路）</h3><p>(名字来源：因为偏置电路是固定的)</p>
<p>输入: U~I~或者I~B~ 或U~BE~ </p>
<p>输出：U~O~ (U~CE~ 的交流分量 阻容耦合)</p>
<p>静态值是指</p>
<ul>
<li>I~B~</li>
<li>I~C~</li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~</li>
</ul>
<p>静态值的直接求解法：</p>
<ul>
<li>I~B~ ： (U~CC~ - U~BE~ ) / R~B~ </li>
<li>I~C~ ： βI~B~ </li>
<li>U~BE~ ：一般是 0.6 V(硅管是0.6 ~ 0.7)</li>
<li>U~CE~ : U~CC~ - R~C~ I~C~ </li>
</ul>
<p>静态值得图解法：</p>
<ul>
<li>三极管的输出特性曲线是I~C~ - U~CE~ (y - x) 因此，只要求出I~C~ = f(U~CE~ ) 即可</li>
<li>由U~CE~ =  U~CC~ - R~C~ I~C~ 因此只要求出U~CC~ 和 R~C~ 即可</li>
</ul>
<p>偏置电路是指产生偏流I~B~ 的电路，偏置电阻是指限流I~B~的电阻 </p>
<h3 id="非线性失真"><a href="#非线性失真" class="headerlink" title="非线性失真"></a>非线性失真</h3><p>原因：静态工作点不合适 或 信号太大</p>
<p>分类</p>
<ul>
<li>截止失真 : 静态工作点位置太低，输入产生的I~B~ 在负半周截止了，导致输出的IC也截止了（负半周），导致U~CE~ 的正半周截止了</li>
<li>饱和失真 ： 静态工作点位置太高，输出的I~C~ 在正半周饱和，导致输出的U~CE~ 在负半周失真。</li>
</ul>
<p>什么可以影响静态工作点：</p>
<p>最直接的因素是I~C~，可以影响I~C~的因素都可以影响静态工作点 </p>
<h3 id="静态工作点的稳定"><a href="#静态工作点的稳定" class="headerlink" title="静态工作点的稳定"></a>静态工作点的稳定</h3><h4 id="分压式偏置放大电路"><a href="#分压式偏置放大电路" class="headerlink" title="分压式偏置放大电路"></a>分压式偏置放大电路</h4><h3 id="射级输出器"><a href="#射级输出器" class="headerlink" title="射级输出器"></a>射级输出器</h3><p>输入电阻大：对内阻高的信号源很有意义</p>
<p>输出电阻小：具有恒压输出的特性，带负载能力较强</p>
<p>一般用于多级放大电路的输入级或输出级或者多级之间的缓冲级/隔离级</p>
<h2 id="第十六章-集成运算放大器"><a href="#第十六章-集成运算放大器" class="headerlink" title="第十六章 集成运算放大器"></a>第十六章 集成运算放大器</h2><h3 id="集成运放的组成"><a href="#集成运放的组成" class="headerlink" title="集成运放的组成"></a>集成运放的组成</h3><ul>
<li><p>输入极</p>
<p>输入极要求输入电阻高，静态电流小，差模放大倍数高，抑制零点漂移和共模干扰信号强，输入极都采用差分放大电路。</p>
</li>
<li><p>中间级</p>
<p>进行电压放大，要求电压放大倍数高，一般采用共发射极放大电路</p>
</li>
<li><p>输出级</p>
<p>要求输出电阻低，带负载能力强，一般由互补功率放大电路或射级输出器构成</p>
</li>
<li><p>偏置电路</p>
<p>为上述个电路提供稳定合适的偏置电流，决定各级的静态工作点，一般由各种恒流源电路组成。</p>
</li>
</ul>
<h3 id="理想运放"><a href="#理想运放" class="headerlink" title="理想运放"></a>理想运放</h3><p>开环电压放大倍数 ∞</p>
<p>差模输入电阻 ∞</p>
<p>开环输出电阻 0</p>
<ul>
<li><p>工作在线性区</p>
<p>虚断：由于差模输入电阻为∞，可以认为两个输入端的电流 i~+~ = i~-~  = 0</p>
<p>虚短：由于开环电压放大倍数 ∞，可以认为 u~+~ = u~-~ </p>
<ul>
<li>虚地，如果由于虚短，如果两个输入端有一个接地，相当于另一个也接地</li>
</ul>
</li>
<li><p>工作在饱和区</p>
<p>虚断：仍然存在</p>
<p><del>虚短</del>：此时工作在饱和区，不能满足在线性区的放大关系，因此，两个输入端的电压不必相等，虚短不存在</p>
<p>u+ &gt; u- : uo = + Uo(sat)</p>
<p>u+ &lt; u- : uo = - Uo(sat)</p>
</li>
</ul>
<h3 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h3><ul>
<li><p>反向比例运算</p>
<p>运放工作在线性区</p>
<p>只要运放的开环放大倍数很高，比例运算的放大能力就只与外接电阻有关</p>
<p>这个放大倍数就是闭环放大倍数</p>
<p>Uo = -(R~F~ / R1) U1</p>
</li>
<li><p>正向比例运算</p>
<p>电压从正向端输入</p>
<p>放大比例也只与外接电阻有关</p>
<p>Uo = (1 + R~F~ / R1) U1</p>
</li>
<li><p>加法运算</p>
<p>Uo = -[(R~F~/R~11~)U~11~ + (R~F~/R~12~)U~12~ + (R~F~/R~13~)U~13~]</p>
<p>Uo = -(R~F~ / R1)(U11 + U12 + U13)</p>
</li>
<li><p>减法运算</p>
<p>Uo = (1 + R~F~ / R~1~ ) (R~3~ / (R1 + R2)) U12 - R~F~ / R~1~ U11</p>
<p>当R1 = R2, R2 = R~F~ </p>
<p>Uo = R~F~ / R~1~(U12 - U11)</p>
<p>当 R1 = R2 = R2 = R~F~ </p>
<p>Uo = U12 - U11</p>
</li>
</ul>
<h2 id="第十七章-电子电路中的反馈"><a href="#第十七章-电子电路中的反馈" class="headerlink" title="第十七章 电子电路中的反馈"></a>第十七章 电子电路中的反馈</h2><p>反馈的模态判断：</p>
<p>反馈信号与输入信号在</p>
<ul>
<li>相同端子上（并联）<ul>
<li>极性相同：正反馈</li>
<li>极性相反：负反馈</li>
</ul>
</li>
<li>相异端子上（串联）<ul>
<li>极性相同：负反馈</li>
<li>极性相反：正反馈</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何判断反馈是电压反馈还是电流反馈？</p>
<p>将输出电压U~O~ 置零，看是否还存在反馈？</p>
<ul>
<li>存在：电流反馈</li>
<li>不存在：电压反馈</li>
</ul>
</li>
<li><p>负反馈对输入输出电阻的影响：</p>
<p>电压负反馈使得输出有电压源的特性，因此电压负反馈可以降低输出电阻ro</p>
<p>电流负反馈使得输出有电流源的特性，因此电流负反馈可以增高输出电阻ro</p>
<p>串联反馈可以增大输入电阻ri</p>
<p>并联反馈可以减小输入电阻ri</p>
</li>
<li><p>负反馈可以减小波形失真，但不能完全消除波形失真</p>
</li>
<li><p>引入负反馈之后可以降低放大倍数</p>
</li>
<li><p>引入负反馈可以提高放大倍数的稳定性</p>
</li>
</ul>
<h2 id="第十八章-直流稳压电源"><a href="#第十八章-直流稳压电源" class="headerlink" title="第十八章 直流稳压电源"></a>第十八章 直流稳压电源</h2><h3 id="整流"><a href="#整流" class="headerlink" title="整流"></a>整流</h3><ul>
<li><p>单相半波整流</p>
<p>变压器的输出（整流电路输入的交流电压，变压器的二次电压）为 u = √2Usin wt (U为交流电压的有效值，也叫变压器的二次电压有效值)</p>
<p>整流电压的平均值 U~O~ = 0.45U</p>
<p>整流电流（负载电流）的平均值 I~O~ = U~O~ / R~L~ = 0.45U/R~L~ </p>
<p>整流元件截止时的最高反向电压 U~RM~ = √2U (并不是元件能承受的最大电压，元件能承受的最大反向电压要看元件自己的参数)</p>
</li>
<li><p>单相全波整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~ </p>
<p>I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = 2√2U</p>
</li>
<li><p>三相半波</p>
<p>U~O~ = 1.17U</p>
<p>I~O~ =  1.17U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45U</p>
</li>
<li><p>单向桥式整流</p>
<p>U~O~ = 0.9U</p>
<p>I~O~ = 0.9U/R~L~</p>
<p>每个二极管中流过的平均电流 I~D~ = (1/2)I~O~ = 0.45U/R~L~ </p>
<p>U~RM~ = √2U</p>
<blockquote>
<p>变压器的变比K = 交流电源电压 / 二次电压有效值</p>
<p>变压器容量 S = UI = 变压器二次电压有效值 * 变压器二次电流有效值</p>
</blockquote>
</li>
<li><p>三相桥式整流</p>
<p>U~O~ = 2.34U</p>
<p>I~O~ = 2.34U/R~L~ </p>
<p>I~D~ = (1/3)I~O~  </p>
<p>U~RM~ = 2.45 U</p>
</li>
</ul>
<h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><ul>
<li><p>电容滤波器</p>
<p>U~O~ = 1.2U</p>
<p>对滤波电容，一般要求</p>
<p>R~L~ C &gt;= (3~5)T/2</p>
</li>
<li><p>电感电容滤波（LC滤波）</p>
<p>适用于电流较大、要求输出电压脉动很小的场合，用于高频时更加合适</p>
</li>
</ul>
<h3 id="直流稳压电源"><a href="#直流稳压电源" class="headerlink" title="直流稳压电源"></a>直流稳压电源</h3><ul>
<li><p>稳压二极管稳压电路</p>
<p>一般交流电压经过整流（桥式整流）和滤波之后，得到的直流电仍存在波动，此时需要进行稳压</p>
<p>引起负载电压变化的原因有二：</p>
<ol>
<li>交流电源电压的变化</li>
<li>负载电流的变化</li>
</ol>
<p>可以对负载电阻，先串联一个保护电阻，在并联一个稳压二极管，稳压二极管通过提高或减小电流，是的保护电阻承担增大或减少的电压。</p>
<p>选取稳压二极管时，一般取：</p>
<ul>
<li><p>U~Z~ = U~O~ （U~Z~ 为稳压二极管的稳定电压，Uo为输出的负载电压）</p>
</li>
<li><p>I~ZM~ = (1.5~3) I~OM~ （I~ZM~ 为最大稳压电流，I~OM~ 为负载电流的最大值） </p>
</li>
<li>U~1~ = (2~3) U~O~ (其中U~1~ 是经过整流 滤波后的输出电压，也就是稳压部分的输入电压，即需要被稳压的部分)</li>
</ul>
</li>
<li><p>集成三端稳压电源</p>
<p>W78XX（输出固定正电压），W79XX（输出固定负电压），W117/217/317（输出电压可调）</p>
<p>有三个引脚，分别是输入端I，输出端O，地段GND</p>
<p>使用时需要在其输入端，输出端，地段并联一个电容</p>
</li>
</ul>
<p>  几种典型的电路：</p>
<ol>
<li>正负电压同时输出的电路</li>
<li>输出电压可调的电路<ol>
<li>用集成运放 + W78XX/W79XX</li>
<li>用W117/217/317</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-title-link" itemprop="url">链接 - CS:APP 第七章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 19:47:36" itemprop="dateCreated datePublished" datetime="2022-09-07T19:47:36+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-23 12:37:32" itemprop="dateModified" datetime="2022-09-23T12:37:32+08:00">2022-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>本文将介绍：</p>
<ul>
<li>编译的过程</li>
<li>三种目标文件</li>
<li>三种链接和链接的过程</li>
</ul>
<h2 id="1-编译的过程"><a href="#1-编译的过程" class="headerlink" title="1 编译的过程"></a>1 编译的过程</h2><ol>
<li><p>源文件（.c /.cpp）经过翻译，形成可重定位目标文件（.o）</p>
<p>具体过程：</p>
<p>预处理</p>
<p><code>cpp main.c -o main.i</code> 或 <code>gcc -E -o main.c main.c</code> </p>
<p>编译器 ：翻译成汇编语言</p>
<p><code>cc1 或 cc main.i -o main.s</code> 或 <code>gcc -S -o main.s main.c</code></p>
<p>汇编器 ：形成可重定位目标文件</p>
<p><code>as [args] -o main.o</code> 这中间参数很多，</p>
<p>如果向直接到这一步可以使用 <code>gcc -c -o main.o main.c</code> </p>
</li>
<li><p>链接器 链接形成可执行目标文件</p>
<p><code>ld -o prog main.o other.o</code> 或 <code>gcc -o prog main.o other.o</code> </p>
</li>
</ol>
<p>如果想要一步一步生成<code>.i</code> <code>.s</code> <code>.o</code> 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。</p>
<p>除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 <code>-E</code> <code>-S</code> <code>-c</code> 参数进行编译。</p>
<blockquote>
<p>顺带一提，在bash中，可以通过 <code>echo $?</code> 来展示上一次程序退出的返回值</p>
</blockquote>
<h2 id="2-三种目标文件"><a href="#2-三种目标文件" class="headerlink" title="2 三种目标文件"></a>2 三种目标文件</h2><p>首先，什么是目标文件？</p>
<blockquote>
<p>计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。</p>
<p>——360百科</p>
</blockquote>
<p>目标文件可以分为三类：</p>
<ol>
<li>可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。</li>
<li>可执行目标文件 ： 可以被复制到内存中执行。</li>
<li>共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接</li>
</ol>
<p>window系统使用<code>PE portable Executable</code> 格式</p>
<p>Linux使用 <code>Executable and Linkable Format, ELF</code>格式  </p>
<h3 id="2-1-可重定位目标文件格式"><a href="#2-1-可重定位目标文件格式" class="headerlink" title="2.1 可重定位目标文件格式"></a>2.1 可重定位目标文件格式</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209091204533.png" alt="image-20220909120357886"> </p>
<p>可重定位目标文件 以ELF头开始，通过<code>readelf -a main.o</code> 我们可以看到ELF头的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">ELF 头：<br>  Magic：   <span class="hljs-number">7f</span> <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">46</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  类别:                              ELF64<br>  数据:                              <span class="hljs-number">2</span> 补码，小端序 (little endian)<br>  Version:                           <span class="hljs-number">1</span> (current)<br>  OS/ABI:                            UNIX - System V<br>  ABI 版本:                          <span class="hljs-number">0</span><br>  类型:                              REL (可重定位文件)<br>  系统架构:                          Advanced Micro Devices X86<span class="hljs-number">-64</span><br>  版本:                              <span class="hljs-number">0x1</span><br>  入口点地址：               <span class="hljs-number">0x0</span><br>  程序头起点：          <span class="hljs-number">0</span> (bytes into file)<br>  Start of section headers:          <span class="hljs-number">1040</span> (bytes into file)<br>  标志：             <span class="hljs-number">0x0</span><br>  Size of this header:               <span class="hljs-number">64</span> (bytes)<br>  Size of program headers:           <span class="hljs-number">0</span> (bytes)<br>  Number of program headers:         <span class="hljs-number">0</span><br>  Size of section headers:           <span class="hljs-number">64</span> (bytes)<br>  Number of section headers:         <span class="hljs-number">13</span><br>  Section header <span class="hljs-built_in">string</span> table index: <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>
<p>可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。</p>
<p>我倾向于认为这是节头部表的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">节头：<br>  [号] 名称              类型             地址              偏移量<br>       大小              全体大小          旗标   链接   信息   对齐<br>  [ <span class="hljs-number">0</span>]                   <span class="hljs-literal">NULL</span>             <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000000</span><br>       <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>           <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span><br>  [ <span class="hljs-number">1</span>] .text             PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000040</span><br>       <span class="hljs-number">0000000000000025</span>  <span class="hljs-number">0000000000000000</span>  AX       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br>  [ <span class="hljs-number">2</span>] .rela.text        RELA             <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000358</span><br>       <span class="hljs-number">0000000000000030</span>  <span class="hljs-number">0000000000000018</span>   I      <span class="hljs-number">10</span>     <span class="hljs-number">1</span>     <span class="hljs-number">8</span><br>  [ <span class="hljs-number">3</span>] .data             PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000068</span><br>       <span class="hljs-number">0000000000000010</span>  <span class="hljs-number">0000000000000000</span>  WA       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">8</span><br>  [ <span class="hljs-number">4</span>] .bss              NOBITS           <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000078</span><br>       <span class="hljs-number">000000000000000</span>c  <span class="hljs-number">0000000000000000</span>  WA       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">4</span><br>  [ <span class="hljs-number">5</span>] .comment          PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000078</span><br>       <span class="hljs-number">000000000000002</span>c  <span class="hljs-number">0000000000000001</span>  MS       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br>  [ <span class="hljs-number">6</span>] .note.GNU-<span class="hljs-built_in">stack</span>   PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>a4<br>       <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>           <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br>  [ <span class="hljs-number">7</span>] .note.gnu.propert NOTE             <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>a8<br>       <span class="hljs-number">0000000000000020</span>  <span class="hljs-number">0000000000000000</span>   A       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">8</span><br>  [ <span class="hljs-number">8</span>] .eh_frame         PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>c8<br>       <span class="hljs-number">0000000000000038</span>  <span class="hljs-number">0000000000000000</span>   A       <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">8</span><br>  [ <span class="hljs-number">9</span>] .rela.eh_frame    RELA             <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000388</span><br>       <span class="hljs-number">0000000000000018</span>  <span class="hljs-number">0000000000000018</span>   I      <span class="hljs-number">10</span>     <span class="hljs-number">8</span>     <span class="hljs-number">8</span><br>  [<span class="hljs-number">10</span>] .symtab           SYMTAB           <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000100</span><br>       <span class="hljs-number">00000000000001</span>c8  <span class="hljs-number">0000000000000018</span>          <span class="hljs-number">11</span>    <span class="hljs-number">12</span>     <span class="hljs-number">8</span><br>  [<span class="hljs-number">11</span>] .strtab           STRTAB           <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000002</span>c8<br>       <span class="hljs-number">0000000000000090</span>  <span class="hljs-number">0000000000000000</span>           <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br>  [<span class="hljs-number">12</span>] .shstrtab         STRTAB           <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000003</span>a0<br>       <span class="hljs-number">000000000000006</span>c  <span class="hljs-number">0000000000000000</span>           <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。</p>
<p>一个典型的ELF可重定位目标文件包含下面的节：</p>
<p><code>.text</code> : 已编译的机器代码</p>
<p><code>.rodata</code> : read only data 只读数据，如printf的格式字符串</p>
<p><code>.data</code> : 已初始化的全局和静态变量</p>
<p><code>.bss</code> : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节）</p>
<p><code>.symtab</code> ：符号表</p>
<p><code>rel.text</code> ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量</p>
<p><code>.rel.data</code></p>
<p><code>.debug</code> ：调试信息</p>
<p><code>.line</code> ：调试时的行号</p>
<p><code>strtab</code> ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字</p>
<h4 id="2-1-1-符号表"><a href="#2-1-1-符号表" class="headerlink" title="2.1.1 符号表"></a>2.1.1 符号表</h4><p>符号表的条目格式是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> name;    <span class="hljs-comment">// 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c</span><br>    <span class="hljs-type">char</span> type:<span class="hljs-number">4</span>,  <span class="hljs-comment">// 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ...</span><br>       binding:<span class="hljs-number">4</span>;	<span class="hljs-comment">// 全局变量还是本地变量 GLOBAL OR LOCAL</span><br>    <span class="hljs-type">char</span> reserved;  <span class="hljs-comment">// 保留的，未使用</span><br>    <span class="hljs-type">short</span> section;  <span class="hljs-comment">// 在ubuntu 上的名字是Ndx,指明该符号是在那个section的</span><br>    <span class="hljs-type">long</span> value;    <span class="hljs-comment">// 距离节section 起始位置的字节偏移</span><br>    <span class="hljs-type">long</span> size;    <span class="hljs-comment">// 该符号最小的大小</span><br>&#125; Elf64_Symbol;<br></code></pre></td></tr></table></figure>
<p>对于section 字段，在<code>ubuntu</code> 的<code>readelf</code> 命令中，显示为 Ndx。</p>
<p>该字段有三个伪节，他们分别是 <code>UNDEF</code> <code>COMMON</code> <code>ABS</code> 。</p>
<p><code>ABS</code> ：代表不改被重定位的符号</p>
<p><code>UNDEF</code> ：代表未定义的符号，即在本模块引用却在其他模块定义的符号</p>
<p><code>COMMON</code> ：还未被分配位置的未初始化的数据目标</p>
<p><code>COMMON</code> 和 <code>.bss</code> 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到<code>COMMON</code> 和<code>.bss</code></p>
<p><code>COMMON</code> ：未初始化的全局变量</p>
<p><code>.bss</code> ：未初始化的静态变量，以及初始化为0的全局或静态变量</p>
<p>下面我们通过一个程序来展示以下ubuntu 中的符号表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> * a, <span class="hljs-type">int</span> n)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-type">int</span> global_not_init;<br><span class="hljs-type">int</span> global_init = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> global_init_zero = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stat_not_init;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stat_init_zero = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stat_init = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">int</span> val = sum(<span class="hljs-built_in">array</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们生成可重定位的目标文件<code>gcc -c main.c</code> </p>
<p>接着使用<code>readelf -a main.o</code> 读取elf，即可查看符号表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shel">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.c<br>cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.o<br>ELF 头：<br>  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  类别:                              ELF64<br>  数据:                              2 补码，小端序 (little endian)<br>  Version:                           1 (current)<br>  OS/ABI:                            UNIX - System V<br>  ABI 版本:                          0<br>  类型:                              REL (可重定位文件)<br>  系统架构:                          Advanced Micro Devices X86-64<br>  版本:                              0x1<br>  入口点地址：               0x0<br>  程序头起点：          0 (bytes into file)<br>  Start of section headers:          1040 (bytes into file)<br>  标志：             0x0<br>  Size of this header:               64 (bytes)<br>  Size of program headers:           0 (bytes)<br>  Number of program headers:         0<br>  Size of section headers:           64 (bytes)<br>  Number of section headers:         13<br>  Section header string table index: 12<br><br>节头：<br>  [号] 名称              类型             地址              偏移量<br>       大小              全体大小          旗标   链接   信息   对齐<br>  [ 0]                   NULL             0000000000000000  00000000<br>       0000000000000000  0000000000000000           0     0     0<br>  [ 1] .text             PROGBITS         0000000000000000  00000040<br>       0000000000000025  0000000000000000  AX       0     0     1<br>  [ 2] .rela.text        RELA             0000000000000000  00000358<br>       0000000000000030  0000000000000018   I      10     1     8<br>  [ 3] .data             PROGBITS         0000000000000000  00000068<br>       0000000000000010  0000000000000000  WA       0     0     8<br>  [ 4] .bss              NOBITS           0000000000000000  00000078<br>       000000000000000c  0000000000000000  WA       0     0     4<br>  [ 5] .comment          PROGBITS         0000000000000000  00000078<br>       000000000000002c  0000000000000001  MS       0     0     1<br>  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a4<br>       0000000000000000  0000000000000000           0     0     1<br>  [ 7] .note.gnu.propert NOTE             0000000000000000  000000a8<br>       0000000000000020  0000000000000000   A       0     0     8<br>  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c8<br>       0000000000000038  0000000000000000   A       0     0     8<br>  [ 9] .rela.eh_frame    RELA             0000000000000000  00000388<br>       0000000000000018  0000000000000018   I      10     8     8<br>  [10] .symtab           SYMTAB           0000000000000000  00000100<br>       00000000000001c8  0000000000000018          11    12     8<br>  [11] .strtab           STRTAB           0000000000000000  000002c8<br>       0000000000000090  0000000000000000           0     0     1<br>  [12] .shstrtab         STRTAB           0000000000000000  000003a0<br>       000000000000006c  0000000000000000           0     0     1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>  L (link order), O (extra OS processing required), G (group), T (TLS),<br>  C (compressed), x (unknown), o (OS specific), E (exclude),<br>  l (large), p (processor specific)<br><br>There are no section groups in this file.<br><br>本文件中没有程序头。<br><br>There is no dynamic section in this file.<br><br>重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries:<br>  偏移量          信息           类型           符号值        符号名称 + 加数<br>000000000014  000c00000002 R_X86_64_PC32     0000000000000000 array - 4<br>000000000019  001200000004 R_X86_64_PLT32    0000000000000000 sum - 4<br><br>重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry:<br>  偏移量          信息           类型           符号值        符号名称 + 加数<br>000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0<br><br>The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.<br><br>Symbol table &#x27;.symtab&#x27; contains 19 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND <br>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c<br>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 <br>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 <br>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 <br>     5: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    3 stat_init.1921<br>     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920<br>     7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919<br>     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 <br>     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 <br>    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 <br>    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 <br>    12: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array<br>    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_not_init<br>    14: 0000000000000008     4 OBJECT  GLOBAL DEFAULT    3 global_init<br>    15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero<br>    16: 0000000000000000    37 FUNC    GLOBAL DEFAULT    1 main<br>    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_<br>    18: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum<br><br>No version information found in this file.<br><br>Displaying notes found in: .note.gnu.property<br>  所有者            Data size   Description<br>  GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0<br>      Properties: x86 feature: IBT, SHSTK<br></code></pre></td></tr></table></figure>
<p>符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量<code>global_not_init</code> 在COMMON 伪节，已经初始化了的全局变量<code>global_init</code>和静态变量<code>stat_init</code>都在<code>.data</code> 节，而初始化为0的全局变量<code>global_init_zero</code> 和没有初始化的静态变量<code>stat_not_init</code> 和初始化为0的静态变量<code>stat_init_zero</code> 在<code>.bss</code> 节</p>
<p>根据这三行的<code>value</code> 字段我们还可以看到这三个变量在<code>.bss</code> 节的存储顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">  15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero<br>6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920<br>   7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919<br></code></pre></td></tr></table></figure>
<p>另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-number">6</span>: <span class="hljs-number">0000000000000004</span>     <span class="hljs-number">4</span> OBJECT  LOCAL  DEFAULT    <span class="hljs-number">4</span> stat_init_zero<span class="hljs-number">.1920</span><br>   <span class="hljs-number">7</span>: <span class="hljs-number">0000000000000008</span>     <span class="hljs-number">4</span> OBJECT  LOCAL  DEFAULT    <span class="hljs-number">4</span> stat_not_init<span class="hljs-number">.1919</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意观察两个静态变量多了两个后辍</p>
</blockquote>
<p>这样做其实是为了区分在同一个模块中同名的两个静态变量</p>
<p>如下面程序的这个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> x = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> x = n + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。</p>
<h3 id="2-2-可执行目标文件格式"><a href="#2-2-可执行目标文件格式" class="headerlink" title="2.2 可执行目标文件格式"></a>2.2 可执行目标文件格式</h3><p>下面是典型的ELF 可执行目标文件</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220910192419982.png" alt="image-20220910192419982"></p>
<p>在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过<code>readelf</code> 来看一下这个段头部表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">LOAD           <span class="hljs-number">0x0000000000000000</span> <span class="hljs-number">0x0000000000400000</span> <span class="hljs-number">0x0000000000400000</span><br>               <span class="hljs-number">0x0000000000000498</span> <span class="hljs-number">0x0000000000000498</span>  R      <span class="hljs-number">0x1000</span><br>LOAD           <span class="hljs-number">0x0000000000001000</span> <span class="hljs-number">0x0000000000401000</span> <span class="hljs-number">0x0000000000401000</span><br>               <span class="hljs-number">0x0000000000000205</span> <span class="hljs-number">0x0000000000000205</span>  R E    <span class="hljs-number">0x1000</span><br>LOAD           <span class="hljs-number">0x0000000000002000</span> <span class="hljs-number">0x0000000000402000</span> <span class="hljs-number">0x0000000000402000</span><br>               <span class="hljs-number">0x0000000000000120</span> <span class="hljs-number">0x0000000000000120</span>  R      <span class="hljs-number">0x1000</span><br>LOAD           <span class="hljs-number">0x0000000000002e50</span> <span class="hljs-number">0x0000000000403e50</span> <span class="hljs-number">0x0000000000403e50</span><br>               <span class="hljs-number">0x00000000000001e0</span> <span class="hljs-number">0x00000000000001e8</span>  RW     <span class="hljs-number">0x1000</span> <br></code></pre></td></tr></table></figure>
<p> 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。</p>
<blockquote>
<p>ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。</p>
</blockquote>
<p>加载可执行文件：</p>
<p>在shell中输入 <code>./prog</code> 后：</p>
<ol>
<li>shell调用fork() 函数，创建子进程</li>
<li>子进程调用execve()，execve调用加载器，加载prog程序</li>
<li>加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址)</li>
<li>_start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数</li>
</ol>
<h3 id="2-3-可共享目标文件格式"><a href="#2-3-可共享目标文件格式" class="headerlink" title="2.3 可共享目标文件格式"></a>2.3 可共享目标文件格式</h3><h2 id="3-三种链接和链接的过程"><a href="#3-三种链接和链接的过程" class="headerlink" title="3 三种链接和链接的过程"></a>3 三种链接和链接的过程</h2><p>三种链接：</p>
<ol>
<li>静态链接</li>
<li>动态链接库</li>
<li>程序运行时链接共享库</li>
</ol>
<h3 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1 静态链接"></a>3.1 静态链接</h3><p>静态链接的两个过程</p>
<ol>
<li>符号解析</li>
<li>重定位</li>
</ol>
<h4 id="3-1-1-符号解析"><a href="#3-1-1-符号解析" class="headerlink" title="3.1.1 符号解析"></a>3.1.1 符号解析</h4><p>链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p>
<p>对于局部符号，它不会出现在符号表中。</p>
<p>对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。</p>
<p>唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。</p>
<p>对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。</p>
<p>而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。</p>
<p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量 (在COMMON伪节)</p>
<p>接着使用以下规则来处理这些符号：</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果一个强符号与多个弱符号同名，选择强符号</li>
<li>若有多个弱符号同名，从这些弱符号中任选一个。</li>
</ol>
<blockquote>
<p>这三个规则很容易造成一些不易察觉的运行时错误。</p>
<p>为什么会有.COMMON伪节？</p>
<p>如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。</p>
<p>而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节</p>
</blockquote>
<p>以上讲的是几个.o 文件的链接，他们都是<code>目标文件</code> </p>
<p>接下来我们讲与静态库的链接，其中会有<code>存档文件</code> 这个概念，注意区别</p>
<blockquote>
<p>静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是  .a</p>
<p>在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。</p>
</blockquote>
<p>生成静态库：</p>
<p>首先编译：<code>gcc -c addvec.c multvec.c</code></p>
<p>接着生成静态库：<code>ar rcs libvector.a addvec.o multvec.o</code> </p>
<p>得到静态库 <code>libvector.a</code>，存档文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101743742.png" alt="image-20220910174348618"> </p>
<p>(重要) 链接器如何使用静态库来解析引用：</p>
<blockquote>
<p>链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。</p>
<ul>
<li>对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。</li>
<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义<br>的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m<br>加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成<br>员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E<br>中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。</li>
<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错<br>误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>
</ul>
</blockquote>
<p>注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。</p>
<p>因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。</p>
<p>但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的</p>
<p>如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B</p>
<p>假如有这样的依赖关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101815751.png" alt="image-20220910181532038"></p>
<p>我们要写成<code>gcc A.o B.a C.a B.a -o prog</code>  因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。</p>
<h4 id="3-1-2-重定位"><a href="#3-1-2-重定位" class="headerlink" title="3.1.2 重定位"></a>3.1.2 重定位</h4><p>《深入理解计算机系统》原书第三版 P 478 7.7</p>
<h3 id="3-2-动态链接库"><a href="#3-2-动态链接库" class="headerlink" title="3.2 动态链接库"></a>3.2 动态链接库</h3><p>静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。</p>
<p>所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。</p>
<p>创建动态库 <code>gcc -shared -fpic -o libvector.so addvec.c multvec.c</code> </p>
<p>与动态库链接：</p>
<p><code>gcc -o prog main.c ./libvector.so</code></p>
<p>与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。</p>
<p>下面是动态链接库的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209112059039.png" alt="image-20220911205952800"> </p>
<blockquote>
<p>一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章)</p>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到 <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
</blockquote>
<h3 id="3-3-程序运行时链接共享库"><a href="#3-3-程序运行时链接共享库" class="headerlink" title="3.3 程序运行时链接共享库"></a>3.3 程序运行时链接共享库</h3><p>可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 7.11 load and link shared library from an application</span><br><span class="hljs-comment">// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> * handle;  <span class="hljs-comment">// shared lib handle</span><br>    <span class="hljs-type">void</span> (*addvec)(<span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span>);  <span class="hljs-comment">// point to a function</span><br>    <span class="hljs-type">void</span> (*multvec)(<span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span> *, <span class="hljs-type">int</span>);  <span class="hljs-comment">// point to a function</span><br>    <span class="hljs-type">char</span> * error;   <span class="hljs-comment">// point to error massages string</span><br><br>    <span class="hljs-comment">// load shared library</span><br>    handle = dlopen(<span class="hljs-string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (!handle)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// search the symbol &quot;multvec&quot; from the shared library</span><br>    multvec = dlsym(handle, <span class="hljs-string">&quot;multvec&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((error = (dlerror())) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, error);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// execute the function</span><br>    multvec(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="hljs-number">0</span>], z[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// unload the shared library</span><br>    <span class="hljs-keyword">if</span> (dlclose(handle) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="名词索引"><a href="#名词索引" class="headerlink" title="名词索引"></a>名词索引</h2><p>ELF-64 目标文件格式</p>
<p>PIC(Position-Independent Code) 位置无关代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">动态数组,二维数组,指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-06 20:45:24 / 修改时间：20:46:41" itemprop="dateCreated datePublished" datetime="2022-09-06T20:45:24+08:00">2022-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">琐碎记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态数组、二维数组、指针"><a href="#动态数组、二维数组、指针" class="headerlink" title="动态数组、二维数组、指针"></a>动态数组、二维数组、指针</h1><p>本文会讲：</p>
<ul>
<li>二维数组的存储形式</li>
<li>数组类型为什么会退化？</li>
<li>二维数组的动态分配</li>
</ul>
<h2 id="1-二维数组的存储形式"><a href="#1-二维数组的存储形式" class="headerlink" title="1 二维数组的存储形式"></a>1 二维数组的存储形式</h2><p>以下这个程序可以很好的说明二维数组的存储形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            a[i][j] = i * <span class="hljs-number">10</span> + j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(a));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:\t%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个程序的运行结果是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>):    <span class="hljs-number">4</span><br><span class="hljs-keyword">sizeof</span>(a):      <span class="hljs-number">32</span>      <br><span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]):   <span class="hljs-number">8</span>       <br><br>a:      <span class="hljs-number">000000000064F</span>DD0<br>&amp;a:     <span class="hljs-number">000000000064F</span>DD0<br><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">00</span><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">01</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">10</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">11</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">20</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">21</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">30</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">31</span><br><br>a[<span class="hljs-number">0</span>]:   <span class="hljs-number">000000000064F</span>DD0<br>a[<span class="hljs-number">1</span>]:   <span class="hljs-number">000000000064F</span>DD8<br>a[<span class="hljs-number">2</span>]:   <span class="hljs-number">000000000064F</span>DE0<br>a[<span class="hljs-number">3</span>]:   <span class="hljs-number">000000000064F</span>DE8<br><br>*a[<span class="hljs-number">0</span>]:  <span class="hljs-number">0</span><br>*a[<span class="hljs-number">1</span>]:  <span class="hljs-number">10</span><br>*a[<span class="hljs-number">2</span>]:  <span class="hljs-number">20</span><br>*a[<span class="hljs-number">3</span>]:  <span class="hljs-number">30</span><br><br>&amp;a[<span class="hljs-number">0</span>]:  <span class="hljs-number">000000000064F</span>DD0<br>&amp;a[<span class="hljs-number">1</span>]:  <span class="hljs-number">000000000064F</span>DD8<br>&amp;a[<span class="hljs-number">2</span>]:  <span class="hljs-number">000000000064F</span>DE0<br>&amp;a[<span class="hljs-number">3</span>]:  <span class="hljs-number">000000000064F</span>DE8<br><br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">000000000064F</span>DD0<br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000064F</span>DD4<br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">000000000064F</span>DD8<br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000064F</span>DDC<br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">000000000064F</span>DE0<br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000064F</span>DE4<br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">000000000064F</span>DE8<br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000064F</span>DEC<br></code></pre></td></tr></table></figure>
<p>可以看出，二维数组是连续储存的，有<code>&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0]</code> ，以此类推。</p>
<p>我们可以这样表示二维数组</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-数组类型为什么会退化？"><a href="#2-数组类型为什么会退化？" class="headerlink" title="2 数组类型为什么会退化？"></a>2 数组类型为什么会退化？</h2><p>有的时候会出现这种情况：</p>
<p>在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/464844221/answer/1940453834">https://www.zhihu.com/question/464844221/answer/1940453834</a></p>
<h2 id="3-动态分配二维数组"><a href="#3-动态分配二维数组" class="headerlink" title="3 动态分配二维数组"></a>3 动态分配二维数组</h2><h3 id="3-1-第一种方法"><a href="#3-1-第一种方法" class="headerlink" title="3.1 第一种方法"></a>3.1 第一种方法</h3><p>先申请一维数组，在将该一维数组强制转换成二维数组</p>
<p>前置知识：</p>
<p>一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息</p>
<p>二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型，</p>
<p>即<code>int q[][4]</code> 和<code>int (*q)[4]</code> 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于<code>q += 2 * 4 * sizeof(int)</code></p>
<p>直接贴代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> *a = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        a[i] = i;<br>    <span class="hljs-type">int</span> (*b)[<span class="hljs-number">4</span>] = (<span class="hljs-type">int</span> (*)[<span class="hljs-number">4</span>])a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。</p>
<p>我们用<code>int (*b)[4]</code> 声明了一个指向 四个元素的数组 的指针。</p>
<p>然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。</p>
<p>这样动态分配的指针和直接<code>int b[2][4]</code> 是一样的。</p>
<p>下面我们使用 1 中的方法对这个数组进行仔细检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        b[i] = i;<br>    <span class="hljs-type">int</span> (*a)[<span class="hljs-number">2</span>] = (<span class="hljs-type">int</span> (*)[<span class="hljs-number">2</span>])b;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:\t%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>):    <span class="hljs-number">4</span><br><span class="hljs-keyword">sizeof</span>(a):      <span class="hljs-number">8</span>       <br><span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]):   <span class="hljs-number">8</span>       <br><br>a:      <span class="hljs-number">00000000009</span>C1420<br>&amp;a:     <span class="hljs-number">000000000064F</span>DF0<br><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">00</span>      <br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">01</span>      <br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">02</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">03</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">04</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">05</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">06</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">07</span><br><br>a[<span class="hljs-number">0</span>]:   <span class="hljs-number">00000000009</span>C1420<br>a[<span class="hljs-number">1</span>]:   <span class="hljs-number">00000000009</span>C1428<br>a[<span class="hljs-number">2</span>]:   <span class="hljs-number">00000000009</span>C1430<br>a[<span class="hljs-number">3</span>]:   <span class="hljs-number">00000000009</span>C1438<br><br>*a[<span class="hljs-number">0</span>]:  <span class="hljs-number">0</span><br>*a[<span class="hljs-number">1</span>]:  <span class="hljs-number">2</span><br>*a[<span class="hljs-number">2</span>]:  <span class="hljs-number">4</span><br>*a[<span class="hljs-number">3</span>]:  <span class="hljs-number">6</span><br><br>&amp;a[<span class="hljs-number">0</span>]:  <span class="hljs-number">00000000009</span>C1420<br>&amp;a[<span class="hljs-number">1</span>]:  <span class="hljs-number">00000000009</span>C1428<br>&amp;a[<span class="hljs-number">2</span>]:  <span class="hljs-number">00000000009</span>C1430<br>&amp;a[<span class="hljs-number">3</span>]:  <span class="hljs-number">00000000009</span>C1438<br><br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">00000000009</span>C1420<br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">00000000009</span>C1424<br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">00000000009</span>C1428<br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">00000000009</span>C142C<br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">00000000009</span>C1430<br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">00000000009</span>C1434<br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">00000000009</span>C1438<br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">00000000009</span>C143C<br></code></pre></td></tr></table></figure>
<p>可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。</p>
<p>这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 </p>
<h3 id="3-2-第二种方法："><a href="#3-2-第二种方法：" class="headerlink" title="3.2 第二种方法："></a>3.2 第二种方法：</h3><blockquote>
<p>参考: <a target="_blank" rel="noopener" href="https://blog.csdn.net/morewindows/article/details/7664479#">https://blog.csdn.net/morewindows/article/details/7664479#</a> 我这里将原文的int 替换成了size_t</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C语言中动态的申请二维数组 malloc free</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//动态申请二维数组</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T** <span class="hljs-title">malloc_Array2D</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> size = <span class="hljs-built_in">sizeof</span>(T);<br>  <span class="hljs-type">int</span> point_size = <span class="hljs-built_in">sizeof</span>(T*);<br>  <span class="hljs-comment">//先申请内存，其中point_size * row表示存放row个行指针</span><br>  T **arr = (T **) <span class="hljs-built_in">malloc</span>(point_size * row + size * row * col);<br>  <span class="hljs-keyword">if</span> (arr != <span class="hljs-literal">NULL</span>)<br>  &#123;	<br>    <span class="hljs-built_in">memset</span>(arr, <span class="hljs-number">0</span>, point_size * row + size * row * col);<br>    T *head = (T*)((<span class="hljs-type">size_t</span>)arr + point_size * row);    <span class="hljs-comment">// 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好</span><br>    <span class="hljs-keyword">while</span> (row--)<br>      arr[row] = (T*)((<span class="hljs-type">size_t</span>)head + row * col * size);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (T**)arr;<br>&#125;<br><br><span class="hljs-comment">//释放二维数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free_Aarray2D</span><span class="hljs-params">(<span class="hljs-type">void</span> **arr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (arr != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">free</span>(arr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  C语言中动态的申请二维数组 malloc free\n&quot;</span>);  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n&quot;</span>);<br> <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入行列(以空格分开): &quot;</span>);<br>  <span class="hljs-type">int</span> nRow, nCol;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;nRow, &amp;nCol);<br> <br>  <span class="hljs-comment">//动态申请连续的二维数组</span><br>  <span class="hljs-type">int</span> **p = <span class="hljs-built_in">malloc_Array2D</span>&lt;<span class="hljs-type">int</span>&gt;(nRow, nCol);<br> <br>  <span class="hljs-comment">//为二维数组赋值	</span><br>  <span class="hljs-type">int</span> i, j;	<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nRow; i++)<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; nCol; j++)<br>      p[i][j] = i + j;<br> <br>  <span class="hljs-comment">//输出二维数组	</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nRow; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; nCol; j++)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d &quot;</span>, p[i][j]);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  &#125;<br> <br>  <span class="hljs-built_in">free_Aarray2D</span>((<span class="hljs-type">void</span>**)p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里，原作者对指针的操作让我叹为观止。</p>
<p>但是，用这种方法创作出来的二维数组和直接<code>int b[2][4]</code> 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-3-第三种方法"><a href="#3-3-第三种方法" class="headerlink" title="3.3 第三种方法"></a>3.3 第三种方法</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/houqd2012/article/details/8146070">https://blog.csdn.net/houqd2012/article/details/8146070</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> **<span class="hljs-title function_">make_array2D</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span><br>&#123;<br>    <span class="hljs-type">int</span> **arr = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(row * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *));<br>    arr[<span class="hljs-number">0</span>] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(row * col * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++)<br>        arr[i] = arr[i - <span class="hljs-number">1</span>] + col;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_array2D</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(arr);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> **a = make_array2D(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>            a[i][j] = <span class="hljs-number">10</span> * i + j;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i][j]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    free_array2D(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。</p>
<p>我们使用 1 中的程序对这个数组进行详细的检查。代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> **<span class="hljs-title function_">make_array2D</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span><br>&#123;<br>    <span class="hljs-type">int</span> **arr = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(row * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *));<br>    arr[<span class="hljs-number">0</span>] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(row * col * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++)<br>        arr[i] = arr[i - <span class="hljs-number">1</span>] + col;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_array2D</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(arr);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> **a = make_array2D(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            a[i][j] = <span class="hljs-number">10</span> * i + j;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:\t%p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);<br>    free_array2D(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>):    <span class="hljs-number">4</span><br><span class="hljs-keyword">sizeof</span>(a):      <span class="hljs-number">8</span><br><span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]):   <span class="hljs-number">8</span><br><br>a:      <span class="hljs-number">0000000000701420</span><br>&amp;a:     <span class="hljs-number">000000000064F</span>DF0<br><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">00</span><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">01</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">10</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">11</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">20</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">21</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:        <span class="hljs-number">30</span><br>a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:        <span class="hljs-number">31</span><br><br>a[<span class="hljs-number">0</span>]:   <span class="hljs-number">0000000000701450</span><br>a[<span class="hljs-number">1</span>]:   <span class="hljs-number">0000000000701458</span><br>a[<span class="hljs-number">2</span>]:   <span class="hljs-number">0000000000701460</span><br>a[<span class="hljs-number">3</span>]:   <span class="hljs-number">0000000000701468</span><br><br>*a[<span class="hljs-number">0</span>]:  <span class="hljs-number">0</span><br>*a[<span class="hljs-number">1</span>]:  <span class="hljs-number">10</span><br>*a[<span class="hljs-number">2</span>]:  <span class="hljs-number">20</span><br>*a[<span class="hljs-number">3</span>]:  <span class="hljs-number">30</span><br><br>&amp;a[<span class="hljs-number">0</span>]:  <span class="hljs-number">0000000000701420</span><br>&amp;a[<span class="hljs-number">1</span>]:  <span class="hljs-number">0000000000701428</span><br>&amp;a[<span class="hljs-number">2</span>]:  <span class="hljs-number">0000000000701430</span><br>&amp;a[<span class="hljs-number">3</span>]:  <span class="hljs-number">0000000000701438</span><br><br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">0000000000701450</span><br>&amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">0000000000701454</span><br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">0000000000701458</span><br>&amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000070145</span>C<br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">0000000000701460</span><br>&amp;a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">0000000000701464</span><br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]:       <span class="hljs-number">0000000000701468</span><br>&amp;a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]:       <span class="hljs-number">000000000070146</span>C<br></code></pre></td></tr></table></figure>
<p>从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接<code>int b[2][4]</code> 得到的二维数组，还是不一样的。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-4-总结-：-下标运算符"><a href="#3-4-总结-：-下标运算符" class="headerlink" title="3.4 总结 ： 下标运算符"></a>3.4 总结 ： 下标运算符</h3><p>首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。</p>
<p>下标运算符是左结合的，我们引用二维数组，通常是这样的    <code>arr[i][j]</code> 但其实也可以这样 <code>(arr[i])[j]</code> 这两种形式是等价的。</p>
<p>下面我们详细地描述下标运算符 </p>
<p><code>ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType))</code></p>
<p>可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型<code>int **</code>, 也可以是数组类型 <code>int (*)[]</code>，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。</p>
<p>首先我们来看内置的数组类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<p>一个内置数组类型表示为<code>int a[5][5]</code> ，但拎出来a，他的类型是 <code>int (*)[5]</code> 所以<code>arr[1]</code> 其实是指<code>a[1][0]</code> 这个位置。<code>a[1]</code> 的类型是<code>int *</code> 所以<code>(a[1])[1]</code> 的类型就是<code>int</code></p>
<p>接下来我们看动态分配二维数组的第一种方法：</p>
<p>这种方法一开始申请了一个一维数组<code>int *a = (int *)malloc(2 * 4 * sizeof(int))</code> a的类型是<code>int *</code></p>
<p>接下来我们使用强制类型转换，将a由<code>int *</code> 转换为<code>int (*)[4]</code> ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。</p>
<p>接下类我们看动态分配二维数组的第二种方法：</p>
<p>首先我们将这种方法分配的图画出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209061948605.png" alt="image-20220906194800829">  </p>
<p>设行数为row，列数为col，假设二维数组存储的类型为 int</p>
<p>第二种方法申请了 <code>row * sizeof(int *) + row * col * sizeof(int)</code> 字节的空间。</p>
<p>这个表达式的前一项<code>row * sizeof(int *)</code> 代表a[0] a[1] a[2] 的空间，后一项<code>row * col * sizeof(int)</code> 指的是连续的二维数组的存储空间。</p>
<p>这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。</p>
<p>需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是<code>int **</code> 而不是<code>int (*)[col]</code> ，也决不能是<code>int (*)[col]</code> 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？</p>
<p>首先a的类型时<code>int **</code> ，a[1]，代表a之后一个指针大小位置的内容，即</p>
<p><code>*((size_t)a + 1 * sizeof(int *))</code>，就是a[1] [0]的地址，而<code>(a[1])[0]</code> 就是a[1] [0]的内容。</p>
<p>为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是<code>int **</code> </p>
<p>第三种二维数组的分析与第二种类似，这里我们给出它的表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209062002932.png" alt="image-20220906200208361"> </p>
<h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><p>我们使用一个程序来展示 <code>int (*)[col]</code> 类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_1</span><span class="hljs-params">(<span class="hljs-type">int</span> a[][<span class="hljs-number">8</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i][j]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_2</span><span class="hljs-params">(<span class="hljs-type">int</span> (*a)[<span class="hljs-number">8</span>], <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i][j]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_3</span><span class="hljs-params">(<span class="hljs-type">int</span> (*a)[<span class="hljs-number">8</span>])</span>  <span class="hljs-comment">// 指向数组的指针</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, (*a)[i]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> q[<span class="hljs-number">4</span>][<span class="hljs-number">8</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>      q[i][j] = <span class="hljs-number">10</span> * i + j;<br><br>  func_1(q, <span class="hljs-number">4</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  func_2(q, <span class="hljs-number">4</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-type">int</span> p[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>  func_3(&amp;p);		<span class="hljs-comment">// 因为是指向数组的指针，p必须要取地址</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>贴一篇文章 ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></p>
<p>这篇文章里对指针类型的分析很好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p; <span class="hljs-comment">//这是一个普通的整型变量</span><br><span class="hljs-type">int</span> *p; <span class="hljs-comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">3</span>]; <span class="hljs-comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span><br><span class="hljs-type">int</span> *p[<span class="hljs-number">3</span>]; <span class="hljs-comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span><br><span class="hljs-type">int</span> (*p)[<span class="hljs-number">3</span>]; <span class="hljs-comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span><br><span class="hljs-type">int</span> **p; <span class="hljs-comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>; <span class="hljs-comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span><br>Int (*p)(<span class="hljs-type">int</span>); <span class="hljs-comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span><br><span class="hljs-type">int</span> *(*p(<span class="hljs-type">int</span>))[<span class="hljs-number">3</span>]; <span class="hljs-comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span><br></code></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cfla</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cfla</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
