{"meta":{"title":"cfla's blog","subtitle":"","description":"","author":"cfla","url":"https://cfla1638.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-20T23:36:33.219Z","updated":"2022-08-20T14:43:28.978Z","comments":true,"path":"Archives.html","permalink":"https://cfla1638.github.io/Archives.html","excerpt":"","text":""},{"title":"关于博客","date":"2022-08-20T16:00:00.000Z","updated":"2022-09-02T05:08:53.737Z","comments":true,"path":"about.html","permalink":"https://cfla1638.github.io/about.html","excerpt":"","text":"关于博客建站日期：2022 年 8 月 20 日 About Blog建立一个自己的博客站，最主要的目的是记录自己在计算机这条路上学到的知识。 写下这些内容的时候是大二，在大一时，我看了好多本计算机专业的书，比如《C++ Primer》，《C Primer Plus》。 暑假的时候我学了Qt，用到 C++ 的 OOP 时，我才意识到自己之前学到的知识是不牢固的。刚看完的书，没有经过实践，就是不能变成自己的东西。但我又不能将所有的内容都去实践。因此我决定为看过的计算机类的书籍都写读书笔记，内容主要是看完这本书的感受，学到的东西。就像操作系统切换进程需要保存上下文一样，将对这本书印象最深时的 “上下文” 保存下来，等以后需要的时候能够快速开始。 同样的道理，也适用于刚做完的项目，刚配置好的系统 … 因此，我的博客将记录自己在计算机领域学到过的、实践过的知识 以及 解决问题的经验。 About me 计算机科学与技术专业 内向的、焦虑的、热爱学习、向往未来的 OTAKU"}],"posts":[{"title":"模电课程 - 大学课程","slug":"模电课程-大学课程","date":"2022-09-10T04:17:18.000Z","updated":"2022-09-10T08:12:49.292Z","comments":true,"path":"2022/09/10/模电课程-大学课程/","link":"","permalink":"https://cfla1638.github.io/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"电工学第十四章 半导体器件二极管： 正向压降 ： 正向通过后，电压的减小量。 二极管的功能： 钳位 钳位二极管_百度百科 (baidu.com) 隔离 稳压 ： 见下面稳压二极管视频 补充计算结点电压的结点电压法：第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com) 稳压二极管： 详见视频： https://www.bilibili.com/video/BV1qY4y1t7sc","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"链接 - CS:APP 第七章","slug":"链接-CS-APP-第七章","date":"2022-09-07T11:47:36.000Z","updated":"2022-09-11T13:02:37.320Z","comments":true,"path":"2022/09/07/链接-CS-APP-第七章/","link":"","permalink":"https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"链接本文将介绍： 编译的过程 三种目标文件 三种链接和链接的过程 1 编译的过程 源文件（.c &#x2F;.cpp）经过翻译，形成可重定位目标文件（.o） 具体过程： 预处理 cpp main.c -o main.i 或 gcc -E -o main.c main.c 编译器 ：翻译成汇编语言 cc1 或 cc main.i -o main.s 或 gcc -S -o main.s main.c 汇编器 ：形成可重定位目标文件 as [args] -o main.o 这中间参数很多， 如果向直接到这一步可以使用 gcc -c -o main.o main.c 链接器 链接形成可执行目标文件 ld -o prog main.o other.o 或 gcc -o prog main.o other.o 如果想要一步一步生成.i .s .o 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。 除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 -E -S -c 参数进行编译。 顺带一提，在bash中，可以通过 echo $? 来展示上一次程序退出的返回值 2 三种目标文件首先，什么是目标文件？ 计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。 ——360百科 目标文件可以分为三类： 可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。 可执行目标文件 ： 可以被复制到内存中执行。 共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接 window系统使用PE portable Executable 格式 Linux使用 Executable and Linkable Format, ELF格式 2.1 可重定位目标文件格式 可重定位目标文件 以ELF头开始，通过readelf -a main.o 我们可以看到ELF头的内容 ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12 可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。 我倾向于认为这是节头部表的内容： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1 在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。 一个典型的ELF可重定位目标文件包含下面的节： .text : 已编译的机器代码 .rodata : read only data 只读数据，如printf的格式字符串 .data : 已初始化的全局和静态变量 .bss : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节） .symtab ：符号表 rel.text ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量 .rel.data .debug ：调试信息 .line ：调试时的行号 strtab ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字 2.1.1 符号表符号表的条目格式是这样的 typedef struct &#123; int name; // 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c char type:4, // 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ... binding:4; // 全局变量还是本地变量 GLOBAL OR LOCAL char reserved; // 保留的，未使用 short section; // 在ubuntu 上的名字是Ndx,指明该符号是在那个section的 long value; // 距离节section 起始位置的字节偏移 long size; // 该符号最小的大小&#125; Elf64_Symbol; 对于section 字段，在ubuntu 的readelf 命令中，显示为 Ndx。 该字段有三个伪节，他们分别是 UNDEF COMMON ABS 。 ABS ：代表不改被重定位的符号 UNDEF ：代表未定义的符号，即在本模块引用却在其他模块定义的符号 COMMON ：还未被分配位置的未初始化的数据目标 COMMON 和 .bss 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到COMMON 和.bss COMMON ：未初始化的全局变量 .bss ：未初始化的静态变量，以及初始化为0的全局或静态变量 下面我们通过一个程序来展示以下ubuntu 中的符号表 int sum(int * a, int n);int array[2] = &#123;1, 3&#125;;int global_not_init;int global_init = 1;int global_init_zero = 0;int main()&#123; static int stat_not_init; static int stat_init_zero = 0; static int stat_init = 1; int val = sum(array, 2); return val;&#125; 下面我们生成可重定位的目标文件gcc -c main.c 接着使用readelf -a main.o 读取elf，即可查看符号表 cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.ccfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.oELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific)There are no section groups in this file.本文件中没有程序头。There is no dynamic section in this file.重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000000014 000c00000002 R_X86_64_PC32 0000000000000000 array - 4000000000019 001200000004 R_X86_64_PLT32 0000000000000000 sum - 4重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.Symbol table &#x27;.symtab&#x27; contains 19 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 000000000000000c 4 OBJECT LOCAL DEFAULT 3 stat_init.1921 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 0 SECTION LOCAL DEFAULT 7 10: 0000000000000000 0 SECTION LOCAL DEFAULT 8 11: 0000000000000000 0 SECTION LOCAL DEFAULT 5 12: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 13: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_not_init 14: 0000000000000008 4 OBJECT GLOBAL DEFAULT 3 global_init 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero 16: 0000000000000000 37 FUNC GLOBAL DEFAULT 1 main 17: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 18: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sumNo version information found in this file.Displaying notes found in: .note.gnu.property 所有者 Data size Description GNU 0x00000010 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK 符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量global_not_init 在COMMON 伪节，已经初始化了的全局变量global_init和静态变量stat_init都在.data 节，而初始化为0的全局变量global_init_zero 和没有初始化的静态变量stat_not_init 和初始化为0的静态变量stat_init_zero 在.bss 节 根据这三行的value 字段我们还可以看到这三个变量在.bss 节的存储顺序 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 注意观察两个静态变量多了两个后辍 这样做其实是为了区分在同一个模块中同名的两个静态变量 如下面程序的这个例子 int func_1(int n)&#123; static int x = n + 1; return x;&#125;int func_2(int n)&#123; static int x = n + 2; return x;&#125; 这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。 2.2 可执行目标文件格式下面是典型的ELF 可执行目标文件 在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过readelf 来看一下这个段头部表 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000498 0x0000000000000498 R 0x1000LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x0000000000000205 0x0000000000000205 R E 0x1000LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x0000000000000120 0x0000000000000120 R 0x1000LOAD 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x00000000000001e0 0x00000000000001e8 RW 0x1000 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。 ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。 加载可执行文件： 在shell中输入 ./prog 后： shell调用fork() 函数，创建子进程 子进程调用execve()，execve调用加载器，加载prog程序 加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址) _start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数 2.3 可共享目标文件格式3 三种链接和链接的过程三种链接： 静态链接 动态链接库 程序运行时链接共享库 3.1 静态链接静态链接的两个过程 符号解析 重定位 3.1.1 符号解析链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。 对于局部符号，它不会出现在符号表中。 对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。 唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。 对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。 而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 (在COMMON伪节) 接着使用以下规则来处理这些符号： 不允许有多个同名的强符号 如果一个强符号与多个弱符号同名，选择强符号 若有多个弱符号同名，从这些弱符号中任选一个。 这三个规则很容易造成一些不易察觉的运行时错误。 为什么会有.COMMON伪节？ 如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。 而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节 以上讲的是几个.o 文件的链接，他们都是目标文件 接下来我们讲与静态库的链接，其中会有存档文件 这个概念，注意区别 静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是 .a 在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。 生成静态库： 首先编译：gcc -c addvec.c multvec.c 接着生成静态库：ar rcs libvector.a addvec.o multvec.o 得到静态库 libvector.a，存档文件 (重要) 链接器如何使用静态库来解析引用： 链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。 对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。 注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。 因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。 但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的 如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B 假如有这样的依赖关系： 我们要写成 gcc A.o B.a C.a B.a -o prog 因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。 3.1.2 重定位《深入理解计算机系统》原书第三版 P 478 7.7 3.2 动态链接库静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。 所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。 创建动态库 gcc -shared -fpic -o libvector.so addvec.c multvec.c 与动态库链接： gcc -o prog main.c ./libvector.so 与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。 下面是动态链接库的过程： 3.3 程序运行时链接共享库可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序： // 7.11 load and link shared library from an application// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int x[2] = &#123;1, 2&#125;;int y[2] = &#123;3, 4&#125;;int z[2];int main(void)&#123; void * handle; // shared lib handle void (*addvec)(int *, int *, int *, int); // point to a function void (*multvec)(int *, int *, int *, int); // point to a function char * error; // point to error massages string // load shared library handle = dlopen(&quot;./libvector.so&quot;, RTLD_LAZY); if (!handle) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; // search the symbol &quot;multvec&quot; from the shared library multvec = dlsym(handle, &quot;multvec&quot;); if ((error = (dlerror())) != NULL) &#123; fprintf(stderr, &quot;%s\\n&quot;, error); exit(1); &#125; // execute the function multvec(x, y, z, 2); printf(&quot;z = [%d %d]\\n&quot;, z[0], z[1]); // unload the shared library if (dlclose(handle) &lt; 0) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; return 0;&#125; 名词索引ELF-64 目标文件格式 PIC(Position-Independent Code) 位置无关代码","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"动态数组,二维数组,指针","slug":"动态数组-二维数组-指针","date":"2022-09-06T12:45:24.000Z","updated":"2022-09-06T12:46:41.480Z","comments":true,"path":"2022/09/06/动态数组-二维数组-指针/","link":"","permalink":"https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/","excerpt":"","text":"动态数组、二维数组、指针本文会讲： 二维数组的存储形式 数组类型为什么会退化？ 二维数组的动态分配 1 二维数组的存储形式以下这个程序可以很好的说明二维数组的存储形式 #include &lt;stdio.h&gt;int main(void)&#123; int a[4][2]; // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = i * 10 + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); return 0;&#125; 这个程序的运行结果是这样的 sizeof(int): 4sizeof(a): 32 sizeof(a[0]): 8 a: 000000000064FDD0&amp;a: 000000000064FDD0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 000000000064FDD0a[1]: 000000000064FDD8a[2]: 000000000064FDE0a[3]: 000000000064FDE8*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 000000000064FDD0&amp;a[1]: 000000000064FDD8&amp;a[2]: 000000000064FDE0&amp;a[3]: 000000000064FDE8&amp;a[0][0]: 000000000064FDD0&amp;a[0][1]: 000000000064FDD4&amp;a[1][0]: 000000000064FDD8&amp;a[1][1]: 000000000064FDDC&amp;a[2][0]: 000000000064FDE0&amp;a[2][1]: 000000000064FDE4&amp;a[3][0]: 000000000064FDE8&amp;a[3][1]: 000000000064FDEC 可以看出，二维数组是连续储存的，有&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0] ，以此类推。 我们可以这样表示二维数组 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 2 数组类型为什么会退化？有的时候会出现这种情况： 在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？ 详见：https://www.zhihu.com/question/464844221/answer/1940453834 3 动态分配二维数组3.1 第一种方法先申请一维数组，在将该一维数组强制转换成二维数组 前置知识： 一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息 二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型， 即int q[][4] 和int (*q)[4] 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于q += 2 * 4 * sizeof(int) 直接贴代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *a = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) a[i] = i; int (*b)[4] = (int (*)[4])a; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, b[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。 我们用int (*b)[4] 声明了一个指向 四个元素的数组 的指针。 然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。 这样动态分配的指针和直接int b[2][4] 是一样的。 下面我们使用 1 中的方法对这个数组进行仔细检查 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; // 初始化数组 int *b = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) b[i] = i; int (*a)[2] = (int (*)[2])b; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]);&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8 sizeof(a[0]): 8 a: 00000000009C1420&amp;a: 000000000064FDF0a[0][0]: 00 a[0][1]: 01 a[1][0]: 02a[1][1]: 03a[2][0]: 04a[2][1]: 05a[3][0]: 06a[3][1]: 07a[0]: 00000000009C1420a[1]: 00000000009C1428a[2]: 00000000009C1430a[3]: 00000000009C1438*a[0]: 0*a[1]: 2*a[2]: 4*a[3]: 6&amp;a[0]: 00000000009C1420&amp;a[1]: 00000000009C1428&amp;a[2]: 00000000009C1430&amp;a[3]: 00000000009C1438&amp;a[0][0]: 00000000009C1420&amp;a[0][1]: 00000000009C1424&amp;a[1][0]: 00000000009C1428&amp;a[1][1]: 00000000009C142C&amp;a[2][0]: 00000000009C1430&amp;a[2][1]: 00000000009C1434&amp;a[3][0]: 00000000009C1438&amp;a[3][1]: 00000000009C143C 可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。 这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 3.2 第二种方法： 参考: https://blog.csdn.net/morewindows/article/details/7664479# 我这里将原文的int 替换成了size_t //C语言中动态的申请二维数组 malloc free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//动态申请二维数组template &lt;typename T&gt;T** malloc_Array2D(int row, int col)&#123; int size = sizeof(T); int point_size = sizeof(T*); //先申请内存，其中point_size * row表示存放row个行指针 T **arr = (T **) malloc(point_size * row + size * row * col); if (arr != NULL) &#123; memset(arr, 0, point_size * row + size * row * col); T *head = (T*)((size_t)arr + point_size * row); // 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好 while (row--) arr[row] = (T*)((size_t)head + row * col * size); &#125; return (T**)arr;&#125;//释放二维数组void free_Aarray2D(void **arr)&#123; if (arr != NULL) free(arr);&#125;int main()&#123; printf(&quot; C语言中动态的申请二维数组 malloc free\\n&quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\\n\\n&quot;); printf(&quot;请输入行列(以空格分开): &quot;); int nRow, nCol; scanf(&quot;%d %d&quot;, &amp;nRow, &amp;nCol); //动态申请连续的二维数组 int **p = malloc_Array2D&lt;int&gt;(nRow, nCol); //为二维数组赋值 int i, j; for (i = 0; i &lt; nRow; i++) for (j = 0; j &lt; nCol; j++) p[i][j] = i + j; //输出二维数组 for (i = 0; i &lt; nRow; i++) &#123; for (j = 0; j &lt; nCol; j++) printf(&quot;%4d &quot;, p[i][j]); putchar(&#x27;\\n&#x27;); &#125; free_Aarray2D((void**)p); return 0;&#125; 这里，原作者对指针的操作让我叹为观止。 但是，用这种方法创作出来的二维数组和直接int b[2][4] 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。 它的具体结构我将在下一小节介绍 3.3 第三种方法 参考：https://blog.csdn.net/houqd2012/article/details/8146070 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(2, 4); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 4; j++) a[i][j] = 10 * i + j; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; free_array2D(a); return 0;&#125; 乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。 我们使用 1 中的程序对这个数组进行详细的检查。代码如下 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(4, 2); // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = 10 * i + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); free_array2D(a); return 0;&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8sizeof(a[0]): 8a: 0000000000701420&amp;a: 000000000064FDF0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 0000000000701450a[1]: 0000000000701458a[2]: 0000000000701460a[3]: 0000000000701468*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 0000000000701420&amp;a[1]: 0000000000701428&amp;a[2]: 0000000000701430&amp;a[3]: 0000000000701438&amp;a[0][0]: 0000000000701450&amp;a[0][1]: 0000000000701454&amp;a[1][0]: 0000000000701458&amp;a[1][1]: 000000000070145C&amp;a[2][0]: 0000000000701460&amp;a[2][1]: 0000000000701464&amp;a[3][0]: 0000000000701468&amp;a[3][1]: 000000000070146C 从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接int b[2][4] 得到的二维数组，还是不一样的。 它的具体结构我将在下一小节介绍 3.4 总结 ： 下标运算符首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。 下标运算符是左结合的，我们引用二维数组，通常是这样的 arr[i][j] 但其实也可以这样 (arr[i])[j] 这两种形式是等价的。 下面我们详细地描述下标运算符 ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType)) 可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型int **, 也可以是数组类型 int (*)[]，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。 首先我们来看内置的数组类型 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 一个内置数组类型表示为int a[5][5] ，但拎出来a，他的类型是 int (*)[5] 所以arr[1] 其实是指a[1][0] 这个位置。a[1] 的类型是int * 所以(a[1])[1] 的类型就是int 接下来我们看动态分配二维数组的第一种方法： 这种方法一开始申请了一个一维数组int *a = (int *)malloc(2 * 4 * sizeof(int)) a的类型是int * 接下来我们使用强制类型转换，将a由int * 转换为int (*)[4] ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。 接下类我们看动态分配二维数组的第二种方法： 首先我们将这种方法分配的图画出来 设行数为row，列数为col，假设二维数组存储的类型为 int 第二种方法申请了 row * sizeof(int *) + row * col * sizeof(int) 字节的空间。 这个表达式的前一项row * sizeof(int *) 代表a[0] a[1] a[2] 的空间，后一项row * col * sizeof(int) 指的是连续的二维数组的存储空间。 这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。 需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是int ** 而不是int (*)[col] ，也决不能是int (*)[col] 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？ 首先a的类型时int ** ，a[1]，代表a之后一个指针大小位置的内容，即 *((size_t)a + 1 * sizeof(int *))，就是a[1] [0]的地址，而(a[1])[0] 就是a[1] [0]的内容。 为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是int ** 第三种二维数组的分析与第二种类似，这里我们给出它的表示 4 指针我们使用一个程序来展示 int (*)[col] 类型 #include &lt;stdio.h&gt;void func_1(int a[][8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_2(int (*a)[8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_3(int (*a)[8]) // 指向数组的指针&#123; for (int i = 0; i &lt; 8; i++) printf(&quot;%d &quot;, (*a)[i]);&#125;int main(void)&#123; int q[4][8]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 8; j++) q[i][j] = 10 * i + j; func_1(q, 4); printf(&quot;\\n&quot;); func_2(q, 4); printf(&quot;\\n&quot;); int p[8] = &#123;0, 1, 2, 3, 4, 5, 6, 7&#125;; func_3(&amp;p); // 因为是指向数组的指针，p必须要取地址&#125; 贴一篇文章 ：https://blog.csdn.net/soonfly/article/details/51131141 这篇文章里对指针类型的分析很好 int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"存储器层次结构 - CS:APP 第六章","slug":"存储器层次结构-CS-APP-第六章","date":"2022-09-04T03:28:41.000Z","updated":"2022-09-07T07:27:25.682Z","comments":true,"path":"2022/09/04/存储器层次结构-CS-APP-第六章/","link":"","permalink":"https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"存储器层次结构本章的主要内容有四： 介绍存储技术 介绍存储器的层次结构思想 特别介绍高速缓存的原理和细节 使用局部性优化程序的性能 本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。 1 存储器的层次结构根据我们的经验观察，读取速度越快的存储器&#x2F;存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。 因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。 但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 L0 寄存器L1 L1高速缓存 SRAML2 L2高速缓存 SRAML3 L3高速缓存 SRAML4 主存 DRAML5 本地二级存储（本地磁盘）L6 远程二级缓存（分布式文件系统、二级服务器） 下面我们介绍它们的存在基础，存储技术。 2 存储技术我们要介绍的存储技术如下 随机存储器RAM SRAM DRAM 非易失性存储器 ROM PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） SSD （基于闪存，固态硬盘就是使用SSD技术） 磁盘 2.1 随机访问存储器随机存储器分为两种材类：SRAM和DRAM SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。 DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。 2.1.1 DRAM &#x2F; 内存的工作原理内存由若干个DRAM芯片构成，被称作内存模块(memory module) 每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。 每个超单元内存储若干个位，一般是一字节八位。 内存/主存||- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片|- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片 首先介绍DRAM 芯片： DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c &#x3D; d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。 我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。 接下来看一下工作流程： 首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。 接着介绍内存模块： 一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 2.2 磁盘 &amp; ROMROM可分为 PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） 我们不多介绍，只需要知道他们的名字和依赖关系即可 磁盘：通常指的是机械硬盘，也不过多介绍。 3 高速缓存首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍： 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。 而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。 数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。 以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。 令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。 这句话暂且悬置。 当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。 但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。 3.1 高速缓存的结构 一个计算机存储器的地址有m位，他被分为三部分： 高t位是标记位 中间s位是组索引位 低b位是组偏移位。 高速缓存被组织为这样的结构： 高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1 每个组中最多有2^t^ 个高速缓存行 每个高速缓存行也由三部分组成 一位有效位，标记着这个高速缓存行是否有效 t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行 2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用 3.2 高速缓存的工作原理当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。 确定是否命中有三个步骤： 组选择 行匹配 字抽取 组选择 回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。 行匹配 如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。 如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。 补充 : 我们先回忆一下地址的构成 标记位 t + 索引位 s + 偏移位b 假设有一个四位的地址，t &#x3D; 1，s &#x3D; 2，b &#x3D; 1 这四位地址的所有组合如下： 我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。 我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。 这样我们较低层的 0、4 映射到了较高层的0组， 1、5映射到了1， 2、6映射到了2， 3、7映射到了3 一个组中可以有最多2^t^ 行，如果我们一组中只有一行。 如果我们首先引用了块0，那么块0每放在较高层的组0， 接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。 通过上面的例子，我想说明两点 一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。 二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？ 注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。 其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。 字抽取 只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。 4 虚拟内存从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。 虚拟内存提供三个重要的能力： 它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。 它位每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。 虚拟内存的存在基础： 同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。 4.1 虚拟内存原理首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。 我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。 4.2 虚拟内存的结构在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。 页表：每个进程都有一个页表，页表将虚拟页映射到物理页。 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。 4.3 虚拟内存的地址翻译下面简单概括以下虚拟内存的地址翻译： 处理器产生一个虚拟地址，并将它传送给MMU MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3 由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4 现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。 下面我们介绍虚拟地址翻译中的一些细节： 什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？ 要解答这个问题，首先我们要介绍虚拟地址的格式。 虚拟页号 VPN 虚拟页偏移 VPO 页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。 PTE 是什么，它的结构是什么？ PTE 是页表条目，他的结构是这样的 SUP 有效位 READ 有效位 WRITE 有效位 PPN 物理页号 (Physical Page Number) 前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。 PPN 物理页号是什么呢？ 让我们回忆以下我们在介绍高速缓存时用到的物理地址 如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。 而标记位和组索引合起来就是PPN。 而块偏移和虚拟地址的虚拟页偏移VPO是一样的 因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。 快表TLB的工作原理是什么？ 快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址： 虚拟地址由VPN和VPO组成 虚拟页号 VPN 虚拟页偏移 VPO 而虚拟页号VPN又可以分为两部分： VPN VPN VPO TLB标记(TLBT) TLB索引(TLBI) VPO TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。 接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。 5 高速缓存系统和虚拟内存系统的对比高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统 虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统 存储在某个存储层，在存储层之间传输的单元叫做块(block) 在高速缓存SRAM中，它叫做高速缓存行，或者行 在主存DRAM中，它叫做块(block) 在虚拟内存系统中，它叫做页(page) 调度策略 高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小 DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大 6 技术总结在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。 有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。 我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。 B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n &#x3D; m + o。 现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。 由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？ 我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t &#x3D; m - i 位来作为标记，区分一组中的不同块。 通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 为什么使用中间位作为索引？ 如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。 接下来我们概括一下内存系统： 一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。 如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。 7 术语索引主存储器(main memory 主存) : 即通常理解的使用DRAM内存。 块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block) VM (Virtual Memory) 虚拟内存 VA(Virtual Address) 虚拟地址 MMU(Memory Management Unit)：内存管理单元，一种硬件 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 页表 ：一个数据类型位PTE的数组 PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型 页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging) 缺页：DRAM缓存不命中称为page fault 内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"CS:APP 读后感","slug":"CS-APP-读后感","date":"2022-09-02T06:23:07.000Z","updated":"2022-09-03T15:05:12.432Z","comments":true,"path":"2022/09/02/CS-APP-读后感/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"CS:APP 读后感这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的） 接下来会陆续更新各章的详细笔记 … 介绍目录： 第1章 计算机系统漫游--- 程序结构和执行第2章 信息的表示和处理第3章 程序的机械级表示第4章 处理器体系结构第5章 优化程序性能第6章 存储器的层次结构--- 在系统上运行程序第7章 链接第8章 异常控制流第9章 虚拟内存--- 程序间的交互和通信第10章 系统及I/O第11章 网络编程第12章 并发编程 本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。 剩下的十一章是本书的正式部分，我认为本书的核心在第 79 章，26章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。 分章介绍第二章 信息的表示和处理 这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。 2.1.3 寻址和字节顺序： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。 2.16 布尔代数介绍 ： 可以使用位向量来表示有限集合。 2.2 整数表示 ： 介绍了整数原码和补码的表示，以及他们之间的转换。 2.3 整数运算 ： 介绍了整数运算可能出现的错误，以及来源。 2.4 ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。 第三章 程序的机器级表示 相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。 这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。 从这一张开始到最后，才是一口气看完的。 3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了objdump 的使用 3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。 3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。 3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法 第四章 处理器体系结构 这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。 第五章 优化程序性能 呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。 客观一点就是 普通人日常写代码小技巧 第六章 存储器层次结构 没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。 第七章 链接 含金量高的来了 这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld 7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位 7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表 7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接 7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方 动态链接：与加载的时候链接的类型 库打桩机制 第八章 异常控制流 最重要的一章之一，介绍了并发编程的基础——异常控制流 介绍了进程，简单带领读者入门了并发编程 讲了信号，有助于以后学习事件驱动的GUI编程 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 8.2 异常 8.3 进程 8.4 用C语言操作进程：fork execve 8.5 信号 SIGINT … 第九章 虚拟内存 最重要的一章之一 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 本章可以分为三部分 第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的 第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve 第三部分介绍了一个内存分配器的实现( malloc() ) 第十章 系统级 I&#x2F;O 这一章读起来很简单，没有什么要理解的东西 首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。 然后着介绍了RIO包，即包装后的IO函数。 本章完 第十一章 网络编程 这一章需要理解的地方不多，只有介绍网络编程的部分 第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。 首先介绍了网络编程 接着介绍了Linux的套接字函数 最后实现了一个小web服务器 11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议 第十二章 并发编程 和上一章差不多的感觉 本章也分为三部分 首先介绍了实现并发编程的三种方法 进程 IO多路复用 线程 之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。 最后介绍了并发编程容易出现的问题：死锁、访问共享变量 …","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"ubuntu 配置","slug":"ubuntu-配置","date":"2022-09-02T02:49:51.000Z","updated":"2022-09-07T06:20:54.963Z","comments":true,"path":"2022/09/02/ubuntu-配置/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 配置2022&#x2F;9&#x2F;1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。 VScode 下载和配置下载的方法见官网，配置C&#x2F;C++的方法网上的博客也很好搜到 Linux系统VsCode 配置C&#x2F;C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境 接下来使将Open With Code 添加到右键菜单 这部分参考 ubuntu中为vscode添加右键菜单–网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com) 其中修改了一点命令，将visual-studio-code 改成了code 去$HOME/.local/share/nautilus/script/ 目录下新建一个文件，文件名就是显示在右键菜单上的名字。 接着将以下内容复制到新建的文件中 #!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&#x27;s directory if it&#x27;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &#x27;s/^file://////&#x27;`&quot;fi# It&#x27;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec code &quot;$destination&quot; 最后运行命令chmod +x 刚才创建的文件名 对文件或文件夹右键就可以看到刚才添加的右键菜单了。 下拉式终端Yakuka在这里 找到 Ubuntu 根据提示安装。 如果安装失败可能要换清华源，如下： 更换清华源 参考：https://blog.csdn.net/weixin_49700990/article/details/122005001 首先使用lsb_release -a 查看自己的Ubuntu版本 我们要更改的文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list， 首先使用命令对这个文件进行备份 sudo cp /etc/apt/sources.list /etc/apt/sources_save.list 接着 进入清华源网站 ，找到Ubuntu的源 ，选择合适的版本，根据提示手动替换即可。 设置应用开机启动在Ubuntu自带的 “启动应用程序” 里配置 更改磁盘大小 参考 https://blog.csdn.net/Shine_Su/article/details/124630751 首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。 将虚拟机的内容复制到虚拟机外 参考：https://blog.csdn.net/u013554213/article/details/124061526 依次执行以下命令，最后重启Ubuntu # 删除原来安装过的文件sudo apt autoremove open-vm-tools# 输入安装命令：sudo apt install open-vm-toolssudo apt install open-vm-tools-desktop 截图软件 https://zhuanlan.zhihu.com/p/415011610 sudo apt install flameshot 查看安装路径 which flameshot 在设置中，添加键盘快捷键 命令是/usr/bin/flameshot gui","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"}]},{"title":"数据结构课程","slug":"数据结构课程","date":"2022-08-23T03:50:55.000Z","updated":"2022-08-23T03:56:14.161Z","comments":true,"path":"2022/08/23/数据结构课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数据结构课程进行中，持续更新 …","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"数字逻辑课程","slug":"数字逻辑课程","date":"2022-08-23T03:44:02.000Z","updated":"2022-08-29T15:15:11.740Z","comments":true,"path":"2022/08/23/数字逻辑课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数字逻辑课程进行中，持续更新 … 第一章 逻辑代数基础1.1 布尔代数也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。 · + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。 虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。 · 即合取，可以像乘号一样省略。 逻辑代数公理： 0 - 1 律 A + 0 = AA + 1 = 1A · 0 = 0A · 1 = A 重叠律 A + A = AA · A = A 互补律 A + ┐A = 1A · ┐A = 0 对合律 ┐┐A = A 交换律 结合律 分配律 A · (B + C) = AB + AC 与对或的分配A + BC = (A + B)(A + C) 或对与的分配 1.2 逻辑函数定义: 从n个逻辑变量到01的映射。记为F &#x3D; f(A1, A2, A3 … ) 逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式） 三种表示法： 逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成 真值表 卡诺图 用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。 挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。 1.2.3 两种标准形式最小项表达式：也叫积之和范式 或 主析取范式 最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。 最小项的表示： 对于n个变量而言，可以构成2的n次方个最小项表达式。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。 对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 mi 来表示这个最小项表达式。 Q：为什么要使用1代表原变量，用0代表反变量？ A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi &#x3D; 1，而且这是唯一的。 例如m6 &#x3D; AB┐C，其顺序为110B &#x3D; 6D，令对应的逻辑变量为1或0，则m6 &#x3D; 1 · 1 · (┐0) &#x3D; 1 例如，最小项表达式 AB, 转换成二进制即11，表示为m3。 最小项表达式A┐B，转换成二进制即10，表示为m2。 最小项的性质： 对于任意一个最小项，只有一组变量取值可以使其值为1 任意两个最小项之积为0 n个变量的所有2^n^ 个最小项之和为1 将任意表达式转换为最小项表达式： 利用公式A = A(B + ┐B) 最小项表达式的性质： 性质1：若mi是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi&#x3D;1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。 性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F&#x3D;F1+F2 将包括 F1 和 F2 中的所有最小项， G&#x3D;F1·F2 将包括 F1 和 F2 中的公有最小项。 性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成 思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式 使用归谬法证明 第一次课到此结束 最大项表达式： 也叫和之积范式或主合取范式 定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。 举例： 二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B) 三变量最大项表达式： 最大项表达式的三条性质类似最小项表达式的三条性质： 对于任意一个最大项，只有一组变量取值可使其值为0。 任意两个最大项 Mi 和 Mj 之和必为1。 n 变量的所有2^n^ 个最大项之积必为0。 最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。 任意逻辑表达式转换成最大项表达式： 先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。 类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。 AB + A┐B, 而这种表达式被称为 “与 - 或”表达式 最大项表达式的性质也与最小项表达式类似： 性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi&#x3D;0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F&#x3D;F1+F2将包括F1和F2中的公有最大项， G&#x3D;F1·F2将包括F1和F2中的所有最大项。 性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。 1.2.4 逻辑函数的三种表示法的关系用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。 同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。 从上一节的学习，我们直到逻辑函数有三种表示法： 逻辑表达式 真值表 卡诺图 首先，逻辑表达式形式都可以化成标准形式。 接着我们来看真值表与逻辑表达式的关系（最大&#x2F;小项表达式也是逻辑表达式）： 还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。 最大项表达式与最小项表达式恰恰相反： 最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。 最后我们来看一下卡诺图与真值表的关系： 卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合： ——————————————A B | F——————————————0 0 | 00 1 | 11 0 | 11 1 | 0—————————————— 它是一维的 线性的。 而卡诺图则二维的： 将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。 将项的组合换成数字的组合，我们得到卡诺图的简化形式 需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。 下面给出一个逻辑函数的卡诺图表示的例子： 补充：格雷码 https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 1位格雷码有两个码字 (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 2位格雷码 3位格雷码 4位格雷码 4位自然二进制码 00 000 0000 0000 01 001 0001 0001 11 011 0011 0010 10 010 0010 0011 110 0110 0100 111 0111 0101 101 0101 0110 100 0100 0111 1100 1000 1101 1001 1111 1010 1110 1011 1010 1100 1011 1101 1001 1110 1000 1111 第二次课结束 1.3 主要定理 &amp; 常用公式4个主要定理德摩根律： 当变量个数较少的时候，可以使用真值表法证明。 当变量较多的时候，使用数学归纳法证明。 香农定理： 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。 注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。 对偶定理: 对偶函数的定义： 将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数 设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) 则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) &#x3D; f (x1, x2, … , xn, 1, 0, ·, 1) 对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。 两个推论： 原函数与其对偶函数互为对偶函数。 两个相等的函数（f &#x3D; g）的对偶函数必定相等（f ‘ &#x3D; g ‘） 自对偶函数：一个函数的对偶函数等于它自己。 展开定理： 两个推理： 展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16 5个常用公式 AB + A┐B &#x3D; A 在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。 A + AB &#x3D; A 在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。 还可以写成ABC + ABCDE &#x3D; ABC A + ┐AB &#x3D; A + B 在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。 ┐C + CE &#x3D; ┐C + E AB + ┐AC + BC &#x3D; AB + ┐AC 包含律 在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。 AB + ┐AC + BCDE &#x3D; AB + ┐AC ┐(A┐B + ┐AB) &#x3D; ┐A┐B + AB 两个变量的异或的反 是 两个变量的同或 上面5个公式的对偶形式也是成立的 异或的性质A ⊕A &#x3D; 0 A⊕┐A &#x3D; 1 A⊕0 &#x3D; A A⊕1 &#x3D; ┐ A 重要 A⊕┐ B &#x3D; A ⊙ B &#x3D; A⊕B⊕1 A⊕B &#x3D; B⊕A 交换律 A⊕(B⊕C) &#x3D; （A⊕B) ⊕C 结合律 A(B⊕C) &#x3D; AB⊕AC 分配律 第三次课到此结束 应用一、转化称其他形式（详见P20） “与或” 表达式转 “或与”表达式 法一：分配律 法二：展开定理 “与或” 表达式 转 “与非 - 与非” 表达式 “与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式 或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可 因此我们的步骤是：两次取反，内层非用德摩根律断开 “与或” 表达式 转 “或非 - 或非” 表达式 “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 二、最大项表达式和最小项表达式的关系 ┐mi &#x3D; Mi 或 mi &#x3D; ┐Mi mi’ &#x3D; Mj，且i + j &#x3D; 2 ** n - 1 原函数 ​ – 变换 –&gt; 最小项表达式 ​ – 一次取反 –&gt; 符号错开，但保持最小项表达式，反函数的最小项表达式 或 或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式 ​ – 二次取反 –&gt; 原函数的最大项表达式（和原函数最小项表达式符号错开） 将最大项表达式或最小项表达式变成对偶函数： 首先将最大项变成最小项，或最小项变成最大项 其次将序号变成互补的序号 1.4 逻辑函数的化简 逻辑函数最简式的定义： 该式中乘积项最少 该式中的乘积项不能再用变量更少的乘积项代替 化简方法: 代数方法 卡诺图法 列表化简法 卡诺图法第四次课到此结束","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"BallMove:基于Qt的GUI小项目","slug":"BallMove-基于Qt的GUI小项目","date":"2022-08-21T11:46:01.000Z","updated":"2022-08-23T12:44:32.474Z","comments":true,"path":"2022/08/21/BallMove-基于Qt的GUI小项目/","link":"","permalink":"https://cfla1638.github.io/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"BallMove:基于Qt的GUI小项目简介在暑假学科目二的时候，看着 Qt学习之路2 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。 今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。 这个项目基于QGraphicsScene + QGraphicsItem + QGraphicsView， 模拟了一个小球在现实世界中的运动。 项目地址：cfla1638&#x2F;BallMove 设定功能：实现了实心球的运动。 考虑的因素有： 用户给予的加速度 重力 摩擦力 空气阻力 细节： 该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg &#x2F; m^3^ 。 重力加速度为 9.8 m&#x2F;s^2^ 。 静摩擦系数为 0.3。 空气阻力使用公式：F &#x3D; 1&#x2F;2 * CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 * 0.04^2^ 。 尺寸换算：1m &#x3D; 250px。 基础知识 Qt的绘制系统由QGraphicsScene + QGraphicsItem + QGraphicsView 相互配合使用。 QGraphicsScene 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。 QGraphicsItem 是在QGraphicsScene 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到QGraphicsScene，进行显示和管理。 QGraphicsView 提供了一个观察的视角，配合QGraphicsScene 进行显示。这个类可以被设为QMainWindow 的CentralWidget。 只有QObject 的子类可以使用信号槽的机制 QTimer类提供计时器功能，使用timer.start(sec) 功能开始计时，这里timer是一个QTimer类的一个对象，每经过sec时间后，timer就会发出一个timeout() 信号。 想要实现物体的运动，就要让物体的位置在每一帧里进行改变&#x2F;刷新（本程序的帧率是120），而QGraphicsScene 提供一个advance() 函数，该函数会调用所有在场景里的QGraphicsItem 对象的advance() 函数，因此我们只要每经过 1000 &#x2F; 120 毫秒 就调用一次QGraphicsScene::advance() 函数，就可以进行场景刷新，从而实现物体的运动。 每个QGraphicsItem::advance(int phase) 都会被一个QGraphicsScene::advance() 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase &#x3D; 0。第二次QGraphicsScene::advance() 将phase &#x3D; 1 传入函数并调用。 基于此，我们只需要在phase &#x3D; 1是进行处理，phase &#x3D; 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。 Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在QGraphicsScene 中的全局坐标系，它记录了每个QGraphicsItem 的位置。第二个是每个QGraphicsItem 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。 每个继承了QGraphicsItem 的类都要重载以下四个函数。 QRectF boundingRect() const;QPainterPath shape() const;void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);void advance(int phase); boundingRect() 返回一个包裹住QGraphicsItem 对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。 shape() 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) 该函数一般由QGraphicsScene 自动调用，绘制该项目。 这个函数一般这样写 void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); // 保存画笔状态 //设置新的画笔状态 painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); // 绘制图型 painter-&gt;restore(); // 还原画笔状态&#125; 我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。 painter-&gt;fillPath(shape(), Qt::blue); 这一行绘制我们在shape() 中返回的图型，在此之前我们可以设置画笔的状态。 编写头文件的建议 如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。 为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。 即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。 项目设计首先来看一下运行效果： 在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象另外，这棵树也为我们展示了本项目的设计思路。└─MainWindow ├─Controller │ ├─Ball │ ├─Balldata │ ├─Ground │ └─QGraphicsScene - Reference ├─QGraphicsScene └─QGraphicsView 自下而上，首先来看Controller下的三个类， Controller下有三个类，分别是Ball, Balldata, Ground，他们都是QGraphicsItem 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。 这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。 值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。 接着是Controller类。 顾名思义，Controller类是我们程序的控制器。 Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。 最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。 当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的QMainWindow::show() 和 QApplication :: exec() 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。 项目实现文件结构首先看一下我们的文件结构 BallMove - BallMove.pro Headers - ball.h - balldata.h - constants.h - controller.h - ground.h - mainwindow.h Sources - ball.cpp - balldata.cpp - controller.cpp - ground.cpp - main.cpp - mainwindow.cpp Ball类的实现首先看一下ball类的实现 class Ball : public QGraphicsItem&#123;public: Ball(qreal x, qreal y); QRectF boundingRect() const; QPainterPath shape() const; void advance(int phase); QPointF getPos()&#123;return pos();&#125; int forceCount = 4; qreal a[2][4]; qreal vx = 0; qreal vy = 0;protected: void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);&#125;; 首先我们来看Ball类的私有变量： 由于我们运动的平面是二维的，因此我们使用一个二维数组qreal a[2][4] 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即a[xAxis][AirResistance] 。如果想要引用y方向的重力加速度，就使用a[yAxis][Gravity] 。 qreal vx, vy 即小球的x方向速度，和y方向的速度。 int forceCount 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。 接着我们来看一下Ball类中声明的函数: 第一个函数getPos()很好理解，即返回小球在全局坐标系中的坐标。 接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：paint() shape() advance() boundingRect() boundingRect : QRectF Ball::boundingRect() const&#123; return QRectF(-BALL_SIZE * 2, -BALL_SIZE * 2, BALL_SIZE * 4, BALL_SIZE * 4); &#125; QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。 BALL_SIZE 定义在constants.h 代表小球的直径。 shape() : QPainterPath Ball::shape() const&#123; QPainterPath path; path.addEllipse(QPointF(0, 0), BALL_SIZE / 2, BALL_SIZE / 2); return path;&#125; 这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。 paint() ： void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); painter-&gt;restore();&#125; 在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。 advance() ： void Ball::advance(int phase)&#123; // 只有phase为1时进行处理 if (!phase) return ; // 计算合力 qreal sumAx = 0, sumAy = 0; for (int i = 0; i &lt; forceCount; i++) &#123; sumAx += a[xAxis][i]; sumAy += a[yAxis][i]; &#125; if (sumAx) vx += (sumAx / FRAME_RATE); if (sumAy) vy += (sumAy / FRAME_RATE); qreal x = fmod(pos().rx() + vx / FRAME_RATE, 1000), y = fmod(pos().ry() + vy / FRAME_RATE, 1000); // 处理小球越界 if (x &lt; 0) x += 1000; if (y &lt; BALL_SIZE / 2) y = BALL_SIZE / 2; // 设置新位置 setPos(QPointF(x, y)); update(); // 更新显示小球&#125; 由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。 在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。 需要注意，一、因为我们的速度、加速度定义为m&#x2F;s和m&#x2F;s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。 二、在设置了小球的位置之后，需要使用update() 函数更新小球的位置。 constants.h 参数存储文件constants.h 文件中存放了项目的各种参数 const int FRAME_RATE = 120; // 帧率：120帧 帧率过低时碰撞会穿透地面const int BALL_SIZE = 20; // 球的直径：20px// 400 对应 112 重力// 3000 对应 2450 重力const int X_SPEED = 1500; // 左右键给球的加速度const int Y_SPEED = 3000; // 上下键给球的加速度const int FRICTION = 735; // 摩擦力大小const int FRICTION_SENSITIVITY = 2; // 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力// 112 对应1.75 米的人// 2450 对应 8cm 的实心球const int GRAVITY = 2450; // 重力大小const double M = 2.1038; // 小球质量enum Directions&#123;xAxis, yAxis&#125;; // x, y轴方向enum Force&#123;User, Gravity, Friction, AirResistance&#125;; // 力的四个维度，用户给出的力，重力，摩擦力，空气阻力 需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。 Balldata &amp; ground这两个类都继承了QGraphicsItem 和Ball类类似，因此我们不在赘述。 Controller类首先看一下Controller类的定义 class Controller : QObject&#123; Q_OBJECTpublic: Controller(QGraphicsScene &amp; scene, QObject * parent = 0); void track(bool); void gravity();public slots: void drawLineOfTrack(); void resume(); void pause(); void advance();protected: bool eventFilter(QObject *atched, QEvent *event);private: void handleKeyPressed(QKeyEvent * event); void handleKeyReleased(QKeyEvent * event); QTimer timer; Ball * ball; QGraphicsScene &amp; scene; Ground * ground; ballData * data;&#125;; Controller类有以下几点功能： 处理键盘事件：如上下左右移动，打开&#x2F;关闭 轨迹显示，清屏。 相关地函数有： bool eventFilter(QObject *atched, QEvent *event);void handleKeyPressed(QKeyEvent * event);void handleKeyReleased(QKeyEvent * event); 控制程序的开始与结束 相关地函数有： void resume();void pause(); 控制程序的一步步地推进，即让小球动起来。 相关地函数有： void advance(); 其他功能 相关地函数有： void track(bool);void gravity();void drawLineOfTrack(); 在这里我们只介绍advance() 函数 void Controller::advance()&#123; scene.advance(); // 首先调用场景的advance() // 获取碰撞信息 static bool lastStatus = false; // 上一帧是否碰撞 static bool nowStatus = false; // 当前是否处于碰撞 nowStatus = ball-&gt;collidesWithItem(ground); //处理碰撞 if (nowStatus == true &amp;&amp; lastStatus == false) &#123; ball-&gt;a[yAxis][Gravity] = 0; // 碰撞时重力与支持力抵消 ball-&gt;vy = -(ball-&gt;vy * 0.667); // 回弹 2/3 的速度 ball-&gt;a[yAxis][User] = 0; // 竖直方向速度为0 &#125; // 处理摩擦力 if (nowStatus) &#123; if (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION; else if (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION; else ball-&gt;a[xAxis][Friction] = 0; &#125; // 没有碰撞的时候 if (!nowStatus) &#123; // 摩擦力置零 ball-&gt;a[xAxis][Friction] = 0; ball-&gt;a[yAxis][Gravity] = GRAVITY; &#125; // 处理空气阻力 qreal sumV = pow(ball-&gt;vx, 2) + pow(ball-&gt;vy, 2); if (fabs(sumV) &gt; 10) &#123; qreal airSum = 0.0009744 * sumV / 250; if (sumV == 0) sumV = 1; ball-&gt;a[xAxis][AirResistance] = (fabs(ball-&gt;vx) / (sqrt(sumV))) * airSum; ball-&gt;a[yAxis][AirResistance] = (fabs(ball-&gt;vy) / (sqrt(sumV))) * airSum; // 将力换算成加速度 ball-&gt;a[xAxis][AirResistance] /= M; ball-&gt;a[yAxis][AirResistance] /= M; if (ball-&gt;vx &gt; 5) ball-&gt;a[xAxis][AirResistance] *= -1; else if (ball -&gt; vx &lt; 10) ; else ball-&gt;a[xAxis][AirResistance] = 0; if (ball-&gt;vy &gt; 5) ball-&gt;a[yAxis][AirResistance] *= -1; else if (ball -&gt; vy &lt; 10) ; else ball-&gt;a[yAxis][AirResistance] = 0; &#125; lastStatus = nowStatus; data-&gt;update(); // 更新数据显示&#125; 由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。 等运动结束之后，我们使用Qt地碰撞检测函数collidesWithItem()看小球是否接触地面。 接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。 其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。 MainWindow 类MainWindow类的代码如下 class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void adjustViewSize();private: void initScene(); QGraphicsView * view; QGraphicsScene * scene; Controller * controller;&#125;; 唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; scene = new QGraphicsScene(this); view = new QGraphicsView(scene, this); controller = new Controller(*scene, this); setCentralWidget(view); resize(750, 750); initScene(); QTimer::singleShot(0, this, SLOT(adjustViewSize()));&#125; 在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的centralWidget 并调整了窗口大小。 在倒数第二步，调用initScene 对scene进行调整。 以上的这些步骤都不会有什么问题，只有最后一步令人困惑： QTimer::singleShot(0, this, SLOT(adjustViewSize())); 首先解释singleShot() 函数，这个函数的声明如下 void QTimer::singleShot(int msec, const QObject *receiver, const char *member) 它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。 那么为什么要使用这个功能呢？ 这里有两个解释 那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数。这就是为什么我们需要用QTimer而不是直接调用adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的callLater()函数。 这个解释来自《Qt学习之路2》 但我并不清楚这里的 “下一次事件循环” 的意思。 依我的理解，应该是这个意思：某个QObject 发出 paintEvent() 事件，但对这个事件的处理比较耗时，如果此时直接调用adjustViewSize() ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用adjustViewSize() ，我们会发现视图小小的挤在屏幕的中间。 后来我又在网上发现了这篇博客：QTimer::singleShot(0, this, slot函数)； ，意思和我理解的大概相似。 但还是挖个坑，等我以后学精了一定回来解释清楚。 参考C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范 Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World","categories":[{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]},{"title":"配置博客","slug":"配置博客","date":"2022-08-20T14:58:00.000Z","updated":"2022-08-21T12:05:04.405Z","comments":true,"path":"2022/08/20/配置博客/","link":"","permalink":"https://cfla1638.github.io/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"博客配置 &amp; 使用教程简介该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。 本文章记录了配置博客和使用博客的一些细节，供以后的我参考。 持续更新中 …… 工作原理在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。 基本命令 调试： hexo server --debug 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面 修改&#x2F;发布博客 进行更新： hexo clean 清理缓存和public文件夹 hexo g generate，生成静态页面，该操作之后即可在本地预览。 hexo d deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。 发布博客 hexo new [layout] [title] 使用layout，在_post&#x2F;title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。 配置文件 可以在 _config.yml 里配置Hexo，在 _config.nexmoe.yml 里配置nexmoe主题。 _config.yml : 配置 网站的标题、副标题、关键词、作者、语言、时区 部署设置，其中repository可以填ssh的链接（执行git clone 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。 _config.nexmoe.yml： 网站的默认头图，头像，图标等均在这里配置。 如果要使用本地相对路径，./ 的绝对路径即博客根目录下的source文件夹。 front-matter在这里可以配置文件的变量。 hexo 的文档：Front-matter | Hexo nexmoe 的私有 front-matter 文档：Front-matter | Hexo Theme Nexmoe 如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900 --title: &lt;title&gt;others...cover: 图片链接--- 配置分类和标签要像这样配置： categories:- Diarytags:- PS3- Games 其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见这里 widgets 关于 “文件归档”：归档页面 | Hexo Theme Nexmoe 关于 “关于博客”：是./ 目录下的一个markdown文件，与其他博文相同。 其他部件可以在_config.nexmoe.yml 里配置 评论系统nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 Valine ，使用方法非常简单，按照Valine的官方手册一步步操作即可。 资源iconfont-阿里巴巴矢量图标库 参考文档Hexo参考文档 Nexmoe 参考文档 nexmoe GitHub地址 从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"},{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"},{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]}