{"meta":{"title":"cfla's blog","subtitle":"","description":"","author":"cfla","url":"https://cfla1638.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-20T23:36:33.219Z","updated":"2022-08-20T14:43:28.978Z","comments":true,"path":"Archives.html","permalink":"https://cfla1638.github.io/Archives.html","excerpt":"","text":""},{"title":"关于博客","date":"2022-08-20T16:00:00.000Z","updated":"2022-09-02T05:08:53.737Z","comments":true,"path":"about.html","permalink":"https://cfla1638.github.io/about.html","excerpt":"","text":"关于博客建站日期：2022 年 8 月 20 日 About Blog建立一个自己的博客站，最主要的目的是记录自己在计算机这条路上学到的知识。 写下这些内容的时候是大二，在大一时，我看了好多本计算机专业的书，比如《C++ Primer》，《C Primer Plus》。 暑假的时候我学了Qt，用到 C++ 的 OOP 时，我才意识到自己之前学到的知识是不牢固的。刚看完的书，没有经过实践，就是不能变成自己的东西。但我又不能将所有的内容都去实践。因此我决定为看过的计算机类的书籍都写读书笔记，内容主要是看完这本书的感受，学到的东西。就像操作系统切换进程需要保存上下文一样，将对这本书印象最深时的 “上下文” 保存下来，等以后需要的时候能够快速开始。 同样的道理，也适用于刚做完的项目，刚配置好的系统 … 因此，我的博客将记录自己在计算机领域学到过的、实践过的知识 以及 解决问题的经验。 About me 计算机科学与技术专业 内向的、焦虑的、热爱学习、向往未来的 OTAKU"}],"posts":[{"title":"Visual Studio 用法","slug":"在Visual-Studio中引入第三方库","date":"2023-03-09T11:09:01.000Z","updated":"2023-03-09T11:32:03.179Z","comments":true,"path":"2023/03/09/在Visual-Studio中引入第三方库/","link":"","permalink":"https://cfla1638.github.io/2023/03/09/%E5%9C%A8Visual-Studio%E4%B8%AD%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","excerpt":"","text":"引入第三方库 （以OpenCV为例）在右侧导航栏项目名称上右键，点击属性 在VC++页面中，找到包含目录和库目录，将要引用的第三方库的include目录和二进制库文件分别添加到里面去。 具体地，以OpenCV 4.7为例，需要包含的目录有: 最后在【链接器 → 输入】里面，指定具体需要用到的库 汇编语言环境 （MASM） 配置汇编项目 1.创建一个 Visual C++ 空工程 (Empty Project), 此时先不要添加汇编源文件。 2.在 “解决方案浏览器” 视图中, 在项目名称上右击 —&gt; 选择 “生成自定义“ —&gt; 在弹出的 “Visual C++ 生成自定义项文件” 窗口中, 勾选 masm(.targets, .props) 项。 3.在 “解决方案浏览器” 视图中, 在项目名称上右击 —&gt; 选择 “属性” —&gt; 在左侧 “配置属性” 导航中 —&gt; 选择 “链接器” —&gt; “系统” —&gt; 在 “子系统“ 右侧下拉菜单中选择 “控制台(&#x2F;SUBSYSTEM:CONSOLE)” (注：VS2022已自动配置) 4.添加汇编源代码 file.asm (添加 C++ 文件, 然后将后缀修改为 .asm), (这一步要放在最后, 否则可能会报错) 。 引入依赖库 1.链接器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —&gt; “链接器” —&gt; “常规” —&gt; “附加库目录” —&gt; “c:\\Irvine”. 2.链接器中添加 “附加依赖项”. 在 “解决方案资源管理器” 中, 项目名称上右击 —&gt; “链接器” —&gt; “输入” —&gt; “附加依赖项” —&gt; 主要包含库: user32.lib, Irvine32.lib, kernel32.Lib . 3.汇编器中添加包含路径. 在 “解决方案资源管理器” 中, 项目名称上右击 —&gt; “Microsoft Macro Assembler” —&gt; “General” —&gt; “Include Paths” —&gt; 添加库目录, 如 “c:\\Irvine” (注意：此选项在添加 .asm 源文件后才出现). 其他注意到，参考文献 2 中 还提到了一些其他的引入第三方库的方法。 参考文献[1] Visual Studio 下配置第三方C&#x2F;C++库的方法 : https://blog.csdn.net/yangfchn/article/details/85162934 [2] VS配置OpenCV教程（超详细） : https://blog.csdn.net/mars_xiaolei/article/details/78759041 [3] Getting Started with MASM and Visual Studio 2022 : http://www.asmirvine.com/gettingStartedVS2022/index.htm","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"关于英文论文作者名称中逗号与句号的使用","slug":"关于英文论文作者名称中逗号与句号的使用","date":"2023-03-06T03:09:00.000Z","updated":"2023-03-06T14:33:01.292Z","comments":true,"path":"2023/03/06/关于英文论文作者名称中逗号与句号的使用/","link":"","permalink":"https://cfla1638.github.io/2023/03/06/%E5%85%B3%E4%BA%8E%E8%8B%B1%E6%96%87%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E5%90%8D%E7%A7%B0%E4%B8%AD%E9%80%97%E5%8F%B7%E4%B8%8E%E5%8F%A5%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Q : 论文作者名称中句号和逗号的意义是什么 A : 你好，这是必应。😊 论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。一般来说，句号用于分隔作者的名和姓，逗号用于分隔多个作者1。例如： 张三.李四,王五.赵六. 表示有两个作者，分别是张三和王五，他们的名字是李四和赵六。 如果你想了解更多关于参考文献著录规则的信息，你可以查看GB&#x2F;T 7714—2015《信息与文献：参考文献著录规则》2。 论文中作者顺序也有一定的含义，通常反映了作者对论文的贡献大小3。例如： 张三.李四,王五.赵六*,刘七.钱八. 表示第一个作者是张三，最后一个作者是刘七，通讯作者（负责联系编辑和审稿人）是王五。 你还有什么问题吗？ Q : 我指的是英文，例如 Howard, J., Hyman, A.A.: ‘Dynamics and mechanics of the microtubule plus end’Nature, 2003, 422, (6933), pp. 753–758. A : 原来如此，你是指英文论文的作者名称。😊 英文论文的作者名称中句号和逗号的意义也可能因不同的引用格式而有所不同。一般来说，句号用于缩写作者的名字，逗号用于分隔多个作者1。例如： Howard, J., Hyman, A.A. 表示有两个作者，分别是Howard和Hyman，他们的名字缩写为J和A.A. 不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者123。例如： Howard, J., Hyman, A.A., &amp; Smith, P. 表示有三个作者，分别是Howard、Hyman和Smith。 Howard, J., et al. 表示有多个作者，只列出了第一个作者Howard。 你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。 Q : Howard, J 代表一个人，为什么它的名字中间还有逗号呢？ A : Howard, J 代表一个人，但是它的名字是由两部分组成的，姓和名。在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。例如： Howard, J. 表示作者的姓是Howard，名是J开头的单词，比如John或James。 你明白了吗？ Q : 所以姓和名之间要用逗号分隔，此外，多个人名中间也需要使用逗号分隔，我理解的正确吗 A : 是的，你理解的正确。😊 姓和名之间要用逗号分隔，多个人名中间也需要使用逗号分隔。这样做可以清楚地表达作者的身份和数量。例如： Howard, J., Hyman, A.A., Smith, P. 表示有三个作者，分别是Howard、Hyman和Smith。 你还有什么问题吗？ Q : 请问 Smith, P. 这个名字，他最后的句号代表什么呢？ A : Smith, P. 这个名字，最后的句号是用来表示作者的名字是缩写的。如果作者的名字不是缩写的，就不需要最后的句号。例如： Smith, Peter 表示作者的名字是Peter，不是缩写的。 Smith, P. 表示作者的名字是P开头的单词，比如Paul或Patrick，是缩写的。 你还有什么问题吗？ Q : 你可以总结一下我们这次的对话，最好有所有的细节，我想保存这次对话，以便于下次查阅，谢谢！ A : 好的，我很乐意为你总结我们这次的对话。😊 我们这次的对话主要是关于论文作者名称中句号和逗号的意义。以下是我们讨论的要点： 论文作者名称中句号和逗号的意义可能因不同的引用格式而有所不同。 一般来说，句号用于分隔或缩写作者的名和姓，逗号用于分隔多个作者。 不同的引用格式可能还有其他的规则，比如使用“&amp;”或“and”连接最后两个作者，使用“et al.”表示多个作者。 你可以根据你要投稿的期刊或者你所在学科的要求选择合适的引用格式。 在英文论文中，通常先写作者的姓，然后用逗号隔开，再写作者的名的缩写。这样做可以方便读者区分作者的姓和名，也可以节省空间。 如果没有下一个作者，就不需要最后一个逗号。如果作者的名字不是缩写的，就不需要最后一个句号。 我希望这次总结能够帮助你更好地理解论文作者名称中句号和逗号的意义。如果你还有其他问题，请随时提出。🙏 关于复姓 Q : 对于复姓的中国作者，他们的名称应该怎样书写呢，例如欧阳 洪，其中欧阳是姓氏，洪是名称。读音是Ouyang Hong A： 对于复姓的中国作者，他们的名称应该按照复姓的拼音和名称的首字母写出，复姓用连字符连接。例如，欧阳 洪的引文格式应该是 Ouyang-H., 或者 Ouyang-Hong","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"西方哲学史 希尔贝克","slug":"西方哲学史 希尔贝克","date":"2023-01-22T03:50:55.000Z","updated":"2023-01-28T02:16:29.980Z","comments":true,"path":"2023/01/22/西方哲学史 希尔贝克/","link":"","permalink":"https://cfla1638.github.io/2023/01/22/%E8%A5%BF%E6%96%B9%E5%93%B2%E5%AD%A6%E5%8F%B2%20%E5%B8%8C%E5%B0%94%E8%B4%9D%E5%85%8B/","excerpt":"","text":"《西方哲学史》希尔贝克 读书笔记Notes在这里记录一下自己感兴趣的问题： 是否存在普遍的善和正当的价值规范存在 智者派的相对主义 苏格拉底的驳斥 柏拉图的理念论 从这里记录一下自己的想法： 很多哲学家都强调过一些东西： 比如苏格拉底强调要通过开放性的对话获得对真正自我的洞见 康德说要运用理性是自己摆脱不成熟状态 罗素说要告诉自己事实是什么 他们的意思都大体相同，都是在强调通过理性形成自己的观点。 前言苏格拉底 苏格拉底感兴趣的是 认识论 和 伦理-政治问题 在认识论上，苏格拉底认为的知识可由粗略的三分法来表述 有关是什么的知识 对于应当是什么的知识 对真正自我的洞见（即通过理性的信服而不是通过修辞术的说服） 要如何获得第三种知识，苏格拉底赞同一种开放性的对话方法，在公开讨论中，让讨论的各方充分地了解论题，得到自己信服的观点。 在伦理政治问题上，驳斥怀疑论，承认有普遍的善和正当的价值规范存在 知识即美德，拥有知识就回去行善，就会导向幸福。 即使苏格拉底得不出一个确定的哲学答案，但他仍在努力寻求答案，仍在赋予道德一个特定的认识论基础 我的理解是，苏格拉底想要在认识论上为道德奠定一个基础，即一个拥有“对真正自我的洞见”的人不去行善，是不可思议的。 柏拉图 本体论，理念论，认为理念是客观存在的第一实体 认识论，回忆说，灵魂通过可感现象的刺激回忆起前世对理念的知识。但柏拉图认为对理念的洞见只有少数人才能达到。 在伦理学上，由于理念论的存在，存在客观存在的善的理念，因此道德具有稳固的基础，即存在普遍的善和正当的价值规范。 一个行为之所以是善的，是因为它分有了善的理念，而善的理念还与智慧、勇敢和节制有关，理念和理念之间交织在一起。 政治上，柏拉图怀疑人们的知善能力，认为必须由「专家」们执政，因此有了三种社会层次——生产者、管理者和统治者。（理想国） 艺术上，柏拉图认为艺术作品不能「为艺术而艺术」，理念之间是相互联系的，善、美的理念交织在一起，艺术不能脱离道德，艺术不是道德中立的。 柏拉图认为艺术的本质是复制和摹仿，理念是可感事物的原型，它是复制可感事物的艺术品的原型，因此艺术家应该努力复制理念。艺术家可以不只受可感事物的激发，而直接被理念激发，这样艺术家就成了传递理念的媒介。 亚里士多德 本体论（形而上学）， 实体与属性论，亚里士多德认为只有个别的事物是存在的，即「实体」。颜色，形状等都是作为实体的属性，离开了实体，属性无法独立存在。属性分为本质属性和非本质属性，根据这两种属性之间的划分，形成了「种的概念」，属性和种是相对存在的。 四因说，亚里士多德将世界上事物变化与运动背后的原因归纳为四大类，即质料因、形式因、动力因、目的因。 潜能 - 现实，变化是潜能的现实化 分级的有机世界观，从纯质料到达纯现实，从无机物到人。在亚里士多德的世界观中，每一种事物都倾向于以最好的方式去实现自己的潜能，万事万物都有一种「向上」的渴望。但是每一个种在宇宙中都有既定的位置。 认识论 获取知识的第一步是用我们的感官来经验个别事物，第二步是从偶然性中抽象出本质和共相。 亚里士多德把知识的获取过程看成一个从感觉经验到本质洞见的过程。 亚里士多德区分了三种学科： 理论科学：目的是确定真理。如自然哲学、数学、形而上学。 实践科学：通过获得性的伦理能力导向明智的行动。如政治学。 创制科学：生产某物，具有创造性。如诗学和修辞学。 伦理学，亚里士多德认为人如同一粒种子，具有可实现的潜力（理性），人要经历社会化的三个阶段（家庭、村落、城邦），在共同体中找到自己的位置。 政治上，支持平等原则。收集了158中城邦材料，讨论其中最好的形式：必须要听取民众的意见，必须要依法治国。 结论是：有限民主是最好的国家政体。这一国家由法律治理，而且是「混合政体」：在量上实行民主制原则，质上实行贵族制原则。 艺术上，亚里士多德认为，艺术是自身产生愉悦的模仿。艺术同样具有道德上的功能，具有净化或纯化的作用。 关于艺术在道德上的功能的两种解释： 艺术的净化作用在于它能使我们「释放情绪」。通过体验戏剧中的英雄、恶棍和崇高的感情，我们释放出被压抑和控制不住的情感，这样就恢复和谐，并重新开始过依照「中道」理想的生活。 艺术的净化作用在于，我们人可以通过艺术来得到教化，使精神升华。 希腊化 - 罗马时期 希腊化时期人民对政治感到无能为力，这种无能为力在思想上表现在：回避对社会进行哲学思辨，而关注如何确保个人的幸福。希腊化时期有一种从关心共同体中的人向关心孤立的、私人的个体的普遍转向。 对于希腊人，法律仅仅适用于地方共同体中的人。到了希腊化时期，出现了一种把法律当作不分国家，不分地位人人适用的普遍法则的观点。（自然法） 「政治」词义的转变，在古希腊，政治指调节一个城邦的地方共同体中的公共活动的理性讨论，在希腊化时期，它主要指统治一个帝国的一般的法律原则。 伊壁鸠鲁主义 伊壁鸠鲁主义是一种受谨慎和深思熟虑影响的快乐哲学，它可以被概括如下 存在着唯一的善是快乐 要确保最大的快乐，我们必须只享受我们能支配的快乐。 伊壁鸠鲁主义的快乐不是一时的感性欲望，伊壁鸠鲁主义者强调那些更精致、更稳定的快乐形式，如友谊、文采。 犬儒学派 犬儒们从社会中抽身，过着一种简单地、半原始的生活 犬儒主义教导境遇不利者要满足于他们所拥有的东西，即使他们一无所有。 希腊斯多葛学派 幸福观（同苏格拉底和柏拉图）：一个人幸福的唯一条件是他或她过有德性的生活，而美德是以知识为基础的。 补充：美德 arete，与英语中的virtue一词相似 arete，美德意味着一个人在社会中实现他的真正潜能，因此是积极美德。（消极美德：不去作恶） 这种美德是道德上的优秀也是指一个人尽可能好地履行被赋予地职能或角色的优秀。教师的优秀体现在教的好，铁匠的优秀体现在能制作出好的工具，人的美德在于尽其所能，实现人之为人的真正潜能。 宿命论，万物都受逻各斯或神的引导，人的任务是去学会对发生的一切事情都愉快地接受，在命运的判决面前，一个人应该显示出斯多葛式的平静。 或者说 人应该去支配自己能够支配的东西，如自己的内心。 希腊 - 希腊化时期的斯多葛学派 成为了中产阶级的意识形态，强调责任与品格，重视一种适用于所有人的自然法。 罗马的斯多葛学派 历史观，对世界历史持有一种循环的观点（宿命论的），任何事物都会像四季那样重复自身，万物都重复自己，那么我们就无法改善这个世界，我们只能尽可能地忍受。 个人，个人不再是群体的有机部分，而是普遍法典和政府体制下的一个人。 法律的来源，对斯多葛学派来说，每个人心中都存在一团「圣火」，他们从普遍理性中引出自然法。（即自然法基于普遍理性） 「完善的法律要到智者的灵魂之中去找」 西塞罗 自然法，法律的-政治的法则的基础在于一个普遍的自然法则（自然法），自然法适用于所有人。 霍布斯 自然哲学：彻底机械唯物主义 政治哲学： 观点： 建立一个可以确保和平与秩序的政府，权力必须集于一身，不论是国王的政府还是议会的政府，都要确保和平与秩序。 研究方法：功能主义的分析与综合 霍布斯用一种功能主义的方法去理解社会，他考察社会各部分的功能，然后将他们组合到一起。霍布斯的方法，不是一种还原论，他不认为整体的功能是部分的组合。 研究历程： 首先考虑政府的作用，用一个思想实验来说明政府的功能，如果没有政府，人们将生活在一种一切人反对一切人的战争的自然状态。由于个人自我保存的需要，一个建立在一种受理性承认的社会契约的基础上的国家出现了。这个国家的政府通过确保和平与秩序而获得合法性，它拥有所有的权力，当政府不能确保和平与秩序时，它也就失去了合法性。 （个人感想）霍布斯的说明是功能主义的，他说社会契约创造的国家政府使人们远离自然状态，并不是说真的存在自然状态，只是在功能主义的思想实验中，如果没有政府，可能会存在一切人对一切人的战争。 正如作者在洛克一节中补充道： 自然状态学说并不是一种关于国家起源的学说，并不是关于国家实际上如何产生的学说，而是一种说明国家是什么，并为国家提供合法性的学说。 资本主义的发展与意识形态之间的联系： 早期的资本主义：生存斗争非常艰苦，需要一个专制君主（霍布斯的观点） 比较成形的资本主义：市民阶级有必要关注专制君主和相对不可侵犯的权利。 完全形成的私人资本主义和自由放任的自由主义：出现了关注快乐的功利主义。 关于自由和自由主义 自由主义（liberalism）和自由主义者（liberalist）:其基本概念是个人、契约和国家 自由气度（liberality）和自由派人士（liberal）：倾向于宽容和司法自由的正面的道德的态度。 洛克既是自由主义者又是自由派人士，霍布斯可有说是自由主义者但不是自由派人士。 自由并不是一个独立成立的概念，一种关于自由的哲学必须预设了一个讨论有关什么是自由的、以什么方式它是自由的学说。 对于自由主义者来说，自由地主体是被理解为自我满足的、理性的、自私自利地行动着地个人，因此我们把自由主义定义为一种形式地个人主义的时候，并不是随心所欲的。 理解自由主义，是离不开它所预设的社会哲学或存在论的——同样，理解任何其他有关自由的学说，也离不开与之伴随的有关什么是自由的、相对于什么而自由的学说。 通常人们用自由主义这个术语来表示这样一些政治-经济理论，他们把自由看作一个基本价值，把个人的开明的自利看作是基础的驱动力，而把国家的任务看作是为独立的行动者确保和平与秩序。 笛卡尔唯理论 有条理的怀疑，确定什么是逻辑上可怀疑的。 我思故我在，是笛卡尔的出发点，他认为自己拥有一个关于完美存在的观念，而关于完美存在的观念不能是由不完美的存在（自己）引起的，因此只能是由上帝引起的。 这样笛卡尔为之前那些原则上可错的知识进行了平反，他们有了一个牢固的基础。 心物二元论：物质实体和精神实体都是存在的，他们相互影响，在松果体交互。 斯宾诺莎 斯宾诺莎在认识论上是一个唯理论者，在道德理论上与斯多葛学派相近，在自然理论上与泛神论有联系。 在认识论上，斯宾诺莎预设了我们拥有清晰的直觉（清晰而确定的知识）。有三种认识的道路，其中借助逻辑推理的方式获得知识是可靠的。 在本体论上（斯宾诺莎在他的《伦理学》中阐述），斯宾诺莎以一种几何学、唯理论的方式进行思考，它首先设定了一些公理，然后从这些公理出发去演绎。 斯宾诺莎对实体的定义（公理）是：「实体，我理解为在自身内并通过自身而被认识的东西。」，即实体是独立的，不依赖他物而存在的。 根据这个定义，如果存在两个以上的实体，那么第一个实体和第二个实体之间的关系就会被包括到我们对实体的理解中，这样实体就不是独立存在的了，这与我们所定义的实体的概念相悖，因此只有一个实体，实体是一，也是无限。 如果存在一个神的话，神不可能是有别于实体的东西，因此实体就是神。（我的理解是，如果一个人信仰存在神的话，它可以把实体理解为神） 实体，属性和样式 实体可以有无限多的显现方式，它向我们现行的方式就是两种属性——思维的属性和广延的属性，而一本书可以是广延属性之下的样式，一个人的思想可以是思想属性下的样式。（关于样式，我认为可以这样理解，想象实体是一个巨大的球体，而上边有很多纹路，即样式，我们用不同的属性去观察实体上的样式，用广延的属性去观察，我们看到了人的形体，用思维的属性去观察，我们看到了人的思想） 关于自由 斯宾诺莎认为，一个人根本上是与实体统一的，因此说一个人相对于实体而自由或者受实体强制是毫无意义的。 莱布尼茨 莱布尼茨说表面上给人印象是物质的、被动的那些东西，本质上确实能动的力量。我们简短地看看莱布尼茨是如何设法在机械论的，唯理论的宇宙地下建立一个非唯物主义的，目的论的「底层」的。 单子论 单子是宇宙建立于其上的基本元素，单子是存在等级的，每个单子都不受其他单子影响。 前定和谐：上帝确保了单子的和谐运行（一种目的论的解释） 「所有可能世界中最好的世界」 洛克 认识论 唯理论者认为清晰的概念使我们洞察实在的本质。从洛克到康德，标准的论证是说，对概念的洞见并不必然提供对实在的洞见。 洛克在进行思考前的预设：要做一个理性的人，就意味着去追求真理的意思，追求真理就预设了某种思想自由和宽容，即别人也可能是正确的，我们也能从他们那里学到什么。这样讨论就预设了一种非独断的、开放的态度。 洛克面临着一个关于还原的问题：知识是经验的总和呢，还是不仅仅是这种总和呢？ 如果我们回答说知识可以还原到经验的部分，我们会得到一种彻底的经验论立场，即知识可以被完全地、充分地分析为简单地直觉观念。 如果我们回答说知识的构成开始于简单的直觉观念，那我们的意思是说知识仍然包含着某种与这些观念之和有质的区别的东西。 洛克很有可能是第二种立场。 政治理论 概括： 洛克的政治理论延续了霍布斯的传统，从自然状态开始，通过社会契约来维护政府的合法性。 背景 洛克是资本主义这样一个时期中的自由主义的思想代表，在这个时期，市民阶级不需要一个绝对君主（霍布斯）来约束贵族，统一民族国家，而希望废除绝对君主制、直接支配政府。 洛克思想的前提：1. 资源足够每个人所用，私人财产是个人劳动的结果。2. 当人们在谈论人民，谈论个人的时候，他们所指的一般是中产阶级或贵族。 内容 洛克的自然状态：洛克的自然状态不同于霍布斯的自然状态（比霍布斯的自然状态要发达），在这里每个人都是平等与自由的，这意味着我们自由地支配着我们自己的身体和我们用我们身体所取得地任何东西。洛克区分了社会和国家，社会是一种自发地有规律地运作，国家则是一种政治安排。在洛克的自然状态中，人们已经订立了一种引进货币的「默许和自愿的同一」，已经产生了土地的不公平分配，人们可以用货币，正当的取得东西，不再有自然的限度。 有两个理由让我们离开这种自然状态：1.每个人都确保对声明感兴趣。2.拥有财产的人确保对这种财产感兴趣，因此每个人都对这样一种社会契约感兴趣。 由此，在人们签订的社会契约下，产生了国家。对洛克来说， 国家首先确保私有财产。 洛克支持这样一种经济制度，国家保护私有财产，对其他国家实行贸易保护主义政策，但不对贸易和产业实行监督和控制。 洛克反对专制主义，认为主权在共同体的公民那里，既然公民们已经批准了社会契约，他们就必须接受多数人的意志。 洛克关心限制统治者的权利，支持政府中的权力分立原则。 关于经济不平等 洛克认为，在人们签订社会契约之前，人们已经订立了一种引进货币的「默许和自愿的同意」，经济不平等就已经出现了，这时候政治意义上的社会还没有建立，人们仍处在自然状态。没有理由因为随着货币的引入而产生的物质不平等去责怪政治意义上的社会。即，对于经济不平等，洛克归结为由于大众自由地达成的一个自愿的同意。 贝克莱 贝克莱从经验主义的认识论出发，拒绝了物质是某种不同于性质的东西的观点，即洛克的第一性质和第二性质都是依赖感知他们的主体，这样贝克莱把通常的物质观诠释为诸多感觉印象的一种集合，当我们谈论实在时，我们谈论的是不依赖我们意志出现的感觉印象。 「存在」就是「被感知」：不可能被感知的就不存在，某物存在就是某物可能被感知。 引入上帝，到达有神论：贝克莱不认为存在依赖于我们的感觉印象，他认为存在就是被感知这个原则，预设了有某人在感知着，这个某人就是上帝。上帝确保了经验的规则性、有序性，事件之间的必然联系的根源在于上帝。 上帝在贝克莱这里起的作用，大致相当于物质在洛克那里起的作用，以及物自体在康德那里起的作用。 评价（希尔贝克）：贝克莱从经验主义的认识论出发，达到了一种关于存在之形式的二元论，意识和印象，理解者和被理解者。 贝克莱从概念唯名论出发拒绝了哲学的物质观念，像马和人类这样的词是作为简略语，但不意味着像马和房子这样的普遍概念存在着。 （所以什么是「存在着」呢？） 休谟 认识论：彻底的&#x2F;激进的经验主义立场 关于知识的起源：休谟在印象和观念之间做出了区分，印象包括外在知觉和内在知觉，观念被视作建立在这些印象之上的心灵图像。 休谟认为存在两种知识： 逻辑知识，它涉及的是概念之间的关系，它们是「分析的」 经验知识，它的基础是简单地感觉印象。它们是「综合的」 休谟认为关键的是，观念有没有正当的「谱系」，即有没有可能把观念回溯到印象 对物质实体、精神实体、因果性的批判 对于物质实体，我们把稳定的印象群成为实体，我们对这些性质群「背后」所存在的任何基础性的物质实体是没有经验的，因此，休谟认为物质实体的观念是一种站不住脚的形而上学的观念。 对于精神实体，我们能把握的仅仅是内部印象，这些印象常常以确定的、比较稳定的方式成群出现。因此我们谈论一个处在「背后」，并将这些内在印象连接在一起的自我，实际上只是一种形而上学的幻觉。 对于因果性，休谟认为，原因的概念具有以下特征1. 相继性2. 接触性 3.必然性，我们能经验到原因的相继性和接触性，但我们通过经验无法保证原因的必然性。 休谟并没有说在原因和结果之间没有必然联系，他只是说我们不可能知道这样一种必然性。","categories":[{"name":"哲学","slug":"哲学","permalink":"https://cfla1638.github.io/categories/%E5%93%B2%E5%AD%A6/"}],"tags":[]},{"title":"什么是启蒙运动？","slug":"什么是启蒙运动","date":"2022-12-19T14:20:46.000Z","updated":"2023-01-24T14:17:07.289Z","comments":true,"path":"2022/12/19/什么是启蒙运动/","link":"","permalink":"https://cfla1638.github.io/2022/12/19/%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%AF%E8%92%99%E8%BF%90%E5%8A%A8/","excerpt":"","text":"康德|什么是启蒙运动？ 启蒙运动就是人类脱离自己所加之于自己的不成熟状态，不成熟状态就是不经别人的引导，就对运用自己的理智无能为力。当其原因不在于缺乏理智，而在于不经别人的引导就缺乏勇气与决心去加以运用时，那么这种不成熟状态就是自己所加之于自己的了。Sapere Aude！要有勇气运用你自己的理智！这就是启蒙运动的口号。 懒惰和怯懦乃是何以有如此大量的人，当大自然早己把他们从外界的引导之下释放出来以后（naturalitermaiorennes）时，却仍然愿意终身处于不成熟状态之中，以及别人何以那么轻而易举地就俨然以他们的保护人自居的原因所在。处于不成熟状态是那么安逸。如果我有一部书能替我有理解，有一位牧师能替我有良心，有一位医生能替我规定食谱，等等；那么我自己就用不着操心了。只要能对我合算，我就无需去思想：自有别人会替我去做这类伤脑筋的事。 绝大部分的人（其中包括全部的女性）都把步入成熟状态认为除了是非常之艰辛而外并且还是非常之危险的；这一点老早就被每一个一片好心在从事监护他们的保护人关注到了。保护人首先是使他们的牲口愚蠢，并且小心提防着这些温驯的畜牲不要竟敢冒险从锁着他们的摇车里面迈出一步；然后就向他们指出他们企图单独行走时会威胁他们的那种危险。可是这种危险实际上并不那么大，因为他们跌过几交之后就终于能学会走路的；然而只要有过一次这类事例，就会使人心惊胆战并且往往吓得完全不敢再去尝试了。 任何一个个人要从几乎已经成为自己天性的那种不成熟状态之中奋斗出来，都是很艰难的。他甚至于已经爱好它了，并且确实暂时还不能运用他自己的理智，因为人们从来都不允许他去做这种尝试。条例和公式这类他那天分的合理运用、或者不如说误用的机械产物，就是对终古长存的不成熟状态的一副脚梏。谁要是抛开它，也就不过是在极狭窄的沟渠上做了一次不可靠的跳跃而己，因为他并不习惯于这类自由的运动。因此就只有很少数的人才能通过自己精神的奋斗而摆脱不成熟的状态，并且从而迈出切实的步伐来。 然而公众要启蒙自己，却是很可能的；只要允许他们自由，这还确实几乎是无可避免的。因为哪怕是在为广大人群所设立的保护者们中间，也总会发见一些有独立思想的人；他们自己在抛却了不成熟状态的羁绊之后，就会传播合理地估计自己的价值以及每个人的本分就在于思想其自身的那种精神。这里面特别值得注意的是：公众本来是被他们套上了这种羁绊的，但当他们的保护者（其本身是不可能有任何启蒙的）中竟有一些人鼓动他们的时候，此后却强迫保护者们自身也处于其中了；种下偏见是那么有害，因为他们终于报复了本来是他们的教唆者或者是他们教唆者的先行者的那些人。因而公众只能是很缓慢地获得启蒙。通过一场革命或许很可以实现推翻个人专制以及贪婪心和权势欲的压迫，但却绝不能实现思想方式的真正改革；而新的偏见也正如旧的一样，将会成为驾驭缺少思想的广大人群的圈套。 然而，这一启蒙运动除了自由而外并不需要任何别的东西，而且还确乎是一切可以称之为自由的东西之中最无害的东西，那就是在一切事情上都有公开运用自己理性的自由。可是我却听到从四面八方都发出这样的叫喊：不许争辩！军官说：不许争辩，只许操练！税吏说：不许争辩，只许纳税。神甫说：不许争辩，只许信仰。（举世只有一位君主说：可以争辩，随便争多少，随便争什么，但是要听话！君主指普鲁士腓德烈大王）到处都有对自由的限制。 然则，哪些限制是有碍启蒙的，哪些不是，反而是足以促进它的呢？–我回答说：必须永远有公开运用自己理性的自由，并且唯有它才能带来人类的启蒙。私下运用自己的理性往往会被限制得很狭隘，虽则不致因此而特别妨碍启蒙运动的进步。而我所理解的对自己理性的公开运用，则是指任何人作为学者在全部听众面前所能做的那种运用。一个人在其所受任的一定公职岗位或者职务上所能运用的自己的理性，我就称之为私下的运用。 就涉及共同体利益的许多事物而言，则我们必须有一定的机器，共同体的一些成员必须靠它来保持纯粹的消极态度，以便他们由于一种人为的一致性而由政府引向公共的目的，或者至少也是防止破坏这一目的。在这上面确实是不容许有争辩的；而是人们必须服从。但是就该机器的这一部分同时也作为整个共同体的，乃至于作为世界公民社会的成员而论，从而也就是以一个学者的资格通过写作面向严格意义上的公众时，则他是绝对可以争辩的，而不致因此就有损于他作为一个消极的成员所从事的那种事业。因此，一个服役的军官在接受他的上级交下某项命令肘，竟抗声争辩这项命令的合目的性或者有用性，那就会非常坏事；他必须服从。但是他作为学者而对军事业务上的错误进行评论并把它提交给公众来作判断时，就不能公开地加以禁止了。公民不能拒绝缴纳规定于他的税额；对所加给他的这类赋税惹事生非地擅行责难，甚至可以当作诽谤（这可能引起普遍的反抗）而加以惩处。然而这同一个人作为一个学者公开发表自己的见解，抗议这种课税的不适宜与不正当不一样，他的行动并没有违背公民的义务。同样地，一个牧师也有义务按照他所服务的那个教会的教义向他的教义问答班上的学生们和他的会众们作报告，因为他是根据这一条件才被批准的。但是作为一个学者，他却有充分自由、甚至于有责任，把他经过深思熟虑有关那种教义的缺点的全部善意的意见以及关于更好地组织宗教团体和教会团体的建议传达给公众。这里面并没有任何可以给他的良心增添负担的东西。因为他把作为一个教会工作者由于自己职务的关系而讲授的东西，当作是某种他自己并没有自由的权力可以按照自己的心意进行讲授的东西；他是受命根据别人的指示并以别人的名义选行讲述的。他将要说：我们的教会教导这些或那些；这里就是他们所引用的论据。于是，他就从他自己不会以完全的信服而赞同、虽则他很可以使自己负责进行宣讲的那些条文中–因为并非是完全不可能其中也隐藏着真理，而且无论如何至少其中不会发见有任何与内心宗教相违背的东西，–为他的听众引绎出全部的实用价值来。因为如果他相信其中可以发见任何与内心宗教相违背的东西，那么他就不能根据良心而尽自己的职务了，他就必须辞职。一个就任的宣教师之向他的会众运用自己的理性，纯粹是一种私下的运用；因为那往往只是一种家庭式的聚会，不管是多大的聚会；而在这方面他作为一个牧师是并不自由的，而且也不能是自由的，因为他是在传达别人的委托。反之，作为一个学者通过自己的著作而向真正的公众亦即向全世界讲话时，则牧师在公开运用他的理性上便享有无限的自由可以使用他自己的理性，并以他自己本人的名义发言。因为人民（在精神事务上）的保护者而其本身居然也不成熟，那便可以归结为一种荒谬性，一种永世长存的荒谬性了。 然则一种牧师团体、一种教会会议或者一种可敬的教门法院（就象他们在荷兰人中间所自称的那样），是不是有权宣誓他们自己之间对某种不变的教义负有义务，以便对其每一个成员并且由此也就是对全体人民进行永不中辍的监护，甚至于使之永恒化呢？我要说：这是完全不可能的。这样一项向人类永远封锁住了任何进一步启蒙的契约乃是绝对无效的，哪怕它被最高权力、被国会和最庄严的和平条约所确认。一个时代决不能使自己负有义务并从而发誓，要把后来的时代置于一种决没有可能扩大自己的（尤其是十分迫切的）认识、清除错误以及一般地在启蒙中继续进步的状态之中。这会是一种违反人性的犯罪行为，人性本来的天职恰好就在于这种进步；因此后世就完全有权拒绝这种以毫无根据而且是犯罪的方式所采取的规定。 凡是一个民族可以总结为法律的任何东西，其试金石都在于这样一个问题：一个民族是不是可以把这样一种法律加之于其自身？它可能在一个有限的短时期之内就好像是在期待着另一种更好的似的，为的是好实行一种制度，使得每一个公民而尤其是牧师都能有自由以学者的身份公开地，也就是通过著作，对现行组织的缺点发表自己的言论。这种新实行的制度将要一直延续下去，直到对这类事情性质的洞见已经是那么公开地到来并且得到了证实，以致于通过他们联合（即使是并不一致）的呼声而可以向王位提出建议，以便对这一依据他们更好的洞见的概念而结合成另一种已经改变了的宗教组织加以保护，而又不致于妨碍那些仍愿保留在旧组织之中的人们。但是统一成一个固定不变的、没有人能够（哪怕在一个人的整个一生中）公开加以怀疑的宗教体制，从而也就犹如消灭了人类朝着改善前进的整整一个时代那样，并由此给后代造成损害，使得他们毫无收获，–这却是绝对不能容许的。一个人确实可以为了他本人并且也只是在一段时间之内，推迟对自己有义务加以认识的事物的启蒙；然而迳行放弃它，那就无论是对他本人，而更其是对于后代，都可以说是违反而且践踏人类的神圣权利了。 而人民对于他们本身都不能规定的事，一个君主就更加不可以对他的人民规定了；因为他的立法威望全靠他把全体人民的意志结合为他自己的意志。只要他注意使一切真正的或号称的改善都与公民秩序结合在一起，那么此外他就可以把他的臣民发觉对自己灵魂得教所必须做的事情留给他们自己去做；这与他无关，虽则他必须防范任何人以强力妨碍别人根据自己的全部才能去做出这种决定并促进这种得救。如果他干预这种事，要以政府的监督来评判他的臣民借以亮明他们自己的见识的那些作品；以及如他凭自己的最高观点来这样做，而使自己受到Caesarnon estt supragrammaticos（凯撒并不高于文法学家）的这种责难；那就会有损于他的威严。如果他把自己的最高权力降低到竟至去支持自己国内的一些暴君对他其余的臣民实行精神专制主义的时候，那就更加每况愈下了。 如果现在有人问：我们目前是不是生活在一个启蒙了的时代？那么回答就是：并不是，但确实是在一个启蒙运动的时代。目前的情形是，要说人类总的说来已经处于，或者是仅仅说已经被置于，一种不需别人引导就能够在宗教的事情上确切地而又很好地使用自己的理智的状态了，则那里面还缺乏许多东西。可是现在领域已经对他们开放了，他们可以自由地在这上面工作了，而且对普遍启蒙的、或者说对摆脱自己所加给自己的不成熟状态的障碍也逐渐地减少了；关于这些我们都有着明确的信号。就这方面考虑，这个时代乃是启蒙的时代，或者说乃是腓德烈的世纪。 一个不以如下说法为与自己不相称的国君：他认为自己的义务就是要在宗教事务方面决不对人们加以任何规定，而是让他们有充分的自由，但他又甚至谢绝宽容这个高傲的名称；这位国君本人就是启蒙了的，并且配得上被天下后世满怀感激之忱尊之为率先使得人类，至少从政权方面而言，脱离了不成熟状态，并使每个人在任何有关良心的事务上都能自由地运用自身所固有的理性。在他的治下，可敬的牧师们可以以学者的身份自由地并且公开地把自己在这里或那里偏离了既定教义的各种判断和见解都提供给全世界来检验，而又无损于自己的职责：至于另外那些不受任何职责约束的人，那就更加是如此了。这种自由精神也要向外扩展，甚至于扩展到必然会和误解了其自身的那种政权这一外部阻碍发生冲突的地步。因为它对这种政权树立了一个范例，即自由并不是一点也不关怀公共的安宁和共同体的团结一致的。只有当人们不再有意地想方设法要把人类保持在野蛮状态的时候，人类才会由于自己的努力而使自己从其中慢慢地走出来。 我把启蒙运动的重点，亦即人类摆脱他们所加之于其自身的不成熟状态，主要是放在宗教事务方面，因为我们的统治者在艺术和科学方面并没有向他们的臣民尽监护之责的兴趣；何况这一不成熟状态既是一切之中最有害的而又是最可耻的一种。但是，一个庇护艺术与科学的国家首领，他的思想方式就要更进一步了，他洞察到：即使是在他的立法方面，容许他的臣民公开运用他们自身的理性，公开向世上提出他们对于更好地编篡法律、甚至于是直言无讳地批评现行法律的各种见解，那也不会有危险的。在这方面，我们有着一个光辉的典范，我们所尊敬的这位君主（指普鲁士腓德烈大王）就是没有别的君主能够超越的。 但是只有那位其本身是启蒙了的、不怕幽灵的而同时手中又掌握着训练精良的大量军队可以保障公共安宁的君主，才能够说出一个自由国家所不敢说的这种话：可以争辩，随便争多少，随便争什么；但是必须听话。这就标志着人间事务的一种可惊异的、不能意料的进程；正犹如当我们对它从整体上加以观察时，其中就几乎一切都是悖论那样。程度更大的公民自由仿佛是有利于人民精神的自由似的，然而它却设下了不可逾越的限度；反之，程度较小的公民自由却为每个人发挥自己的才能开辟了余地。因为当大自然在这种坚硬的外壳之下打开了为她所极为精心照料着的幼芽时，也就是要求思想自由的倾向与任务时，它也就要逐步地反作用于人民的心灵面貌（从而他们慢慢地就能掌握自由）；并且终于还会反作用于政权原则，使之发见按照人的尊严–人并不仅仅是机器而已–去看待人，也是有利于政权本身的。 1784年9月30日，于普鲁士哥尼斯堡（刘伟录自《历史理性批判文集》）","categories":[{"name":"哲学","slug":"哲学","permalink":"https://cfla1638.github.io/categories/%E5%93%B2%E5%AD%A6/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://cfla1638.github.io/tags/%E8%BD%AC%E8%BD%BD/"}],"author":"Immanuel Kant"},{"title":"placement new","slug":"placement-new","date":"2022-12-17T14:11:27.000Z","updated":"2022-12-17T14:17:06.052Z","comments":true,"path":"2022/12/17/placement-new/","link":"","permalink":"https://cfla1638.github.io/2022/12/17/placement-new/","excerpt":"","text":"placement new最典型的placement new 的签名如下： void * operator new(std::size_t, void * pMemory) throw(); placement new 就得名于这个最典型的new。 下面这个程序将展示这种placement new 的用法： #include &lt;iostream&gt;#include &lt;new&gt;#include &lt;cstdlib&gt;using namespace std;class obj&#123;public: obj() &#123;num = 233;&#125; void print() &#123;cout &lt;&lt; num &lt;&lt; endl;&#125;private: int num;&#125;;int main(void)&#123; cout &lt;&lt; sizeof(obj); obj * p = (obj *)malloc(sizeof (obj)); p-&gt;print(); obj * t = new(p) obj(); // placement new : 在一片已分配但未使用的区域调用构造函数 p-&gt;print(); cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; t; // p 和 t的值相同，说明placement new 的返回值就是p return 0;&#125; 运行结果如下： 4116892962330xb25fb0 0xb25fb0 当最初使用malloc时，obj的构造函数并没有被调用，因此num的值是垃圾值，当使用placement new之后，在原位置调用了构造函数，因此num的值变为了233，而这个placement new的返回值也就是我们传入的那个rawMemory","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"在vscode配置cmake","slug":"在vscode配置cmake","date":"2022-11-14T14:48:49.000Z","updated":"2022-11-14T15:43:11.394Z","comments":true,"path":"2022/11/14/在vscode配置cmake/","link":"","permalink":"https://cfla1638.github.io/2022/11/14/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEcmake/","excerpt":"","text":"在vscode中配置cmake配置includePathvscode的静态语法检查是 intellisense 完成的，想要使它能搜寻到指定的includePath需要这要做： ctrl p，输入c&#x2F;c++ edit configurations(JSON)，这会在本地的./vscode/下创建c_cpp_properties.json 在includePath里面添加上自己的include path即可 配置generator首先 ctrl+p，输入settings.json，点击 “首选项：打开工作区设置(JSON)”。 此操作会创建 ./vscode/settings.json 在此文件中加入&quot;cmake.generator&quot; : &quot;MinGW Makefiles&quot; 根据不同的系统，配置不同的generator。 配置debugger在侧边栏 调试 中点击创建 “launch.json” 或直接创建launch.json 只要是带有调试信息的可执行文件，都可以调试","categories":[],"tags":[]},{"title":"cmake学习之路","slug":"cmake学习之路","date":"2022-10-22T15:28:14.000Z","updated":"2022-10-24T12:09:39.066Z","comments":true,"path":"2022/10/22/cmake学习之路/","link":"","permalink":"https://cfla1638.github.io/2022/10/22/cmake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"cmake 学习之路 参考链接 CMake 如何入门？ - 知乎 (zhihu.com) ttroy50&#x2F;cmake-examples: Useful CMake Examples (github.com) 超详细的cmake入门教程【转载】_Korpse的博客-CSDN博客_cmake 教程 01-basicA-hello cmake概念： CMakeLists.txt : 存储cmake命令，当在一个文件夹中运行cmake时，cmake会寻找这个文件，如果找不到会报错。 三个命令： cmake_minimum_required(VERSION 3.5) 最小的cmake版本 project() 指定项目的名称，cmake可以通过include一个项目名称来引用另一个项目，这对多项目是很方便的。另外这个命令也会创建一个名为 $&#123;PROJECT_NAME&#125; 的变量，它的内容就是我们指定的项目名称。 add_executable(hello_cmake hello_cmake.cpp) 第一个参数是我们生成可执行文件的名称，第二个参数以后则是为了生成这个可执行文件需要的源文件列表 两种构建方式 In-Place Build 将生成的二进制文件和源文件放在一起，这样构建会比较混乱 在Linux上的方法是 cmake . 参数代表CMakeLists.txt 所在的位置 make 注意，在window上，默认的生成器是nmake 要使用mingw的make应当这样： cmake -G &quot;MinGW Makefiles&quot; . 注意字符串大小写严格 cmake . make Out-of-Source Build 将生成的二进制文件单独放在一个文件夹中，这样比较整洁 具体的方法是（Linux） mkdir build cd build cmake ..make 在 window上的方法是 mkdir build cd build cmake -G &quot;MinGW Makefiles&quot; ..cmake ..make B hello headers将头文件和源文件分离编译 我们有一个include目录和一个src目录 CMakeLists.txt ： # Set the minimum version of CMake that can be used# To find the cmake version run# $ cmake --versioncmake_minimum_required(VERSION 3.5)# Set the project nameproject (hello_headers)# Create a sources variable with a link to all cpp files to compileset(SOURCES src/Hello.cpp src/main.cpp)# Add an executable with the above sourcesadd_executable(hello_headers $&#123;SOURCES&#125;)# Set the directories that should be included in the build command for this target# when running g++ these will be included as -I/directory/path/target_include_directories(hello_headers PRIVATE $&#123;PROJECT_SOURCE_DIR&#125;/include) 有两个需要注意的点： 首先我们使用了set函数，将源文件甚至为了其内容，add_executable() 函数的第二个参数也使用该变量。 使用了target_include_directories 函数，这个函数的文档[在这里](target_include_directories — CMake 3.0.2 Documentation) ，需要注意的是，这个函数必须在我们已经添加了源文件或库之后才能使用。否则会构建失败。 详见文档 target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) Specify include directories or targets to use when compiling a given target. The named &lt;target&gt; must have been created by a command such as add_executable() or add_library() and must not be an IMPORTED target. 附：cmake 预先定义的一些变量 Variable Info CMAKE_SOURCE_DIR The root source directory CMAKE_CURRENT_SOURCE_DIR The current source directory if using sub-projects and directories. PROJECT_SOURCE_DIR The source directory of the current cmake project. CMAKE_BINARY_DIR The root binary &#x2F; build directory. This is the directory where you ran the cmake command. CMAKE_CURRENT_BINARY_DIR The build directory you are currently in. PROJECT_BINARY_DIR The build directory for the current project.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"cmake","slug":"cmake","permalink":"https://cfla1638.github.io/tags/cmake/"}]},{"title":"模板与泛型编程 - C++","slug":"模板与泛型编程-C","date":"2022-10-08T08:43:49.000Z","updated":"2022-10-09T09:00:04.467Z","comments":true,"path":"2022/10/08/模板与泛型编程-C/","link":"","permalink":"https://cfla1638.github.io/2022/10/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-C/","excerpt":"","text":"模板与泛型编程定义模板模板的定义以关键字template 开始，它的形式如下 template &lt;typename T, typename T1, ...&gt; ，尖括号括起来的部分叫做模板参数列表，我们使用模板时，显示或隐式地将模板实参绑定到模板参数列表上。 typename 关键字也可以用class 关键字代替，在模板参数列表中，它们是等价的。 模板参数： T 叫做模板类型参数。 也可以定义非类型的模板参数，它必须是整形或指向对象的或函数的指针或者左值引用，整形必须是一个常量表达式，指针或者引用必须要具有静态生存期。总而言之，它必须能够在编译期间被确定。 例子： template &lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123; return strcmp(p1, p2);&#125; 模板编译： 编译器遇到模板的定义时，并不会生成代码，只有在使用模板时，编译器才会生成代码。 建议：函数模板和类模板成员函数的定义通常放在头文件中 当我们使用一个函数时，我们只需要它的声明，它的定义可以由链接器在链接期间与其他文件链接。 而模板通常在使用时就要实例化，生成代码，因此，模板的声明和定义最好都放在头文件中。 函数模板函数模板通常是使用隐式模板实参推断，编译器会用函数的实参推断模板实参。 在函数模板中，模板类型参数 T 可用于指定返回类型或函数的参数类型，也可以在函数体内声明变量和进行类型转换。 类模板编译器不能为类模板推断模板类型参数，我们必须显式指明。 类模板的成员函数： 在类内部定义的成员函数隐式inline 在类模板外部定义成员函数： 必须以template + 模板参数列表开始，因为不同类型的模板实例对应不同的成员函数 类模板的模板实例化： 只有程序用到类模板时，才会实例化它。如果没有用到某个成员函数，只用到了这个类，那么这个成员函数也不会被实例化。 简化模板类名 模板名不是类型，只有提供模板实参，模板名才能称为类名。因此我们在使用模板类型时，必须提供模板实参。 但在类模板的作用域内，我们可以只是用模板名，而省略模板实参。 在类模板的定义外，只有遇到类名之后，我们才进入类的作用域。在此之前，例如我们想要是使用模板类型作为返回值，都不能省略模板实参 类模板和友元 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有的模板实例， 如果友元自身是模板，则友元可以授予模板的所有实例，也可以授予部分实例。 模板类型的静态成员 对于每个类型的模板实例，都有一个静态成员。 默认模板实参 可以像函数形参一样，提供一个默认参数。 对于类模板，就算我们需要使用默认模板实参，我们也不能省略尖括号。 templateType&lt;&gt; foo; // 使用默认模板实参 成员模板 可以将类模板或普通类的成员函数声明称模板 普通类： class base&#123; template &lt;typename T&gt; void mem(const T &amp;);&#125; 类模板 template &lt;typename T&gt; class base&#123; template &lt;typename It&gt; base(It begin, It end);&#125; 模板作用域模板参数遵循普通的作用域规则，一个模板参数的可用范围在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明相同的名字。 使用类的类型和类的静态成员： 当我们模板使用classType::name 引用类的类型或静态成员，会导致语义不明（因为只有用到模板是才会生成代码，错误检查不会立即发生） 我们必须使用typename 关键字显式声明这是一个类内定义的类型 例子： template &lt;typename T&gt;typename T::value_type top(const T&amp; c)&#123;/*...*/&#125; 显式实例化两个独立编译的源文件使用相同的模板，并提供了相同的模板实参，每个文件中就都会有一个模板的实例。在一个大型工程中，会造成很大空间浪费。 因此我们需要显式控制模板实例化 形式 extern template chass&lt;string&gt;; 模板实参推断对于传递给模板类型参数的实参，编译器可以选择对实参进行类型转换，也可以不进行类型转换直接生成新的模板。 对于非类型的参数，会进行 只有在一下两种情况会进行类型转换，其他的情况都会生成新的模板 非const转换成const，顶层const会被忽略 数组或函数指针：数组可以转换成指针（即使它们的大小不同，但引用不可以，因为对不同长度的数组的引用不是同一个类型），，函数可以转换成函数指针 特殊情况：因为模板不会进行算数转换，如果一个函数的两个参数使用一个模板形参。即使，传递的实参可以转换成一个类型，调用也会报错： template &lt;typename T&gt;bool cmp(const T &amp;, const T &amp;);long lint = 456;cmp(123, lint); // 错误，类型不匹配 这是我们可以这样处理 template &lt;typename T1, typename T2&gt;bool cmp(const T1 &amp;, const T2 &amp;); 函数模板显式指定模板参数放在函数名之后，模板名之前，靠右的模板参数如果可以通过实参推断出来，则可以省略。 template &lt;typename T1, typename T2, typename T3&gt;T1 cmp(const T2 &amp;, const T3 &amp;);cmp&lt;long long&gt;(20, 30); // T1被显式指定，T2、T3自动推断 显式指定参数之后，模板函数即可执行正常的类型转换 template &lt;typename T&gt;bool cmp(const T &amp;, const T &amp;);long lint = 456;cmp(123, lint); // 错误，类型不匹配cmp&lt;long&gt;(123, lint); // 正确，显式指定模板类型参数之后就可以执行正常的类型转换了。 尾置返回类型当返回类型需要传入的实参，经过decltype 推断后得出时，我们遇到了一个问题，在写返回类型时，形参还没有被创建。 针对这种情况，我们可以使用尾置返回类型，将返回类型放在参数列表后面 template &lt;typename It&gt;auto func(It beg, It end) -&gt; decltype(*beg); 省略608 - 613 关于右值引用 和 转发 模板重载 C++ Primer P614 - P617 重载规则： 对于一个调用，其候选包括所有的模板实参推断和非模板函数 如果有一个函数（不论是模板还是非模板），提供比其他类型的函数更好的匹配，选择它 如果有多个函数提供同样好的匹配，则 如果同样好的函数中，有一个时非模板函数，选择它 如果都是模板函数，则选择更加特例化的哪一个模板函数 否则，调用有歧义 模板特例化模板函数的特例化：必须为模板函数的每一个模板参数提供模板实参，不能部分特例化，因此，函数模板特例化必须以template&lt;&gt; 开始。 模板特例化本质上是接管了编译器的工作，特例化的函数也是一个模板实例而不是一个重载函数。 类模板特例化 特例化方法与函数模板特例化无异，但类模板特例化可以部分特例化，详见P628。 感觉我也不会用到多少这东西。","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"C++ OOP","slug":"C-OOP","date":"2022-09-29T07:48:03.000Z","updated":"2022-10-08T08:47:52.272Z","comments":true,"path":"2022/09/29/C-OOP/","link":"","permalink":"https://cfla1638.github.io/2022/09/29/C-OOP/","excerpt":"","text":"C++ OOPC++ 的类this 指针调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。 在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用 this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。 常量成员函数即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层const的的this指针。 由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。 为了解决这个问题，我们可以将成员函数声明成const 例如，像下面这样，在参数列表后添加上const class A &#123; public: int get_a() const &#123;&#125;; private: int a;&#125; 此时，这个this指针，既是顶层const (this指针所固有的属性)，又是底层const （我们声明的结果） 友元 P241, P250，P545 想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部 由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置 可以将一个类声明成另一个类的友元 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员 可以将一个类的成员函数声明成另一个类的友元函数 友元声明是单向的，友元声明不具有传递性 关于友元的作用域：P252 友元关系是不能继承的 基类的友元在访问派生类时没有特殊性。 派生类的友元也不能访问基类的私有成员 类的类型成员类的成员不只可以有变量和函数，还可以有类型 类内定义的类型也有访问权限的限制 用来定义类型的成员必须先定义再使用 原因：&#x2F;&#x2F; TODO 类的内联函数 内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销 内联函数会在编译时，被编译器展开 例如 inline const string &amp; shorterString(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; max(), min() 之类的函数特别适合被定义为内联函数 定义在类内部的成员函数，它们默认是内联函数 可以在类内声明时使用inline，同时在类外定义函数时也同时使用inline ，但最好是只在类外部定义函数时使用inline 声明。 可变数据成员 from effective c++ 编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为mutable 如果在定义类的成员时，使用mutable 关键字，那么，即使这个对象被声明成const ，我们依然可以改变这个成员变量的值。 class A &#123; public: void inc() const; private: mutable size_t cnt;&#125;void A::inc() const&#123; cnt++;&#125; 返回*this 左值当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值 我们可以根据this指针是否具有底层const 来对函数进行重载 底层const的重载见：P206 P247 类的前向声明可以使用类似这种形式声明类 class A; 这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。 前向声明可以放在类的头文件中，从而减少依赖。 类的名字查找 我们可以在成员函数的任意地方使用类的成员 原因在于编译器如何处理类： 编译所有的成员声明 编译函数体 如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。 在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用typedef 或使用using symbol = type）不能再类中重定义。 成员函数的名字查找规则 1. 在成员函数内查找名字（成员函数体定义的名字，形参的名字）2. 在类作用域内查找名字3. 在成员函数定义之前的作用域内继续查找 如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。 类的隐式类型转换 P263 隐式的类类型转换 P514 重载类型转换运算符 如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换 这种类型转换只允许一步类型转换 一直类的隐式类型转换： 使用关键字explicit 该关键字只能在类内声明中使用，不能在类外重复 该关键字只能用于接受一个值的构造函数前面 类的静态成员类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0 类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的 由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似 在.h 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理 我们可以使用类的静态成员作为成员函数的默认实参 拷贝控制 类的初始化、对象拷贝、移动、销毁 由以下六个函数决定： 构造函数 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数 后五个称为类的拷贝控制操作 构造函数 C++ Primer P235、P257、P551、P689 构造函数没有返回值 构造函数可以重载 构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。 合成的默认构造函数如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下 如果存在类内的初始值，用它来初始化成员 否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数） 如果出现以下情况，编译器无法为类构造合成的默认构造函数 类有定义一个构造函数 遇到这种情况，可以使用 类名() = defalut 来给予类一个默认的构造函数 类存在一个成员，这个成员没有默认的构造函数 构造函数的初始化列表Sales_data(const std::string &amp;s) : BookNo(s) &#123;&#125; 当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化 （重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化 由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。 class A &#123;// 没有默认构造函数public: A(int num) : elem(num) &#123;&#125;private: int elem = 0;&#125;;class B&#123;public: B(int num) : elem_int(num) &#123;&#125; // 错误，因为A没有默认构造函数，所以必须对它进行列表初始化private: A elem_A; int elem_int;&#125;; 因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。 （重要）列表初始化的初始化顺序 列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！ 委托构造函数class Sales_data &#123;public: // 非委托构造函数要使用的构造函数 Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) &#123;&#125; // 委托构造函数 Sales_data() : Sales_data(&quot;&quot;, 0, 0)&#123;&#125; Sales_data(std::string s) : Sales_data(s, 0, 0) &#123;&#125; Sales_data(std::istream &amp;is) : Sales_data() &#123;read(is, *this);&#125;&#125; 委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体 默认构造函数被调用的时机 C++ Primer P262 默认初始化 在块作用域内不适用任何初始值定义一个非静态变量 一个类类型本身含有类成员，并且使用合成的默认构造函数时 没有在列表初始化中被显示初始化时 值初始化 数组初始化时，提供的值小于数组的大小 不适用初始值定义一个局部静态变量 使用T() 这种表达式来显示请求值初始化 继承体系中的合成的默认构造函数 派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。 继承直接基类的构造函数，使用using 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数 拷贝构造函数定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。 拷贝构造函数的形式通常是 ClassType(const ClassType &amp;) 拷贝构造函数通常不应该是explicit的 合成的拷贝构造函数如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数 对于内置类型，合成的拷贝构造函数会直接拷贝 对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数 对于数组，合成的拷贝构造函数会逐个拷贝它的元素 一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别： 几种初始化的区别：https://blog.csdn.net/qq_38231713/article/details/106291397 默认初始化：对象可能产生未定义的值，出现场景： 块作用域内不使用任何初始值定义一个非静态变量； 类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员 如果存在类内初始值，用它来初始化成员 否则，默认初始化该成员 值初始化：对象的值是确定（预设）的，出现场景： 数组初始化时，初始值数量小于数组的长度。 不使用初始值定义一个静态变量（带有初始值0） 使用类似classType() 形式表达式显示请求值初始化 只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化 vector&lt;int&gt; vec(10); 值初始化为0 直接初始化：使用classType() 初始化对象 拷贝初始化：使用classType foo = classType() 初始化对象 不光在使用 &#x3D; 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化 将参数作为实参传递给非引用类型的形参 从返回类型为非引用的函数返回一个对象 使用花括号列表初始化数组或聚合类 初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数） 二、不同的初始化方式会调用那种构造函数 参考：https://blog.csdn.net/sksukai/article/details/104741675/ 当定义类时，会有直接初始化和拷贝初始化两种区别 foo var1; // 直接初始化，使用默认构造函数foo var2(1); // 直接初始化，使用一个参数的构造函数foo var3 = 50; // 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3foo var4 = foo(50); // 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数foo var5 = var3; // 拷贝初始化，调用拷贝构造函数 继承体系中的拷贝构造函数我们需要使用基类的拷贝构造函数显示的初始化基类的成员 class base &#123;/* ... */&#125;;class derived : public base&#123; derived(const derived &amp;d) : base(d) // 显式的使用基类的拷贝构造函数+ &#123;/*...*/&#125;&#125; 拷贝赋值运算符 可能会误以为拷贝初始化classType obj = ori; 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数 当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符 此外我们还可以定义两种赋值运算符 移动赋值运算符 其他类型到此类型的赋值运算符 但这个运算符是最常用的运算符 拷贝赋值运算符的形式通常是classType operator=(const classType &amp;) 因为他是一个成员函数，因此它的左侧成员自动绑定 合成的拷贝赋值运算符合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝 继承体系中的拷贝赋值运算符派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作 classType &amp; classType::operator=(const classType &amp; rhs)&#123; Base::operator=(rhs); // 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用 /* 派生类成员的赋值操作 */ return *this;&#125; 析构函数释放对象使用的资源，销毁对象的非static成员 析构函数的形式是~classType() 没有返回值，不接受参数 不能被重载，对于任意一个类有且只有一个析构函数 析构函数不能是删除的 析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员 继承体系中的析构函数 派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。 对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。 移动构造函数类的拷贝控制成员被默认定义为删除的 P450、P476、P553、P751 面向对象 类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符， 派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见 动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定 基类通过在成员函数前加上virtual 关键字使得函数执行运行时动态绑定。 任何构造函数之外的非静态函数都可以是虚函数 关键字virtual 只能出现在类内声明语句中，而不能出现在定义语句中 没有用virtual 声明的函数，其解析发生在编译时，而非运行时 访问控制： 如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为protected 派生类的构造函数 派生类必须使用基类的构造函数初始化其基类的部分 防止继承 定义类的时候使用final class NoDerived final &#123;/* ... */&#125;; 纯虚函数和抽象基类 纯虚函数 通过在函数声明的分号前添加 &#x3D; 0 即可声明这个函数为纯虚函数 纯虚函数只是提供了一个接口，无需定义纯虚函数 含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象 Protected 派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员 基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响 若基类的访问说明符 派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高） 对于派生类成员来说，它可以访问基类的public 和private 部分 改变个别成员的可访问性可以在派生类中使用using 声明改变它继承自基类的成员的可访问性 但using声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。 struct 和 class的区别 struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数 在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数 他们的可访问性： struct的默认成员都是public，class的默认成员都是private struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承 类的作用域 每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。 当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。 一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。 如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。 与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。 编译器解析类的函数调用的过程： 例如obj.func() 确定obj的静态类型，去对应的类的作用域内查找该名称 如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。 如果找到了该名子，编译器进行类型检查，看这次调用是否合法。 如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。 否则直接进行函数调用。 声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。 因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。 成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。 如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用using 声明 class base&#123; public: virtual func(int); virtual func(int, int); virtual func(char, int);&#125;;class derived : public base&#123; public: using base::func; // 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见 func(int) override;&#125;","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"const 和 constexpr 的详解和区别","slug":"const-和-constexpr-的详解和区别","date":"2022-09-26T07:40:53.000Z","updated":"2022-09-29T07:45:33.300Z","comments":true,"path":"2022/09/26/const-和-constexpr-的详解和区别/","link":"","permalink":"https://cfla1638.github.io/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"const和constexprconstexpr常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式 常量表达式是由 数据类型 数据初始值 决定的。 int a = 1 a 不是一个常量表达式，因为它的数据类型不是常量 const int b = get_val() b不是一个常量表达式，因为它的初始值不是常量 由于使用const 不能确定一个表达式是不是常量，因此C++11使用constexpr 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。 下面这个程序是不正确的，因为a虽然被const 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式 int main(void)&#123; int b = 3; const int a = b; constexpr int i = a; int arr[i]; return 0;&#125; 而只要将a = b 改为 a = 1 程序就不会报错了，因为此时a的确是一个常量表达式 constexpr 函数普通的函数不是常量表达式，但我们可以定义constexpr 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定 constexpr 指针 &amp; 引用constexpr 指向的位置必须是全局变量，静态变量，或者字面值等放在.bss 节.data 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。 constconst用来修饰变量，根据const 出现的位置，可以分为两种const ：顶层const 和底层const 顶层const 可以表示任意的对象是常量 const int a = 1; // a不能改变，是顶层constint *const p = &amp;a; // p不能改变指向，是顶层const 低层const 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量 const int *p = &amp;a; // 指向a的指针，不能通过这个指针修改a的值，是底层constconst int &amp;ref = a; // a的引用，不能通过这种方式修改a, 是底层const const 与参数传递 在参数传递时，顶层const会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层const 后没有区别 void func(int i);void func(const int i); 可以使用非常量初始化底层const ，但不能使用常量去初始化非底层const int a = 1;const int b = 1;const int &amp;ref_1 = a; // 可以， 可以使用非常量初始化底层constint &amp;ret_2 = b; // 不可以， 不能使用常量去初始化非底层const 非常量的引用必须是左值，常量的引用可以是左值，也可以是右值 const int &amp;a = 1; // 正确int &amp;b = 2; // 错误 因此尽量将不会改变形参的函数的形参定义成底层const ，因为这样定义我们可以使用字面量（rvalue）。","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"并发编程 - CS:APP 第十二章","slug":"并发编程-CS-APP-第十二章","date":"2022-09-25T14:10:57.000Z","updated":"2022-09-26T06:38:29.889Z","comments":true,"path":"2022/09/25/并发编程-CS-APP-第十二章/","link":"","permalink":"https://cfla1638.github.io/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"并发编程 - CS:APP 第十二章本章主要内容： 实现并发程序的三种方法： fork() 进程 I&#x2F;O 多路复用 使用线程 使用信号量同步线程 线程安全问题 使用进程进行并发编程fork() &amp; execve 优点：进程模型清晰，有独立的地址空间 缺点：不方便进程之间共享信息 基于进程的并发echo服务器 #include &lt;csapp.h&gt;void echo(int connfd)&#123; size_t n; char buf[MAXLINE]; rio_t rio; Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; printf(&quot;server received %d bytes\\n&quot;, (int)n); Rio_writen(connfd, buf, n); &#125;&#125;void sigchld_handler(int sig)&#123; while (waitpid(-1, 0, WNOHANG) &gt; 0); return ;&#125;int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; if (argc != 2) &#123; fprintf(stderr, &quot;args error&quot;); exit(0); &#125; Signal(SIGCHLD, sigchld_handler); listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); if (Fork() == 0) &#123; printf(&quot;process:%d connected\\n&quot;, getpid()); Close(listenfd); echo(connfd); printf(&quot;process:%d close connection\\n&quot;, getpid()); Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125; IO多路复用可以使用select() 函数显示等待一个进程有一个IO事件发生。 例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。 只要有一个IO事件发生，程序的逻辑流就会改变。 #include &lt;sys/select.h&gt;/*如果fdset中的描述符准备好读或者写，就返回返回值：返回已准备好的描述符数目，若出错返回-1*/int select(int n, fd_set *fdset, NULL, NULL, NULL);FD_ZERO(fd_set *fdset);FD_CLR(int fd, fd_set *fdset);FD_SET(int fd, fd_set *fdset);FD_ISSET(int fd, fd_set *fdset); #include &lt;csapp.h&gt;typedef struct &#123; int maxfd; fd_set read_set; fd_set ready_set; int nready; int maxi; int clientfd[FD_SETSIZE]; rio_t clientrio[FD_SETSIZE];&#125;pool;int byte_cnt = 0;void init_pool(int listenfd, pool *p);void add_client(int connfd, pool *p);void check_clients(pool *p);int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; static pool pool; if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(0); &#125; listenfd = Open_listenfd(argv[1]); init_pool(listenfd, &amp;pool); while (1) &#123; pool.ready_set = pool.read_set; pool.nready = Select(pool.maxfd + 1, &amp;pool.ready_set, NULL, NULL, NULL); printf(&quot;%d&quot;, pool.nready); if (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); add_client(connfd, &amp;pool); &#125; check_clients(&amp;pool); &#125;&#125;void init_pool(int listenfd, pool *p)&#123; int i; p-&gt;maxi = -1; for (i = 0; i &lt; FD_SETSIZE; i++) p-&gt;clientfd[i] = -1; p-&gt;maxfd = listenfd; FD_ZERO(&amp;p-&gt;read_set); FD_SET(listenfd, &amp;p-&gt;read_set);&#125;void add_client(int connfd, pool *p)&#123; int i; p-&gt;nready--; for (i = 0; i &lt; FD_SETSIZE; i++) &#123; if (p-&gt;clientfd[i] &lt; 0) &#123; p-&gt;clientfd[i] = connfd; Rio_readinitb(&amp;p-&gt;clientrio[i], connfd); FD_SET(connfd, &amp;p-&gt;read_set); if(connfd &gt; p-&gt;maxfd) p-&gt;maxfd = connfd; if (i &gt; p-&gt;maxi) p-&gt;maxi = i; break; &#125; &#125; if (i == FD_SETSIZE) app_error(&quot;add_client error: Too many clients&quot;);&#125;void check_clients(pool *p)&#123; int i, connfd, n; char buf[MAXLINE]; rio_t rio; for (i = 0; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; 0; i++) &#123; connfd = p-&gt;clientfd[i]; rio = p-&gt;clientrio[i]; if ((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123; p-&gt;nready--; if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; byte_cnt += n; printf(&quot;Server received %d (%d total) bytes on fd %d\\n&quot;, n, byte_cnt, connfd); Rio_writen(connfd, buf, n); &#125; else &#123; Close(connfd); FD_CLR(connfd, &amp;p-&gt;read_set); p-&gt;clientfd[i] = -1; &#125; &#125; &#125;&#125; 缺点：编码特别复杂 基于线程的并发编程线程是运行在进程上下文中的逻辑流 运行在同一个进程里的线程共享 虚拟地址空间 有自己独立的 栈、栈指针、PC、通用目的寄存器和条件码 线程之间是对等的，没有和进程一样有父子之分 进程有两种状态：可结合的和分离的 可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收 分离的：不能被其他线程杀死，内存资源结束时由系统自动释放 #include &lt;pthread.h&gt;typedef void *(func)(void *);// 创建线程int pthread_create(pthread_t *tid, pthread_attr_t * attr, func *f, void *arg);// 获取自己的tidpthread_t pthread_self(void);// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程void pthread_exit(void *thread_return);// 终止 tidint pthread_cancel(pthread_t tid);// 阻塞，等待tid终止int pthread_join(pthread_t tid, void **thread_return);// 当这个线程第一次被调用时，执行 init_routine()，用于初始化pthread_once_t once_control = PTHREAD_ONCE_INIT;int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); 用信号量同步线程如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误 对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。 想要实现互斥的访问，我们可以使用信号量机制 信号量： 信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它： P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。 V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。 P中测试和加一的操作是不可分割的 V中测试和加以的操作也是不可分割的 如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。 互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。 生产者消费者问题 生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。 因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。 基于生产者消费者的sbuf包： sbuf.h #ifndef H_SBUF#define H_SBUF#include &lt;csapp.h&gt;typedef struct&#123; int *buf; // 缓冲区 int n; // 缓冲区长度 int front; // 队列头 int rear; // 队列尾 sem_t mutex; // 对缓冲区的互斥锁 sem_t slots; // 控制生产者的信号量 sem_t items; // 控制消费者的信号量&#125;sbuf_t;void sbuf_init(sbuf_t *sp, int n);void sbuf_deinit(sbuf_t *sp);void sbuf_insert(sbuf_t *sp, int item);int sbuf_remove(sbuf_t *sp);#endif sbuf.c #include &quot;sbuf.h&quot;// 初始化void sbuf_init(sbuf_t *sp, int n)&#123; sp-&gt;buf = Calloc(n, sizeof(int)); sp-&gt;n = n; sp-&gt;front = sp-&gt;rear = 0; Sem_init(&amp;sp-&gt;mutex, 0, 1); Sem_init(&amp;sp-&gt;slots, 0, n); Sem_init(&amp;sp-&gt;items, 0, 0);&#125;// 释放缓冲区空间void sbuf_deinit(sbuf_t *sp)&#123; Free(sp-&gt;buf);&#125;// 向缓冲区插入数据void sbuf_insert(sbuf_t *sp, int item)&#123; P(&amp;sp-&gt;slots); // 如果缓冲区已满，想要插入的线程会阻塞在这里 P(&amp;sp-&gt;mutex); // 互斥锁加锁 sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; // 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小 V(&amp;sp-&gt;mutex); // 互斥锁解锁 V(&amp;sp-&gt;items); // 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们&#125;int sbuf_remove(sbuf_t *sp)&#123; int item; P(&amp;sp-&gt;items); // 如果缓冲区为空，想要取出的线程会阻塞 P(&amp;sp-&gt;mutex); item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n]; // 因为信号量的机制，我们不用担心从空缓冲区里取出数据 V(&amp;sp-&gt;mutex); V(&amp;sp-&gt;slots); // 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们 return item;&#125; 基于预线程化的并发服务器 #include &lt;csapp.h&gt;#include &quot;sbuf.h&quot;#define NTHREADS 4#define SBUFSIZE 16void echo_cnt(int connfd);void *thread(void *vargp);sbuf_t sbuf;static int byte_cnt;static sem_t mutex;int main(int argc, char **argv)&#123; int i, listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; pthread_t tid; if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(0); &#125; listenfd = Open_listenfd(argv[1]); sbuf_init(&amp;sbuf, SBUFSIZE); for (i = 0; i &lt; NTHREADS; i++) Pthread_create(&amp;tid, NULL, thread, NULL); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); sbuf_insert(&amp;sbuf, connfd); &#125;&#125;void *thread(void *vargp)&#123; Pthread_detach(pthread_self()); while (1) &#123; int connfd = sbuf_remove(&amp;sbuf); echo_cnt(connfd); Close(connfd); &#125;&#125;static void init_echo_cnt(void)&#123; Sem_init(&amp;mutex, 0, 1); byte_cnt = 0;&#125;void echo_cnt(int connfd)&#123; int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(&amp;once, init_echo_cnt); Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; P(&amp;mutex); byte_cnt += n; printf(&quot;server received %d (%d total) bytes on fd %d\\n&quot;, n, byte_cnt, connfd); V(&amp;mutex); Rio_writen(connfd, buf, n); &#125;&#125; 线程安全四个种不安全的函数 不保护共享变量的函数 保持跨越多个调用的状态的函数（依赖前次调用结果的函数） 返回指向静态变量指针的函数 调用线程不安全函数的函数 可重入的函数通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集 定义：当它被多个线程使用时，不会引用任何共享数据 竞争一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争 死锁deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件 给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"网络编程 - CS:APP 第十一章","slug":"网络编程-CS-APP-第十一章","date":"2022-09-22T09:53:11.000Z","updated":"2022-09-25T14:14:00.031Z","comments":true,"path":"2022/09/22/网络编程-CS-APP-第十一章/","link":"","permalink":"https://cfla1638.github.io/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/","excerpt":"","text":"网络编程 - CS:APP 第十一章客户端和服务器都是进程，而不是机器或主机。 IP地址IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中 struct in_addr &#123; uint32_t s_addr; // 32位IP地址，使用网络字节顺序（大端法）&#125; 由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。 字节顺序和主机顺序的转换： #include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong); // host to netuint16_t htons(uint16_t hostshort); // host to netuint32_t ntohl(uint32_t netlong); // net to hostuint16_t ntohs(uint16_t netshort); // net to host 点分IP地址与32位IP地址的转换： #include &lt;arpa/inet.h&gt;// 点分十进制转换成32位地址/*得到的32位地址也要转换成本地顺序返回：若成功返回1，串非法返回0，错误返回-1*/int inet_pton(AF_INET, const char *src, void *dst);// 32位地址转换成点分十进制/*在使用该函数之前，要将32位IP地址转换成网络顺序把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中返回：若成功返回指向点分十进制地址的指针，出错返回NULL*/int char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size); 附 1. // 将十六进制字符串转换成十进制数：使用sscanf(str, &quot;%x&quot;, &amp;num) 使用32位IP地址时，可以直接使用in_addr结构而不是in_addr结构里的s_addr 套接字是一组绝大多数操作系统都定义的函数，可以实现网络应用。 套接字地址结构 // 这两个结构体所占字节数相同，可以互相转换struct sockaddr_in &#123; uint16_t sin_family; // 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6) uint16_t sin_port; // 端口号，使用网络字节顺序 struct in_addr sin_addr; // IP地址结构 unsigned char sin_zero[8]; // 填充0，为了满足struct sockaddr的大小&#125;; // 这个结构体一共占16个字节struct sockaddr &#123; uint16_t sa_family; char sa_data[14];&#125;typedef struct sockaddr SA; socket() 通用#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);/*使套接字称为一个连接的结点返回一个还不能用于读写的描述符*/// 使称为一个连接点clientfd = socket(AF_INET, SOCK_STREAM, 0); connect() 客户端#include &lt;sys/socket.h&gt;int connect(int clientfd, const struct sockaddr * addr, socklen_t addrlen);/*客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ bind() 服务器#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);/*将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ listen() 服务器#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);/*该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024成功返回0， 出错返回-1*/ accept() 服务器#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen);/*成功返回非负连接描述符， 出错返回-1*/ 建立连接服务器： 调用socket()，创建连接结点 调用bind() 成为一个服务器套接字 调用listen() 转换成监听描述符 调用accept() ，阻塞程序，等待客户端连接，返回连接描述符 客户端： 调用socket()，创建连接结点 调用connect()， 连接服务器 套接字地址和主机名服务名的转换首先了解，域名和IP地址是等价的，服务名和端口号是等价的 例如localhost和127.0.0.1是等价的，http和80是等价的 从 字符串主机名服务名信息 到 二进制套接字地址信息 为什么要使用这个函数？ 域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。 #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;/*host: 域名或点分十进制IP地址service: 服务名或端口号hints: 可选 传递设置result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构*/int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);// 释放返回的链表void freeaddrinfo(struct addrinfo, *result);// 将错误代码转换成错误信息const char *gai_strerror(int errcode); getaddrinfo 使用的结构 struct addrinfo &#123; int ai_flags; int ai_family; int ai_socktype; int ai_protocol; char *ai_canonname; size_t ai_addrlen; struct sockaddr *ai_addr; struct addrinfo *ai_next;&#125; 从 二进制套接字地址信息 到 字符串主机名服务名信息#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *service, size_t servlen, int flags); 辅助简化函数int open_clientfd(char *hostname, char *port) &#123; int clientfd, rc; struct addrinfo hints, *listp, *p; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Open a connection */ hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */ hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */ if ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (%s:%s): %s\\n&quot;, hostname, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can successfully connect to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Connect to the server */ if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -1) break; /* Success */ if (close(clientfd) &lt; 0) &#123; /* Connect failed, try another */ //line:netp:openclientfd:closefd fprintf(stderr, &quot;open_clientfd: close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* All connects failed */ return -1; else /* The last connect succeeded */ return clientfd;&#125; int open_listenfd(char *port) &#123; struct addrinfo hints, *listp, *p; int listenfd, rc, optval=1; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Accept connections */ hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */ hints.ai_flags |= AI_NUMERICSERV; /* ... using port number */ if ((rc = getaddrinfo(NULL, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (port %s): %s\\n&quot;, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can bind to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Eliminates &quot;Address already in use&quot; error from bind */ setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, //line:netp:csapp:setsockopt (const void *)&amp;optval , sizeof(int)); /* Bind the descriptor to the address */ if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0) break; /* Success */ if (close(listenfd) &lt; 0) &#123; /* Bind failed, try the next */ fprintf(stderr, &quot;open_listenfd close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* No address worked */ return -1; /* Make it a listening socket ready to accept connection requests */ if (listen(listenfd, LISTENQ) &lt; 0) &#123; close(listenfd); return -1; &#125; return listenfd;&#125; 例子// echoclient.c#include &lt;csapp.h&gt;int main(int argc, char *argv[])&#123; int clientfd; char *host, *port, buf[MAXLINE]; rio_t rio; if (argc != 3) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; host = argv[1]; port = argv[2]; clientfd = Open_clientfd(host, port); Rio_readinitb(&amp;rio, clientfd); while (Fgets(buf, MAXLINE, stdin) != NULL) &#123; Rio_writen(clientfd, buf, strlen(buf)); Rio_readlineb(&amp;rio, buf, MAXLINE); Fputs(buf, stdout); &#125; Close(clientfd); exit(0);&#125; // echoserver.c#include &lt;csapp.h&gt;void echo(int connfd)&#123; size_t n; char buf[MAXLINE]; rio_t rio; Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; printf(&quot;server received %d bytes\\n&quot;, (int)n); printf(&quot;Received:%s\\n&quot;, buf); Rio_writen(connfd, buf, n); &#125;&#125;int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if (argc != 2) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, 0); printf(&quot;connected to (%s, %s)\\n&quot;, client_hostname, client_port); echo(connfd); Close(connfd); &#125; exit(0);&#125; 术语索引protocol family 协议簇：一组相关联的协议","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"系统级I/O - CS:APP 第十章","slug":"系统级I-O-CS-APP-第十章","date":"2022-09-20T07:18:55.000Z","updated":"2022-09-25T14:15:11.726Z","comments":true,"path":"2022/09/20/系统级I-O-CS-APP-第十章/","link":"","permalink":"https://cfla1638.github.io/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"系统级I&#x2F;O - CS:APP 第十章Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。 在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。 文件描述符 定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。 Linux Shell 创建的进程会打开三个文件： 0：标准输入；也可以使用定义在unistd.h 中的STDIN_FILENO 来显示表述 1：标准输出；STDOUT_FILENO 2：标准错误；STDERR_FILENO EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;&#x3D; m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。 文件类型 普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。 目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是. 和.. 分别代表自己和上层目录。 套接字 socket ：用来和其他进程进行跨网络通信的文件。 系统级IO函数#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;// 打开和关闭文件int open(char * filename, int flags, mode_t mode);/*flags: 文件的打开方式O_RDONLY 只读O_WRONLY 只写O_RDWR 可读可写O_CREAT 如果文件不存在，创建O_TRUNC 如果文件已存在，截断它（即覆盖原文件）O_APPEND 添加到文件末尾不同的flag可以使用管道符| 连接使用 mode:一般为0*/int close(int fd);// 读写ssize_t read(int fd, void *buf, size_t n);// 返回值：若成功返回-1，EOF返回0，出错返回-1ssize_t write(int fd, const void *buf, size_t n);// 返回值：若成功返回写的字节数，出错返回-1 ssize_t ：signed size type read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n 可能会返回不足值得情况： 读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。 从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。 读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。 RIO包函数RIO(Robust I&#x2F;O)：用于网络编程中，会自动处理不足值的情况。 总览：// 不带缓冲区的版本ssize_t rio_readn(int fd, void *usrbuf, size_t n); // 代替readssize_t rio_writen(int fd, void *usrbuf, size_t n); // 代替write// 带缓冲区的版本void rio_readinitb(rio_t *rp, int fd);ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n); // 带缓冲区的rio_readn 带缓冲区和不带缓冲区的优劣： 带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。 不带缓冲区：比较快速，方便在网络上进行数据传输（臆断） 不带缓冲区的函数rio_readn()用来代替read 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。 ssize_t rio_readn(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被读取的字节 ssize_t nread; // 单次调用read 函数所读取的字节 char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; // read 函数发生错误 if (errno == EINTR) // interrupted by a sig handler return nread = 0; // call read again else return -1; // unknown error &#125; else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft; // 这个程序读取的所有字节&#125; rio_writen()用来代替write 的函数，无缓冲区，绝对不可能返回不足值 ssize_t rio_writen(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被写入的字节 ssize_t nwritten; // 单词write函数写入的字节 char *bufp = usrbuf; // 下一个将被写入的位置 while (nleft &gt; 0) &#123; if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) &#123; if (errno == EINTR) // 被一个信号处理程序返回打断 nwritten = 0; else return -1; // 未知错误 &#125; nleft -= nwritten; bufp += nwritten; &#125; return n;&#125; 带缓冲区的函数缓冲区的代码 #define RIO_BUFSIZE 8192 // 缓冲区的大小typedef struct&#123; int rio_fd; // 与缓冲区关联的文件描述符 int rio_cnt; // 缓冲区中的未读字节数 char *rio_bufptr; // 下一个未读字节地址 char rio_buf[RIO_BUFSIZE]; // 缓冲区&#125;rio_t; 初始化缓冲区 void rio_ rio_read()带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数 该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。 该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。 static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)&#123; int cnt; // 本次调用函数读取的字节数 while (rp-&gt;rio_cnt &lt;= 0) &#123; // 如果缓冲区为空，重新填满缓冲区 rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf)); if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno != EINTR) // 被信号打断，自动重启 return -1; // 未知错误 &#125; else if (rp-&gt;rio_cnt == 0) return 0; // EOF else rp-&gt;rio_bufptr = rp-&gt;rio_buf; // 重置bufptr &#125; cnt = n; if (rp-&gt;rio_cnt &lt; n) // 缓冲区字节数不够 cnt = rp-&gt;rio_cnt; // 返回不足值 memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125; rio_readlineb()读取一行，最多读取maxlen-1个字节，最后一个字节要填充&#39;\\0&#39; ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)&#123; int n, rc; // n 程序读取字节数， rc 单次rio_read 的返回值 char c, *bufp = usrbuf; // c一个临时变量，用于逐个读取，测试是否为换行 for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = rio_read(rp, &amp;c, 1)) == 1) &#123; // 正常 *bufp++ = c; if (c == &#x27;\\n&#x27;) &#123; n++; break; &#125; &#125; else if (rc == 0) &#123; // 返回不足值 if (n == 1) return 0; // EOF，什么字节也没读取，直接返回0 else break; // EOF, 但已经读取了一些字节，需要处理后返回 &#125; else return -1; // 未知错误 &#125; *bufp = 0; // 最后一位用 &#x27;\\0&#x27; 填充 return n - 1;&#125; rio_readnb()rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同 ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)&#123; size_t nleft = n; // bytes that has not been read ssize_t nread; // read() func had read nread bytes char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = rio_read(rp, bufp, nleft)) &lt; 0) // someting wrong return -1; // unknown error else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft;&#125; 读取文件元数据#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *filename, struct stat *buf);int fstat(int fd, struct stat *buf); stat() 函数以文件名作为输入，填写struct stat *buf 我们只对struct stat 的一些条目感兴趣： buf-&gt;st_size 文件的大小 buf-&gt;st_mode 使用在sys/stat.h 的三个宏可以判断文件类型： S_ISREG(mode) 这是一个普通文件吗？ S_ISDIR(mode) 这是一个目录文件吗？ S_ISSOCK(mode) 这是一个网络套接字吗？ 读取目录#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);#include &lt;dirent.h&gt;struct dirent * readdir(DIR *dirp);struct dirent &#123; ino_t d_ino; // inode number 文件位置 char d_name[256]; // Filename 文件名&#125; IO重定位#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);/*复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd*/","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章","slug":"虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章","date":"2022-09-17T03:03:22.000Z","updated":"2022-09-17T03:27:16.949Z","comments":true,"path":"2022/09/17/虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章/","link":"","permalink":"https://cfla1638.github.io/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"虚拟内存视角下的Linux进程 &amp; 动态内存分配Linux的虚拟内存系统Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分： 进程虚拟内存部分 内核虚拟内存部分 进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是： 用户栈 %rsp → 共享库的内存映射区域 brk → 运行时的堆（通过malloc分配的） 未初始化的数据(.bss) 已初始化的数据(.data) 0x400000 → 代码(.text) 内核虚拟内存可分为两部分： 内核中的代码和数据及数据结构 被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置） 与进程相关的数据结构（页表、task和mm结构、内核栈） 每个进程都不相同 物理内存 每个进程都相同 内核代码和数据 每个进程都相同 Linux如何组织虚拟内存Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段 这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap） 用户级内存映射Linux 可以使用mmap函数来创建新的虚拟内存，并将对象映射到这些区域中 #include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);/*将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域prot:PROT_EXEC 该页面的区域可以被执行PROT_READ 该页面区域可读PROT_WRITE ... 可写PROT_NONE ... 不能被访问flags:MAP_ANON 被映射的对象是一个匿名对象MAP_PRIVATE 是一个私有对象，使用写时复制机制MAP_SHARE 是一个共享对象*/int munmap(void *start, size_t length); // 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误 例子：将任意磁盘文件赋值到stdout #include &lt;csapp.h&gt;void mmapcopy(int fd, int size)&#123; char *bufp; // load to virtual memory bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0); Write(STDOUT_FILENO, bufp, size); // write to stdout return ;&#125;int main(int argc, char *argv[])&#123; struct stat stat; int fd; if (argc != 2) &#123; printf(&quot;usage: %s &lt;filename&gt;\\n&quot;, argv[0]); exit(0); &#125; // open file fd = Open(argv[1], O_RDONLY, 0); fstat(fd, &amp;stat); // get detailed message of file mmapcopy(fd, stat.st_size); // call mmapcopy exit(0);&#125;","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"异常控制流 - CS:APP 第8章","slug":"异常控制流-CS-APP-第8章","date":"2022-09-12T01:48:49.000Z","updated":"2022-09-25T14:15:19.214Z","comments":true,"path":"2022/09/12/异常控制流-CS-APP-第8章/","link":"","permalink":"https://cfla1638.github.io/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/","excerpt":"","text":"异常控制流 - CS:APP 第8章 这一章更多的是实践，理论的部分实在不多 本文将介绍： 常见的异常 (Linux)部分并发编程 一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。 异常及其分类 中断 (interrupt) : 异步发生，是来自处理器外部I&#x2F;O设备的信号的结果 陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过syscall 指令，造成一个到异常处理程序的陷阱。 系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式 故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页 终止 (abort)：不可恢复的错误。 Linux 进程进程的定义：一个执行中的程序实例 进程提供给程序两个抽象的概念： 一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。 区分并发和并行： 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 获取进程id #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 在linux上，pid_t 被定义为 intpid_t getpid(void); // 获取当前进程pidpid_t getppid(void); // 获得父进程pid 进程只有三种状态： 运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。 暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。) 终止。进程永远地停止了。进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程 从主程序返回 调用exit函数。 创建进程： #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);/*该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）子进程与父进程的虚拟地址空间相同，文件描述符相同该函数返回两次：在父进程中返回创建子进程的pid在子进程中返回0可以依此区分两个进程*/ 回收僵死进程: #include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *statusp, int options);/*pid 等待集合 pid &gt; 0 一个单独的子进程 pid = -1 父进程的所有子进程 statusp 导致返回的状态信息options 选项return :成功回收：回收进程的pidWNOHANG 返回0其他错误 -1 (例如没有子进程)：如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR典型用法：waitpid(-1, NULL, 0);挂起该进程，等待该进程的子进程终止，回收该僵死进程*/pid_t wait(int *statusp); // 等价于waitpid(-1, &amp;statusp, 0); 让进程休眠： #include &lt;unistd.h&gt;unsigned int sleep(unsigned int secs); // 挂起进程secs秒，如果因为信号中断则会提前返回int pause(void); // 挂起进程，因为进程中断会提前返回 加载并运行程序 #include &lt;unistd.h&gt;// filename 可执行文件路径，argv参数列表，envp环境变量int execve(const char *filename, const char *argv[], const char *envp[]);/*execve调用一次，从不返回，除非找不到可执行文件文件argv/envp 指向以NULL结尾的指针数组特别强调：通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码*/ 信号信号是一种软件层次的异常 发送信号的两个原因： 内核检测到一个系统事件，如子进程终止，发送SIGCHLD 一个进程显式地调用了kill函数，向某个进程发送了信号 一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此： 当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。 为了能方便向大量进程发送信号，Linux提供了进程组这个概念。 进程组相关： #include &lt;unistd.h&gt;pid_t getpgrp(void); // 获取当前进程的进程组int setpgid(pid_t pid, pid_t pgid); // 设置pid的进程组/*如果pid为0，则设置当前的进程如果pgid为0，则用pid指定的PID作为进程组idsetpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID*/ 发送信号 /bin/kill 程序可以手动发送信号 在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。 kill函数 alarm函数 #include &lt;unistd.h&gt;unsigned int alarm(unsigned int secs);// secs秒后，发送一个SIGALRM信号给调用进程 接受处理信号： #include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler handler);/*signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：1. 如果handler是SG_IGN,那么忽略类型为signum的信号。2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。*/ 阻塞 &amp; 解除阻塞信号： #include &lt;signal.h&gt;int sigprocmask(int how, sigset_t *set, sigset *oldset);int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int setdelset(sigset_t *set, int signum);int sigismember(const sigset_t *set, int signum);/*对于sigprocmask的how，有三个选项：SIG_BLOCK 将set中的信号添加到阻塞集合SIG_UNBLOCK 将set中的信号从阻塞信号中删除SIG_SETMASK 将block = set*/ 非本地跳转 #include &lt;setjmp.h&gt;int setjmp(jmp_buf env);int sigsetjmp(sigjmp_buf env, int savesigs);void longjmp(jmp_buf env, int retval);void siglongjmp(sigjmp_buf env, int retrval); 附：Linux 配置CSAPP库 参考： https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435 https://zhuanlan.zhihu.com/p/76930507 https://blog.csdn.net/jakejohn/article/details/79825086 第三版CSAPP库 代码下载：http://csapp.cs.cmu.edu/3e/code.html 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 术语索引抢占(preempted) 暂时挂起 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 挂起(suspended) 阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"模电课程 - 大学课程","slug":"模电课程-大学课程","date":"2022-09-10T04:17:18.000Z","updated":"2022-12-20T09:56:34.885Z","comments":true,"path":"2022/09/10/模电课程-大学课程/","link":"","permalink":"https://cfla1638.github.io/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"电工学基础知识基尔霍夫电压定理 基尔霍夫电流定理 结点电压法：第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com) 回路电流法： 叠加定理：电学基础理论之叠加定理 (baidu.com) 戴维南等效电路 二极管： 正向压降 ： 正向通过后，电压的减小量。 二极管的功能： 钳位 钳位二极管_百度百科 (baidu.com) 隔离 稳压 ： 见下面稳压二极管视频 稳压二极管： 详见视频： https://www.bilibili.com/video/BV1qY4y1t7sc 详见P15页笔记 绪论 电压源 理想的电压源内阻为0，输出电压U = E - IR0, R0 &#x3D; 0，因此输出电压恒定不变。当内阻远小于外电阻时，可近似看作理想电压源。 电流源 理想电流源的内阻为无穷大，因此输出的电流I &#x3D; IS - U &#x2F; R ，恒定不变。 第十四章 半导体器件二极管 导通电压： 硅管：0.5V 锗管：0.1V 正向压降 硅管：0.6 ~ 0.8 V 锗管：0.2 ~ 0.3 V 主要参数 最大整流电流 IOM : 长时间使用所允许通过的最大正向平均电流 反向工作峰值电压 URWM : 保证二极管不被击穿而给出的反向峰值电压，一般是反向击穿电压的1&#x2F;2或2&#x2F;3。 反向峰值电流 IRM ：在URWM 下的电流 作用 整流 限伏&#x2F;钳位 隔离：两个二极管并联，某个二极管的电压高，则它优先导通。因而电压低的那一个二极管被隔离了。 稳压二极管 使用稳压二极管时一定要有限流电阻R，不然二极管必定会被烧坏。 稳压二极管的工作原理：当电源电压升高，使得稳压二极管两侧电压有升高的趋势时，此时稳压二极管的电阻升高，电流增大，引起干路限流电阻的电流增加，限流电阻的电阻不变，因此限流电阻的分压增大，抵消了电源增加的电压。 在分析使用稳压二极管之前，假设二极管尚未反向导通，先判断二极管两侧的电压，只有二极管反向击穿时，才能有稳压的效果。 三极管 放大区，IE &#x3D; IC + IB , IC &#x3D; β IB ，发射结正偏，集电结反偏。 截止区，IC &#x3D; 0, UCE &#x3D; UCC ， 约等于断开，此时 IB &#x3D; 0或以下 饱和区，此时IB 和IC 关系很小，IC &#x3D; UCC &#x2F; RC , UCE &#x3D; 0, 相当于短路 如何判断三极管的工作状态？ 求出 IC Maximun &#x3D; (Vcc - UCE) &#x2F; RC 求出 IB 若βIB &gt; ICMaximun 饱和 否则处于放大区 参数 硅管 UBE &#x3D; 0.6 ~ 0.7 V β 杠 ： 静态电流放大系数 β：动态电流放大系数 ICBO ICEO ICM 集电极允许的最大电流，超过它放大系数将会下降 U（BR）CEO 如果UCE 固定，那么随着IB 的增加，三极管的工作状态会慢慢从放大状态转为过饱和状态。 第十五章 基本放大电路放大电路的输入电阻：输入电路的等效负载电阻 放大电路的输出电阻：输出电路的等效内阻 共发射极放大电路（固定偏置放大电路）(名字来源：因为偏置电路是固定的) 输入: UI或者IB 或UBE 输出：UO (UCE 的交流分量 阻容耦合) 静态值是指 IB IC UBE ：一般是 0.6 V(硅管是0.6 ~ 0.7) UCE 静态值的直接求解法： IB ： (UCC - UBE ) &#x2F; RB IC ： βIB UBE ：一般是 0.6 V(硅管是0.6 ~ 0.7) UCE : UCC - RC IC 静态值得图解法： 三极管的输出特性曲线是IC - UCE (y - x) 因此，只要求出IC &#x3D; f(UCE ) 即可 由UCE &#x3D; UCC - RC IC 因此只要求出UCC 和 RC 即可 偏置电路是指产生偏流IB 的电路，偏置电阻是指限流IB的电阻 非线性失真原因：静态工作点不合适 或 信号太大 分类 截止失真 : 静态工作点位置太低，输入产生的IB 在负半周截止了，导致输出的IC也截止了（负半周），导致UCE 的正半周截止了 饱和失真 ： 静态工作点位置太高，输出的IC 在正半周饱和，导致输出的UCE 在负半周失真。 什么可以影响静态工作点： 最直接的因素是IC，可以影响IC的因素都可以影响静态工作点 静态工作点的稳定分压式偏置放大电路射级输出器输入电阻大：对内阻高的信号源很有意义 输出电阻小：具有恒压输出的特性，带负载能力较强 一般用于多级放大电路的输入级或输出级或者多级之间的缓冲级&#x2F;隔离级 第十六章 集成运算放大器集成运放的组成 输入极 输入极要求输入电阻高，静态电流小，差模放大倍数高，抑制零点漂移和共模干扰信号强，输入极都采用差分放大电路。 中间级 进行电压放大，要求电压放大倍数高，一般采用共发射极放大电路 输出级 要求输出电阻低，带负载能力强，一般由互补功率放大电路或射级输出器构成 偏置电路 为上述个电路提供稳定合适的偏置电流，决定各级的静态工作点，一般由各种恒流源电路组成。 理想运放开环电压放大倍数 ∞ 差模输入电阻 ∞ 开环输出电阻 0 工作在线性区 虚断：由于差模输入电阻为∞，可以认为两个输入端的电流 i+ &#x3D; i- &#x3D; 0 虚短：由于开环电压放大倍数 ∞，可以认为 u+ &#x3D; u- 虚地，如果由于虚短，如果两个输入端有一个接地，相当于另一个也接地 工作在饱和区 虚断：仍然存在 虚短：此时工作在饱和区，不能满足在线性区的放大关系，因此，两个输入端的电压不必相等，虚短不存在 u+ &gt; u- : uo &#x3D; + Uo(sat) u+ &lt; u- : uo &#x3D; - Uo(sat) 信号运算 反向比例运算 运放工作在线性区 只要运放的开环放大倍数很高，比例运算的放大能力就只与外接电阻有关 这个放大倍数就是闭环放大倍数 Uo &#x3D; -(RF &#x2F; R1) U1 正向比例运算 电压从正向端输入 放大比例也只与外接电阻有关 Uo &#x3D; (1 + RF &#x2F; R1) U1 加法运算 Uo &#x3D; -[(RF&#x2F;R11)U11 + (RF&#x2F;R12)U12 + (RF&#x2F;R13)U13] Uo &#x3D; -(RF &#x2F; R1)(U11 + U12 + U13) 减法运算 Uo &#x3D; (1 + RF &#x2F; R1 ) (R3 &#x2F; (R1 + R2)) U12 - RF &#x2F; R1 U11 当R1 &#x3D; R2, R2 &#x3D; RF Uo &#x3D; RF &#x2F; R1(U12 - U11) 当 R1 &#x3D; R2 &#x3D; R2 &#x3D; RF Uo &#x3D; U12 - U11 第十七章 电子电路中的反馈反馈的模态判断： 反馈信号与输入信号在 相同端子上（并联） 极性相同：正反馈 极性相反：负反馈 相异端子上（串联） 极性相同：负反馈 极性相反：正反馈 如何判断反馈是电压反馈还是电流反馈？ 将输出电压UO 置零，看是否还存在反馈？ 存在：电流反馈 不存在：电压反馈 负反馈对输入输出电阻的影响： 电压负反馈使得输出有电压源的特性，因此电压负反馈可以降低输出电阻ro 电流负反馈使得输出有电流源的特性，因此电流负反馈可以增高输出电阻ro 串联反馈可以增大输入电阻ri 并联反馈可以减小输入电阻ri 负反馈可以减小波形失真，但不能完全消除波形失真 引入负反馈之后可以降低放大倍数 引入负反馈可以提高放大倍数的稳定性 第十八章 直流稳压电源整流 单相半波整流 变压器的输出（整流电路输入的交流电压，变压器的二次电压）为 u &#x3D; √2Usin wt (U为交流电压的有效值，也叫变压器的二次电压有效值) 整流电压的平均值 UO &#x3D; 0.45U 整流电流（负载电流）的平均值 IO &#x3D; UO &#x2F; RL &#x3D; 0.45U&#x2F;RL 整流元件截止时的最高反向电压 URM &#x3D; √2U (并不是元件能承受的最大电压，元件能承受的最大反向电压要看元件自己的参数) 单相全波整流 UO &#x3D; 0.9U IO &#x3D; 0.9U&#x2F;RL ID &#x3D; (1&#x2F;2)IO &#x3D; 0.45U&#x2F;RL URM &#x3D; 2√2U 三相半波 UO &#x3D; 1.17U IO &#x3D; 1.17U&#x2F;RL ID &#x3D; (1&#x2F;3)IO URM &#x3D; 2.45U 单向桥式整流 UO &#x3D; 0.9U IO &#x3D; 0.9U&#x2F;RL 每个二极管中流过的平均电流 ID &#x3D; (1&#x2F;2)IO &#x3D; 0.45U&#x2F;RL URM &#x3D; √2U 变压器的变比K &#x3D; 交流电源电压 &#x2F; 二次电压有效值 变压器容量 S &#x3D; UI &#x3D; 变压器二次电压有效值 * 变压器二次电流有效值 三相桥式整流 UO &#x3D; 2.34U IO &#x3D; 2.34U&#x2F;RL ID &#x3D; (1&#x2F;3)IO URM &#x3D; 2.45 U 滤波 电容滤波器 UO &#x3D; 1.2U 对滤波电容，一般要求 RL C &gt;&#x3D; (3~5)T&#x2F;2 电感电容滤波（LC滤波） 适用于电流较大、要求输出电压脉动很小的场合，用于高频时更加合适 直流稳压电源 稳压二极管稳压电路 一般交流电压经过整流（桥式整流）和滤波之后，得到的直流电仍存在波动，此时需要进行稳压 引起负载电压变化的原因有二： 交流电源电压的变化 负载电流的变化 可以对负载电阻，先串联一个保护电阻，在并联一个稳压二极管，稳压二极管通过提高或减小电流，是的保护电阻承担增大或减少的电压。 选取稳压二极管时，一般取： UZ &#x3D; UO （UZ 为稳压二极管的稳定电压，Uo为输出的负载电压） IZM &#x3D; (1.53) IOM~ （IZM 为最大稳压电流，IOM 为负载电流的最大值） U1 &#x3D; (23) UO~ (其中U1 是经过整流 滤波后的输出电压，也就是稳压部分的输入电压，即需要被稳压的部分) 集成三端稳压电源 W78XX（输出固定正电压），W79XX（输出固定负电压），W117&#x2F;217&#x2F;317（输出电压可调） 有三个引脚，分别是输入端I，输出端O，地段GND 使用时需要在其输入端，输出端，地段并联一个电容 几种典型的电路： 正负电压同时输出的电路 输出电压可调的电路 用集成运放 + W78XX&#x2F;W79XX 用W117&#x2F;217&#x2F;317","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"链接 - CS:APP 第七章","slug":"链接-CS-APP-第七章","date":"2022-09-07T11:47:36.000Z","updated":"2022-09-23T04:37:32.473Z","comments":true,"path":"2022/09/07/链接-CS-APP-第七章/","link":"","permalink":"https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"链接本文将介绍： 编译的过程 三种目标文件 三种链接和链接的过程 1 编译的过程 源文件（.c &#x2F;.cpp）经过翻译，形成可重定位目标文件（.o） 具体过程： 预处理 cpp main.c -o main.i 或 gcc -E -o main.c main.c 编译器 ：翻译成汇编语言 cc1 或 cc main.i -o main.s 或 gcc -S -o main.s main.c 汇编器 ：形成可重定位目标文件 as [args] -o main.o 这中间参数很多， 如果向直接到这一步可以使用 gcc -c -o main.o main.c 链接器 链接形成可执行目标文件 ld -o prog main.o other.o 或 gcc -o prog main.o other.o 如果想要一步一步生成.i .s .o 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。 除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 -E -S -c 参数进行编译。 顺带一提，在bash中，可以通过 echo $? 来展示上一次程序退出的返回值 2 三种目标文件首先，什么是目标文件？ 计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。 ——360百科 目标文件可以分为三类： 可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。 可执行目标文件 ： 可以被复制到内存中执行。 共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接 window系统使用PE portable Executable 格式 Linux使用 Executable and Linkable Format, ELF格式 2.1 可重定位目标文件格式 可重定位目标文件 以ELF头开始，通过readelf -a main.o 我们可以看到ELF头的内容 ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12 可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。 我倾向于认为这是节头部表的内容： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1 在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。 一个典型的ELF可重定位目标文件包含下面的节： .text : 已编译的机器代码 .rodata : read only data 只读数据，如printf的格式字符串 .data : 已初始化的全局和静态变量 .bss : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节） .symtab ：符号表 rel.text ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量 .rel.data .debug ：调试信息 .line ：调试时的行号 strtab ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字 2.1.1 符号表符号表的条目格式是这样的 typedef struct &#123; int name; // 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c char type:4, // 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ... binding:4; // 全局变量还是本地变量 GLOBAL OR LOCAL char reserved; // 保留的，未使用 short section; // 在ubuntu 上的名字是Ndx,指明该符号是在那个section的 long value; // 距离节section 起始位置的字节偏移 long size; // 该符号最小的大小&#125; Elf64_Symbol; 对于section 字段，在ubuntu 的readelf 命令中，显示为 Ndx。 该字段有三个伪节，他们分别是 UNDEF COMMON ABS 。 ABS ：代表不改被重定位的符号 UNDEF ：代表未定义的符号，即在本模块引用却在其他模块定义的符号 COMMON ：还未被分配位置的未初始化的数据目标 COMMON 和 .bss 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到COMMON 和.bss COMMON ：未初始化的全局变量 .bss ：未初始化的静态变量，以及初始化为0的全局或静态变量 下面我们通过一个程序来展示以下ubuntu 中的符号表 int sum(int * a, int n);int array[2] = &#123;1, 3&#125;;int global_not_init;int global_init = 1;int global_init_zero = 0;int main()&#123; static int stat_not_init; static int stat_init_zero = 0; static int stat_init = 1; int val = sum(array, 2); return val;&#125; 下面我们生成可重定位的目标文件gcc -c main.c 接着使用readelf -a main.o 读取elf，即可查看符号表 cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.ccfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.oELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific)There are no section groups in this file.本文件中没有程序头。There is no dynamic section in this file.重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000000014 000c00000002 R_X86_64_PC32 0000000000000000 array - 4000000000019 001200000004 R_X86_64_PLT32 0000000000000000 sum - 4重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.Symbol table &#x27;.symtab&#x27; contains 19 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 000000000000000c 4 OBJECT LOCAL DEFAULT 3 stat_init.1921 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 0 SECTION LOCAL DEFAULT 7 10: 0000000000000000 0 SECTION LOCAL DEFAULT 8 11: 0000000000000000 0 SECTION LOCAL DEFAULT 5 12: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 13: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_not_init 14: 0000000000000008 4 OBJECT GLOBAL DEFAULT 3 global_init 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero 16: 0000000000000000 37 FUNC GLOBAL DEFAULT 1 main 17: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 18: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sumNo version information found in this file.Displaying notes found in: .note.gnu.property 所有者 Data size Description GNU 0x00000010 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK 符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量global_not_init 在COMMON 伪节，已经初始化了的全局变量global_init和静态变量stat_init都在.data 节，而初始化为0的全局变量global_init_zero 和没有初始化的静态变量stat_not_init 和初始化为0的静态变量stat_init_zero 在.bss 节 根据这三行的value 字段我们还可以看到这三个变量在.bss 节的存储顺序 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 注意观察两个静态变量多了两个后辍 这样做其实是为了区分在同一个模块中同名的两个静态变量 如下面程序的这个例子 int func_1(int n)&#123; static int x = n + 1; return x;&#125;int func_2(int n)&#123; static int x = n + 2; return x;&#125; 这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。 2.2 可执行目标文件格式下面是典型的ELF 可执行目标文件 在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过readelf 来看一下这个段头部表 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000498 0x0000000000000498 R 0x1000LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x0000000000000205 0x0000000000000205 R E 0x1000LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x0000000000000120 0x0000000000000120 R 0x1000LOAD 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x00000000000001e0 0x00000000000001e8 RW 0x1000 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。 ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。 加载可执行文件： 在shell中输入 ./prog 后： shell调用fork() 函数，创建子进程 子进程调用execve()，execve调用加载器，加载prog程序 加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址) _start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数 2.3 可共享目标文件格式3 三种链接和链接的过程三种链接： 静态链接 动态链接库 程序运行时链接共享库 3.1 静态链接静态链接的两个过程 符号解析 重定位 3.1.1 符号解析链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。 对于局部符号，它不会出现在符号表中。 对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。 唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。 对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。 而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 (在COMMON伪节) 接着使用以下规则来处理这些符号： 不允许有多个同名的强符号 如果一个强符号与多个弱符号同名，选择强符号 若有多个弱符号同名，从这些弱符号中任选一个。 这三个规则很容易造成一些不易察觉的运行时错误。 为什么会有.COMMON伪节？ 如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。 而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节 以上讲的是几个.o 文件的链接，他们都是目标文件 接下来我们讲与静态库的链接，其中会有存档文件 这个概念，注意区别 静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是 .a 在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。 生成静态库： 首先编译：gcc -c addvec.c multvec.c 接着生成静态库：ar rcs libvector.a addvec.o multvec.o 得到静态库 libvector.a，存档文件 (重要) 链接器如何使用静态库来解析引用： 链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。 对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。 注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。 因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。 但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的 如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B 假如有这样的依赖关系： 我们要写成 gcc A.o B.a C.a B.a -o prog 因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。 3.1.2 重定位《深入理解计算机系统》原书第三版 P 478 7.7 3.2 动态链接库静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。 所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。 创建动态库 gcc -shared -fpic -o libvector.so addvec.c multvec.c 与动态库链接： gcc -o prog main.c ./libvector.so 与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。 下面是动态链接库的过程： 一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章) 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 3.3 程序运行时链接共享库可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序： // 7.11 load and link shared library from an application// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int x[2] = &#123;1, 2&#125;;int y[2] = &#123;3, 4&#125;;int z[2];int main(void)&#123; void * handle; // shared lib handle void (*addvec)(int *, int *, int *, int); // point to a function void (*multvec)(int *, int *, int *, int); // point to a function char * error; // point to error massages string // load shared library handle = dlopen(&quot;./libvector.so&quot;, RTLD_LAZY); if (!handle) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; // search the symbol &quot;multvec&quot; from the shared library multvec = dlsym(handle, &quot;multvec&quot;); if ((error = (dlerror())) != NULL) &#123; fprintf(stderr, &quot;%s\\n&quot;, error); exit(1); &#125; // execute the function multvec(x, y, z, 2); printf(&quot;z = [%d %d]\\n&quot;, z[0], z[1]); // unload the shared library if (dlclose(handle) &lt; 0) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; return 0;&#125; 名词索引ELF-64 目标文件格式 PIC(Position-Independent Code) 位置无关代码","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"动态数组,二维数组,指针","slug":"动态数组-二维数组-指针","date":"2022-09-06T12:45:24.000Z","updated":"2022-09-06T12:46:41.480Z","comments":true,"path":"2022/09/06/动态数组-二维数组-指针/","link":"","permalink":"https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/","excerpt":"","text":"动态数组、二维数组、指针本文会讲： 二维数组的存储形式 数组类型为什么会退化？ 二维数组的动态分配 1 二维数组的存储形式以下这个程序可以很好的说明二维数组的存储形式 #include &lt;stdio.h&gt;int main(void)&#123; int a[4][2]; // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = i * 10 + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); return 0;&#125; 这个程序的运行结果是这样的 sizeof(int): 4sizeof(a): 32 sizeof(a[0]): 8 a: 000000000064FDD0&amp;a: 000000000064FDD0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 000000000064FDD0a[1]: 000000000064FDD8a[2]: 000000000064FDE0a[3]: 000000000064FDE8*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 000000000064FDD0&amp;a[1]: 000000000064FDD8&amp;a[2]: 000000000064FDE0&amp;a[3]: 000000000064FDE8&amp;a[0][0]: 000000000064FDD0&amp;a[0][1]: 000000000064FDD4&amp;a[1][0]: 000000000064FDD8&amp;a[1][1]: 000000000064FDDC&amp;a[2][0]: 000000000064FDE0&amp;a[2][1]: 000000000064FDE4&amp;a[3][0]: 000000000064FDE8&amp;a[3][1]: 000000000064FDEC 可以看出，二维数组是连续储存的，有&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0] ，以此类推。 我们可以这样表示二维数组 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 2 数组类型为什么会退化？有的时候会出现这种情况： 在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？ 详见：https://www.zhihu.com/question/464844221/answer/1940453834 3 动态分配二维数组3.1 第一种方法先申请一维数组，在将该一维数组强制转换成二维数组 前置知识： 一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息 二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型， 即int q[][4] 和int (*q)[4] 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于q += 2 * 4 * sizeof(int) 直接贴代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *a = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) a[i] = i; int (*b)[4] = (int (*)[4])a; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, b[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。 我们用int (*b)[4] 声明了一个指向 四个元素的数组 的指针。 然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。 这样动态分配的指针和直接int b[2][4] 是一样的。 下面我们使用 1 中的方法对这个数组进行仔细检查 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; // 初始化数组 int *b = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) b[i] = i; int (*a)[2] = (int (*)[2])b; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]);&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8 sizeof(a[0]): 8 a: 00000000009C1420&amp;a: 000000000064FDF0a[0][0]: 00 a[0][1]: 01 a[1][0]: 02a[1][1]: 03a[2][0]: 04a[2][1]: 05a[3][0]: 06a[3][1]: 07a[0]: 00000000009C1420a[1]: 00000000009C1428a[2]: 00000000009C1430a[3]: 00000000009C1438*a[0]: 0*a[1]: 2*a[2]: 4*a[3]: 6&amp;a[0]: 00000000009C1420&amp;a[1]: 00000000009C1428&amp;a[2]: 00000000009C1430&amp;a[3]: 00000000009C1438&amp;a[0][0]: 00000000009C1420&amp;a[0][1]: 00000000009C1424&amp;a[1][0]: 00000000009C1428&amp;a[1][1]: 00000000009C142C&amp;a[2][0]: 00000000009C1430&amp;a[2][1]: 00000000009C1434&amp;a[3][0]: 00000000009C1438&amp;a[3][1]: 00000000009C143C 可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。 这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 3.2 第二种方法： 参考: https://blog.csdn.net/morewindows/article/details/7664479# 我这里将原文的int 替换成了size_t //C语言中动态的申请二维数组 malloc free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//动态申请二维数组template &lt;typename T&gt;T** malloc_Array2D(int row, int col)&#123; int size = sizeof(T); int point_size = sizeof(T*); //先申请内存，其中point_size * row表示存放row个行指针 T **arr = (T **) malloc(point_size * row + size * row * col); if (arr != NULL) &#123; memset(arr, 0, point_size * row + size * row * col); T *head = (T*)((size_t)arr + point_size * row); // 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好 while (row--) arr[row] = (T*)((size_t)head + row * col * size); &#125; return (T**)arr;&#125;//释放二维数组void free_Aarray2D(void **arr)&#123; if (arr != NULL) free(arr);&#125;int main()&#123; printf(&quot; C语言中动态的申请二维数组 malloc free\\n&quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\\n\\n&quot;); printf(&quot;请输入行列(以空格分开): &quot;); int nRow, nCol; scanf(&quot;%d %d&quot;, &amp;nRow, &amp;nCol); //动态申请连续的二维数组 int **p = malloc_Array2D&lt;int&gt;(nRow, nCol); //为二维数组赋值 int i, j; for (i = 0; i &lt; nRow; i++) for (j = 0; j &lt; nCol; j++) p[i][j] = i + j; //输出二维数组 for (i = 0; i &lt; nRow; i++) &#123; for (j = 0; j &lt; nCol; j++) printf(&quot;%4d &quot;, p[i][j]); putchar(&#x27;\\n&#x27;); &#125; free_Aarray2D((void**)p); return 0;&#125; 这里，原作者对指针的操作让我叹为观止。 但是，用这种方法创作出来的二维数组和直接int b[2][4] 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。 它的具体结构我将在下一小节介绍 3.3 第三种方法 参考：https://blog.csdn.net/houqd2012/article/details/8146070 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(2, 4); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 4; j++) a[i][j] = 10 * i + j; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; free_array2D(a); return 0;&#125; 乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。 我们使用 1 中的程序对这个数组进行详细的检查。代码如下 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(4, 2); // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = 10 * i + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); free_array2D(a); return 0;&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8sizeof(a[0]): 8a: 0000000000701420&amp;a: 000000000064FDF0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 0000000000701450a[1]: 0000000000701458a[2]: 0000000000701460a[3]: 0000000000701468*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 0000000000701420&amp;a[1]: 0000000000701428&amp;a[2]: 0000000000701430&amp;a[3]: 0000000000701438&amp;a[0][0]: 0000000000701450&amp;a[0][1]: 0000000000701454&amp;a[1][0]: 0000000000701458&amp;a[1][1]: 000000000070145C&amp;a[2][0]: 0000000000701460&amp;a[2][1]: 0000000000701464&amp;a[3][0]: 0000000000701468&amp;a[3][1]: 000000000070146C 从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接int b[2][4] 得到的二维数组，还是不一样的。 它的具体结构我将在下一小节介绍 3.4 总结 ： 下标运算符首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。 下标运算符是左结合的，我们引用二维数组，通常是这样的 arr[i][j] 但其实也可以这样 (arr[i])[j] 这两种形式是等价的。 下面我们详细地描述下标运算符 ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType)) 可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型int **, 也可以是数组类型 int (*)[]，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。 首先我们来看内置的数组类型 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 一个内置数组类型表示为int a[5][5] ，但拎出来a，他的类型是 int (*)[5] 所以arr[1] 其实是指a[1][0] 这个位置。a[1] 的类型是int * 所以(a[1])[1] 的类型就是int 接下来我们看动态分配二维数组的第一种方法： 这种方法一开始申请了一个一维数组int *a = (int *)malloc(2 * 4 * sizeof(int)) a的类型是int * 接下来我们使用强制类型转换，将a由int * 转换为int (*)[4] ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。 接下类我们看动态分配二维数组的第二种方法： 首先我们将这种方法分配的图画出来 设行数为row，列数为col，假设二维数组存储的类型为 int 第二种方法申请了 row * sizeof(int *) + row * col * sizeof(int) 字节的空间。 这个表达式的前一项row * sizeof(int *) 代表a[0] a[1] a[2] 的空间，后一项row * col * sizeof(int) 指的是连续的二维数组的存储空间。 这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。 需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是int ** 而不是int (*)[col] ，也决不能是int (*)[col] 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？ 首先a的类型时int ** ，a[1]，代表a之后一个指针大小位置的内容，即 *((size_t)a + 1 * sizeof(int *))，就是a[1] [0]的地址，而(a[1])[0] 就是a[1] [0]的内容。 为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是int ** 第三种二维数组的分析与第二种类似，这里我们给出它的表示 4 指针我们使用一个程序来展示 int (*)[col] 类型 #include &lt;stdio.h&gt;void func_1(int a[][8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_2(int (*a)[8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_3(int (*a)[8]) // 指向数组的指针&#123; for (int i = 0; i &lt; 8; i++) printf(&quot;%d &quot;, (*a)[i]);&#125;int main(void)&#123; int q[4][8]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 8; j++) q[i][j] = 10 * i + j; func_1(q, 4); printf(&quot;\\n&quot;); func_2(q, 4); printf(&quot;\\n&quot;); int p[8] = &#123;0, 1, 2, 3, 4, 5, 6, 7&#125;; func_3(&amp;p); // 因为是指向数组的指针，p必须要取地址&#125; 贴一篇文章 ：https://blog.csdn.net/soonfly/article/details/51131141 这篇文章里对指针类型的分析很好 int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"存储器层次结构 - CS:APP 第六章","slug":"存储器层次结构-CS-APP-第六章","date":"2022-09-04T03:28:41.000Z","updated":"2022-09-25T14:13:47.752Z","comments":true,"path":"2022/09/04/存储器层次结构-CS-APP-第六章/","link":"","permalink":"https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"存储器层次结构 - CS:APP 第六章本章的主要内容有四： 介绍存储技术 介绍存储器的层次结构思想 特别介绍高速缓存的原理和细节 使用局部性优化程序的性能 本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。 1 存储器的层次结构根据我们的经验观察，读取速度越快的存储器&#x2F;存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。 因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。 但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 L0 寄存器L1 L1高速缓存 SRAML2 L2高速缓存 SRAML3 L3高速缓存 SRAML4 主存 DRAML5 本地二级存储（本地磁盘）L6 远程二级缓存（分布式文件系统、二级服务器） 下面我们介绍它们的存在基础，存储技术。 2 存储技术我们要介绍的存储技术如下 随机存储器RAM SRAM DRAM 非易失性存储器 ROM PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） SSD （基于闪存，固态硬盘就是使用SSD技术） 磁盘 2.1 随机访问存储器随机存储器分为两种材类：SRAM和DRAM SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。 DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。 2.1.1 DRAM &#x2F; 内存的工作原理内存由若干个DRAM芯片构成，被称作内存模块(memory module) 每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。 每个超单元内存储若干个位，一般是一字节八位。 内存/主存||- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片|- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片 首先介绍DRAM 芯片： DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c &#x3D; d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。 我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。 接下来看一下工作流程： 首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。 接着介绍内存模块： 一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 2.2 磁盘 &amp; ROMROM可分为 PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） 我们不多介绍，只需要知道他们的名字和依赖关系即可 磁盘：通常指的是机械硬盘，也不过多介绍。 3 高速缓存首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍： 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。 而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。 数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。 以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。 令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。 这句话暂且悬置。 当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。 但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。 3.1 高速缓存的结构 一个计算机存储器的地址有m位，他被分为三部分： 高t位是标记位 中间s位是组索引位 低b位是组偏移位。 高速缓存被组织为这样的结构： 高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1 每个组中最多有2^t^ 个高速缓存行 每个高速缓存行也由三部分组成 一位有效位，标记着这个高速缓存行是否有效 t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行 2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用 3.2 高速缓存的工作原理当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。 确定是否命中有三个步骤： 组选择 行匹配 字抽取 组选择 回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。 行匹配 如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。 如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。 补充 : 我们先回忆一下地址的构成 标记位 t + 索引位 s + 偏移位b 假设有一个四位的地址，t &#x3D; 1，s &#x3D; 2，b &#x3D; 1 这四位地址的所有组合如下： 我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。 我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。 这样我们较低层的 0、4 映射到了较高层的0组， 1、5映射到了1， 2、6映射到了2， 3、7映射到了3 一个组中可以有最多2^t^ 行，如果我们一组中只有一行。 如果我们首先引用了块0，那么块0每放在较高层的组0， 接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。 通过上面的例子，我想说明两点 一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。 二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？ 注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。 其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。 字抽取 只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。 4 虚拟内存从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。 虚拟内存提供三个重要的能力： 它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。 它位每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。 虚拟内存的存在基础： 同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。 4.1 虚拟内存原理首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。 我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。 4.2 虚拟内存的结构在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。 页表：每个进程都有一个页表，页表将虚拟页映射到物理页。 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。 4.3 虚拟内存的地址翻译下面简单概括以下虚拟内存的地址翻译： 处理器产生一个虚拟地址，并将它传送给MMU MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3 由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4 现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。 下面我们介绍虚拟地址翻译中的一些细节： 什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？ 要解答这个问题，首先我们要介绍虚拟地址的格式。 虚拟页号 VPN 虚拟页偏移 VPO 页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。 PTE 是什么，它的结构是什么？ PTE 是页表条目，他的结构是这样的 SUP 有效位 READ 有效位 WRITE 有效位 PPN 物理页号 (Physical Page Number) 前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。 PPN 物理页号是什么呢？ 让我们回忆以下我们在介绍高速缓存时用到的物理地址 如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。 而标记位和组索引合起来就是PPN。 而块偏移和虚拟地址的虚拟页偏移VPO是一样的 因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。 快表TLB的工作原理是什么？ 快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址： 虚拟地址由VPN和VPO组成 虚拟页号 VPN 虚拟页偏移 VPO 而虚拟页号VPN又可以分为两部分： VPN VPN VPO TLB标记(TLBT) TLB索引(TLBI) VPO TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。 接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。 5 高速缓存系统和虚拟内存系统的对比高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统 虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统 存储在某个存储层，在存储层之间传输的单元叫做块(block) 在高速缓存SRAM中，它叫做高速缓存行，或者行 在主存DRAM中，它叫做块(block) 在虚拟内存系统中，它叫做页(page) 调度策略 高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小 DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大 6 技术总结在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。 有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。 我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。 B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n &#x3D; m + o。 现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。 由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？ 我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t &#x3D; m - i 位来作为标记，区分一组中的不同块。 通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 为什么使用中间位作为索引？ 如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。 接下来我们概括一下内存系统： 一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。 如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。 7 术语索引主存储器(main memory 主存) : 即通常理解的使用DRAM内存。 块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block) VM (Virtual Memory) 虚拟内存 VA(Virtual Address) 虚拟地址 MMU(Memory Management Unit)：内存管理单元，一种硬件 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 页表 ：一个数据类型位PTE的数组 PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型 页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging) 缺页：DRAM缓存不命中称为page fault 内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"CS:APP 读后感","slug":"CS-APP-读后感","date":"2022-09-02T06:23:07.000Z","updated":"2022-09-03T15:05:12.432Z","comments":true,"path":"2022/09/02/CS-APP-读后感/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"CS:APP 读后感这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的） 接下来会陆续更新各章的详细笔记 … 介绍目录： 第1章 计算机系统漫游--- 程序结构和执行第2章 信息的表示和处理第3章 程序的机械级表示第4章 处理器体系结构第5章 优化程序性能第6章 存储器的层次结构--- 在系统上运行程序第7章 链接第8章 异常控制流第9章 虚拟内存--- 程序间的交互和通信第10章 系统及I/O第11章 网络编程第12章 并发编程 本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。 剩下的十一章是本书的正式部分，我认为本书的核心在第 79 章，26章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。 分章介绍第二章 信息的表示和处理 这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。 2.1.3 寻址和字节顺序： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。 2.16 布尔代数介绍 ： 可以使用位向量来表示有限集合。 2.2 整数表示 ： 介绍了整数原码和补码的表示，以及他们之间的转换。 2.3 整数运算 ： 介绍了整数运算可能出现的错误，以及来源。 2.4 ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。 第三章 程序的机器级表示 相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。 这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。 从这一张开始到最后，才是一口气看完的。 3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了objdump 的使用 3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。 3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。 3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法 第四章 处理器体系结构 这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。 第五章 优化程序性能 呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。 客观一点就是 普通人日常写代码小技巧 第六章 存储器层次结构 没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。 第七章 链接 含金量高的来了 这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld 7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位 7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表 7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接 7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方 动态链接：与加载的时候链接的类型 库打桩机制 第八章 异常控制流 最重要的一章之一，介绍了并发编程的基础——异常控制流 介绍了进程，简单带领读者入门了并发编程 讲了信号，有助于以后学习事件驱动的GUI编程 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 8.2 异常 8.3 进程 8.4 用C语言操作进程：fork execve 8.5 信号 SIGINT … 第九章 虚拟内存 最重要的一章之一 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 本章可以分为三部分 第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的 第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve 第三部分介绍了一个内存分配器的实现( malloc() ) 第十章 系统级 I&#x2F;O 这一章读起来很简单，没有什么要理解的东西 首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。 然后着介绍了RIO包，即包装后的IO函数。 本章完 第十一章 网络编程 这一章需要理解的地方不多，只有介绍网络编程的部分 第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。 首先介绍了网络编程 接着介绍了Linux的套接字函数 最后实现了一个小web服务器 11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议 第十二章 并发编程 和上一章差不多的感觉 本章也分为三部分 首先介绍了实现并发编程的三种方法 进程 IO多路复用 线程 之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。 最后介绍了并发编程容易出现的问题：死锁、访问共享变量 …","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"ubuntu 配置","slug":"ubuntu-配置","date":"2022-09-02T02:49:51.000Z","updated":"2022-09-07T06:20:54.963Z","comments":true,"path":"2022/09/02/ubuntu-配置/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 配置2022&#x2F;9&#x2F;1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。 VScode 下载和配置下载的方法见官网，配置C&#x2F;C++的方法网上的博客也很好搜到 Linux系统VsCode 配置C&#x2F;C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境 接下来使将Open With Code 添加到右键菜单 这部分参考 ubuntu中为vscode添加右键菜单–网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com) 其中修改了一点命令，将visual-studio-code 改成了code 去$HOME/.local/share/nautilus/script/ 目录下新建一个文件，文件名就是显示在右键菜单上的名字。 接着将以下内容复制到新建的文件中 #!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&#x27;s directory if it&#x27;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &#x27;s/^file://////&#x27;`&quot;fi# It&#x27;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec code &quot;$destination&quot; 最后运行命令chmod +x 刚才创建的文件名 对文件或文件夹右键就可以看到刚才添加的右键菜单了。 下拉式终端Yakuka在这里 找到 Ubuntu 根据提示安装。 如果安装失败可能要换清华源，如下： 更换清华源 参考：https://blog.csdn.net/weixin_49700990/article/details/122005001 首先使用lsb_release -a 查看自己的Ubuntu版本 我们要更改的文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list， 首先使用命令对这个文件进行备份 sudo cp /etc/apt/sources.list /etc/apt/sources_save.list 接着 进入清华源网站 ，找到Ubuntu的源 ，选择合适的版本，根据提示手动替换即可。 设置应用开机启动在Ubuntu自带的 “启动应用程序” 里配置 更改磁盘大小 参考 https://blog.csdn.net/Shine_Su/article/details/124630751 首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。 将虚拟机的内容复制到虚拟机外 参考：https://blog.csdn.net/u013554213/article/details/124061526 依次执行以下命令，最后重启Ubuntu # 删除原来安装过的文件sudo apt autoremove open-vm-tools# 输入安装命令：sudo apt install open-vm-toolssudo apt install open-vm-tools-desktop 截图软件 https://zhuanlan.zhihu.com/p/415011610 sudo apt install flameshot 查看安装路径 which flameshot 在设置中，添加键盘快捷键 命令是/usr/bin/flameshot gui","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"}]},{"title":"数据结构课程","slug":"数据结构课程","date":"2022-08-23T03:50:55.000Z","updated":"2023-01-07T01:04:26.721Z","comments":true,"path":"2022/08/23/数据结构课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数据结构1. 线性表1.1 顺序实现#include &lt;cstdlib&gt;using namespace std;typedef int ElemType;typedef int Status;const int OK = 0;const int ERROR = 1;const int OVERFLOW = 2;const int LIST_INIT_SIZE = 100;const int LIST_INCREMENT = 10;typedef struct &#123; ElemType * elem; int length; int listsize;&#125;SqList;// 初始化Status InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType)); if (!L.elem) exit(OVERFLOW); L.length = 0; L.listsize = LIST_INIT_SIZE;&#125;// 插入Status insert(SqList &amp;L, int i, ElemType e)&#123; // 插入的合法范围为 1 &lt;= i &lt;= length + 1, 插入在length + 1时，需要另外申请空间，等价于append if (i &lt; 1 || i &gt; L.length + 1) return ERROR; // 若已满，重新分配空间 if (L.length &gt;= L.listsize) &#123; ElemType * newbase = (ElemType *)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof (ElemType)); if (!newbase) exit(OVERFLOW); L.elem = newbase; L.listsize += LIST_INCREMENT; &#125; // 位移 ElemType * pos = &amp;(L.elem[i - 1]); for (ElemType * rear = &amp;(L.elem[L.length - 1]); rear &gt;= pos; rear--) *(rear + 1) = * rear; * pos = e; L.length++; return OK;&#125;Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123; if (i &lt; 1 || i &gt; L.length) return ERROR; ElemType * pos = &amp;(L.elem[i - 1]); e = * pos; ElemType * rear = &amp;(L.elem[L.length - 1]); for (pos++; pos &lt;= rear; pos++) * (pos - 1) = * pos; L.length--; return OK;&#125; 1.2 链式实现#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;enum &#123;OK, ERROR, OVERFLOW&#125;;typedef int ElemType;typedef int Status;typedef struct LNode&#123; ElemType data; struct LNode * next;&#125;LNode, * LinkList;Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123; auto p = L-&gt;next; int j = 1; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i) return ERROR; e = p-&gt;data; return OK;&#125;Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; auto p = L; int j = 0; // 由于头节点的存在，计数器从0开始 // 寻找第i - 1个结点，也就是待插入节点的前驱节点 while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (!p || j &gt; i - 1) // i超出表长+1(append), 或i为负数 return ERROR; auto s = (LinkList)malloc(sizeof (LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK;&#125;Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; auto p = L; // 指向头节点 int j = 0; // 计数器 // 找到待删除结点的前驱 while (p-&gt;next &amp;&amp; j &lt; i - 1) &#123; // 这里的第一个测试条件是p-&gt;next是因为下面要引用p-&gt;next,如果测试条件是p的话，下面会报段错误 p = p-&gt;next; j++; &#125; // 待删除结点的位置超出表厂或者为负数 if (!p-&gt;next || j &gt; i - 1) return ERROR; auto q = p-&gt;next; p-&gt;next = q-&gt;next; e = q-&gt;data; free(q); return OK;&#125;/** * @brief 头插法创建单链表 * * @param L * @param n * * 输入 1 2 3 4 5 * 建好的单链表为 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 */void CreateList_L(LinkList &amp;L, int n)&#123; L = (LinkList)malloc(sizeof (LNode)); // 为头节点分配空间 L-&gt;next = NULL; for (int i = 0; i &lt; n; i++) &#123; auto p = (LinkList)malloc(sizeof (LNode)); // 分配新节点 scanf(&quot;%d&quot;, &amp;p-&gt;data); p-&gt;next = L-&gt;next; // 插入 L-&gt;next = p; &#125;&#125;/** * @brief 尾插法创建单链表 * * @param L * @param n * * 输入 1 2 3 4 5 * 建好的单链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 */void CreateList_L_tail(LinkList &amp;L, int n)&#123; L = (LinkList)malloc(sizeof (LNode)); auto r = L; for (int i = 0; i &lt; n; i++) &#123; auto p = (LinkList)malloc(sizeof (LNode)); scanf(&quot;%d&quot;, &amp;p-&gt;data); p-&gt;next = NULL; r-&gt;next = p; r = p; &#125;&#125; 1.3 循环链表 表中最后一个结点的指针域指向第一个节点 typedef struct node&#123; int seqNumber; // 存储每个人的编号 int psd; // 存储每个人的密码 struct node * next;&#125;Node, * NodePtr;typedef struct&#123; NodePtr rear; // 存储循环链表的尾指针 int length;&#125;CirLinkedList;void InitList(CirLinkedList * L)&#123; L-&gt;rear = NULL; L-&gt;length = 0;&#125;inline int empty(const CirLinkedList * L)&#123; return !(L-&gt;length);&#125;void append(CirLinkedList * L, int sq, int psd)&#123; NodePtr p = (NodePtr)malloc(sizeof(Node)); p-&gt;seqNumber = sq; p-&gt;psd = psd; if (empty(L)) &#123; // 不想单链表一样有头节点，因此插入第一个元素时需要特殊处理 L-&gt;rear = p; p-&gt;next = p; &#125; else &#123; p-&gt;next = L-&gt;rear-&gt;next; L-&gt;rear-&gt;next = p; L-&gt;rear = p; &#125; L-&gt;length++;&#125;void CreateList(CirLinkedList * L)&#123; int cnt, psd; printf(&quot;请输入表长:&quot;); scanf(&quot;%d&quot;, &amp;cnt); for (int i = 0; i &lt; cnt; i++) &#123; printf(&quot;请输入元素%d的密码:&quot;, i + 1); scanf(&quot;%d&quot;, &amp;psd); append(L, i + 1, psd); &#125;&#125;void traverse(const CirLinkedList * L)&#123; if (empty(L)) return ; NodePtr p = (L-&gt;rear)-&gt;next; for (int i = 0; i &lt; L-&gt;length + 1; i++) &#123; printf(&quot;%4d &quot;, p-&gt;seqNumber); p = p-&gt;next; &#125; p = L-&gt;rear-&gt;next; printf(&quot;\\n&quot;); for (int i = 0; i &lt; L-&gt;length + 1; i++) &#123; printf(&quot;%4d &quot;, p-&gt;psd); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;void Remove(CirLinkedList * L, NodePtr *p)&#123; NodePtr prev = L-&gt;rear, t = *p; while (prev-&gt;next != (*p)) prev = prev-&gt;next; prev-&gt;next = (*p)-&gt;next; *p = prev; if (t == L-&gt;rear) L-&gt;rear = prev; free(t); L-&gt;length--; if (L-&gt;length == 0) *p = NULL;&#125; 不设头节点，存储尾指针，尾指针指向循环链表的最后一个结点，尾指针的next指向头节点 1.4 双向链表typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior, * next;&#125;DuLNode, * DuLinkList 2. 栈和队列2.1 顺序栈 空栈：S.base == S.Top 栈长：S.Top - S.base 栈满：S.top – S.base &gt;= S.stacksize // 顺序栈的课本典型实现#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;enum &#123;OK, ERROR, OVERFLOW&#125;;typedef int SElemType;typedef int Status;const int STACK_INIT_SIZE = 100;const int STACK_INCREMENT = 10;typedef struct&#123; SElemType * base; SElemType * top; int stacksize;&#125;SqStack;Status InitStack(SqStack &amp;S)&#123; S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof (SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;&#125;Status GetTop(SqStack S, SElemType &amp;e)&#123; if (S.base == S.top) return ERROR; e = *(S.top - 1); return OK;&#125;bool StackEmpty(SqStack S)&#123; if (S.top == S.base) return true; else return false;&#125;Status Push(SqStack &amp;S, SElemType e)&#123; // 处理栈满的情况 栈的有效范围是 0 ~ stacksize - 1 if (S.top == S.base + S.stacksize) &#123; // S.base + S.stacksize 刚好是尾后指针 S.base = (SElemType *)realloc(S.base, (S.stacksize + STACK_INCREMENT) * sizeof(SElemType)); if (!S.base) exit(OVERFLOW); S.top = S.base + S.stacksize; S.stacksize += STACK_INCREMENT; &#125; *(S.top++) = e; return OK;&#125;Status Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top == S.base) return ERROR; e = *(--S.top); return OK;&#125;int length(const SqStack S)&#123; return S.base - S.top;&#125; 2.2 链栈typedef struct SNode&#123; ElemType data; struct SNode *next;&#125;SNode, *LinkStack;Status Push(LinkStack &amp;S, SElemType e)&#123; //插入元素e为新的栈顶元素 p = (LinkStack)malloc(sizeof(SNode)); if (!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = S-&gt;next; S-&gt;next = p; //头插栈顶元素 return OK;&#125;status Pop(LinkStack &amp;S, SElemType &amp;e)&#123; //若栈不空，则删除栈顶元素，用e返回其值，并返回OK； //否则返回ERROR if(S-&gt;next == NULL) return ERROR; //栈空 p = S-&gt;next; e = p-&gt;data; S-&gt;next = p-&gt;next; free(p); //删除栈顶元素 return OK;&#125; 2.3 栈的应用 数制转换 括号匹配 迷宫问题 表达式求值 2.4 循环队列#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;enum &#123;OK, ERROR, OVERFLOW&#125;;typedef int QElemType;typedef int Status;const int MaxQSize = 100;typedef struct&#123; QElemType * base; int front; // 队头元素的下标 int rear; // 队尾元素的下标&#125;SqQueue; 判断队空：Q.front == Q.rear 判断队满：(Q.rear + 1) % MaxQSize == Q.front 也可以用 变量记录当前队列长度 求队长：(Q.rear - Q.front + MaxQSize) % MaxQSzie Status InitQueue_Sq(SqQueue &amp;Q)&#123; Q.base = (QElemType *)malloc(MaxQSize * sizeof (QElemType)); if (!Q.base) exit (OVERFLOW); Q.front = Q.rear = 0; return OK;&#125;Status EnQueue_Sq(SqQueue &amp;Q, QElemType e)&#123; if ((Q.rear + 1) % MaxQSize == Q.front) return ERROR; Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MaxQSize; return OK;&#125;Status DeQueue_Sq(SqQueue &amp;Q, QElemType &amp;e)&#123; if (Q.rear == Q.front) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MaxQSize; return OK;&#125;int length(const SqQueue Q)&#123; return (Q.rear - Q.front + MaxQSize) % MaxQSize;&#125; 2.5 链队列#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;enum &#123;OK, ERROR, OVERFLOW&#125;;typedef int QElemType;typedef int Status;typedef struct QNode&#123; QElemType data; struct QNode * next;&#125;QNode, * QueuePtr;typedef struct &#123; QueuePtr front; QueuePtr rear;&#125;LinkQueue;Status InitQueue(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if (!Q.front) exit(OVERFLOW); Q.front-&gt;next = NULL; return OK;&#125;Status EnQueue(LinkQueue &amp;Q, QElemType e)&#123; auto p = (QueuePtr)malloc(sizeof(QNode)); if (!p) exit (OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; // 尾插入到rear Q.rear-&gt;next = p; Q.rear = p; return OK;&#125;Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123; if (Q.front == Q.rear) return ERROR; auto p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; // 需要特判只有一个元素的时候，此时被释放的结点为rear,必须改变rear的指向，是指与front相同 if (Q.rear == p) Q.rear = Q.front; free(p); return OK;&#125;Status DestroyQueue(LinkQueue &amp;Q)&#123; while (Q.front) &#123; Q.rear = Q.front-&gt;next; free(Q.front); Q.front = Q.rear; &#125; return OK;&#125; 3. 树树的度：结点拥有的子树个数 叶子节点或终端结点：度为0的结点 层次：树的根为第一层，根的孩子为第二层 深度：树中结点的最大层次。 3.1 二叉树的性质 二叉树的第i层至多有2^i-1^ 个结点 深度为k的二叉树至多有2^k^ -1个结点 对任何一棵二叉树，若它含有n0 个叶子结点、n2 个度（出度）为 2 的结点，则必存在关系式：n0 &#x3D; n2+1。 推论：适用于Huffman树 对于有n0 个结点的Huffman树，它的总结点数为n0 + n2 &#x3D; 2n0 -1 具有n个结点的完全二叉树的深度为 floor(log2 n) + 1 ceil()向上取整，floor向下取整 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点： 若 i &#x3D; 1，则该结点是二叉树的根，无双亲， 否则，编号为floor(i/2) 的结点为其双亲结点； 若 2i &gt; n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点； 若 2i+1 &gt; n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。 具有n个结点的完全二叉树有ceil(n/2)个叶子结点 完全二叉树最后一个非终端结点的编号为floor(n/2) 3.2 二叉树的链式存储typedef char ElemType;typedef struct Node&#123; ElemType val; struct Node *left = nullptr; struct Node *right = nullptr;&#125; *Tree, Node;const int MaxNodeCnt = 100;// 按先序遍历顺序创建二叉树void CreateTree(Tree &amp;T)&#123; char ch = getchar(); if (ch == &#x27;#&#x27;) T = nullptr; else &#123; T = new Node; T-&gt;val = ch; CreateTree(T-&gt;left); CreateTree(T-&gt;right); &#125;&#125; 3.3 二叉树的遍历void PreorderTraverse(const Tree T)&#123; if (T) &#123; cout &lt;&lt; T-&gt;val &lt;&lt; &quot; &quot;; PreorderTraverse(T-&gt;left); PreorderTraverse(T-&gt;right); &#125;&#125;void InorderTraverse(const Tree T)&#123; if (T) &#123; InorderTraverse(T-&gt;left); cout &lt;&lt; T-&gt;val &lt;&lt; &quot; &quot;; InorderTraverse(T-&gt;right); &#125;&#125;void PostorderTraverse(const Tree T)&#123; if (T) &#123; PostorderTraverse(T-&gt;left); PostorderTraverse(T-&gt;right); cout &lt;&lt; T-&gt;val &lt;&lt; &quot; &quot;; &#125;&#125;// 层次遍历void BFS(const Tree T)&#123; using myqueue::queue; if (!T) return ; queue&lt;Tree&gt; Q; Q.push(T); while (!Q.empty()) &#123; Tree t = Q.front(); Q.pop(); cout &lt;&lt; t-&gt;val &lt;&lt; &quot; &quot;; if (t-&gt;left) Q.push(t-&gt;left); if (t-&gt;right) Q.push(t-&gt;right); &#125;&#125; 先序遍历非递归思路： 从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，访问所遇结点，并依次把所遇结点进栈，当左子树为空时，从栈顶退出某结点，并将指针指向该结点的右孩子。如此重复，直到栈为空或指针为空止。 void PreorderTraverseNonRec(const Tree T)&#123; Tree cur = T; Tree stack[MaxNodeCnt]; int top = 0; while (cur != nullptr || top != 0) &#123; if (cur != nullptr) &#123; // 当未走到最左边的结点时，继续向左走，同时访问结点 cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; stack[top++] = cur; cur = cur-&gt;left; &#125; else &#123; // 访问右子树 cur = stack[--top]; cur = cur-&gt;right; &#125; &#125;&#125; 中序非递归思路 从二叉树根结点开始，沿左子树一直走到末端(左孩子为空)为止，在走的过程中，把依次遇到的结点进栈待左子树为空时,从栈中退出结点并访问,然后再转向它的右子树。如此重复，直到栈空或指针为空止。 void InorderTraverseNonRec(const Tree T)&#123; Tree cur = T; Tree stack[MaxNodeCnt]; int top = 0; while (cur != nullptr || top != 0) &#123; if (cur != nullptr) &#123; stack[top++] = cur; cur = cur-&gt;left; &#125; else &#123; cur = stack[--top]; cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; cur = cur-&gt;right; &#125; &#125;&#125; 后序非递归思路 利用栈来实现二叉树的后序遍历要比前序和中序遍历复杂得多，在后序遍历中， 当搜索指针指向某一个结点时，不能马上进行访问，而先要遍历左子树，所以此结点应先进栈保存， 当遍历完它的左子树后，再次回到该结点，还不能访问它， 还需先遍历其右子树,所以该结点还必须再次进栈， 只有等它的右子树遍历完后，再次退栈时，才能访问该结点。 为了区分同一结点的两次进栈，引入一个栈次数的标志，一个元素第一次进栈标志为0，第二次进标志为1，并将标志存入另一个栈中，当从标志栈中退出的元素为1时，访问结点。 void PostorderTraverseNonRec(const Tree T)&#123; Tree stack[MaxNodeCnt]; int cnt[MaxNodeCnt], top = 0, tc; Tree cur = T, tt; while (cur != nullptr || top != 0) &#123; if (cur) &#123; stack[top] = cur; cnt[top++] = 0; cur = cur-&gt;left; &#125; else &#123; tt = stack[top - 1]; tc = cnt[--top]; if (tc) &#123; cout &lt;&lt; tt-&gt;val &lt;&lt; &quot; &quot;; cur = nullptr; &#125; else &#123; stack[top] = tt; cnt[top++] = tc + 1; cur = tt-&gt;right; &#125; &#125; &#125; &#125; 3.4 二叉树遍历的应用 求树的叶子节点个数 求树的深度 复制二叉树 3.5 线索化：可以以线性的方式访问二叉树结构 3.5.1 中序线索树 对于中序线索树，我们约定： 它有两个存储左右子树标记的域，如果左子树的标记为0，那么它存储的是其左孩子，如果左子树的标记为1，那么它存储的是其中序遍历时的直接前驱. 如果右子树的标记为0，它存储的是其右孩子。如果右子树的标记为1，那么它存储的是中序遍历时的直接后继。 求中序线索树的前驱： 如果 左标记为1: 直接返回其左孩子否则: 返回其左子树的最右下的结点 求中序线索树的后继： 如果 右标记为1: 返回其右孩子否则: 返回其右子树的最左下的孩子 遍历中序线索树 // 方法1// 正序遍历for (BiThrTree p = T-&gt;lchild; p != T; p = in_suss(p)) visit(p);// 寻找后继的函数BiThrTree in_succ(BiThrTree p)&#123; if (p-&gt;RTag == 1) return p-&gt;rchild; else &#123; BiThrTree q; for (q = p-&gt;rchild; q-&gt;LTag == 0; q = q-&gt;lchild) ; // 找到右子树的最左下的孩子 return q; &#125;&#125;// 倒序遍历for (BiThrTree p = T-&gt;rchild; p != T; p = in_pre(p)) visit(p);// 寻找前驱BiThrTree in_pre(BiThrTree p)&#123; if (p-&gt;LTag == 1) return p-&gt;lchild; else &#123; BiThrTree q; for (q = p-&gt;lchild; q-&gt;LTag == 0; q = q-&gt;rchild) ; return q; &#125;&#125; // 方法2void InOrderTraverse_Thr(BiThrTree T, void (*Visit)(TElemType e)) &#123; p = T-&gt;lchild; // p = first_node while (p != T) &#123; // 空树或遍历结束时，p==T // case 1: while (p-&gt;LTag==Link) p = p-&gt;lchild; //第一个结点 if(!Visit(p-&gt;data)) return ERROR; // case 2: while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) &#123; p = p-&gt;rchild; Visit(p-&gt;data); // 访问后继结点 &#125; p = p-&gt;rchild; // p进至其右子树根 &#125;&#125; // InOrderTraverse_Thr 建立中序线索树 //全局变量BiTNode *Pre = new BiTNode;//中序线索化带头结点二叉树void InOrderThreading(BiTree &amp;Thrt, BiTree T)&#123; Thrt = new BiTNode; //建立头结点 Thrt-&gt;LTag = 0; //头结点有左孩子，若树非空，则其左孩子为树根 Thrt-&gt;RTag = 1; //头结点右孩子为右线索 Thrt-&gt;right = Thrt; //初始化时右孩子指向自己 if (!T) //如果树为空则左孩子也指向自己 Thrt-&gt;left = Thrt; else &#123; Thrt-&gt;left = T; Pre = Thrt; InThreading(T); // 完成在线索化中未完成的那部分事情 Pre-&gt;right = Thrt; // 最后一个结点的后继指向头节点 Pre-&gt;RTag = 1; Thrt-&gt;right = Pre; // 头节点的右指针为最后一个结点 &#125;&#125;//上一个算法，中序线索化void InThreading(BiTree &amp;T)&#123; if (T) //根节点非空 &#123; InThreading(T-&gt;left); //左子树线索化 if (!T-&gt;left) // T的左孩子为空 &#123; T-&gt;LTag = 1; T-&gt;left = Pre; &#125; else T-&gt;LTag = 0; if (!Pre-&gt;right) // T的右孩子为空 &#123; Pre-&gt;RTag = 1; Pre-&gt;right = T; &#125; else Pre-&gt;RTag = 0; Pre = T; InThreading(T-&gt;right); &#125;&#125; 1.3 一般的树和森林的表示：三种表示法： 父亲表示法（并查集的实现方法） 孩子表示法 孩子表示法（将一般的树或森林转换成二叉树） 让二叉树结点的左孩子指向这个一般的树的第一个孩子，右孩子指向下一个兄弟 1.4 一般的树和森林的遍历：二叉树： 先序遍历 中序遍历 后序遍历 一般的树 先根遍历（先遍历根，再从左到右依次遍历子树） 先序遍历 后根遍历 （遍历一个树的根时，先左到右依次遍历该树的子树）中序遍历 层次遍历 层次遍历 森林 先序遍历（即从左到右对森林中的每一棵树进行先根遍历） 先序遍历 中序遍历（从左到右对森立中的每一棵树进行后根遍历） 中序遍历 1.5 Huffman树 路径长度l：路径上的分支数目 树的带权路径长度WPL &#x3D; 求和(k &#x3D; 1, n) wk lk 4. 图4.1 术语 弧：有向边 网：弧或边带权的图成为有向网或无向网 完全图，有向完全图，稀疏图，稠密图 设图有n个结点，e条边 含有e &#x3D; n(n-1)/2条边的无向图成为完全图 含有e &#x3D; n(n-1) 条弧的有向图成为有向完全图 若边或弧的个数e，e&lt;nlogn 则成为稀疏图，否则成为稠密图 结点的度 &#x3D; 入度 + 出度 简单路径：顶点不重复的路径 简单回路：除起点终点，顶点不重复的回路 图中任意两个顶点之间都有路径可以联通则成为连通图（有向图 &#x2F; 无向图） 无向图中，极大连通子图称为连通分量 有向图中，任意两点都有路径可以连通，即为强连通图，否则，各强连通子图成为强连通分量 有向图的底图连通即为弱连通图 假设一个连通图有 n 个顶点和 e 条边，其中 n-1 条边和 n 个顶点构成一个极小连通子图，称该极小连通子图为此连通图的生成树 4.2 图的遍历void DFS(Graph G, int v) &#123; visited[v] = TRUE; VisitFunc(v); for(auto w : G.Adj) if (!visited[w]) DFS(G, w);&#125; 4.3 最小生成树 Prim算法 取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在待添加的顶点w 和已经在生成树上的顶点v之间必定存在一条边，并且该边的权值在所有连通顶点v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n个顶点为止。 Kruskal算法 具体做法: 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。 4.4 重连通图和关节点 重连通图：若从一个连通图中删去任何一个顶点及其相关联的边，他仍为一个连通图的话，则该连通图为重（双）连通图。 若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为关节点。没有关节点的连通图即为重连通图 如何判断关节点？ 若生成树的根结点，有两个或两个以上的分支，则此顶点(生成树的根)必为关节点； 对生成树上的任意一个“顶点”，若其某棵子树的根或子树中的其它“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点。 4.5 拓扑排序 从有向图中选取一个没有前驱的顶点，并输出之； 从有向图中删去此顶点以及所有以它为尾的弧； 重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。 5. 查找 评价指标 ASL ASL &#x3D; 求和(i&#x3D;1, n) Ci × Pi Ci查找到第i条记录时，K与关键字的比较次数 Pi 查找第i条记录的概率 5.1 顺序查找表 查找成功ASL &#x3D; n(n+1)&#x2F;2 * (1 &#x2F; n) &#x3D; n+1&#x2F;2 查找失败的ASL &#x3D; n+1 平均 &#x3D; (3&#x2F;4)(n+1) 5.2 折半查找 折半查找判定树 查找失败并不会多查找一次 课本上的典型实现： int Search_Bin(SSTable ST, KeyType K)&#123; int low = 1, high = ST.length; int mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (K &lt; ST[mid].key) high = mid - 1; //在左区间继续查找 else if (K &gt; ST[mid].key) low = mid + 1; //在右区间继续查找 else return mid; //查找成功的出口 &#125;//while return 0; //查找失败的出口&#125;//Search_Bin yxc的二分一般实现： bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l;&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125;作者：yxc链接：https://www.acwing.com/blog/content/277/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 5.3 分块索引5.4 二叉排序树 二叉排序树的中序遍历序列是一个有序序列 和折半查找判定树类似，查找失败也不会增加比较次数 二叉排序树的删除 设待删除的结点为p，若p的度为0，直接删除 若p的度为1，则直接用其孩子替换它 若p的度为2，方法1： 将p的右孩子交给其中序前驱，p的左孩子交给其双亲，删除p 用p的中序前驱（后继）替换它，然后删除其中序前驱。 AVL树 插入：四种旋转 删除： 要删除的结点为叶子结点，直接删除它，并自下而上调整AVL树。 要删除的结点只有左孩子，用其左孩子替换该节点，并删除其左孩子。因为AVL树的性质，左右子树高度只差不超过1，因此左孩子一定是叶子结点，这种情况便转换为了第一种情况。 要删除的结点只有右孩子，和只有左孩子的情况相同。 要删除的结点既有左孩子，也有右孩子，此时只需寻找其中序遍历的前驱节点或后继结点，用它们替换该结点，在删除它的中序前驱结点或后继结点，而它的中序前驱后后继必定是叶子结点，该情况也转换为了第一种情况。 5.5 哈希表构造哈希函数的方法： 直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 处理冲突的方法： 开放定址法 Hi = (H(key) + di) mod m - i = 1, 2, 3, ..., k (k &lt;= m - 1) - H(key) hash值 - di 增量序列 - m 哈希表的容量 拉链法 再哈希法 建立公共溢出区法 查找成功失败的ASL 6. 排序 插入排序 直接插入排序 折半插入排序 2路插入排序 希尔排序 交换排序 冒泡排序 快速排序 选择排序 选择排序 堆排序 归并排序 基数排序","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"数字逻辑课程","slug":"数字逻辑课程","date":"2022-08-23T03:44:02.000Z","updated":"2022-12-06T14:09:22.735Z","comments":true,"path":"2022/08/23/数字逻辑课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数字逻辑第一章 逻辑代数基础1.1 布尔代数也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。 · + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。 虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。 · 即合取，可以像乘号一样省略。 逻辑代数公理： 0 - 1 律 A + 0 = AA + 1 = 1A · 0 = 0A · 1 = A 重叠律 A + A = AA · A = A 互补律 A + ┐A = 1A · ┐A = 0 对合律 ┐┐A = A 交换律 结合律 分配律 A · (B + C) = AB + AC 与对或的分配A + BC = (A + B)(A + C) 或对与的分配 1.2 逻辑函数定义: 从n个逻辑变量到01的映射。记为F &#x3D; f(A1, A2, A3 … ) 逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式） 1.2.1 三种表示法： 逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成 真值表 卡诺图 用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。 挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。 1.2.2 两种标准形式最小项表达式：也叫积之和范式 或 主析取范式 最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。 最小项的表示： 对于n个变量而言，可以构成2的n次方个最小项。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。 对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 mi 来表示这个最小项表达式。 Q：为什么要使用1代表原变量，用0代表反变量？ A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi &#x3D; 1，而且这是唯一的。 例如m6 &#x3D; AB┐C，其顺序为110B &#x3D; 6D，令对应的逻辑变量为1或0，则m6 &#x3D; 1 · 1 · (┐0) &#x3D; 1 例如，最小项表达式 AB, 转换成二进制即11，表示为m3。 最小项表达式A┐B，转换成二进制即10，表示为m2。 最小项的性质： 对于任意一个最小项，只有一组变量取值可以使其值为1 任意两个最小项之积为0 n个变量的所有2^n^ 个最小项之和为1 将任意表达式转换为最小项表达式： 利用公式A = A(B + ┐B) 最小项表达式的性质： 性质1：若mi是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi&#x3D;1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。 性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F&#x3D;F1+F2 将包括 F1 和 F2 中的所有最小项， G&#x3D;F1·F2 将包括 F1 和 F2 中的公有最小项。 性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成 思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式 使用归谬法证明 第一次课到此结束 最大项表达式： 也叫和之积范式或主合取范式 定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。 举例： 二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B) 三变量最大项表达式： 最大项表达式的三条性质类似最小项表达式的三条性质： 对于任意一个最大项，只有一组变量取值可使其值为0。 任意两个最大项 Mi 和 Mj 之和必为1。 n 变量的所有2^n^ 个最大项之积必为0。 最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。 任意逻辑表达式转换成最大项表达式： 先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。 类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。 AB + A┐B, 而这种表达式被称为 “与 - 或”表达式 最大项表达式的性质也与最小项表达式类似： 性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi&#x3D;0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F&#x3D;F1+F2将包括F1和F2中的公有最大项， G&#x3D;F1·F2将包括F1和F2中的所有最大项。 性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。 1.2.3 逻辑函数的三种表示法的关系用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。 同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。 从上一节的学习，我们知道逻辑函数有三种表示法： 逻辑表达式 真值表 卡诺图 首先，逻辑表达式形式都可以化成标准形式。 接着我们来看真值表与逻辑表达式的关系（最大&#x2F;小项表达式也是逻辑表达式）： 还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。 最大项表达式与最小项表达式恰恰相反： 最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。 最后我们来看一下卡诺图与真值表的关系： 卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合： ——————————————A B | F——————————————0 0 | 00 1 | 11 0 | 11 1 | 0—————————————— 它是一维的 线性的。 而卡诺图则二维的： 将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。 将项的组合换成数字的组合，我们得到卡诺图的简化形式 需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。 下面给出一个逻辑函数的卡诺图表示的例子： 补充：格雷码 https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 1位格雷码有两个码字 (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 2位格雷码 3位格雷码 4位格雷码 4位自然二进制码 00 000 0000 0000 01 001 0001 0001 11 011 0011 0010 10 010 0010 0011 110 0110 0100 111 0111 0101 101 0101 0110 100 0100 0111 1100 1000 1101 1001 1111 1010 1110 1011 1010 1100 1011 1101 1001 1110 1000 1111 第二次课结束 1.3 主要定理 &amp; 常用公式1.3.1个主要定理德摩根律： 当变量个数较少的时候，可以使用真值表法证明。 当变量较多的时候，使用数学归纳法证明。 香农定理： 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。 注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。 对偶定理: 对偶函数的定义： 将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数 设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) 则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) &#x3D; f (x1, x2, … , xn, 1, 0, ·, 1) 对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。 两个推论： 原函数与其对偶函数互为对偶函数。 两个相等的函数（f &#x3D; g）的对偶函数必定相等（f ‘ &#x3D; g ‘） 自对偶函数：一个函数的对偶函数等于它自己。 展开定理： 两个推理： 展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16 1.3.2 5个常用公式 AB + A┐B &#x3D; A 在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。 A + AB &#x3D; A 在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。 还可以写成ABC + ABCDE &#x3D; ABC A + ┐AB &#x3D; A + B 在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。 ┐C + CE &#x3D; ┐C + E AB + ┐AC + BC &#x3D; AB + ┐AC 包含律 在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。 AB + ┐AC + BCDE &#x3D; AB + ┐AC ┐(A┐B + ┐AB) &#x3D; ┐A┐B + AB 两个变量的异或的反 是 两个变量的同或 上面5个公式的对偶形式也是成立的 1.3.3 异或的性质A ⊕A &#x3D; 0 A⊕┐A &#x3D; 1 A⊕0 &#x3D; A A⊕1 &#x3D; ┐ A 重要 A⊕┐ B &#x3D; A ⊙ B &#x3D; A⊕B⊕1 A⊕B &#x3D; B⊕A 交换律 A⊕(B⊕C) &#x3D; （A⊕B) ⊕C 结合律 A(B⊕C) &#x3D; AB⊕AC 分配律 第三次课到此结束 1.3.4 应用一、转化称其他形式（详见P20） “与或” 表达式转 “或与”表达式 法一：分配律 法二：展开定理 “与或” 表达式 转 “与非 - 与非” 表达式 “与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式 或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可 因此我们的步骤是：两次取反，内层非用德摩根律断开 “与或” 表达式 转 “或非 - 或非” 表达式 “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 二、最大项表达式和最小项表达式的关系 ┐mi &#x3D; Mi 或 mi &#x3D; ┐Mi mi’ &#x3D; Mj，且i + j &#x3D; 2 ** n - 1 原函数 ​ – 变换 –&gt; 最小项表达式 ​ – 一次取反 –&gt; 符号错开，但保持最小项表达式，反函数的最小项表达式 或 或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式 ​ – 二次取反 –&gt; 原函数的最大项表达式（和原函数最小项表达式符号错开） 将最大项表达式或最小项表达式变成对偶函数： 首先将最大项变成最小项，或最小项变成最大项 其次将序号变成互补的序号 1.4 逻辑函数的化简 逻辑函数最简式的定义： 该式中乘积项最少 该式中的乘积项不能再用变量更少的乘积项代替 化简方法: 代数方法 卡诺图法 列表化简法 1.4.1 卡诺图法第四次课到此结束 基本原理：ABC + ┐ABC &#x3D; (A + ┐A)BC &#x3D; BC 反映在卡诺图上，就是相邻的两个格可以构成一个圈。 n变量的卡诺图，任何2^m^ 个标1的相邻单元可以形成一个圈，改圈所代表的乘积项由n-m个变量组成，可以消去m个变量。 名词解释： 蕴含项：最小项，以及2^m^ 个相邻单元所形成的圈组成的项。 素项：不是其他蕴含项子集的蕴含项。 实质素项：包含某一最小项，该最小项只被该素项包含。 化简方法： 作出卡诺图，找出全部素项 找出全部实质素项 若有未被覆盖的最小项，找出一个可以包含该最小项的蕴含项，将其添加到实质素项集合中。 得到的集合，写成代数形式，即是化简结果。 第二章 组合电路的分析2.1 各种门电路或门 与门 非门 与非门 或非门 与或非门 异或门 三态门 三态门真值表： E A F 0 0 0 0 1 1 1 任意 高阻抗 第五次课结束 2.2 门电路的主要参数以及组合电路的分析方法门电路的主要参数： 标称逻辑电平：表示逻辑值01的理想电平 扇入系数：门电路允许的输入端数目 若使用的输入端数目比扇入系数小，则多余的输入端再不改变电路逻辑功能的情况下接高电平或低电平 扇出系数：一个门电路输出端所连接的下一级输入端的个数 平均时延 组合电路的分析方法： 给定组合线路 列写逻辑表达式 列真值表 指出线路的逻辑功能 对线路进行评价和改进 2.3 全加器符号表示： A 被加数 B 加数 Ci-1 低位向高位的进位 S 和 全加器的逻辑符号： S &#x3D; A⊕B⊕Ci-1 ​ &#x3D; ∑(1, 2, 4, 7) C &#x3D; AB+(A⊕B)Ci-1 &#x3D; AB+(A+B)Ci-1 ​ &#x3D; ∑(3, 5, 6, 7) 2.4 译码器几种常见的十进制数在二进制下的编码： 8421码：顾名思义，就是十进制数转直接转换成二进制数（范围是0000-1001） 格雷码：相邻的格雷码只有一个位不同 8421转格雷码：Gi&#x3D;B⊕Bi+1 (i &lt;&#x3D; n-1); Gi &#x3D; Bi (i &#x3D; n) 余三码：8421码+3得到余三码（范围是0011-1100） 十进制数 8421 格雷码 余三码 0 0000 0000 0011 1 0001 0001 0100 2 0010 0011 0101 3 0011 0010 0110 4 0100 0110 0111 5 0101 0111 1000 6 0110 0101 1001 7 0111 0100 1010 8 1000 1100 1011 9 1001 1101 1100 第五次课结束 不同的译码器： 三位译八位译码器（多一译码）：从三位二进制数中，翻译出他们的最小项表达式。 高电平译重：翻译出来的那个最小项的电平是高电平 低电平译重：翻译出来的最小项的电平是低电平 如果使用与非门实现译码器，使用低电平译重可以节省非门 2.5.格雷码转8421码：利用异或的性质，一个逻辑表达式异或同一个逻辑表达式两次，等于原逻辑表达式 已知从8421码到格雷码的转换有： G0 &#x3D; B0 ⊕ B1 G1 &#x3D; B1 ⊕ B2 G2 &#x3D; B2 ⊕ B3 G3 &#x3D; B3 则根据异或的性质 B3 &#x3D; G3 已知 G2 &#x3D; B2 ⊕ B3 已知 G2 &#x3D; B2 ⊕ G3 （2） G3 ⊕ G2 &#x3D; B2 ⊕ G3 ⊕ G3 两边同时异或G3 B2 &#x3D; G2 ⊕ G3 异或的性质，消去两个G3 于是我们有： 从格雷码到8421码： B3 &#x3D; G3 B2 &#x3D; G2 ⊕ G3 B1 &#x3D; G1 ⊕ G2 ⊕ G3 B0 &#x3D; G0 ⊕ G1 ⊕ G2 ⊕ G3 2.6 奇偶校验器分为奇校验和偶校验： 我们有一个n位二进制数和一个校验位p 奇校验：n位二进制数和p中，1的个数是奇数 偶校验：n位二进制数和p中，1的个数是偶数 奇偶校验的原理： n个二进制数异或，如果他们中1的数目是奇数，则结果为1 这个原理可以使用数学归纳法证明 一个逻辑变量异或1等于它的非 一个逻辑变量异或0等于它本身 下面以奇校验为例： 生成校验位: p &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ 1 校验 is_valid &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ P 偶校验 p &#x3D; B8 ⊕B4 ⊕B2 ⊕B1 校验 is_valid &#x3D; B8 ⊕B4 ⊕B2 ⊕B1⊕p⊕1 第三章 组合线路的设计设计流程： 确定逻辑功能 列真值表（也就得到了最小项表达式） 根据卡诺图化简逻辑表达式 按照设计要求变换逻辑表达式 考虑工程问题 3.1 逻辑函数的变换与或变与非： 两次取反，中间DM断开 对F的反函数，三次取反（可以理解为四次取反，怎样好用用那个） 与或非： 两次取反，不断开 对反函数一次取反 或非 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 首先将原函数转换成其对偶函数，再将对偶函数化成最小项表达式，两次取反转换成与非形式 在进行一次对偶，变回原函数，得到或非形式 第六次课结束 3.2 利用任意项的线路设计任意项定义：是的约束方程推的逻辑值为0的最小项，也称无关项。 任意项再当前约束条件下的逻辑值必定为0，因此我们将任意项和原函数进行或运算，不影响原函数的取值。 任意项在卡诺图或真值表中，用φ表示，将它在卡诺图中画出来可以方便形成更大的圈，从而简化得到的逻辑表达式。但我们使用真值表化简带有任意项的逻辑函数时，不必考虑任意项是否被圈全部包含，只需要考虑逻辑函数的最小项。 3.3 多输出函数的线路设计（需要考虑共享项）当我们有多个逻辑函数，共享输入时，我们需要从全局出发考虑，看是否有可以共享的项目，从而减少要使用的逻辑器件。 考虑共享项的最小覆盖修改原则： 若Fi的一个素项Bk也是Fj的一个素项，则Bk不作修改，除非修改后能减少总圈数。 若Bi、Bj分别是Fi、Fj的素项，且Bi、Bj都包含一个蕴涵项Bk,在选取Bk后，Bi、Bj中余下的最小项均分别包含在Fi、Fj其它素项中，则在Fi、Fj中改选Bk 示例： Fi的一个素项Bi，中的一些最小项分别被Fj, Fj+1, … , Fj+m中的素项Bj, Bj+1 , … , Bj+m覆盖，且Bj, Bj+1, … , Bj+m ⊆ B, 若在Fi中选取Bj,Bj+1, …, Bj+m 后，Bi中余下的最小项均包含在的其它素项中，则将Bi改选为Bj, Bj+1, …, Bj+m 示例： 第七次课到此结束 3.4 应用MSI功能块的组合线路设计SSI：小规模集成电路 MSI：中规模集成电路 利用数据多路选择器进行设计 首先要知道数据多路选择器的原理 f &#x3D; a0┐x0┐x1 + a1┐x0x1 + a2x0┐x1 + a3x0x1 设计步骤： 首先，对于给定n变量的逻辑函数，我们选择N &#x3D; 2^n-1^ 路数据选择器 选定n-1个变量作为地址输入，作为数据选择器的控制端，根据选择的地址输入，确定数据选择器输入端的各表达式输入 对于如何确定数据选择器输入端的各表达式，我们可以使用代数方法得到，也可以使用卡诺图方法得到。 利用译码器进行线路设计 将对应逻辑表达式转换为最小项表达式，直接将译码出来的最小项用或门连接（高电平译中）或用与非门连接（低电平译中），输出即可。 第八次课到此结束 第四章 时序电路的分析4.1 触发器的外特性4.1.1 基本触发器基本触发器通过其电路的设计，可以具有存储二进制位的功能，其电路就是存储器，而不是有单独的存储器。 基本触发器有两个稳态，分别表示0和1。当基本触发器（RD ，SD）输入 1，1时，基本触发器里存储的位被保持输出，当输入0，1时，基本触发器被置零，当输入1，0时，基本触发器被置一，当输入0，0时不能确定输出的是当前存储的状态，还是其他状态。因此不能输入0。 基本触发器的RD 和SD 端都是低电平有效，R端是Reset重置，置零端，S端是Set，置一端。 基本触发器的特征表达式 ┐RD┐ SD &#x3D; 0 (RD 和SD 不能同时为0) Q^n+1^ &#x3D; ┐SD + RD Q 4.1.2 RS触发器 电位触发，高电位时触发 五个输入端，RD , SD ，R, S, CP CP只有在为1时才有效，CP为0时保持。 特征方程： Q^n+1^ &#x3D; S + ┐RQ 4.1.3 D 触发器 边缘触发器，正跳变触发 关于电位触发和边缘触发： 边缘触发：输出不能迟于触发信号到达，但触发信号已到达，输入信号就可以撤下来 电位触发：输入信号可以迟于触发电位到达，但在触发电位变回非触发电位前，输入信号不能改变 Q^n+1^ &#x3D; D 4.1.4 JK 触发器 边缘触发器，负跳变触发 Q^n+1^ &#x3D; J ┐Q^n^ + ┐K Q^n^ 当J，K同为0时，输出Q 当J，K同为1时，输出┐Q 当J，K相异时，输出 J 4.1.5 T触发器 边缘触发器，负跳变触发 Q^n+1^ &#x3D; T┐Q^n^ + ┐TQ^n^ 当T为0时，输出Q 当T为1时，输出┐Q 第九次课到此结束 4.2 时序电路的分析方法 列些输出函数和控制函数表达式 输出函数：线路的外输出函数（z） 控制函数：向存储元件的输入 建立次态表达式及状态转移表 建立状态表及状态图 画波形图（optional） 说明时序线路的功能 异步电路分析： 写出输出函数和控制函数和每个触发器的CP端 建立次态表达式，次态表达式要将CP写进去，注意，不同触发器CP为一的条件不同 建立状态转移，如果输入信号是脉冲信号，那么输入信号为一代表打一个脉冲，而非输入信号恒唯一。 建立状态表和状态图 画波形图 说明时序电路功能 第十&amp;十一次课到此结束 4.3 同步时序电路的设计同步时序电路设计的一般步骤： 根据问题的描述，建立原始的状态表 使用隐含表法（下三角矩阵）化简原始状态表 对最简状态表进行编码，建立编码状态表 画出真值表（包括外部输入，现态，次态，控制函数，输出） 根据真值表写出触发器的控制函数 设计组合线路，考虑工程问题 4.3.1 关于状态的化简两个状态可以合并的条件： 在所有不同的输入下，输出均相同且满足以下条件 两个次态完全相同 两个次态为其现态的交错 两个次态的某一后续状态对可以合并 两个次态为状态对封闭链中的一个状态对。 本课程结束","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"BallMove:基于Qt的GUI小项目","slug":"BallMove-基于Qt的GUI小项目","date":"2022-08-21T11:46:01.000Z","updated":"2022-09-29T10:22:02.774Z","comments":true,"path":"2022/08/21/BallMove-基于Qt的GUI小项目/","link":"","permalink":"https://cfla1638.github.io/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"BallMove:基于Qt的GUI小项目简介在暑假学科目二的时候，看着 Qt学习之路2 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。 今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。 这个项目基于QGraphicsScene + QGraphicsItem + QGraphicsView， 模拟了一个小球在现实世界中的运动。 项目地址：cfla1638&#x2F;BallMove 设定功能：实现了实心球的运动。 考虑的因素有： 用户给予的加速度 重力 摩擦力 空气阻力 细节： 该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg &#x2F; m^3^ 。 重力加速度为 9.8 m&#x2F;s^2^ 。 静摩擦系数为 0.3。 空气阻力使用公式：F &#x3D; 1&#x2F;2 * CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 * 0.04^2^ 。 尺寸换算：1m &#x3D; 250px。 基础知识 Qt的绘制系统由QGraphicsScene + QGraphicsItem + QGraphicsView 相互配合使用。 QGraphicsScene 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。 QGraphicsItem 是在QGraphicsScene 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到QGraphicsScene，进行显示和管理。 QGraphicsView 提供了一个观察的视角，配合QGraphicsScene 进行显示。这个类可以被设为QMainWindow 的CentralWidget。 只有QObject 的子类可以使用信号槽的机制 QTimer类提供计时器功能，使用timer.start(sec) 功能开始计时，这里timer是一个QTimer类的一个对象，每经过sec时间后，timer就会发出一个timeout() 信号。 想要实现物体的运动，就要让物体的位置在每一帧里进行改变&#x2F;刷新（本程序的帧率是120），而QGraphicsScene 提供一个advance() 函数，该函数会调用所有在场景里的QGraphicsItem 对象的advance() 函数，因此我们只要每经过 1000 &#x2F; 120 毫秒 就调用一次QGraphicsScene::advance() 函数，就可以进行场景刷新，从而实现物体的运动。 每个QGraphicsItem::advance(int phase) 都会被一个QGraphicsScene::advance() 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase &#x3D; 0。第二次QGraphicsScene::advance() 将phase &#x3D; 1 传入函数并调用。 基于此，我们只需要在phase &#x3D; 1是进行处理，phase &#x3D; 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。 Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在QGraphicsScene 中的全局坐标系，它记录了每个QGraphicsItem 的位置。第二个是每个QGraphicsItem 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。 每个继承了QGraphicsItem 的类都要重载以下四个函数。 QRectF boundingRect() const;QPainterPath shape() const;void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);void advance(int phase); boundingRect() 返回一个包裹住QGraphicsItem 对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。 shape() 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) 该函数一般由QGraphicsScene 自动调用，绘制该项目。 这个函数一般这样写 void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); // 保存画笔状态 //设置新的画笔状态 painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); // 绘制图型 painter-&gt;restore(); // 还原画笔状态&#125; 我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。 painter-&gt;fillPath(shape(), Qt::blue); 这一行绘制我们在shape() 中返回的图型，在此之前我们可以设置画笔的状态。 编写头文件的建议 如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。 为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。 即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。 项目设计首先来看一下运行效果： 在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象另外，这棵树也为我们展示了本项目的设计思路。└─MainWindow ├─Controller │ ├─Ball │ ├─Balldata │ ├─Ground │ └─QGraphicsScene - Reference ├─QGraphicsScene └─QGraphicsView 自下而上，首先来看Controller下的三个类， Controller下有三个类，分别是Ball, Balldata, Ground，他们都是QGraphicsItem 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。 这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。 值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。 接着是Controller类。 顾名思义，Controller类是我们程序的控制器。 Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。 最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。 当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的QMainWindow::show() 和 QApplication :: exec() 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。 项目实现文件结构首先看一下我们的文件结构 BallMove - BallMove.pro Headers - ball.h - balldata.h - constants.h - controller.h - ground.h - mainwindow.h Sources - ball.cpp - balldata.cpp - controller.cpp - ground.cpp - main.cpp - mainwindow.cpp Ball类的实现首先看一下ball类的实现 class Ball : public QGraphicsItem&#123;public: Ball(qreal x, qreal y); QRectF boundingRect() const; QPainterPath shape() const; void advance(int phase); QPointF getPos()&#123;return pos();&#125; int forceCount = 4; qreal a[2][4]; qreal vx = 0; qreal vy = 0;protected: void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);&#125;; 首先我们来看Ball类的私有变量： 由于我们运动的平面是二维的，因此我们使用一个二维数组qreal a[2][4] 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即a[xAxis][AirResistance] 。如果想要引用y方向的重力加速度，就使用a[yAxis][Gravity] 。 qreal vx, vy 即小球的x方向速度，和y方向的速度。 int forceCount 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。 接着我们来看一下Ball类中声明的函数: 第一个函数getPos()很好理解，即返回小球在全局坐标系中的坐标。 接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：paint() shape() advance() boundingRect() boundingRect : QRectF Ball::boundingRect() const&#123; return QRectF(-BALL_SIZE * 2, -BALL_SIZE * 2, BALL_SIZE * 4, BALL_SIZE * 4); &#125; QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。 BALL_SIZE 定义在constants.h 代表小球的直径。 shape() : QPainterPath Ball::shape() const&#123; QPainterPath path; path.addEllipse(QPointF(0, 0), BALL_SIZE / 2, BALL_SIZE / 2); return path;&#125; 这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。 paint() ： void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); painter-&gt;restore();&#125; 在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。 advance() ： void Ball::advance(int phase)&#123; // 只有phase为1时进行处理 if (!phase) return ; // 计算合力 qreal sumAx = 0, sumAy = 0; for (int i = 0; i &lt; forceCount; i++) &#123; sumAx += a[xAxis][i]; sumAy += a[yAxis][i]; &#125; if (sumAx) vx += (sumAx / FRAME_RATE); if (sumAy) vy += (sumAy / FRAME_RATE); qreal x = fmod(pos().rx() + vx / FRAME_RATE, 1000), y = fmod(pos().ry() + vy / FRAME_RATE, 1000); // 处理小球越界 if (x &lt; 0) x += 1000; if (y &lt; BALL_SIZE / 2) y = BALL_SIZE / 2; // 设置新位置 setPos(QPointF(x, y)); update(); // 更新显示小球&#125; 由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。 在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。 需要注意，一、因为我们的速度、加速度定义为m&#x2F;s和m&#x2F;s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。 二、在设置了小球的位置之后，需要使用update() 函数更新小球的位置。 constants.h 参数存储文件constants.h 文件中存放了项目的各种参数 const int FRAME_RATE = 120; // 帧率：120帧 帧率过低时碰撞会穿透地面const int BALL_SIZE = 20; // 球的直径：20px// 400 对应 112 重力// 3000 对应 2450 重力const int X_SPEED = 1500; // 左右键给球的加速度const int Y_SPEED = 3000; // 上下键给球的加速度const int FRICTION = 735; // 摩擦力大小const int FRICTION_SENSITIVITY = 2; // 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力// 112 对应1.75 米的人// 2450 对应 8cm 的实心球const int GRAVITY = 2450; // 重力大小const double M = 2.1038; // 小球质量enum Directions&#123;xAxis, yAxis&#125;; // x, y轴方向enum Force&#123;User, Gravity, Friction, AirResistance&#125;; // 力的四个维度，用户给出的力，重力，摩擦力，空气阻力 需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。 Balldata &amp; ground这两个类都继承了QGraphicsItem 和Ball类类似，因此我们不在赘述。 Controller类首先看一下Controller类的定义 class Controller : QObject&#123; Q_OBJECTpublic: Controller(QGraphicsScene &amp; scene, QObject * parent = 0); void track(bool); void gravity();public slots: void drawLineOfTrack(); void resume(); void pause(); void advance();protected: bool eventFilter(QObject *atched, QEvent *event);private: void handleKeyPressed(QKeyEvent * event); void handleKeyReleased(QKeyEvent * event); QTimer timer; Ball * ball; QGraphicsScene &amp; scene; Ground * ground; ballData * data;&#125;; Controller类有以下几点功能： 处理键盘事件：如上下左右移动，打开&#x2F;关闭 轨迹显示，清屏。 相关地函数有： bool eventFilter(QObject *atched, QEvent *event);void handleKeyPressed(QKeyEvent * event);void handleKeyReleased(QKeyEvent * event); 控制程序的开始与结束 相关地函数有： void resume();void pause(); 控制程序的一步步地推进，即让小球动起来。 相关地函数有： void advance(); 其他功能 相关地函数有： void track(bool);void gravity();void drawLineOfTrack(); 在这里我们只介绍advance() 函数 void Controller::advance()&#123; scene.advance(); // 首先调用场景的advance() // 获取碰撞信息 static bool lastStatus = false; // 上一帧是否碰撞 static bool nowStatus = false; // 当前是否处于碰撞 nowStatus = ball-&gt;collidesWithItem(ground); //处理碰撞 if (nowStatus == true &amp;&amp; lastStatus == false) &#123; ball-&gt;a[yAxis][Gravity] = 0; // 碰撞时重力与支持力抵消 ball-&gt;vy = -(ball-&gt;vy * 0.667); // 回弹 2/3 的速度 ball-&gt;a[yAxis][User] = 0; // 竖直方向速度为0 &#125; // 处理摩擦力 if (nowStatus) &#123; if (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION; else if (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION; else ball-&gt;a[xAxis][Friction] = 0; &#125; // 没有碰撞的时候 if (!nowStatus) &#123; // 摩擦力置零 ball-&gt;a[xAxis][Friction] = 0; ball-&gt;a[yAxis][Gravity] = GRAVITY; &#125; // 处理空气阻力 qreal sumV = pow(ball-&gt;vx, 2) + pow(ball-&gt;vy, 2); if (fabs(sumV) &gt; 10) &#123; qreal airSum = 0.0009744 * sumV / 250; if (sumV == 0) sumV = 1; ball-&gt;a[xAxis][AirResistance] = (fabs(ball-&gt;vx) / (sqrt(sumV))) * airSum; ball-&gt;a[yAxis][AirResistance] = (fabs(ball-&gt;vy) / (sqrt(sumV))) * airSum; // 将力换算成加速度 ball-&gt;a[xAxis][AirResistance] /= M; ball-&gt;a[yAxis][AirResistance] /= M; if (ball-&gt;vx &gt; 5) ball-&gt;a[xAxis][AirResistance] *= -1; else if (ball -&gt; vx &lt; 10) ; else ball-&gt;a[xAxis][AirResistance] = 0; if (ball-&gt;vy &gt; 5) ball-&gt;a[yAxis][AirResistance] *= -1; else if (ball -&gt; vy &lt; 10) ; else ball-&gt;a[yAxis][AirResistance] = 0; &#125; lastStatus = nowStatus; data-&gt;update(); // 更新数据显示&#125; 由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。 等运动结束之后，我们使用Qt地碰撞检测函数collidesWithItem()看小球是否接触地面。 接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。 其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。 MainWindow 类MainWindow类的代码如下 class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void adjustViewSize();private: void initScene(); QGraphicsView * view; QGraphicsScene * scene; Controller * controller;&#125;; 唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), scene(new QGraphicsScene(this)), view(new QGraphicsView(scene, this)), controller(new Controller(*scene, this))&#123; setCentralWidget(view); resize(750, 750); initScene(); QTimer::singleShot(0, this, SLOT(adjustViewSize()));&#125; 在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的centralWidget 并调整了窗口大小。 在倒数第二步，调用initScene 对scene进行调整。 以上的这些步骤都不会有什么问题，只有最后一步令人困惑： QTimer::singleShot(0, this, SLOT(adjustViewSize())); 首先解释singleShot() 函数，这个函数的声明如下 void QTimer::singleShot(int msec, const QObject *receiver, const char *member) 它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。 那么为什么要使用这个功能呢？ 这里有两个解释 那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数。这就是为什么我们需要用QTimer而不是直接调用adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的callLater()函数。 这个解释来自《Qt学习之路2》 但我并不清楚这里的 “下一次事件循环” 的意思。 依我的理解，应该是这个意思：某个QObject 发出 paintEvent() 事件，但对这个事件的处理比较耗时，如果此时直接调用adjustViewSize() ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用adjustViewSize() ，我们会发现视图小小的挤在屏幕的中间。 后来我又在网上发现了这篇博客：QTimer::singleShot(0, this, slot函数)； ，意思和我理解的大概相似。 但还是挖个坑，等我以后学精了一定回来解释清楚。 参考C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范 Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World","categories":[{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]},{"title":"配置博客","slug":"配置博客","date":"2022-08-20T14:58:00.000Z","updated":"2022-08-21T12:05:04.405Z","comments":true,"path":"2022/08/20/配置博客/","link":"","permalink":"https://cfla1638.github.io/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"博客配置 &amp; 使用教程简介该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。 本文章记录了配置博客和使用博客的一些细节，供以后的我参考。 持续更新中 …… 工作原理在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。 基本命令 调试： hexo server --debug 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面 修改&#x2F;发布博客 进行更新： hexo clean 清理缓存和public文件夹 hexo g generate，生成静态页面，该操作之后即可在本地预览。 hexo d deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。 发布博客 hexo new [layout] [title] 使用layout，在_post&#x2F;title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。 配置文件 可以在 _config.yml 里配置Hexo，在 _config.nexmoe.yml 里配置nexmoe主题。 _config.yml : 配置 网站的标题、副标题、关键词、作者、语言、时区 部署设置，其中repository可以填ssh的链接（执行git clone 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。 _config.nexmoe.yml： 网站的默认头图，头像，图标等均在这里配置。 如果要使用本地相对路径，./ 的绝对路径即博客根目录下的source文件夹。 front-matter在这里可以配置文件的变量。 hexo 的文档：Front-matter | Hexo nexmoe 的私有 front-matter 文档：Front-matter | Hexo Theme Nexmoe 如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900 --title: &lt;title&gt;others...cover: 图片链接--- 配置分类和标签要像这样配置： categories:- Diarytags:- PS3- Games 其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见这里 widgets 关于 “文件归档”：归档页面 | Hexo Theme Nexmoe 关于 “关于博客”：是./ 目录下的一个markdown文件，与其他博文相同。 其他部件可以在_config.nexmoe.yml 里配置 评论系统nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 Valine ，使用方法非常简单，按照Valine的官方手册一步步操作即可。 资源iconfont-阿里巴巴矢量图标库 参考文档Hexo参考文档 Nexmoe 参考文档 nexmoe GitHub地址 从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"},{"name":"哲学","slug":"哲学","permalink":"https://cfla1638.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"},{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"转载","slug":"转载","permalink":"https://cfla1638.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"cmake","slug":"cmake","permalink":"https://cfla1638.github.io/tags/cmake/"},{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]}