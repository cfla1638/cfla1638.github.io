{"meta":{"title":"cfla's blog","subtitle":"","description":"","author":"cfla","url":"https://cfla1638.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-20T23:36:33.219Z","updated":"2022-08-20T14:43:28.978Z","comments":true,"path":"Archives.html","permalink":"https://cfla1638.github.io/Archives.html","excerpt":"","text":""},{"title":"关于博客","date":"2022-08-20T16:00:00.000Z","updated":"2022-09-02T05:08:53.737Z","comments":true,"path":"about.html","permalink":"https://cfla1638.github.io/about.html","excerpt":"","text":"关于博客建站日期：2022 年 8 月 20 日 About Blog建立一个自己的博客站，最主要的目的是记录自己在计算机这条路上学到的知识。 写下这些内容的时候是大二，在大一时，我看了好多本计算机专业的书，比如《C++ Primer》，《C Primer Plus》。 暑假的时候我学了Qt，用到 C++ 的 OOP 时，我才意识到自己之前学到的知识是不牢固的。刚看完的书，没有经过实践，就是不能变成自己的东西。但我又不能将所有的内容都去实践。因此我决定为看过的计算机类的书籍都写读书笔记，内容主要是看完这本书的感受，学到的东西。就像操作系统切换进程需要保存上下文一样，将对这本书印象最深时的 “上下文” 保存下来，等以后需要的时候能够快速开始。 同样的道理，也适用于刚做完的项目，刚配置好的系统 … 因此，我的博客将记录自己在计算机领域学到过的、实践过的知识 以及 解决问题的经验。 About me 计算机科学与技术专业 内向的、焦虑的、热爱学习、向往未来的 OTAKU"}],"posts":[{"title":"网络编程 - CS:APP 第十一章","slug":"网络编程-CS-APP-第十一章","date":"2022-09-22T09:53:11.000Z","updated":"2022-09-23T05:13:10.865Z","comments":true,"path":"2022/09/22/网络编程-CS-APP-第十一章/","link":"","permalink":"https://cfla1638.github.io/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/","excerpt":"","text":"网络编程客户端和服务器都是进程，而不是机器或主机。 IP地址IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中 struct in_addr &#123; uint32_t s_addr; // 32位IP地址，使用网络字节顺序（大端法）&#125; 由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。 字节顺序和主机顺序的转换： #include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong); // host to netuint16_t htons(uint16_t hostshort); // host to netuint32_t ntohl(uint32_t netlong); // net to hostuint16_t ntohs(uint16_t netshort); // net to host 点分IP地址与32位IP地址的转换： #include &lt;arpa/inet.h&gt;// 点分十进制转换成32位地址/*得到的32位地址也要转换成本地顺序返回：若成功返回1，串非法返回0，错误返回-1*/int inet_pton(AF_INET, const char *src, void *dst);// 32位地址转换成点分十进制/*在使用该函数之前，要将32位IP地址转换成网络顺序把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中返回：若成功返回指向点分十进制地址的指针，出错返回NULL*/int char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size); 附 1. // 将十六进制字符串转换成十进制数：使用sscanf(str, &quot;%x&quot;, &amp;num) 使用32位IP地址时，可以直接使用in_addr结构而不是in_addr结构里的s_addr 套接字是一组绝大多数操作系统都定义的函数，可以实现网络应用。 套接字地址结构 // 这两个结构体所占字节数相同，可以互相转换struct sockaddr_in &#123; uint16_t sin_family; // 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6) uint16_t sin_port; // 端口号，使用网络字节顺序 struct in_addr sin_addr; // IP地址结构 unsigned char sin_zero[8]; // 填充0，为了满足struct sockaddr的大小&#125;; // 这个结构体一共占16个字节struct sockaddr &#123; uint16_t sa_family; char sa_data[14];&#125;typedef struct sockaddr SA; socket() 通用#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);/*使套接字称为一个连接的结点返回一个还不能用于读写的描述符*/// 使称为一个连接点clientfd = socket(AF_INET, SOCK_STREAM, 0); connect() 客户端#include &lt;sys/socket.h&gt;int connect(int clientfd, const struct sockaddr * addr, socklen_t addrlen);/*客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ bind() 服务器#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);/*将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ listen() 服务器#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);/*该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024成功返回0， 出错返回-1*/ accept() 服务器#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen);/*成功返回非负连接描述符， 出错返回-1*/ 建立连接服务器： 调用socket()，创建连接结点 调用bind() 成为一个服务器套接字 调用listen() 转换成监听描述符 调用accept() ，阻塞程序，等待客户端连接，返回连接描述符 客户端： 调用socket()，创建连接结点 调用connect()， 连接服务器 套接字地址和主机名服务名的转换首先了解，域名和IP地址是等价的，服务名和端口号是等价的 例如localhost和127.0.0.1是等价的，http和80是等价的 从 字符串主机名服务名信息 到 二进制套接字地址信息 为什么要使用这个函数？ 域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。 #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;/*host: 域名或点分十进制IP地址service: 服务名或端口号hints: 可选 传递设置result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构*/int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);// 释放返回的链表void freeaddrinfo(struct addrinfo, *result);// 将错误代码转换成错误信息const char *gai_strerror(int errcode); getaddrinfo 使用的结构 struct addrinfo &#123; int ai_flags; int ai_family; int ai_socktype; int ai_protocol; char *ai_canonname; size_t ai_addrlen; struct sockaddr *ai_addr; struct addrinfo *ai_next;&#125; 从 二进制套接字地址信息 到 字符串主机名服务名信息#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *service, size_t servlen, int flags); 辅助简化函数int open_clientfd(char *hostname, char *port) &#123; int clientfd, rc; struct addrinfo hints, *listp, *p; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Open a connection */ hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */ hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */ if ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (%s:%s): %s\\n&quot;, hostname, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can successfully connect to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Connect to the server */ if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -1) break; /* Success */ if (close(clientfd) &lt; 0) &#123; /* Connect failed, try another */ //line:netp:openclientfd:closefd fprintf(stderr, &quot;open_clientfd: close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* All connects failed */ return -1; else /* The last connect succeeded */ return clientfd;&#125; int open_listenfd(char *port) &#123; struct addrinfo hints, *listp, *p; int listenfd, rc, optval=1; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Accept connections */ hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */ hints.ai_flags |= AI_NUMERICSERV; /* ... using port number */ if ((rc = getaddrinfo(NULL, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (port %s): %s\\n&quot;, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can bind to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Eliminates &quot;Address already in use&quot; error from bind */ setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, //line:netp:csapp:setsockopt (const void *)&amp;optval , sizeof(int)); /* Bind the descriptor to the address */ if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0) break; /* Success */ if (close(listenfd) &lt; 0) &#123; /* Bind failed, try the next */ fprintf(stderr, &quot;open_listenfd close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* No address worked */ return -1; /* Make it a listening socket ready to accept connection requests */ if (listen(listenfd, LISTENQ) &lt; 0) &#123; close(listenfd); return -1; &#125; return listenfd;&#125; 例子// echoclient.c#include &lt;csapp.h&gt;int main(int argc, char *argv[])&#123; int clientfd; char *host, *port, buf[MAXLINE]; rio_t rio; if (argc != 3) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; host = argv[1]; port = argv[2]; clientfd = Open_clientfd(host, port); Rio_readinitb(&amp;rio, clientfd); while (Fgets(buf, MAXLINE, stdin) != NULL) &#123; Rio_writen(clientfd, buf, strlen(buf)); Rio_readlineb(&amp;rio, buf, MAXLINE); Fputs(buf, stdout); &#125; Close(clientfd); exit(0);&#125; // echoserver.c#include &lt;csapp.h&gt;void echo(int connfd)&#123; size_t n; char buf[MAXLINE]; rio_t rio; Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; printf(&quot;server received %d bytes\\n&quot;, (int)n); printf(&quot;Received:%s\\n&quot;, buf); Rio_writen(connfd, buf, n); &#125;&#125;int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if (argc != 2) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, 0); printf(&quot;connected to (%s, %s)\\n&quot;, client_hostname, client_port); echo(connfd); Close(connfd); &#125; exit(0);&#125; 术语索引protocol family 协议簇：一组相关联的协议","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"系统级I/O - CS:APP 第十章","slug":"系统级I-O-CS-APP-第十章","date":"2022-09-20T07:18:55.000Z","updated":"2022-09-20T11:48:52.513Z","comments":true,"path":"2022/09/20/系统级I-O-CS-APP-第十章/","link":"","permalink":"https://cfla1638.github.io/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"系统级I&#x2F;OLinux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。 在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。 文件描述符 定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。 Linux Shell 创建的进程会打开三个文件： 0：标准输入；也可以使用定义在unistd.h 中的STDIN_FILENO 来显示表述 1：标准输出；STDOUT_FILENO 2：标准错误；STDERR_FILENO EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;&#x3D; m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。 文件类型 普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。 目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是. 和.. 分别代表自己和上层目录。 套接字 socket ：用来和其他进程进行跨网络通信的文件。 系统级IO函数#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;// 打开和关闭文件int open(char * filename, int flags, mode_t mode);/*flags: 文件的打开方式O_RDONLY 只读O_WRONLY 只写O_RDWR 可读可写O_CREAT 如果文件不存在，创建O_TRUNC 如果文件已存在，截断它（即覆盖原文件）O_APPEND 添加到文件末尾不同的flag可以使用管道符| 连接使用 mode:一般为0*/int close(int fd);// 读写ssize_t read(int fd, void *buf, size_t n);// 返回值：若成功返回-1，EOF返回0，出错返回-1ssize_t write(int fd, const void *buf, size_t n);// 返回值：若成功返回写的字节数，出错返回-1 ssize_t ：signed size type read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n 可能会返回不足值得情况： 读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。 从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。 读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。 RIO包函数RIO(Robust I&#x2F;O)：用于网络编程中，会自动处理不足值的情况。 总览：// 不带缓冲区的版本ssize_t rio_readn(int fd, void *usrbuf, size_t n); // 代替readssize_t rio_writen(int fd, void *usrbuf, size_t n); // 代替write// 带缓冲区的版本void rio_readinitb(rio_t *rp, int fd);ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n); // 带缓冲区的rio_readn 带缓冲区和不带缓冲区的优劣： 带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。 不带缓冲区：比较快速，方便在网络上进行数据传输（臆断） 不带缓冲区的函数rio_readn()用来代替read 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。 ssize_t rio_readn(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被读取的字节 ssize_t nread; // 单次调用read 函数所读取的字节 char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; // read 函数发生错误 if (errno == EINTR) // interrupted by a sig handler return nread = 0; // call read again else return -1; // unknown error &#125; else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft; // 这个程序读取的所有字节&#125; rio_writen()用来代替write 的函数，无缓冲区，绝对不可能返回不足值 ssize_t rio_writen(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被写入的字节 ssize_t nwritten; // 单词write函数写入的字节 char *bufp = usrbuf; // 下一个将被写入的位置 while (nleft &gt; 0) &#123; if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) &#123; if (errno == EINTR) // 被一个信号处理程序返回打断 nwritten = 0; else return -1; // 未知错误 &#125; nleft -= nwritten; bufp += nwritten; &#125; return n;&#125; 带缓冲区的函数缓冲区的代码 #define RIO_BUFSIZE 8192 // 缓冲区的大小typedef struct&#123; int rio_fd; // 与缓冲区关联的文件描述符 int rio_cnt; // 缓冲区中的未读字节数 char *rio_bufptr; // 下一个未读字节地址 char rio_buf[RIO_BUFSIZE]; // 缓冲区&#125;rio_t; 初始化缓冲区 void rio_ rio_read()带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数 该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。 该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。 static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)&#123; int cnt; // 本次调用函数读取的字节数 while (rp-&gt;rio_cnt &lt;= 0) &#123; // 如果缓冲区为空，重新填满缓冲区 rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf)); if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno != EINTR) // 被信号打断，自动重启 return -1; // 未知错误 &#125; else if (rp-&gt;rio_cnt == 0) return 0; // EOF else rp-&gt;rio_bufptr = rp-&gt;rio_buf; // 重置bufptr &#125; cnt = n; if (rp-&gt;rio_cnt &lt; n) // 缓冲区字节数不够 cnt = rp-&gt;rio_cnt; // 返回不足值 memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125; rio_readlineb()读取一行，最多读取maxlen-1个字节，最后一个字节要填充&#39;\\0&#39; ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)&#123; int n, rc; // n 程序读取字节数， rc 单次rio_read 的返回值 char c, *bufp = usrbuf; // c一个临时变量，用于逐个读取，测试是否为换行 for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = rio_read(rp, &amp;c, 1)) == 1) &#123; // 正常 *bufp++ = c; if (c == &#x27;\\n&#x27;) &#123; n++; break; &#125; &#125; else if (rc == 0) &#123; // 返回不足值 if (n == 1) return 0; // EOF，什么字节也没读取，直接返回0 else break; // EOF, 但已经读取了一些字节，需要处理后返回 &#125; else return -1; // 未知错误 &#125; *bufp = 0; // 最后一位用 &#x27;\\0&#x27; 填充 return n - 1;&#125; rio_readnb()rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同 ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)&#123; size_t nleft = n; // bytes that has not been read ssize_t nread; // read() func had read nread bytes char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = rio_read(rp, bufp, nleft)) &lt; 0) // someting wrong return -1; // unknown error else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft;&#125; 读取文件元数据#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *filename, struct stat *buf);int fstat(int fd, struct stat *buf); stat() 函数以文件名作为输入，填写struct stat *buf 我们只对struct stat 的一些条目感兴趣： buf-&gt;st_size 文件的大小 buf-&gt;st_mode 使用在sys/stat.h 的三个宏可以判断文件类型： S_ISREG(mode) 这是一个普通文件吗？ S_ISDIR(mode) 这是一个目录文件吗？ S_ISSOCK(mode) 这是一个网络套接字吗？ 读取目录#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);#include &lt;dirent.h&gt;struct dirent * readdir(DIR *dirp);struct dirent &#123; ino_t d_ino; // inode number 文件位置 char d_name[256]; // Filename 文件名&#125; IO重定位#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);/*复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd*/","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章","slug":"虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章","date":"2022-09-17T03:03:22.000Z","updated":"2022-09-17T03:27:16.949Z","comments":true,"path":"2022/09/17/虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章/","link":"","permalink":"https://cfla1638.github.io/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"虚拟内存视角下的Linux进程 &amp; 动态内存分配Linux的虚拟内存系统Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分： 进程虚拟内存部分 内核虚拟内存部分 进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是： 用户栈 %rsp → 共享库的内存映射区域 brk → 运行时的堆（通过malloc分配的） 未初始化的数据(.bss) 已初始化的数据(.data) 0x400000 → 代码(.text) 内核虚拟内存可分为两部分： 内核中的代码和数据及数据结构 被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置） 与进程相关的数据结构（页表、task和mm结构、内核栈） 每个进程都不相同 物理内存 每个进程都相同 内核代码和数据 每个进程都相同 Linux如何组织虚拟内存Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段 这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap） 用户级内存映射Linux 可以使用mmap函数来创建新的虚拟内存，并将对象映射到这些区域中 #include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);/*将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域prot:PROT_EXEC 该页面的区域可以被执行PROT_READ 该页面区域可读PROT_WRITE ... 可写PROT_NONE ... 不能被访问flags:MAP_ANON 被映射的对象是一个匿名对象MAP_PRIVATE 是一个私有对象，使用写时复制机制MAP_SHARE 是一个共享对象*/int munmap(void *start, size_t length); // 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误 例子：将任意磁盘文件赋值到stdout #include &lt;csapp.h&gt;void mmapcopy(int fd, int size)&#123; char *bufp; // load to virtual memory bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0); Write(STDOUT_FILENO, bufp, size); // write to stdout return ;&#125;int main(int argc, char *argv[])&#123; struct stat stat; int fd; if (argc != 2) &#123; printf(&quot;usage: %s &lt;filename&gt;\\n&quot;, argv[0]); exit(0); &#125; // open file fd = Open(argv[1], O_RDONLY, 0); fstat(fd, &amp;stat); // get detailed message of file mmapcopy(fd, stat.st_size); // call mmapcopy exit(0);&#125;","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"异常控制流 - CS:APP 第8章","slug":"异常控制流-CS-APP-第8章","date":"2022-09-12T01:48:49.000Z","updated":"2022-09-17T02:17:00.344Z","comments":true,"path":"2022/09/12/异常控制流-CS-APP-第8章/","link":"","permalink":"https://cfla1638.github.io/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/","excerpt":"","text":"异常控制流 这一章更多的是实践，理论的部分实在不多 本文将介绍： 常见的异常 (Linux)部分并发编程 一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。 异常及其分类 中断 (interrupt) : 异步发生，是来自处理器外部I&#x2F;O设备的信号的结果 陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过syscall 指令，造成一个到异常处理程序的陷阱。 系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式 故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页 终止 (abort)：不可恢复的错误。 Linux 进程进程的定义：一个执行中的程序实例 进程提供给程序两个抽象的概念： 一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。 区分并发和并行： 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 获取进程id #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 在linux上，pid_t 被定义为 intpid_t getpid(void); // 获取当前进程pidpid_t getppid(void); // 获得父进程pid 进程只有三种状态： 运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。 暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。) 终止。进程永远地停止了。进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程 从主程序返回 调用exit函数。 创建进程： #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);/*该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）子进程与父进程的虚拟地址空间相同，文件描述符相同该函数返回两次：在父进程中返回创建子进程的pid在子进程中返回0可以依此区分两个进程*/ 回收僵死进程: #include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *statusp, int options);/*pid 等待集合 pid &gt; 0 一个单独的子进程 pid = -1 父进程的所有子进程 statusp 导致返回的状态信息options 选项return :成功回收：回收进程的pidWNOHANG 返回0其他错误 -1 (例如没有子进程)：如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR典型用法：waitpid(-1, NULL, 0);挂起该进程，等待该进程的子进程终止，回收该僵死进程*/pid_t wait(int *statusp); // 等价于waitpid(-1, &amp;statusp, 0); 让进程休眠： #include &lt;unistd.h&gt;unsigned int sleep(unsigned int secs); // 挂起进程secs秒，如果因为信号中断则会提前返回int pause(void); // 挂起进程，因为进程中断会提前返回 加载并运行程序 #include &lt;unistd.h&gt;// filename 可执行文件路径，argv参数列表，envp环境变量int execve(const char *filename, const char *argv[], const char *envp[]);/*execve调用一次，从不返回，除非找不到可执行文件文件argv/envp 指向以NULL结尾的指针数组特别强调：通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码*/ 信号信号是一种软件层次的异常 发送信号的两个原因： 内核检测到一个系统事件，如子进程终止，发送SIGCHLD 一个进程显式地调用了kill函数，向某个进程发送了信号 一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此： 当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。 为了能方便向大量进程发送信号，Linux提供了进程组这个概念。 进程组相关： #include &lt;unistd.h&gt;pid_t getpgrp(void); // 获取当前进程的进程组int setpgid(pid_t pid, pid_t pgid); // 设置pid的进程组/*如果pid为0，则设置当前的进程如果pgid为0，则用pid指定的PID作为进程组idsetpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID*/ 发送信号 /bin/kill 程序可以手动发送信号 在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。 kill函数 alarm函数 #include &lt;unistd.h&gt;unsigned int alarm(unsigned int secs);// secs秒后，发送一个SIGALRM信号给调用进程 接受处理信号： #include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler handler);/*signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：1. 如果handler是SG_IGN,那么忽略类型为signum的信号。2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。*/ 阻塞 &amp; 解除阻塞信号： #include &lt;signal.h&gt;int sigprocmask(int how, sigset_t *set, sigset *oldset);int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int setdelset(sigset_t *set, int signum);int sigismember(const sigset_t *set, int signum);/*对于sigprocmask的how，有三个选项：SIG_BLOCK 将set中的信号添加到阻塞集合SIG_UNBLOCK 将set中的信号从阻塞信号中删除SIG_SETMASK 将block = set*/ 非本地跳转 #include &lt;setjmp.h&gt;int setjmp(jmp_buf env);int sigsetjmp(sigjmp_buf env, int savesigs);void longjmp(jmp_buf env, int retval);void siglongjmp(sigjmp_buf env, int retrval); 附：Linux 配置CSAPP库 参考： https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435 https://zhuanlan.zhihu.com/p/76930507 https://blog.csdn.net/jakejohn/article/details/79825086 第三版CSAPP库 代码下载：http://csapp.cs.cmu.edu/3e/code.html 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 术语索引抢占(preempted) 暂时挂起 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 挂起(suspended) 阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"模电课程 - 大学课程","slug":"模电课程-大学课程","date":"2022-09-10T04:17:18.000Z","updated":"2022-09-10T08:12:49.292Z","comments":true,"path":"2022/09/10/模电课程-大学课程/","link":"","permalink":"https://cfla1638.github.io/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"电工学第十四章 半导体器件二极管： 正向压降 ： 正向通过后，电压的减小量。 二极管的功能： 钳位 钳位二极管_百度百科 (baidu.com) 隔离 稳压 ： 见下面稳压二极管视频 补充计算结点电压的结点电压法：第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com) 稳压二极管： 详见视频： https://www.bilibili.com/video/BV1qY4y1t7sc","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"链接 - CS:APP 第七章","slug":"链接-CS-APP-第七章","date":"2022-09-07T11:47:36.000Z","updated":"2022-09-23T04:37:32.473Z","comments":true,"path":"2022/09/07/链接-CS-APP-第七章/","link":"","permalink":"https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"链接本文将介绍： 编译的过程 三种目标文件 三种链接和链接的过程 1 编译的过程 源文件（.c &#x2F;.cpp）经过翻译，形成可重定位目标文件（.o） 具体过程： 预处理 cpp main.c -o main.i 或 gcc -E -o main.c main.c 编译器 ：翻译成汇编语言 cc1 或 cc main.i -o main.s 或 gcc -S -o main.s main.c 汇编器 ：形成可重定位目标文件 as [args] -o main.o 这中间参数很多， 如果向直接到这一步可以使用 gcc -c -o main.o main.c 链接器 链接形成可执行目标文件 ld -o prog main.o other.o 或 gcc -o prog main.o other.o 如果想要一步一步生成.i .s .o 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。 除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 -E -S -c 参数进行编译。 顺带一提，在bash中，可以通过 echo $? 来展示上一次程序退出的返回值 2 三种目标文件首先，什么是目标文件？ 计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。 ——360百科 目标文件可以分为三类： 可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。 可执行目标文件 ： 可以被复制到内存中执行。 共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接 window系统使用PE portable Executable 格式 Linux使用 Executable and Linkable Format, ELF格式 2.1 可重定位目标文件格式 可重定位目标文件 以ELF头开始，通过readelf -a main.o 我们可以看到ELF头的内容 ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12 可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。 我倾向于认为这是节头部表的内容： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1 在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。 一个典型的ELF可重定位目标文件包含下面的节： .text : 已编译的机器代码 .rodata : read only data 只读数据，如printf的格式字符串 .data : 已初始化的全局和静态变量 .bss : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节） .symtab ：符号表 rel.text ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量 .rel.data .debug ：调试信息 .line ：调试时的行号 strtab ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字 2.1.1 符号表符号表的条目格式是这样的 typedef struct &#123; int name; // 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c char type:4, // 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ... binding:4; // 全局变量还是本地变量 GLOBAL OR LOCAL char reserved; // 保留的，未使用 short section; // 在ubuntu 上的名字是Ndx,指明该符号是在那个section的 long value; // 距离节section 起始位置的字节偏移 long size; // 该符号最小的大小&#125; Elf64_Symbol; 对于section 字段，在ubuntu 的readelf 命令中，显示为 Ndx。 该字段有三个伪节，他们分别是 UNDEF COMMON ABS 。 ABS ：代表不改被重定位的符号 UNDEF ：代表未定义的符号，即在本模块引用却在其他模块定义的符号 COMMON ：还未被分配位置的未初始化的数据目标 COMMON 和 .bss 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到COMMON 和.bss COMMON ：未初始化的全局变量 .bss ：未初始化的静态变量，以及初始化为0的全局或静态变量 下面我们通过一个程序来展示以下ubuntu 中的符号表 int sum(int * a, int n);int array[2] = &#123;1, 3&#125;;int global_not_init;int global_init = 1;int global_init_zero = 0;int main()&#123; static int stat_not_init; static int stat_init_zero = 0; static int stat_init = 1; int val = sum(array, 2); return val;&#125; 下面我们生成可重定位的目标文件gcc -c main.c 接着使用readelf -a main.o 读取elf，即可查看符号表 cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.ccfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.oELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific)There are no section groups in this file.本文件中没有程序头。There is no dynamic section in this file.重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000000014 000c00000002 R_X86_64_PC32 0000000000000000 array - 4000000000019 001200000004 R_X86_64_PLT32 0000000000000000 sum - 4重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.Symbol table &#x27;.symtab&#x27; contains 19 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 000000000000000c 4 OBJECT LOCAL DEFAULT 3 stat_init.1921 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 0 SECTION LOCAL DEFAULT 7 10: 0000000000000000 0 SECTION LOCAL DEFAULT 8 11: 0000000000000000 0 SECTION LOCAL DEFAULT 5 12: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 13: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_not_init 14: 0000000000000008 4 OBJECT GLOBAL DEFAULT 3 global_init 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero 16: 0000000000000000 37 FUNC GLOBAL DEFAULT 1 main 17: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 18: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sumNo version information found in this file.Displaying notes found in: .note.gnu.property 所有者 Data size Description GNU 0x00000010 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK 符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量global_not_init 在COMMON 伪节，已经初始化了的全局变量global_init和静态变量stat_init都在.data 节，而初始化为0的全局变量global_init_zero 和没有初始化的静态变量stat_not_init 和初始化为0的静态变量stat_init_zero 在.bss 节 根据这三行的value 字段我们还可以看到这三个变量在.bss 节的存储顺序 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 注意观察两个静态变量多了两个后辍 这样做其实是为了区分在同一个模块中同名的两个静态变量 如下面程序的这个例子 int func_1(int n)&#123; static int x = n + 1; return x;&#125;int func_2(int n)&#123; static int x = n + 2; return x;&#125; 这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。 2.2 可执行目标文件格式下面是典型的ELF 可执行目标文件 在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过readelf 来看一下这个段头部表 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000498 0x0000000000000498 R 0x1000LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x0000000000000205 0x0000000000000205 R E 0x1000LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x0000000000000120 0x0000000000000120 R 0x1000LOAD 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x00000000000001e0 0x00000000000001e8 RW 0x1000 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。 ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。 加载可执行文件： 在shell中输入 ./prog 后： shell调用fork() 函数，创建子进程 子进程调用execve()，execve调用加载器，加载prog程序 加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址) _start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数 2.3 可共享目标文件格式3 三种链接和链接的过程三种链接： 静态链接 动态链接库 程序运行时链接共享库 3.1 静态链接静态链接的两个过程 符号解析 重定位 3.1.1 符号解析链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。 对于局部符号，它不会出现在符号表中。 对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。 唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。 对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。 而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 (在COMMON伪节) 接着使用以下规则来处理这些符号： 不允许有多个同名的强符号 如果一个强符号与多个弱符号同名，选择强符号 若有多个弱符号同名，从这些弱符号中任选一个。 这三个规则很容易造成一些不易察觉的运行时错误。 为什么会有.COMMON伪节？ 如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。 而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节 以上讲的是几个.o 文件的链接，他们都是目标文件 接下来我们讲与静态库的链接，其中会有存档文件 这个概念，注意区别 静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是 .a 在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。 生成静态库： 首先编译：gcc -c addvec.c multvec.c 接着生成静态库：ar rcs libvector.a addvec.o multvec.o 得到静态库 libvector.a，存档文件 (重要) 链接器如何使用静态库来解析引用： 链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。 对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。 注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。 因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。 但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的 如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B 假如有这样的依赖关系： 我们要写成 gcc A.o B.a C.a B.a -o prog 因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。 3.1.2 重定位《深入理解计算机系统》原书第三版 P 478 7.7 3.2 动态链接库静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。 所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。 创建动态库 gcc -shared -fpic -o libvector.so addvec.c multvec.c 与动态库链接： gcc -o prog main.c ./libvector.so 与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。 下面是动态链接库的过程： 一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章) 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 3.3 程序运行时链接共享库可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序： // 7.11 load and link shared library from an application// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int x[2] = &#123;1, 2&#125;;int y[2] = &#123;3, 4&#125;;int z[2];int main(void)&#123; void * handle; // shared lib handle void (*addvec)(int *, int *, int *, int); // point to a function void (*multvec)(int *, int *, int *, int); // point to a function char * error; // point to error massages string // load shared library handle = dlopen(&quot;./libvector.so&quot;, RTLD_LAZY); if (!handle) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; // search the symbol &quot;multvec&quot; from the shared library multvec = dlsym(handle, &quot;multvec&quot;); if ((error = (dlerror())) != NULL) &#123; fprintf(stderr, &quot;%s\\n&quot;, error); exit(1); &#125; // execute the function multvec(x, y, z, 2); printf(&quot;z = [%d %d]\\n&quot;, z[0], z[1]); // unload the shared library if (dlclose(handle) &lt; 0) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; return 0;&#125; 名词索引ELF-64 目标文件格式 PIC(Position-Independent Code) 位置无关代码","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"动态数组,二维数组,指针","slug":"动态数组-二维数组-指针","date":"2022-09-06T12:45:24.000Z","updated":"2022-09-06T12:46:41.480Z","comments":true,"path":"2022/09/06/动态数组-二维数组-指针/","link":"","permalink":"https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/","excerpt":"","text":"动态数组、二维数组、指针本文会讲： 二维数组的存储形式 数组类型为什么会退化？ 二维数组的动态分配 1 二维数组的存储形式以下这个程序可以很好的说明二维数组的存储形式 #include &lt;stdio.h&gt;int main(void)&#123; int a[4][2]; // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = i * 10 + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); return 0;&#125; 这个程序的运行结果是这样的 sizeof(int): 4sizeof(a): 32 sizeof(a[0]): 8 a: 000000000064FDD0&amp;a: 000000000064FDD0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 000000000064FDD0a[1]: 000000000064FDD8a[2]: 000000000064FDE0a[3]: 000000000064FDE8*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 000000000064FDD0&amp;a[1]: 000000000064FDD8&amp;a[2]: 000000000064FDE0&amp;a[3]: 000000000064FDE8&amp;a[0][0]: 000000000064FDD0&amp;a[0][1]: 000000000064FDD4&amp;a[1][0]: 000000000064FDD8&amp;a[1][1]: 000000000064FDDC&amp;a[2][0]: 000000000064FDE0&amp;a[2][1]: 000000000064FDE4&amp;a[3][0]: 000000000064FDE8&amp;a[3][1]: 000000000064FDEC 可以看出，二维数组是连续储存的，有&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0] ，以此类推。 我们可以这样表示二维数组 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 2 数组类型为什么会退化？有的时候会出现这种情况： 在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？ 详见：https://www.zhihu.com/question/464844221/answer/1940453834 3 动态分配二维数组3.1 第一种方法先申请一维数组，在将该一维数组强制转换成二维数组 前置知识： 一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息 二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型， 即int q[][4] 和int (*q)[4] 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于q += 2 * 4 * sizeof(int) 直接贴代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *a = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) a[i] = i; int (*b)[4] = (int (*)[4])a; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, b[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。 我们用int (*b)[4] 声明了一个指向 四个元素的数组 的指针。 然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。 这样动态分配的指针和直接int b[2][4] 是一样的。 下面我们使用 1 中的方法对这个数组进行仔细检查 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; // 初始化数组 int *b = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) b[i] = i; int (*a)[2] = (int (*)[2])b; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]);&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8 sizeof(a[0]): 8 a: 00000000009C1420&amp;a: 000000000064FDF0a[0][0]: 00 a[0][1]: 01 a[1][0]: 02a[1][1]: 03a[2][0]: 04a[2][1]: 05a[3][0]: 06a[3][1]: 07a[0]: 00000000009C1420a[1]: 00000000009C1428a[2]: 00000000009C1430a[3]: 00000000009C1438*a[0]: 0*a[1]: 2*a[2]: 4*a[3]: 6&amp;a[0]: 00000000009C1420&amp;a[1]: 00000000009C1428&amp;a[2]: 00000000009C1430&amp;a[3]: 00000000009C1438&amp;a[0][0]: 00000000009C1420&amp;a[0][1]: 00000000009C1424&amp;a[1][0]: 00000000009C1428&amp;a[1][1]: 00000000009C142C&amp;a[2][0]: 00000000009C1430&amp;a[2][1]: 00000000009C1434&amp;a[3][0]: 00000000009C1438&amp;a[3][1]: 00000000009C143C 可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。 这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 3.2 第二种方法： 参考: https://blog.csdn.net/morewindows/article/details/7664479# 我这里将原文的int 替换成了size_t //C语言中动态的申请二维数组 malloc free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//动态申请二维数组template &lt;typename T&gt;T** malloc_Array2D(int row, int col)&#123; int size = sizeof(T); int point_size = sizeof(T*); //先申请内存，其中point_size * row表示存放row个行指针 T **arr = (T **) malloc(point_size * row + size * row * col); if (arr != NULL) &#123; memset(arr, 0, point_size * row + size * row * col); T *head = (T*)((size_t)arr + point_size * row); // 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好 while (row--) arr[row] = (T*)((size_t)head + row * col * size); &#125; return (T**)arr;&#125;//释放二维数组void free_Aarray2D(void **arr)&#123; if (arr != NULL) free(arr);&#125;int main()&#123; printf(&quot; C语言中动态的申请二维数组 malloc free\\n&quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\\n\\n&quot;); printf(&quot;请输入行列(以空格分开): &quot;); int nRow, nCol; scanf(&quot;%d %d&quot;, &amp;nRow, &amp;nCol); //动态申请连续的二维数组 int **p = malloc_Array2D&lt;int&gt;(nRow, nCol); //为二维数组赋值 int i, j; for (i = 0; i &lt; nRow; i++) for (j = 0; j &lt; nCol; j++) p[i][j] = i + j; //输出二维数组 for (i = 0; i &lt; nRow; i++) &#123; for (j = 0; j &lt; nCol; j++) printf(&quot;%4d &quot;, p[i][j]); putchar(&#x27;\\n&#x27;); &#125; free_Aarray2D((void**)p); return 0;&#125; 这里，原作者对指针的操作让我叹为观止。 但是，用这种方法创作出来的二维数组和直接int b[2][4] 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。 它的具体结构我将在下一小节介绍 3.3 第三种方法 参考：https://blog.csdn.net/houqd2012/article/details/8146070 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(2, 4); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 4; j++) a[i][j] = 10 * i + j; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; free_array2D(a); return 0;&#125; 乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。 我们使用 1 中的程序对这个数组进行详细的检查。代码如下 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(4, 2); // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = 10 * i + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); free_array2D(a); return 0;&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8sizeof(a[0]): 8a: 0000000000701420&amp;a: 000000000064FDF0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 0000000000701450a[1]: 0000000000701458a[2]: 0000000000701460a[3]: 0000000000701468*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 0000000000701420&amp;a[1]: 0000000000701428&amp;a[2]: 0000000000701430&amp;a[3]: 0000000000701438&amp;a[0][0]: 0000000000701450&amp;a[0][1]: 0000000000701454&amp;a[1][0]: 0000000000701458&amp;a[1][1]: 000000000070145C&amp;a[2][0]: 0000000000701460&amp;a[2][1]: 0000000000701464&amp;a[3][0]: 0000000000701468&amp;a[3][1]: 000000000070146C 从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接int b[2][4] 得到的二维数组，还是不一样的。 它的具体结构我将在下一小节介绍 3.4 总结 ： 下标运算符首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。 下标运算符是左结合的，我们引用二维数组，通常是这样的 arr[i][j] 但其实也可以这样 (arr[i])[j] 这两种形式是等价的。 下面我们详细地描述下标运算符 ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType)) 可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型int **, 也可以是数组类型 int (*)[]，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。 首先我们来看内置的数组类型 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 一个内置数组类型表示为int a[5][5] ，但拎出来a，他的类型是 int (*)[5] 所以arr[1] 其实是指a[1][0] 这个位置。a[1] 的类型是int * 所以(a[1])[1] 的类型就是int 接下来我们看动态分配二维数组的第一种方法： 这种方法一开始申请了一个一维数组int *a = (int *)malloc(2 * 4 * sizeof(int)) a的类型是int * 接下来我们使用强制类型转换，将a由int * 转换为int (*)[4] ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。 接下类我们看动态分配二维数组的第二种方法： 首先我们将这种方法分配的图画出来 设行数为row，列数为col，假设二维数组存储的类型为 int 第二种方法申请了 row * sizeof(int *) + row * col * sizeof(int) 字节的空间。 这个表达式的前一项row * sizeof(int *) 代表a[0] a[1] a[2] 的空间，后一项row * col * sizeof(int) 指的是连续的二维数组的存储空间。 这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。 需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是int ** 而不是int (*)[col] ，也决不能是int (*)[col] 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？ 首先a的类型时int ** ，a[1]，代表a之后一个指针大小位置的内容，即 *((size_t)a + 1 * sizeof(int *))，就是a[1] [0]的地址，而(a[1])[0] 就是a[1] [0]的内容。 为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是int ** 第三种二维数组的分析与第二种类似，这里我们给出它的表示 4 指针我们使用一个程序来展示 int (*)[col] 类型 #include &lt;stdio.h&gt;void func_1(int a[][8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_2(int (*a)[8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_3(int (*a)[8]) // 指向数组的指针&#123; for (int i = 0; i &lt; 8; i++) printf(&quot;%d &quot;, (*a)[i]);&#125;int main(void)&#123; int q[4][8]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 8; j++) q[i][j] = 10 * i + j; func_1(q, 4); printf(&quot;\\n&quot;); func_2(q, 4); printf(&quot;\\n&quot;); int p[8] = &#123;0, 1, 2, 3, 4, 5, 6, 7&#125;; func_3(&amp;p); // 因为是指向数组的指针，p必须要取地址&#125; 贴一篇文章 ：https://blog.csdn.net/soonfly/article/details/51131141 这篇文章里对指针类型的分析很好 int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"存储器层次结构 - CS:APP 第六章","slug":"存储器层次结构-CS-APP-第六章","date":"2022-09-04T03:28:41.000Z","updated":"2022-09-07T07:27:25.682Z","comments":true,"path":"2022/09/04/存储器层次结构-CS-APP-第六章/","link":"","permalink":"https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"存储器层次结构本章的主要内容有四： 介绍存储技术 介绍存储器的层次结构思想 特别介绍高速缓存的原理和细节 使用局部性优化程序的性能 本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。 1 存储器的层次结构根据我们的经验观察，读取速度越快的存储器&#x2F;存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。 因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。 但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 L0 寄存器L1 L1高速缓存 SRAML2 L2高速缓存 SRAML3 L3高速缓存 SRAML4 主存 DRAML5 本地二级存储（本地磁盘）L6 远程二级缓存（分布式文件系统、二级服务器） 下面我们介绍它们的存在基础，存储技术。 2 存储技术我们要介绍的存储技术如下 随机存储器RAM SRAM DRAM 非易失性存储器 ROM PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） SSD （基于闪存，固态硬盘就是使用SSD技术） 磁盘 2.1 随机访问存储器随机存储器分为两种材类：SRAM和DRAM SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。 DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。 2.1.1 DRAM &#x2F; 内存的工作原理内存由若干个DRAM芯片构成，被称作内存模块(memory module) 每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。 每个超单元内存储若干个位，一般是一字节八位。 内存/主存||- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片|- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片 首先介绍DRAM 芯片： DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c &#x3D; d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。 我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。 接下来看一下工作流程： 首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。 接着介绍内存模块： 一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 2.2 磁盘 &amp; ROMROM可分为 PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） 我们不多介绍，只需要知道他们的名字和依赖关系即可 磁盘：通常指的是机械硬盘，也不过多介绍。 3 高速缓存首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍： 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。 而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。 数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。 以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。 令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。 这句话暂且悬置。 当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。 但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。 3.1 高速缓存的结构 一个计算机存储器的地址有m位，他被分为三部分： 高t位是标记位 中间s位是组索引位 低b位是组偏移位。 高速缓存被组织为这样的结构： 高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1 每个组中最多有2^t^ 个高速缓存行 每个高速缓存行也由三部分组成 一位有效位，标记着这个高速缓存行是否有效 t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行 2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用 3.2 高速缓存的工作原理当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。 确定是否命中有三个步骤： 组选择 行匹配 字抽取 组选择 回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。 行匹配 如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。 如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。 补充 : 我们先回忆一下地址的构成 标记位 t + 索引位 s + 偏移位b 假设有一个四位的地址，t &#x3D; 1，s &#x3D; 2，b &#x3D; 1 这四位地址的所有组合如下： 我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。 我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。 这样我们较低层的 0、4 映射到了较高层的0组， 1、5映射到了1， 2、6映射到了2， 3、7映射到了3 一个组中可以有最多2^t^ 行，如果我们一组中只有一行。 如果我们首先引用了块0，那么块0每放在较高层的组0， 接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。 通过上面的例子，我想说明两点 一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。 二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？ 注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。 其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。 字抽取 只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。 4 虚拟内存从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。 虚拟内存提供三个重要的能力： 它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。 它位每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。 虚拟内存的存在基础： 同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。 4.1 虚拟内存原理首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。 我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。 4.2 虚拟内存的结构在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。 页表：每个进程都有一个页表，页表将虚拟页映射到物理页。 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。 4.3 虚拟内存的地址翻译下面简单概括以下虚拟内存的地址翻译： 处理器产生一个虚拟地址，并将它传送给MMU MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3 由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4 现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。 下面我们介绍虚拟地址翻译中的一些细节： 什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？ 要解答这个问题，首先我们要介绍虚拟地址的格式。 虚拟页号 VPN 虚拟页偏移 VPO 页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。 PTE 是什么，它的结构是什么？ PTE 是页表条目，他的结构是这样的 SUP 有效位 READ 有效位 WRITE 有效位 PPN 物理页号 (Physical Page Number) 前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。 PPN 物理页号是什么呢？ 让我们回忆以下我们在介绍高速缓存时用到的物理地址 如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。 而标记位和组索引合起来就是PPN。 而块偏移和虚拟地址的虚拟页偏移VPO是一样的 因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。 快表TLB的工作原理是什么？ 快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址： 虚拟地址由VPN和VPO组成 虚拟页号 VPN 虚拟页偏移 VPO 而虚拟页号VPN又可以分为两部分： VPN VPN VPO TLB标记(TLBT) TLB索引(TLBI) VPO TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。 接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。 5 高速缓存系统和虚拟内存系统的对比高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统 虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统 存储在某个存储层，在存储层之间传输的单元叫做块(block) 在高速缓存SRAM中，它叫做高速缓存行，或者行 在主存DRAM中，它叫做块(block) 在虚拟内存系统中，它叫做页(page) 调度策略 高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小 DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大 6 技术总结在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。 有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。 我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。 B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n &#x3D; m + o。 现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。 由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？ 我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t &#x3D; m - i 位来作为标记，区分一组中的不同块。 通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 为什么使用中间位作为索引？ 如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。 接下来我们概括一下内存系统： 一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。 如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。 7 术语索引主存储器(main memory 主存) : 即通常理解的使用DRAM内存。 块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block) VM (Virtual Memory) 虚拟内存 VA(Virtual Address) 虚拟地址 MMU(Memory Management Unit)：内存管理单元，一种硬件 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 页表 ：一个数据类型位PTE的数组 PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型 页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging) 缺页：DRAM缓存不命中称为page fault 内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"CS:APP 读后感","slug":"CS-APP-读后感","date":"2022-09-02T06:23:07.000Z","updated":"2022-09-03T15:05:12.432Z","comments":true,"path":"2022/09/02/CS-APP-读后感/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"CS:APP 读后感这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的） 接下来会陆续更新各章的详细笔记 … 介绍目录： 第1章 计算机系统漫游--- 程序结构和执行第2章 信息的表示和处理第3章 程序的机械级表示第4章 处理器体系结构第5章 优化程序性能第6章 存储器的层次结构--- 在系统上运行程序第7章 链接第8章 异常控制流第9章 虚拟内存--- 程序间的交互和通信第10章 系统及I/O第11章 网络编程第12章 并发编程 本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。 剩下的十一章是本书的正式部分，我认为本书的核心在第 79 章，26章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。 分章介绍第二章 信息的表示和处理 这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。 2.1.3 寻址和字节顺序： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。 2.16 布尔代数介绍 ： 可以使用位向量来表示有限集合。 2.2 整数表示 ： 介绍了整数原码和补码的表示，以及他们之间的转换。 2.3 整数运算 ： 介绍了整数运算可能出现的错误，以及来源。 2.4 ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。 第三章 程序的机器级表示 相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。 这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。 从这一张开始到最后，才是一口气看完的。 3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了objdump 的使用 3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。 3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。 3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法 第四章 处理器体系结构 这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。 第五章 优化程序性能 呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。 客观一点就是 普通人日常写代码小技巧 第六章 存储器层次结构 没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。 第七章 链接 含金量高的来了 这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld 7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位 7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表 7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接 7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方 动态链接：与加载的时候链接的类型 库打桩机制 第八章 异常控制流 最重要的一章之一，介绍了并发编程的基础——异常控制流 介绍了进程，简单带领读者入门了并发编程 讲了信号，有助于以后学习事件驱动的GUI编程 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 8.2 异常 8.3 进程 8.4 用C语言操作进程：fork execve 8.5 信号 SIGINT … 第九章 虚拟内存 最重要的一章之一 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 本章可以分为三部分 第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的 第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve 第三部分介绍了一个内存分配器的实现( malloc() ) 第十章 系统级 I&#x2F;O 这一章读起来很简单，没有什么要理解的东西 首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。 然后着介绍了RIO包，即包装后的IO函数。 本章完 第十一章 网络编程 这一章需要理解的地方不多，只有介绍网络编程的部分 第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。 首先介绍了网络编程 接着介绍了Linux的套接字函数 最后实现了一个小web服务器 11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议 第十二章 并发编程 和上一章差不多的感觉 本章也分为三部分 首先介绍了实现并发编程的三种方法 进程 IO多路复用 线程 之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。 最后介绍了并发编程容易出现的问题：死锁、访问共享变量 …","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"ubuntu 配置","slug":"ubuntu-配置","date":"2022-09-02T02:49:51.000Z","updated":"2022-09-07T06:20:54.963Z","comments":true,"path":"2022/09/02/ubuntu-配置/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 配置2022&#x2F;9&#x2F;1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。 VScode 下载和配置下载的方法见官网，配置C&#x2F;C++的方法网上的博客也很好搜到 Linux系统VsCode 配置C&#x2F;C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境 接下来使将Open With Code 添加到右键菜单 这部分参考 ubuntu中为vscode添加右键菜单–网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com) 其中修改了一点命令，将visual-studio-code 改成了code 去$HOME/.local/share/nautilus/script/ 目录下新建一个文件，文件名就是显示在右键菜单上的名字。 接着将以下内容复制到新建的文件中 #!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&#x27;s directory if it&#x27;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &#x27;s/^file://////&#x27;`&quot;fi# It&#x27;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec code &quot;$destination&quot; 最后运行命令chmod +x 刚才创建的文件名 对文件或文件夹右键就可以看到刚才添加的右键菜单了。 下拉式终端Yakuka在这里 找到 Ubuntu 根据提示安装。 如果安装失败可能要换清华源，如下： 更换清华源 参考：https://blog.csdn.net/weixin_49700990/article/details/122005001 首先使用lsb_release -a 查看自己的Ubuntu版本 我们要更改的文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list， 首先使用命令对这个文件进行备份 sudo cp /etc/apt/sources.list /etc/apt/sources_save.list 接着 进入清华源网站 ，找到Ubuntu的源 ，选择合适的版本，根据提示手动替换即可。 设置应用开机启动在Ubuntu自带的 “启动应用程序” 里配置 更改磁盘大小 参考 https://blog.csdn.net/Shine_Su/article/details/124630751 首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。 将虚拟机的内容复制到虚拟机外 参考：https://blog.csdn.net/u013554213/article/details/124061526 依次执行以下命令，最后重启Ubuntu # 删除原来安装过的文件sudo apt autoremove open-vm-tools# 输入安装命令：sudo apt install open-vm-toolssudo apt install open-vm-tools-desktop 截图软件 https://zhuanlan.zhihu.com/p/415011610 sudo apt install flameshot 查看安装路径 which flameshot 在设置中，添加键盘快捷键 命令是/usr/bin/flameshot gui","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"}]},{"title":"数据结构课程","slug":"数据结构课程","date":"2022-08-23T03:50:55.000Z","updated":"2022-09-22T07:47:01.264Z","comments":true,"path":"2022/08/23/数据结构课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数据结构TODO： 初步：写好面向对象 要实现的数据结构： 顺序表 栈 队列 链表 循环链表 双向链表 游标实现 树 二叉树 AVL树 红黑树 堆 二叉堆 左式堆 二项队列 哈希表 高级数据结构 红黑树 … 隐式数据共享 想做到： 写成模板形式，可以尽可能向STL靠近，打包成静态库","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"数字逻辑课程","slug":"数字逻辑课程","date":"2022-08-23T03:44:02.000Z","updated":"2022-09-22T01:28:49.394Z","comments":true,"path":"2022/08/23/数字逻辑课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数字逻辑课程进行中，持续更新 … 第一章 逻辑代数基础1.1 布尔代数也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。 · + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。 虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。 · 即合取，可以像乘号一样省略。 逻辑代数公理： 0 - 1 律 A + 0 = AA + 1 = 1A · 0 = 0A · 1 = A 重叠律 A + A = AA · A = A 互补律 A + ┐A = 1A · ┐A = 0 对合律 ┐┐A = A 交换律 结合律 分配律 A · (B + C) = AB + AC 与对或的分配A + BC = (A + B)(A + C) 或对与的分配 1.2 逻辑函数定义: 从n个逻辑变量到01的映射。记为F &#x3D; f(A1, A2, A3 … ) 逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式） 1.2.1 三种表示法： 逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成 真值表 卡诺图 用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。 挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。 1.2.2 两种标准形式最小项表达式：也叫积之和范式 或 主析取范式 最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。 最小项的表示： 对于n个变量而言，可以构成2的n次方个最小项表达式。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。 对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 mi 来表示这个最小项表达式。 Q：为什么要使用1代表原变量，用0代表反变量？ A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi &#x3D; 1，而且这是唯一的。 例如m6 &#x3D; AB┐C，其顺序为110B &#x3D; 6D，令对应的逻辑变量为1或0，则m6 &#x3D; 1 · 1 · (┐0) &#x3D; 1 例如，最小项表达式 AB, 转换成二进制即11，表示为m3。 最小项表达式A┐B，转换成二进制即10，表示为m2。 最小项的性质： 对于任意一个最小项，只有一组变量取值可以使其值为1 任意两个最小项之积为0 n个变量的所有2^n^ 个最小项之和为1 将任意表达式转换为最小项表达式： 利用公式A = A(B + ┐B) 最小项表达式的性质： 性质1：若mi是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi&#x3D;1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。 性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F&#x3D;F1+F2 将包括 F1 和 F2 中的所有最小项， G&#x3D;F1·F2 将包括 F1 和 F2 中的公有最小项。 性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成 思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式 使用归谬法证明 第一次课到此结束 最大项表达式： 也叫和之积范式或主合取范式 定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。 举例： 二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B) 三变量最大项表达式： 最大项表达式的三条性质类似最小项表达式的三条性质： 对于任意一个最大项，只有一组变量取值可使其值为0。 任意两个最大项 Mi 和 Mj 之和必为1。 n 变量的所有2^n^ 个最大项之积必为0。 最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。 任意逻辑表达式转换成最大项表达式： 先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。 类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。 AB + A┐B, 而这种表达式被称为 “与 - 或”表达式 最大项表达式的性质也与最小项表达式类似： 性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi&#x3D;0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F&#x3D;F1+F2将包括F1和F2中的公有最大项， G&#x3D;F1·F2将包括F1和F2中的所有最大项。 性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。 1.2.3 逻辑函数的三种表示法的关系用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。 同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。 从上一节的学习，我们直到逻辑函数有三种表示法： 逻辑表达式 真值表 卡诺图 首先，逻辑表达式形式都可以化成标准形式。 接着我们来看真值表与逻辑表达式的关系（最大&#x2F;小项表达式也是逻辑表达式）： 还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。 最大项表达式与最小项表达式恰恰相反： 最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。 最后我们来看一下卡诺图与真值表的关系： 卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合： ——————————————A B | F——————————————0 0 | 00 1 | 11 0 | 11 1 | 0—————————————— 它是一维的 线性的。 而卡诺图则二维的： 将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。 将项的组合换成数字的组合，我们得到卡诺图的简化形式 需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。 下面给出一个逻辑函数的卡诺图表示的例子： 补充：格雷码 https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 1位格雷码有两个码字 (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 2位格雷码 3位格雷码 4位格雷码 4位自然二进制码 00 000 0000 0000 01 001 0001 0001 11 011 0011 0010 10 010 0010 0011 110 0110 0100 111 0111 0101 101 0101 0110 100 0100 0111 1100 1000 1101 1001 1111 1010 1110 1011 1010 1100 1011 1101 1001 1110 1000 1111 第二次课结束 1.3 主要定理 &amp; 常用公式1.3.1个主要定理德摩根律： 当变量个数较少的时候，可以使用真值表法证明。 当变量较多的时候，使用数学归纳法证明。 香农定理： 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。 注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。 对偶定理: 对偶函数的定义： 将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数 设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) 则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) &#x3D; f (x1, x2, … , xn, 1, 0, ·, 1) 对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。 两个推论： 原函数与其对偶函数互为对偶函数。 两个相等的函数（f &#x3D; g）的对偶函数必定相等（f ‘ &#x3D; g ‘） 自对偶函数：一个函数的对偶函数等于它自己。 展开定理： 两个推理： 展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16 1.3.2 5个常用公式 AB + A┐B &#x3D; A 在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。 A + AB &#x3D; A 在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。 还可以写成ABC + ABCDE &#x3D; ABC A + ┐AB &#x3D; A + B 在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。 ┐C + CE &#x3D; ┐C + E AB + ┐AC + BC &#x3D; AB + ┐AC 包含律 在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。 AB + ┐AC + BCDE &#x3D; AB + ┐AC ┐(A┐B + ┐AB) &#x3D; ┐A┐B + AB 两个变量的异或的反 是 两个变量的同或 上面5个公式的对偶形式也是成立的 1.3.3 异或的性质A ⊕A &#x3D; 0 A⊕┐A &#x3D; 1 A⊕0 &#x3D; A A⊕1 &#x3D; ┐ A 重要 A⊕┐ B &#x3D; A ⊙ B &#x3D; A⊕B⊕1 A⊕B &#x3D; B⊕A 交换律 A⊕(B⊕C) &#x3D; （A⊕B) ⊕C 结合律 A(B⊕C) &#x3D; AB⊕AC 分配律 第三次课到此结束 1.3.4 应用一、转化称其他形式（详见P20） “与或” 表达式转 “或与”表达式 法一：分配律 法二：展开定理 “与或” 表达式 转 “与非 - 与非” 表达式 “与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式 或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可 因此我们的步骤是：两次取反，内层非用德摩根律断开 “与或” 表达式 转 “或非 - 或非” 表达式 “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 二、最大项表达式和最小项表达式的关系 ┐mi &#x3D; Mi 或 mi &#x3D; ┐Mi mi’ &#x3D; Mj，且i + j &#x3D; 2 ** n - 1 原函数 ​ – 变换 –&gt; 最小项表达式 ​ – 一次取反 –&gt; 符号错开，但保持最小项表达式，反函数的最小项表达式 或 或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式 ​ – 二次取反 –&gt; 原函数的最大项表达式（和原函数最小项表达式符号错开） 将最大项表达式或最小项表达式变成对偶函数： 首先将最大项变成最小项，或最小项变成最大项 其次将序号变成互补的序号 1.4 逻辑函数的化简 逻辑函数最简式的定义： 该式中乘积项最少 该式中的乘积项不能再用变量更少的乘积项代替 化简方法: 代数方法 卡诺图法 列表化简法 1.4.1 卡诺图法第四次课到此结束 基本原理：ABC + ┐ABC &#x3D; (A + ┐A)BC &#x3D; BC 反映在卡诺图上，就是相邻的两个格可以构成一个圈。 n变量的卡诺图，任何2^m^ 个标1的相邻单元可以形成一个圈，改圈所代表的乘积项由n-m个变量组成，可以消去m个变量。 名词解释： 蕴含项：最小项，以及2^m^ 个相邻单元所形成的圈组成的项。 素项：不是其他蕴含项子集的蕴含项。 实质素项：包含某一最小项，该最小项只被该素项包含。 化简方法： 作出卡诺图，找出全部素项 找出全部实质素项 若有未被覆盖的最小项，找出一个可以包含该最小项的蕴含项，将其添加到实质素项集合中。 得到的集合，写成代数形式，即是化简结果。 第二章 组合电路的分析2.1 各种门电路或门 与门 非门 与非门 或非门 与或非门 异或门 三态门 三态门真值表： E A F 0 0 0 0 1 1 1 任意 高阻抗 第五次课结束 2.2 门电路的主要参数以及组合电路的分析方法门电路的主要参数： 标称逻辑电平：表示逻辑值01的理想电平 扇入系数：门电路允许的输入端数目 若使用的输入端数目比扇入系数小，则多余的输入端再不改变电路逻辑功能的情况下接高电平或低电平 扇出系数：一个门电路输出端所连接的下一级输入端的个数 平均时延 组合电路的分析方法： 给定组合线路 列写逻辑表达式 列真值表 指出线路的逻辑功能 对线路进行评价和改进 2.3 全加器符号表示： A 被加数 B 加数 Ci-1 低位向高位的进位 S 和 全加器的逻辑符号： S &#x3D; A⊕B⊕Ci-1 ​ &#x3D; ∑(1, 2, 4, 7) C &#x3D; AB+(A⊕B)Ci-1 &#x3D; AB+(A+B)Ci-1 ​ &#x3D; ∑(3, 5, 6, 7) 2.4 译码器几种常见的十进制数在二进制下的编码： 8421码：顾名思义，就是十进制数转直接转换成二进制数（范围是0000-1001） 格雷码：相邻的格雷码只有一个位不同 8421转格雷码：Gi&#x3D;B⊕Bi+1 (i &lt;&#x3D; n-1); Gi &#x3D; Bi (i &#x3D; n) 余三码：8421码+3得到余三码（范围是0011-1100） 十进制数 8421 格雷码 余三码 0 0000 0000 0011 1 0001 0001 0100 2 0010 0011 0101 3 0011 0010 0110 4 0100 0110 0111 5 0101 0111 1000 6 0110 0101 1001 7 0111 0100 1010 8 1000 1100 1011 9 1001 1101 1100 第五次课结束 不同的译码器： 三位译八位译码器（多一译码）：从三位二进制数中，翻译出他们的最小项表达式。 高电平译重：翻译出来的那个最小项的电平是高电平 低电平译重：翻译出来的最小项的电平是低电平 如果使用与非门实现译码器，使用低电平译重可以节省非门 2.5.格雷码转8421码：利用异或的性质，一个逻辑表达式异或同一个逻辑表达式两次，等于原逻辑表达式 已知从8421码到格雷码的转换有： G0 &#x3D; B0 ⊕ B1 G1 &#x3D; B1 ⊕ B2 G2 &#x3D; B2 ⊕ B3 G3 &#x3D; B3 则根据异或的性质 B3 &#x3D; G3 已知 G2 &#x3D; B2 ⊕ B3 已知 G2 &#x3D; B2 ⊕ G3 （2） G3 ⊕ G2 &#x3D; B2 ⊕ G3 ⊕ G3 两边同时异或G3 B2 &#x3D; G2 ⊕ G3 异或的性质，消去两个G3 于是我们有： 从格雷码到8421码： B3 &#x3D; G3 B2 &#x3D; G2 ⊕ G3 B1 &#x3D; G1 ⊕ G2 ⊕ G3 B0 &#x3D; G0 ⊕ G1 ⊕ G2 ⊕ G3 2.6 奇偶校验器分为奇校验和偶校验： 我们有一个n位二进制数和一个校验位p 奇校验：n位二进制数和p中，1的个数是奇数 偶校验：n位二进制数和p中，1的个数是偶数 奇偶校验的原理： n个二进制数异或，如果他们中1的数目是奇数，则结果为1 这个原理可以使用数学归纳法证明 一个逻辑变量异或1等于它的非 一个逻辑变量异或0等于它本身 下面以奇校验为例： 生成校验位: p &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ 1 校验 ret &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ P 第三章 组合线路的设计设计流程： 确定逻辑功能 列真值表（也就得到了最小项表达式） 根据卡诺图化简逻辑表达式 按照设计要求变换逻辑表达式 考虑工程问题 3.1 逻辑函数的变换与或变与非： 两次取反，中间DM断开 对F的反函数，三次取反（可以理解为四次取反，怎样好用用那个） 与或非： 两次取反，不断开 对反函数一次取反 或非 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 对F两次求对偶函数 第六次课结束","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"BallMove:基于Qt的GUI小项目","slug":"BallMove-基于Qt的GUI小项目","date":"2022-08-21T11:46:01.000Z","updated":"2022-08-23T12:44:32.474Z","comments":true,"path":"2022/08/21/BallMove-基于Qt的GUI小项目/","link":"","permalink":"https://cfla1638.github.io/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"BallMove:基于Qt的GUI小项目简介在暑假学科目二的时候，看着 Qt学习之路2 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。 今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。 这个项目基于QGraphicsScene + QGraphicsItem + QGraphicsView， 模拟了一个小球在现实世界中的运动。 项目地址：cfla1638&#x2F;BallMove 设定功能：实现了实心球的运动。 考虑的因素有： 用户给予的加速度 重力 摩擦力 空气阻力 细节： 该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg &#x2F; m^3^ 。 重力加速度为 9.8 m&#x2F;s^2^ 。 静摩擦系数为 0.3。 空气阻力使用公式：F &#x3D; 1&#x2F;2 * CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 * 0.04^2^ 。 尺寸换算：1m &#x3D; 250px。 基础知识 Qt的绘制系统由QGraphicsScene + QGraphicsItem + QGraphicsView 相互配合使用。 QGraphicsScene 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。 QGraphicsItem 是在QGraphicsScene 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到QGraphicsScene，进行显示和管理。 QGraphicsView 提供了一个观察的视角，配合QGraphicsScene 进行显示。这个类可以被设为QMainWindow 的CentralWidget。 只有QObject 的子类可以使用信号槽的机制 QTimer类提供计时器功能，使用timer.start(sec) 功能开始计时，这里timer是一个QTimer类的一个对象，每经过sec时间后，timer就会发出一个timeout() 信号。 想要实现物体的运动，就要让物体的位置在每一帧里进行改变&#x2F;刷新（本程序的帧率是120），而QGraphicsScene 提供一个advance() 函数，该函数会调用所有在场景里的QGraphicsItem 对象的advance() 函数，因此我们只要每经过 1000 &#x2F; 120 毫秒 就调用一次QGraphicsScene::advance() 函数，就可以进行场景刷新，从而实现物体的运动。 每个QGraphicsItem::advance(int phase) 都会被一个QGraphicsScene::advance() 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase &#x3D; 0。第二次QGraphicsScene::advance() 将phase &#x3D; 1 传入函数并调用。 基于此，我们只需要在phase &#x3D; 1是进行处理，phase &#x3D; 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。 Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在QGraphicsScene 中的全局坐标系，它记录了每个QGraphicsItem 的位置。第二个是每个QGraphicsItem 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。 每个继承了QGraphicsItem 的类都要重载以下四个函数。 QRectF boundingRect() const;QPainterPath shape() const;void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);void advance(int phase); boundingRect() 返回一个包裹住QGraphicsItem 对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。 shape() 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) 该函数一般由QGraphicsScene 自动调用，绘制该项目。 这个函数一般这样写 void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); // 保存画笔状态 //设置新的画笔状态 painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); // 绘制图型 painter-&gt;restore(); // 还原画笔状态&#125; 我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。 painter-&gt;fillPath(shape(), Qt::blue); 这一行绘制我们在shape() 中返回的图型，在此之前我们可以设置画笔的状态。 编写头文件的建议 如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。 为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。 即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。 项目设计首先来看一下运行效果： 在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象另外，这棵树也为我们展示了本项目的设计思路。└─MainWindow ├─Controller │ ├─Ball │ ├─Balldata │ ├─Ground │ └─QGraphicsScene - Reference ├─QGraphicsScene └─QGraphicsView 自下而上，首先来看Controller下的三个类， Controller下有三个类，分别是Ball, Balldata, Ground，他们都是QGraphicsItem 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。 这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。 值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。 接着是Controller类。 顾名思义，Controller类是我们程序的控制器。 Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。 最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。 当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的QMainWindow::show() 和 QApplication :: exec() 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。 项目实现文件结构首先看一下我们的文件结构 BallMove - BallMove.pro Headers - ball.h - balldata.h - constants.h - controller.h - ground.h - mainwindow.h Sources - ball.cpp - balldata.cpp - controller.cpp - ground.cpp - main.cpp - mainwindow.cpp Ball类的实现首先看一下ball类的实现 class Ball : public QGraphicsItem&#123;public: Ball(qreal x, qreal y); QRectF boundingRect() const; QPainterPath shape() const; void advance(int phase); QPointF getPos()&#123;return pos();&#125; int forceCount = 4; qreal a[2][4]; qreal vx = 0; qreal vy = 0;protected: void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);&#125;; 首先我们来看Ball类的私有变量： 由于我们运动的平面是二维的，因此我们使用一个二维数组qreal a[2][4] 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即a[xAxis][AirResistance] 。如果想要引用y方向的重力加速度，就使用a[yAxis][Gravity] 。 qreal vx, vy 即小球的x方向速度，和y方向的速度。 int forceCount 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。 接着我们来看一下Ball类中声明的函数: 第一个函数getPos()很好理解，即返回小球在全局坐标系中的坐标。 接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：paint() shape() advance() boundingRect() boundingRect : QRectF Ball::boundingRect() const&#123; return QRectF(-BALL_SIZE * 2, -BALL_SIZE * 2, BALL_SIZE * 4, BALL_SIZE * 4); &#125; QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。 BALL_SIZE 定义在constants.h 代表小球的直径。 shape() : QPainterPath Ball::shape() const&#123; QPainterPath path; path.addEllipse(QPointF(0, 0), BALL_SIZE / 2, BALL_SIZE / 2); return path;&#125; 这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。 paint() ： void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); painter-&gt;restore();&#125; 在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。 advance() ： void Ball::advance(int phase)&#123; // 只有phase为1时进行处理 if (!phase) return ; // 计算合力 qreal sumAx = 0, sumAy = 0; for (int i = 0; i &lt; forceCount; i++) &#123; sumAx += a[xAxis][i]; sumAy += a[yAxis][i]; &#125; if (sumAx) vx += (sumAx / FRAME_RATE); if (sumAy) vy += (sumAy / FRAME_RATE); qreal x = fmod(pos().rx() + vx / FRAME_RATE, 1000), y = fmod(pos().ry() + vy / FRAME_RATE, 1000); // 处理小球越界 if (x &lt; 0) x += 1000; if (y &lt; BALL_SIZE / 2) y = BALL_SIZE / 2; // 设置新位置 setPos(QPointF(x, y)); update(); // 更新显示小球&#125; 由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。 在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。 需要注意，一、因为我们的速度、加速度定义为m&#x2F;s和m&#x2F;s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。 二、在设置了小球的位置之后，需要使用update() 函数更新小球的位置。 constants.h 参数存储文件constants.h 文件中存放了项目的各种参数 const int FRAME_RATE = 120; // 帧率：120帧 帧率过低时碰撞会穿透地面const int BALL_SIZE = 20; // 球的直径：20px// 400 对应 112 重力// 3000 对应 2450 重力const int X_SPEED = 1500; // 左右键给球的加速度const int Y_SPEED = 3000; // 上下键给球的加速度const int FRICTION = 735; // 摩擦力大小const int FRICTION_SENSITIVITY = 2; // 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力// 112 对应1.75 米的人// 2450 对应 8cm 的实心球const int GRAVITY = 2450; // 重力大小const double M = 2.1038; // 小球质量enum Directions&#123;xAxis, yAxis&#125;; // x, y轴方向enum Force&#123;User, Gravity, Friction, AirResistance&#125;; // 力的四个维度，用户给出的力，重力，摩擦力，空气阻力 需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。 Balldata &amp; ground这两个类都继承了QGraphicsItem 和Ball类类似，因此我们不在赘述。 Controller类首先看一下Controller类的定义 class Controller : QObject&#123; Q_OBJECTpublic: Controller(QGraphicsScene &amp; scene, QObject * parent = 0); void track(bool); void gravity();public slots: void drawLineOfTrack(); void resume(); void pause(); void advance();protected: bool eventFilter(QObject *atched, QEvent *event);private: void handleKeyPressed(QKeyEvent * event); void handleKeyReleased(QKeyEvent * event); QTimer timer; Ball * ball; QGraphicsScene &amp; scene; Ground * ground; ballData * data;&#125;; Controller类有以下几点功能： 处理键盘事件：如上下左右移动，打开&#x2F;关闭 轨迹显示，清屏。 相关地函数有： bool eventFilter(QObject *atched, QEvent *event);void handleKeyPressed(QKeyEvent * event);void handleKeyReleased(QKeyEvent * event); 控制程序的开始与结束 相关地函数有： void resume();void pause(); 控制程序的一步步地推进，即让小球动起来。 相关地函数有： void advance(); 其他功能 相关地函数有： void track(bool);void gravity();void drawLineOfTrack(); 在这里我们只介绍advance() 函数 void Controller::advance()&#123; scene.advance(); // 首先调用场景的advance() // 获取碰撞信息 static bool lastStatus = false; // 上一帧是否碰撞 static bool nowStatus = false; // 当前是否处于碰撞 nowStatus = ball-&gt;collidesWithItem(ground); //处理碰撞 if (nowStatus == true &amp;&amp; lastStatus == false) &#123; ball-&gt;a[yAxis][Gravity] = 0; // 碰撞时重力与支持力抵消 ball-&gt;vy = -(ball-&gt;vy * 0.667); // 回弹 2/3 的速度 ball-&gt;a[yAxis][User] = 0; // 竖直方向速度为0 &#125; // 处理摩擦力 if (nowStatus) &#123; if (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION; else if (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION; else ball-&gt;a[xAxis][Friction] = 0; &#125; // 没有碰撞的时候 if (!nowStatus) &#123; // 摩擦力置零 ball-&gt;a[xAxis][Friction] = 0; ball-&gt;a[yAxis][Gravity] = GRAVITY; &#125; // 处理空气阻力 qreal sumV = pow(ball-&gt;vx, 2) + pow(ball-&gt;vy, 2); if (fabs(sumV) &gt; 10) &#123; qreal airSum = 0.0009744 * sumV / 250; if (sumV == 0) sumV = 1; ball-&gt;a[xAxis][AirResistance] = (fabs(ball-&gt;vx) / (sqrt(sumV))) * airSum; ball-&gt;a[yAxis][AirResistance] = (fabs(ball-&gt;vy) / (sqrt(sumV))) * airSum; // 将力换算成加速度 ball-&gt;a[xAxis][AirResistance] /= M; ball-&gt;a[yAxis][AirResistance] /= M; if (ball-&gt;vx &gt; 5) ball-&gt;a[xAxis][AirResistance] *= -1; else if (ball -&gt; vx &lt; 10) ; else ball-&gt;a[xAxis][AirResistance] = 0; if (ball-&gt;vy &gt; 5) ball-&gt;a[yAxis][AirResistance] *= -1; else if (ball -&gt; vy &lt; 10) ; else ball-&gt;a[yAxis][AirResistance] = 0; &#125; lastStatus = nowStatus; data-&gt;update(); // 更新数据显示&#125; 由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。 等运动结束之后，我们使用Qt地碰撞检测函数collidesWithItem()看小球是否接触地面。 接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。 其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。 MainWindow 类MainWindow类的代码如下 class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void adjustViewSize();private: void initScene(); QGraphicsView * view; QGraphicsScene * scene; Controller * controller;&#125;; 唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; scene = new QGraphicsScene(this); view = new QGraphicsView(scene, this); controller = new Controller(*scene, this); setCentralWidget(view); resize(750, 750); initScene(); QTimer::singleShot(0, this, SLOT(adjustViewSize()));&#125; 在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的centralWidget 并调整了窗口大小。 在倒数第二步，调用initScene 对scene进行调整。 以上的这些步骤都不会有什么问题，只有最后一步令人困惑： QTimer::singleShot(0, this, SLOT(adjustViewSize())); 首先解释singleShot() 函数，这个函数的声明如下 void QTimer::singleShot(int msec, const QObject *receiver, const char *member) 它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。 那么为什么要使用这个功能呢？ 这里有两个解释 那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数。这就是为什么我们需要用QTimer而不是直接调用adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的callLater()函数。 这个解释来自《Qt学习之路2》 但我并不清楚这里的 “下一次事件循环” 的意思。 依我的理解，应该是这个意思：某个QObject 发出 paintEvent() 事件，但对这个事件的处理比较耗时，如果此时直接调用adjustViewSize() ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用adjustViewSize() ，我们会发现视图小小的挤在屏幕的中间。 后来我又在网上发现了这篇博客：QTimer::singleShot(0, this, slot函数)； ，意思和我理解的大概相似。 但还是挖个坑，等我以后学精了一定回来解释清楚。 参考C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范 Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World","categories":[{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]},{"title":"配置博客","slug":"配置博客","date":"2022-08-20T14:58:00.000Z","updated":"2022-08-21T12:05:04.405Z","comments":true,"path":"2022/08/20/配置博客/","link":"","permalink":"https://cfla1638.github.io/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"博客配置 &amp; 使用教程简介该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。 本文章记录了配置博客和使用博客的一些细节，供以后的我参考。 持续更新中 …… 工作原理在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。 基本命令 调试： hexo server --debug 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面 修改&#x2F;发布博客 进行更新： hexo clean 清理缓存和public文件夹 hexo g generate，生成静态页面，该操作之后即可在本地预览。 hexo d deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。 发布博客 hexo new [layout] [title] 使用layout，在_post&#x2F;title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。 配置文件 可以在 _config.yml 里配置Hexo，在 _config.nexmoe.yml 里配置nexmoe主题。 _config.yml : 配置 网站的标题、副标题、关键词、作者、语言、时区 部署设置，其中repository可以填ssh的链接（执行git clone 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。 _config.nexmoe.yml： 网站的默认头图，头像，图标等均在这里配置。 如果要使用本地相对路径，./ 的绝对路径即博客根目录下的source文件夹。 front-matter在这里可以配置文件的变量。 hexo 的文档：Front-matter | Hexo nexmoe 的私有 front-matter 文档：Front-matter | Hexo Theme Nexmoe 如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900 --title: &lt;title&gt;others...cover: 图片链接--- 配置分类和标签要像这样配置： categories:- Diarytags:- PS3- Games 其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见这里 widgets 关于 “文件归档”：归档页面 | Hexo Theme Nexmoe 关于 “关于博客”：是./ 目录下的一个markdown文件，与其他博文相同。 其他部件可以在_config.nexmoe.yml 里配置 评论系统nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 Valine ，使用方法非常简单，按照Valine的官方手册一步步操作即可。 资源iconfont-阿里巴巴矢量图标库 参考文档Hexo参考文档 Nexmoe 参考文档 nexmoe GitHub地址 从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"},{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"},{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]}