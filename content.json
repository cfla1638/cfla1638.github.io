{"meta":{"title":"cfla's blog","subtitle":"","description":"","author":"cfla","url":"https://cfla1638.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-20T23:36:33.219Z","updated":"2022-08-20T14:43:28.978Z","comments":true,"path":"Archives.html","permalink":"https://cfla1638.github.io/Archives.html","excerpt":"","text":""},{"title":"关于博客","date":"2022-08-20T16:00:00.000Z","updated":"2022-09-02T05:08:53.737Z","comments":true,"path":"about.html","permalink":"https://cfla1638.github.io/about.html","excerpt":"","text":"关于博客建站日期：2022 年 8 月 20 日 About Blog建立一个自己的博客站，最主要的目的是记录自己在计算机这条路上学到的知识。 写下这些内容的时候是大二，在大一时，我看了好多本计算机专业的书，比如《C++ Primer》，《C Primer Plus》。 暑假的时候我学了Qt，用到 C++ 的 OOP 时，我才意识到自己之前学到的知识是不牢固的。刚看完的书，没有经过实践，就是不能变成自己的东西。但我又不能将所有的内容都去实践。因此我决定为看过的计算机类的书籍都写读书笔记，内容主要是看完这本书的感受，学到的东西。就像操作系统切换进程需要保存上下文一样，将对这本书印象最深时的 “上下文” 保存下来，等以后需要的时候能够快速开始。 同样的道理，也适用于刚做完的项目，刚配置好的系统 … 因此，我的博客将记录自己在计算机领域学到过的、实践过的知识 以及 解决问题的经验。 About me 计算机科学与技术专业 内向的、焦虑的、热爱学习、向往未来的 OTAKU"}],"posts":[{"title":"在vscode配置cmake","slug":"在vscode配置cmake","date":"2022-11-14T14:48:49.000Z","updated":"2022-11-14T15:43:11.394Z","comments":true,"path":"2022/11/14/在vscode配置cmake/","link":"","permalink":"https://cfla1638.github.io/2022/11/14/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEcmake/","excerpt":"","text":"在vscode中配置cmake配置includePathvscode的静态语法检查是 intellisense 完成的，想要使它能搜寻到指定的includePath需要这要做： ctrl p，输入c&#x2F;c++ edit configurations(JSON)，这会在本地的./vscode/下创建c_cpp_properties.json 在includePath里面添加上自己的include path即可 配置generator首先 ctrl+p，输入settings.json，点击 “首选项：打开工作区设置(JSON)”。 此操作会创建 ./vscode/settings.json 在此文件中加入&quot;cmake.generator&quot; : &quot;MinGW Makefiles&quot; 根据不同的系统，配置不同的generator。 配置debugger在侧边栏 调试 中点击创建 “launch.json” 或直接创建launch.json 只要是带有调试信息的可执行文件，都可以调试","categories":[],"tags":[]},{"title":"cmake学习之路","slug":"cmake学习之路","date":"2022-10-22T15:28:14.000Z","updated":"2022-10-24T12:09:39.066Z","comments":true,"path":"2022/10/22/cmake学习之路/","link":"","permalink":"https://cfla1638.github.io/2022/10/22/cmake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"cmake 学习之路 参考链接 CMake 如何入门？ - 知乎 (zhihu.com) ttroy50&#x2F;cmake-examples: Useful CMake Examples (github.com) 超详细的cmake入门教程【转载】_Korpse的博客-CSDN博客_cmake 教程 01-basicA-hello cmake概念： CMakeLists.txt : 存储cmake命令，当在一个文件夹中运行cmake时，cmake会寻找这个文件，如果找不到会报错。 三个命令： cmake_minimum_required(VERSION 3.5) 最小的cmake版本 project() 指定项目的名称，cmake可以通过include一个项目名称来引用另一个项目，这对多项目是很方便的。另外这个命令也会创建一个名为 $&#123;PROJECT_NAME&#125; 的变量，它的内容就是我们指定的项目名称。 add_executable(hello_cmake hello_cmake.cpp) 第一个参数是我们生成可执行文件的名称，第二个参数以后则是为了生成这个可执行文件需要的源文件列表 两种构建方式 In-Place Build 将生成的二进制文件和源文件放在一起，这样构建会比较混乱 在Linux上的方法是 cmake . 参数代表CMakeLists.txt 所在的位置 make 注意，在window上，默认的生成器是nmake 要使用mingw的make应当这样： cmake -G &quot;MinGW Makefiles&quot; . 注意字符串大小写严格 cmake . make Out-of-Source Build 将生成的二进制文件单独放在一个文件夹中，这样比较整洁 具体的方法是（Linux） mkdir build cd build cmake ..make 在 window上的方法是 mkdir build cd build cmake -G &quot;MinGW Makefiles&quot; ..cmake ..make B hello headers将头文件和源文件分离编译 我们有一个include目录和一个src目录 CMakeLists.txt ： # Set the minimum version of CMake that can be used# To find the cmake version run# $ cmake --versioncmake_minimum_required(VERSION 3.5)# Set the project nameproject (hello_headers)# Create a sources variable with a link to all cpp files to compileset(SOURCES src/Hello.cpp src/main.cpp)# Add an executable with the above sourcesadd_executable(hello_headers $&#123;SOURCES&#125;)# Set the directories that should be included in the build command for this target# when running g++ these will be included as -I/directory/path/target_include_directories(hello_headers PRIVATE $&#123;PROJECT_SOURCE_DIR&#125;/include) 有两个需要注意的点： 首先我们使用了set函数，将源文件甚至为了其内容，add_executable() 函数的第二个参数也使用该变量。 使用了target_include_directories 函数，这个函数的文档[在这里](target_include_directories — CMake 3.0.2 Documentation) ，需要注意的是，这个函数必须在我们已经添加了源文件或库之后才能使用。否则会构建失败。 详见文档 target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) Specify include directories or targets to use when compiling a given target. The named &lt;target&gt; must have been created by a command such as add_executable() or add_library() and must not be an IMPORTED target. 附：cmake 预先定义的一些变量 Variable Info CMAKE_SOURCE_DIR The root source directory CMAKE_CURRENT_SOURCE_DIR The current source directory if using sub-projects and directories. PROJECT_SOURCE_DIR The source directory of the current cmake project. CMAKE_BINARY_DIR The root binary &#x2F; build directory. This is the directory where you ran the cmake command. CMAKE_CURRENT_BINARY_DIR The build directory you are currently in. PROJECT_BINARY_DIR The build directory for the current project.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"cmake","slug":"cmake","permalink":"https://cfla1638.github.io/tags/cmake/"}]},{"title":"模板与泛型编程 - C++","slug":"模板与泛型编程-C","date":"2022-10-08T08:43:49.000Z","updated":"2022-10-09T09:00:04.467Z","comments":true,"path":"2022/10/08/模板与泛型编程-C/","link":"","permalink":"https://cfla1638.github.io/2022/10/08/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-C/","excerpt":"","text":"模板与泛型编程定义模板模板的定义以关键字template 开始，它的形式如下 template &lt;typename T, typename T1, ...&gt; ，尖括号括起来的部分叫做模板参数列表，我们使用模板时，显示或隐式地将模板实参绑定到模板参数列表上。 typename 关键字也可以用class 关键字代替，在模板参数列表中，它们是等价的。 模板参数： T 叫做模板类型参数。 也可以定义非类型的模板参数，它必须是整形或指向对象的或函数的指针或者左值引用，整形必须是一个常量表达式，指针或者引用必须要具有静态生存期。总而言之，它必须能够在编译期间被确定。 例子： template &lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123; return strcmp(p1, p2);&#125; 模板编译： 编译器遇到模板的定义时，并不会生成代码，只有在使用模板时，编译器才会生成代码。 建议：函数模板和类模板成员函数的定义通常放在头文件中 当我们使用一个函数时，我们只需要它的声明，它的定义可以由链接器在链接期间与其他文件链接。 而模板通常在使用时就要实例化，生成代码，因此，模板的声明和定义最好都放在头文件中。 函数模板函数模板通常是使用隐式模板实参推断，编译器会用函数的实参推断模板实参。 在函数模板中，模板类型参数 T 可用于指定返回类型或函数的参数类型，也可以在函数体内声明变量和进行类型转换。 类模板编译器不能为类模板推断模板类型参数，我们必须显式指明。 类模板的成员函数： 在类内部定义的成员函数隐式inline 在类模板外部定义成员函数： 必须以template + 模板参数列表开始，因为不同类型的模板实例对应不同的成员函数 类模板的模板实例化： 只有程序用到类模板时，才会实例化它。如果没有用到某个成员函数，只用到了这个类，那么这个成员函数也不会被实例化。 简化模板类名 模板名不是类型，只有提供模板实参，模板名才能称为类名。因此我们在使用模板类型时，必须提供模板实参。 但在类模板的作用域内，我们可以只是用模板名，而省略模板实参。 在类模板的定义外，只有遇到类名之后，我们才进入类的作用域。在此之前，例如我们想要是使用模板类型作为返回值，都不能省略模板实参 类模板和友元 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有的模板实例， 如果友元自身是模板，则友元可以授予模板的所有实例，也可以授予部分实例。 模板类型的静态成员 对于每个类型的模板实例，都有一个静态成员。 默认模板实参 可以像函数形参一样，提供一个默认参数。 对于类模板，就算我们需要使用默认模板实参，我们也不能省略尖括号。 templateType&lt;&gt; foo; // 使用默认模板实参 成员模板 可以将类模板或普通类的成员函数声明称模板 普通类： class base&#123; template &lt;typename T&gt; void mem(const T &amp;);&#125; 类模板 template &lt;typename T&gt; class base&#123; template &lt;typename It&gt; base(It begin, It end);&#125; 模板作用域模板参数遵循普通的作用域规则，一个模板参数的可用范围在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明相同的名字。 使用类的类型和类的静态成员： 当我们模板使用classType::name 引用类的类型或静态成员，会导致语义不明（因为只有用到模板是才会生成代码，错误检查不会立即发生） 我们必须使用typename 关键字显式声明这是一个类内定义的类型 例子： template &lt;typename T&gt;typename T::value_type top(const T&amp; c)&#123;/*...*/&#125; 显式实例化两个独立编译的源文件使用相同的模板，并提供了相同的模板实参，每个文件中就都会有一个模板的实例。在一个大型工程中，会造成很大空间浪费。 因此我们需要显式控制模板实例化 形式 extern template chass&lt;string&gt;; 模板实参推断对于传递给模板类型参数的实参，编译器可以选择对实参进行类型转换，也可以不进行类型转换直接生成新的模板。 对于非类型的参数，会进行 只有在一下两种情况会进行类型转换，其他的情况都会生成新的模板 非const转换成const，顶层const会被忽略 数组或函数指针：数组可以转换成指针（即使它们的大小不同，但引用不可以，因为对不同长度的数组的引用不是同一个类型），，函数可以转换成函数指针 特殊情况：因为模板不会进行算数转换，如果一个函数的两个参数使用一个模板形参。即使，传递的实参可以转换成一个类型，调用也会报错： template &lt;typename T&gt;bool cmp(const T &amp;, const T &amp;);long lint = 456;cmp(123, lint); // 错误，类型不匹配 这是我们可以这样处理 template &lt;typename T1, typename T2&gt;bool cmp(const T1 &amp;, const T2 &amp;); 函数模板显式指定模板参数放在函数名之后，模板名之前，靠右的模板参数如果可以通过实参推断出来，则可以省略。 template &lt;typename T1, typename T2, typename T3&gt;T1 cmp(const T2 &amp;, const T3 &amp;);cmp&lt;long long&gt;(20, 30); // T1被显式指定，T2、T3自动推断 显式指定参数之后，模板函数即可执行正常的类型转换 template &lt;typename T&gt;bool cmp(const T &amp;, const T &amp;);long lint = 456;cmp(123, lint); // 错误，类型不匹配cmp&lt;long&gt;(123, lint); // 正确，显式指定模板类型参数之后就可以执行正常的类型转换了。 尾置返回类型当返回类型需要传入的实参，经过decltype 推断后得出时，我们遇到了一个问题，在写返回类型时，形参还没有被创建。 针对这种情况，我们可以使用尾置返回类型，将返回类型放在参数列表后面 template &lt;typename It&gt;auto func(It beg, It end) -&gt; decltype(*beg); 省略608 - 613 关于右值引用 和 转发 模板重载 C++ Primer P614 - P617 重载规则： 对于一个调用，其候选包括所有的模板实参推断和非模板函数 如果有一个函数（不论是模板还是非模板），提供比其他类型的函数更好的匹配，选择它 如果有多个函数提供同样好的匹配，则 如果同样好的函数中，有一个时非模板函数，选择它 如果都是模板函数，则选择更加特例化的哪一个模板函数 否则，调用有歧义 模板特例化模板函数的特例化：必须为模板函数的每一个模板参数提供模板实参，不能部分特例化，因此，函数模板特例化必须以template&lt;&gt; 开始。 模板特例化本质上是接管了编译器的工作，特例化的函数也是一个模板实例而不是一个重载函数。 类模板特例化 特例化方法与函数模板特例化无异，但类模板特例化可以部分特例化，详见P628。 感觉我也不会用到多少这东西。","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"C++ OOP","slug":"C-OOP","date":"2022-09-29T07:48:03.000Z","updated":"2022-10-08T08:47:52.272Z","comments":true,"path":"2022/09/29/C-OOP/","link":"","permalink":"https://cfla1638.github.io/2022/09/29/C-OOP/","excerpt":"","text":"C++ OOPC++ 的类this 指针调用成员函数时，成员函数通过名为this的额外隐式参数访问调用它的那个对象。 在成员函数内部，任何对类成员的直接访问都被看作是对this的隐式使用 this指针总是指向调用成员函数的对象，因此，this指针是一个常量指针，它的const是顶层const，即它永远不会改变它指向的位置。 常量成员函数即使this指针是隐式的，但初始化this指针也要遵循初始化规则，即不能用一个常量去初始化非底层const的的this指针。 由于这条规则的存在，我们无法调用一个被声明成const的对象的普通成员函数，因为这个成员函数的this指针不是底层const的指针。 为了解决这个问题，我们可以将成员函数声明成const 例如，像下面这样，在参数列表后添加上const class A &#123; public: int get_a() const &#123;&#125;; private: int a;&#125; 此时，这个this指针，既是顶层const (this指针所固有的属性)，又是底层const （我们声明的结果） 友元 P241, P250，P545 想让其他类或其他函数访问类的私有成员，需要在一条友元声明，友元声明必须出现在类的内部 由于友元声明并不是类的成员，因此他和访问说明符（public:, private:） 无关，可以出现在类的任意位置 可以将一个类声明成另一个类的友元 如果一个类是另一个类的友元，那么友元类的成员函数可以访问类的所有成员 可以将一个类的成员函数声明成另一个类的友元函数 友元声明是单向的，友元声明不具有传递性 关于友元的作用域：P252 友元关系是不能继承的 基类的友元在访问派生类时没有特殊性。 派生类的友元也不能访问基类的私有成员 类的类型成员类的成员不只可以有变量和函数，还可以有类型 类内定义的类型也有访问权限的限制 用来定义类型的成员必须先定义再使用 原因：&#x2F;&#x2F; TODO 类的内联函数 内联函数(inline)：一些小的，简单的函数可以被定义为内联函数，以减少调用函数的开销 内联函数会在编译时，被编译器展开 例如 inline const string &amp; shorterString(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; max(), min() 之类的函数特别适合被定义为内联函数 定义在类内部的成员函数，它们默认是内联函数 可以在类内声明时使用inline，同时在类外定义函数时也同时使用inline ，但最好是只在类外部定义函数时使用inline 声明。 可变数据成员 from effective c++ 编译器执行的const检查时定义上的，不是逻辑上的，如果类内有些成员是可变的，但不影响它在逻辑上是const，我们可以把它声明为mutable 如果在定义类的成员时，使用mutable 关键字，那么，即使这个对象被声明成const ，我们依然可以改变这个成员变量的值。 class A &#123; public: void inc() const; private: mutable size_t cnt;&#125;void A::inc() const&#123; cnt++;&#125; 返回*this 左值当成员函数是const 版本时，this指针具有底层的const， 因此它的返回的左值也是带底层const的左值 我们可以根据this指针是否具有底层const 来对函数进行重载 底层const的重载见：P206 P247 类的前向声明可以使用类似这种形式声明类 class A; 这是一个不完整类型，我们可以使用这种类型的指针或者引用，但不能创建这种类型的引用。 前向声明可以放在类的头文件中，从而减少依赖。 类的名字查找 我们可以在成员函数的任意地方使用类的成员 原因在于编译器如何处理类： 编译所有的成员声明 编译函数体 如果编译器无法在类内找到一个符号，编译器会在类的外层作用域继续寻找该名字，但只会考虑该语句之前出现过的外层作用域里的符号。 在内层作用域中可以重定义名字，但外层作用域中定义的类型（使用typedef 或使用using symbol = type）不能再类中重定义。 成员函数的名字查找规则 1. 在成员函数内查找名字（成员函数体定义的名字，形参的名字）2. 在类作用域内查找名字3. 在成员函数定义之前的作用域内继续查找 如果想要在成员函数内使用一个类作用域的名字（该名字已经在成员函数的块作用域内被覆盖），可以使用作用域运算符。 类的隐式类型转换 P263 隐式的类类型转换 P514 重载类型转换运算符 如果类的某个构造函数只接受一个参数，它就是一个转换构造函数，定义了一个由其他类型到这个类的隐式类型转换 这种类型转换只允许一步类型转换 一直类的隐式类型转换： 使用关键字explicit 该关键字只能在类内声明中使用，不能在类外重复 该关键字只能用于接受一个值的构造函数前面 类的静态成员类的静态成员存在于任何对象之外，对象中不包括任何于静态成员有关的数据，相当于一个全局变量。合成的默认构造函数也不会初始化它，他被初始化为0 类的静态成员函数不与任何成员绑定，没有this指针，因此也不能是const的 由于静态成员和全局变量一样，都需要链接器来处理，因此，两者的性质十分相似 在.h 文件的类的定义中，静态成员可以是不完整类型，因为它需要链接器处理 我们可以使用类的静态成员作为成员函数的默认实参 拷贝控制 类的初始化、对象拷贝、移动、销毁 由以下六个函数决定： 构造函数 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数 后五个称为类的拷贝控制操作 构造函数 C++ Primer P235、P257、P551、P689 构造函数没有返回值 构造函数可以重载 构造函数不能被声明称const，在构造const对象时，构造函数可以改变它，只有构造函数完成初始化之后，该对象才具有const的属性。 合成的默认构造函数如果没有定义构造函数，编译器会为类定义默认的构造函数，规则如下 如果存在类内的初始值，用它来初始化成员 否则，默认初始化。（内置类型垃圾值，其他类调用默认构造函数） 如果出现以下情况，编译器无法为类构造合成的默认构造函数 类有定义一个构造函数 遇到这种情况，可以使用 类名() = defalut 来给予类一个默认的构造函数 类存在一个成员，这个成员没有默认的构造函数 构造函数的初始化列表Sales_data(const std::string &amp;s) : BookNo(s) &#123;&#125; 当某个数据成员被构造函数的初始化列表忽略时，它将以合成默认构造函数相同的方式隐式初始化 （重要）当某个数据成员被构造函数的初始化列表忽略时，他将在执行构造函数函数体之前被默认初始化 由于有的类没有默认构造函数，因此我们必须使用列表初始化对其进行初始化。 class A &#123;// 没有默认构造函数public: A(int num) : elem(num) &#123;&#125;private: int elem = 0;&#125;;class B&#123;public: B(int num) : elem_int(num) &#123;&#125; // 错误，因为A没有默认构造函数，所以必须对它进行列表初始化private: A elem_A; int elem_int;&#125;; 因为所有的类成员都会在构造函数体执行前进行初始化（列表初始化或默认初始化）因此使用列表初始化一定会比在构造函数中赋值更加高效。 （重要）列表初始化的初始化顺序 列表初始化的顺序与他们在类的定义中出现的顺序一样，而与列表初始化的列表顺序无关，如果初始化变量之间会相互依赖，一定要注意他们初始化的顺序！！ 委托构造函数class Sales_data &#123;public: // 非委托构造函数要使用的构造函数 Sales_data(std::string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) &#123;&#125; // 委托构造函数 Sales_data() : Sales_data(&quot;&quot;, 0, 0)&#123;&#125; Sales_data(std::string s) : Sales_data(s, 0, 0) &#123;&#125; Sales_data(std::istream &amp;is) : Sales_data() &#123;read(is, *this);&#125;&#125; 委托构造函数首先执行列表初始化的被委托构造函数的列表初始化，在执行被委托构造函数的函数体，最后执行委托构造函数的函数体 默认构造函数被调用的时机 C++ Primer P262 默认初始化 在块作用域内不适用任何初始值定义一个非静态变量 一个类类型本身含有类成员，并且使用合成的默认构造函数时 没有在列表初始化中被显示初始化时 值初始化 数组初始化时，提供的值小于数组的大小 不适用初始值定义一个局部静态变量 使用T() 这种表达式来显示请求值初始化 继承体系中的合成的默认构造函数 派生类的合成的默认构造函数，首先会调用其基类的构造函数，其基类的构造函数也会调用其基类的构造函数，直到继承链的顶端，接着继承链顶端的基类开始初始化其成员，再执行其构造函数体，接着向下，最后执行派生类的构造函数。 继承直接基类的构造函数，使用using 语句 P557 一种语法糖，可以让编译器根据直接基类的构造函数为派生类生成构造函数 拷贝构造函数定义：如果一个构造函数的第一个参数是自身类型的引用，且其他任何的额外参数都有默认值，则此构造函数是一个拷贝构造函数。 拷贝构造函数的形式通常是 ClassType(const ClassType &amp;) 拷贝构造函数通常不应该是explicit的 合成的拷贝构造函数如果我们没有定义类的拷贝构造函数，编译器会为我们合成一个默认的拷贝构造函数 对于内置类型，合成的拷贝构造函数会直接拷贝 对于类类型，合成的拷贝构造函数会调用它的拷贝构造函数 对于数组，合成的拷贝构造函数会逐个拷贝它的元素 一、默认初始化、值初始化、直接初始化和拷贝初始化 几个术语的含义及其区别： 几种初始化的区别：https://blog.csdn.net/qq_38231713/article/details/106291397 默认初始化：对象可能产生未定义的值，出现场景： 块作用域内不使用任何初始值定义一个非静态变量； 类通过默认构造函数来控制默认初始化过程，默认构造函数以如下规则初始化类的数据成员 如果存在类内初始值，用它来初始化成员 否则，默认初始化该成员 值初始化：对象的值是确定（预设）的，出现场景： 数组初始化时，初始值数量小于数组的长度。 不使用初始值定义一个静态变量（带有初始值0） 使用类似classType() 形式表达式显示请求值初始化 只提供vector可以容纳的元素数量，不提供初始值，库会自动进行值初始化 vector&lt;int&gt; vec(10); 值初始化为0 直接初始化：使用classType() 初始化对象 拷贝初始化：使用classType foo = classType() 初始化对象 不光在使用 &#x3D; 赋值时会发生拷贝初始化，在以下情况时也会发生拷贝初始化 将参数作为实参传递给非引用类型的形参 从返回类型为非引用的函数返回一个对象 使用花括号列表初始化数组或聚合类 初始化标准库容器或者使用insert或push（顺带一提使用emplace会直接初始化，不会调用拷贝构造函数） 二、不同的初始化方式会调用那种构造函数 参考：https://blog.csdn.net/sksukai/article/details/104741675/ 当定义类时，会有直接初始化和拷贝初始化两种区别 foo var1; // 直接初始化，使用默认构造函数foo var2(1); // 直接初始化，使用一个参数的构造函数foo var3 = 50; // 拷贝初始化，本来是50先使用构造函数构造临时对象，再使用拷贝构造函数初始化var3，但经过实际测试，编译优化了这一部分，直接使用构造函数初始化了var3foo var4 = foo(50); // 和var3的情况完全相同，优化后也是只使用了一次接受一个对象的构造函数foo var5 = var3; // 拷贝初始化，调用拷贝构造函数 继承体系中的拷贝构造函数我们需要使用基类的拷贝构造函数显示的初始化基类的成员 class base &#123;/* ... */&#125;;class derived : public base&#123; derived(const derived &amp;d) : base(d) // 显式的使用基类的拷贝构造函数+ &#123;/*...*/&#125;&#125; 拷贝赋值运算符 可能会误以为拷贝初始化classType obj = ori; 会使用拷贝赋值运算符，事实上，这只调用拷贝构造函数 当我们定义了拷贝赋值运算符，我们就重载了它的赋值运算符 此外我们还可以定义两种赋值运算符 移动赋值运算符 其他类型到此类型的赋值运算符 但这个运算符是最常用的运算符 拷贝赋值运算符的形式通常是classType operator=(const classType &amp;) 因为他是一个成员函数，因此它的左侧成员自动绑定 合成的拷贝赋值运算符合成的拷贝赋值运算符会将右侧的每个非static成员赋值给左侧成员，对于数组类型，它会逐个拷贝 继承体系中的拷贝赋值运算符派生类的拷贝赋值运算符要显式调用基类的拷贝赋值运算符，之后我们再为派生类的成员完成赋值操作 classType &amp; classType::operator=(const classType &amp; rhs)&#123; Base::operator=(rhs); // 调用基类的拷贝赋值运算符，即使他是合成的运算符也可以这样调用 /* 派生类成员的赋值操作 */ return *this;&#125; 析构函数释放对象使用的资源，销毁对象的非static成员 析构函数的形式是~classType() 没有返回值，不接受参数 不能被重载，对于任意一个类有且只有一个析构函数 析构函数不能是删除的 析构函数首先执行析构函数体，接着按初始化顺序逆序销毁成员 继承体系中的析构函数 派生类的析构函数只需要处理它自己的成员，不需要在析构函数体里显示调用基类的析构函数。它们所占用的资源（除了申请的堆资源），都会隐式的销毁。 对象销毁的顺序：先销毁派生类的资源，再销毁基类的成员直到继承体系顶端。 移动构造函数类的拷贝控制成员被默认定义为删除的 P450、P476、P553、P751 面向对象 类派生列表：首先是一个类名之后的冒号，接着是基类名，基类名之间以逗号隔开，每个基类名之前有访问说明符， 派生类列表的访问说明符的作用：控制派生类从基类继承的成员是否对派生类用户可见 动态绑定（运行时绑定）：在运行时，根据传入的实参，动态选择函数版本，称为动态绑定 基类通过在成员函数前加上virtual 关键字使得函数执行运行时动态绑定。 任何构造函数之外的非静态函数都可以是虚函数 关键字virtual 只能出现在类内声明语句中，而不能出现在定义语句中 没有用virtual 声明的函数，其解析发生在编译时，而非运行时 访问控制： 如果类的成员能被派生类访问，但不能被其他类访问，它应该被定义为protected 派生类的构造函数 派生类必须使用基类的构造函数初始化其基类的部分 防止继承 定义类的时候使用final class NoDerived final &#123;/* ... */&#125;; 纯虚函数和抽象基类 纯虚函数 通过在函数声明的分号前添加 &#x3D; 0 即可声明这个函数为纯虚函数 纯虚函数只是提供了一个接口，无需定义纯虚函数 含有纯虚函数的类是抽象基类， 不能直接创造一个抽象基类对象 Protected 派生类的成员和友元只能访问派生类中的基类部分的受保护成员，而不能通过派生类访问基类的受保护成员 基类成员对于它的派生类 的用户来说，访问权限主要受两部分影响 若基类的访问说明符 派生类派生列表的访问说明符（对于派生类用户来说，此条的优先级更高） 对于派生类成员来说，它可以访问基类的public 和private 部分 改变个别成员的可访问性可以在派生类中使用using 声明改变它继承自基类的成员的可访问性 但using声明只能改变它能访问的成员的可访问性，即它不能改变基类的私有成员的在派生类中的可访问性。 struct 和 class的区别 struct是C语言的关键字，它定义结构体，而C语言没有构造函数和拷贝控制函数 在C++中struct和class除了他们的可访问性以外，没有任何不同，c++的编译器都会为他们生成构造析构函数和拷贝控制函数 他们的可访问性： struct的默认成员都是public，class的默认成员都是private struct定义的类，它的继承默认是公有继承，class定义的类，默认继承方式是私有继承 类的作用域 每个类定义自己的作用域，在这个作用域内我们定义自己的成员函数。 当存在派生关系时，派生类的作用域嵌套在基类的作用域内：当我们遇到一个派生类中的名字，在派生类作用域中找不到这个名字，就会在基类的作用域内继续搜索这个名字。 一个对象、引用 或 指针的静态类型，决定了该对象究竟有那些对象是可见的。 如果我们用基类指针绑定了派生类的成员，我们不能用这个指针去访问派生了特有的成员，因为对于这个成员名字的搜索将从基类的作用域开始，这决定了我们永远不会搜索派生类的作用域。 与往常一样，内层作用域会隐藏与存在于它内部的名字重名的外层作用域名字。 编译器解析类的函数调用的过程： 例如obj.func() 确定obj的静态类型，去对应的类的作用域内查找该名称 如果在类的作用域内找不到该名称，则继续查找它的基类的作用域，如果一直到派生链的顶端也找不到该名子，编译器报错。 如果找到了该名子，编译器进行类型检查，看这次调用是否合法。 如果调用合法，看这个函数是不是虚函数，调用对象是不是指针或引用，如果是，编译器执行动态绑定，生成运行时决定调用那个函数的代码。 否则直接进行函数调用。 声明在内层作用域中的函数不会重载声明在外层作用域中的函数，即使派生类中的函数的形参列表与基类中的形参列表不一样，也不会重载。 因此虚函数与其在派生类中的覆盖函数，它们的形参列表必须相同，否则就不会导致虚函数机制，而是直接用内层作用域中的函数覆盖外层作用域中的函数。 成员函数无论是否是虚函数，都可以重载，因此对于基类的重载函数，派生类如果想要看到基类的全部重载的某个成员函数，它必须全部覆盖基类的重载虚函数 或者 一个重载虚函数也不覆盖。 如果想要让覆盖重载虚函数的一些函数，但其他函数也不会因为作用域的原因而不可见，可以使用using 声明 class base&#123; public: virtual func(int); virtual func(int, int); virtual func(char, int);&#125;;class derived : public base&#123; public: using base::func; // 使用using 我们可以只覆盖重载虚函数的一个实例而让其他的虚函数也可见 func(int) override;&#125;","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"const 和 constexpr 的详解和区别","slug":"const-和-constexpr-的详解和区别","date":"2022-09-26T07:40:53.000Z","updated":"2022-09-29T07:45:33.300Z","comments":true,"path":"2022/09/26/const-和-constexpr-的详解和区别/","link":"","permalink":"https://cfla1638.github.io/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"const和constexprconstexpr常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式 常量表达式是由 数据类型 数据初始值 决定的。 int a = 1 a 不是一个常量表达式，因为它的数据类型不是常量 const int b = get_val() b不是一个常量表达式，因为它的初始值不是常量 由于使用const 不能确定一个表达式是不是常量，因此C++11使用constexpr 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。 下面这个程序是不正确的，因为a虽然被const 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式 int main(void)&#123; int b = 3; const int a = b; constexpr int i = a; int arr[i]; return 0;&#125; 而只要将a = b 改为 a = 1 程序就不会报错了，因为此时a的确是一个常量表达式 constexpr 函数普通的函数不是常量表达式，但我们可以定义constexpr 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定 constexpr 指针 &amp; 引用constexpr 指向的位置必须是全局变量，静态变量，或者字面值等放在.bss 节.data 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。 constconst用来修饰变量，根据const 出现的位置，可以分为两种const ：顶层const 和底层const 顶层const 可以表示任意的对象是常量 const int a = 1; // a不能改变，是顶层constint *const p = &amp;a; // p不能改变指向，是顶层const 低层const 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量 const int *p = &amp;a; // 指向a的指针，不能通过这个指针修改a的值，是底层constconst int &amp;ref = a; // a的引用，不能通过这种方式修改a, 是底层const const 与参数传递 在参数传递时，顶层const会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层const 后没有区别 void func(int i);void func(const int i); 可以使用非常量初始化底层const ，但不能使用常量去初始化非底层const int a = 1;const int b = 1;const int &amp;ref_1 = a; // 可以， 可以使用非常量初始化底层constint &amp;ret_2 = b; // 不可以， 不能使用常量去初始化非底层const 非常量的引用必须是左值，常量的引用可以是左值，也可以是右值 const int &amp;a = 1; // 正确int &amp;b = 2; // 错误 因此尽量将不会改变形参的函数的形参定义成底层const ，因为这样定义我们可以使用字面量（rvalue）。","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"并发编程 - CS:APP 第十二章","slug":"并发编程-CS-APP-第十二章","date":"2022-09-25T14:10:57.000Z","updated":"2022-09-26T06:38:29.889Z","comments":true,"path":"2022/09/25/并发编程-CS-APP-第十二章/","link":"","permalink":"https://cfla1638.github.io/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"并发编程 - CS:APP 第十二章本章主要内容： 实现并发程序的三种方法： fork() 进程 I&#x2F;O 多路复用 使用线程 使用信号量同步线程 线程安全问题 使用进程进行并发编程fork() &amp; execve 优点：进程模型清晰，有独立的地址空间 缺点：不方便进程之间共享信息 基于进程的并发echo服务器 #include &lt;csapp.h&gt;void echo(int connfd)&#123; size_t n; char buf[MAXLINE]; rio_t rio; Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; printf(&quot;server received %d bytes\\n&quot;, (int)n); Rio_writen(connfd, buf, n); &#125;&#125;void sigchld_handler(int sig)&#123; while (waitpid(-1, 0, WNOHANG) &gt; 0); return ;&#125;int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; if (argc != 2) &#123; fprintf(stderr, &quot;args error&quot;); exit(0); &#125; Signal(SIGCHLD, sigchld_handler); listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); if (Fork() == 0) &#123; printf(&quot;process:%d connected\\n&quot;, getpid()); Close(listenfd); echo(connfd); printf(&quot;process:%d close connection\\n&quot;, getpid()); Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125; IO多路复用可以使用select() 函数显示等待一个进程有一个IO事件发生。 例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。 只要有一个IO事件发生，程序的逻辑流就会改变。 #include &lt;sys/select.h&gt;/*如果fdset中的描述符准备好读或者写，就返回返回值：返回已准备好的描述符数目，若出错返回-1*/int select(int n, fd_set *fdset, NULL, NULL, NULL);FD_ZERO(fd_set *fdset);FD_CLR(int fd, fd_set *fdset);FD_SET(int fd, fd_set *fdset);FD_ISSET(int fd, fd_set *fdset); #include &lt;csapp.h&gt;typedef struct &#123; int maxfd; fd_set read_set; fd_set ready_set; int nready; int maxi; int clientfd[FD_SETSIZE]; rio_t clientrio[FD_SETSIZE];&#125;pool;int byte_cnt = 0;void init_pool(int listenfd, pool *p);void add_client(int connfd, pool *p);void check_clients(pool *p);int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; static pool pool; if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(0); &#125; listenfd = Open_listenfd(argv[1]); init_pool(listenfd, &amp;pool); while (1) &#123; pool.ready_set = pool.read_set; pool.nready = Select(pool.maxfd + 1, &amp;pool.ready_set, NULL, NULL, NULL); printf(&quot;%d&quot;, pool.nready); if (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); add_client(connfd, &amp;pool); &#125; check_clients(&amp;pool); &#125;&#125;void init_pool(int listenfd, pool *p)&#123; int i; p-&gt;maxi = -1; for (i = 0; i &lt; FD_SETSIZE; i++) p-&gt;clientfd[i] = -1; p-&gt;maxfd = listenfd; FD_ZERO(&amp;p-&gt;read_set); FD_SET(listenfd, &amp;p-&gt;read_set);&#125;void add_client(int connfd, pool *p)&#123; int i; p-&gt;nready--; for (i = 0; i &lt; FD_SETSIZE; i++) &#123; if (p-&gt;clientfd[i] &lt; 0) &#123; p-&gt;clientfd[i] = connfd; Rio_readinitb(&amp;p-&gt;clientrio[i], connfd); FD_SET(connfd, &amp;p-&gt;read_set); if(connfd &gt; p-&gt;maxfd) p-&gt;maxfd = connfd; if (i &gt; p-&gt;maxi) p-&gt;maxi = i; break; &#125; &#125; if (i == FD_SETSIZE) app_error(&quot;add_client error: Too many clients&quot;);&#125;void check_clients(pool *p)&#123; int i, connfd, n; char buf[MAXLINE]; rio_t rio; for (i = 0; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; 0; i++) &#123; connfd = p-&gt;clientfd[i]; rio = p-&gt;clientrio[i]; if ((connfd &gt; 0) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123; p-&gt;nready--; if ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; byte_cnt += n; printf(&quot;Server received %d (%d total) bytes on fd %d\\n&quot;, n, byte_cnt, connfd); Rio_writen(connfd, buf, n); &#125; else &#123; Close(connfd); FD_CLR(connfd, &amp;p-&gt;read_set); p-&gt;clientfd[i] = -1; &#125; &#125; &#125;&#125; 缺点：编码特别复杂 基于线程的并发编程线程是运行在进程上下文中的逻辑流 运行在同一个进程里的线程共享 虚拟地址空间 有自己独立的 栈、栈指针、PC、通用目的寄存器和条件码 线程之间是对等的，没有和进程一样有父子之分 进程有两种状态：可结合的和分离的 可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收 分离的：不能被其他线程杀死，内存资源结束时由系统自动释放 #include &lt;pthread.h&gt;typedef void *(func)(void *);// 创建线程int pthread_create(pthread_t *tid, pthread_attr_t * attr, func *f, void *arg);// 获取自己的tidpthread_t pthread_self(void);// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程void pthread_exit(void *thread_return);// 终止 tidint pthread_cancel(pthread_t tid);// 阻塞，等待tid终止int pthread_join(pthread_t tid, void **thread_return);// 当这个线程第一次被调用时，执行 init_routine()，用于初始化pthread_once_t once_control = PTHREAD_ONCE_INIT;int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); 用信号量同步线程如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误 对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。 想要实现互斥的访问，我们可以使用信号量机制 信号量： 信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它： P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。 V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。 P中测试和加一的操作是不可分割的 V中测试和加以的操作也是不可分割的 如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。 互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。 生产者消费者问题 生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。 因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。 基于生产者消费者的sbuf包： sbuf.h #ifndef H_SBUF#define H_SBUF#include &lt;csapp.h&gt;typedef struct&#123; int *buf; // 缓冲区 int n; // 缓冲区长度 int front; // 队列头 int rear; // 队列尾 sem_t mutex; // 对缓冲区的互斥锁 sem_t slots; // 控制生产者的信号量 sem_t items; // 控制消费者的信号量&#125;sbuf_t;void sbuf_init(sbuf_t *sp, int n);void sbuf_deinit(sbuf_t *sp);void sbuf_insert(sbuf_t *sp, int item);int sbuf_remove(sbuf_t *sp);#endif sbuf.c #include &quot;sbuf.h&quot;// 初始化void sbuf_init(sbuf_t *sp, int n)&#123; sp-&gt;buf = Calloc(n, sizeof(int)); sp-&gt;n = n; sp-&gt;front = sp-&gt;rear = 0; Sem_init(&amp;sp-&gt;mutex, 0, 1); Sem_init(&amp;sp-&gt;slots, 0, n); Sem_init(&amp;sp-&gt;items, 0, 0);&#125;// 释放缓冲区空间void sbuf_deinit(sbuf_t *sp)&#123; Free(sp-&gt;buf);&#125;// 向缓冲区插入数据void sbuf_insert(sbuf_t *sp, int item)&#123; P(&amp;sp-&gt;slots); // 如果缓冲区已满，想要插入的线程会阻塞在这里 P(&amp;sp-&gt;mutex); // 互斥锁加锁 sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; // 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小 V(&amp;sp-&gt;mutex); // 互斥锁解锁 V(&amp;sp-&gt;items); // 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们&#125;int sbuf_remove(sbuf_t *sp)&#123; int item; P(&amp;sp-&gt;items); // 如果缓冲区为空，想要取出的线程会阻塞 P(&amp;sp-&gt;mutex); item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n]; // 因为信号量的机制，我们不用担心从空缓冲区里取出数据 V(&amp;sp-&gt;mutex); V(&amp;sp-&gt;slots); // 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们 return item;&#125; 基于预线程化的并发服务器 #include &lt;csapp.h&gt;#include &quot;sbuf.h&quot;#define NTHREADS 4#define SBUFSIZE 16void echo_cnt(int connfd);void *thread(void *vargp);sbuf_t sbuf;static int byte_cnt;static sem_t mutex;int main(int argc, char **argv)&#123; int i, listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; pthread_t tid; if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(0); &#125; listenfd = Open_listenfd(argv[1]); sbuf_init(&amp;sbuf, SBUFSIZE); for (i = 0; i &lt; NTHREADS; i++) Pthread_create(&amp;tid, NULL, thread, NULL); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); sbuf_insert(&amp;sbuf, connfd); &#125;&#125;void *thread(void *vargp)&#123; Pthread_detach(pthread_self()); while (1) &#123; int connfd = sbuf_remove(&amp;sbuf); echo_cnt(connfd); Close(connfd); &#125;&#125;static void init_echo_cnt(void)&#123; Sem_init(&amp;mutex, 0, 1); byte_cnt = 0;&#125;void echo_cnt(int connfd)&#123; int n; char buf[MAXLINE]; rio_t rio; static pthread_once_t once = PTHREAD_ONCE_INIT; Pthread_once(&amp;once, init_echo_cnt); Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; P(&amp;mutex); byte_cnt += n; printf(&quot;server received %d (%d total) bytes on fd %d\\n&quot;, n, byte_cnt, connfd); V(&amp;mutex); Rio_writen(connfd, buf, n); &#125;&#125; 线程安全四个种不安全的函数 不保护共享变量的函数 保持跨越多个调用的状态的函数（依赖前次调用结果的函数） 返回指向静态变量指针的函数 调用线程不安全函数的函数 可重入的函数通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集 定义：当它被多个线程使用时，不会引用任何共享数据 竞争一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争 死锁deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件 给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"网络编程 - CS:APP 第十一章","slug":"网络编程-CS-APP-第十一章","date":"2022-09-22T09:53:11.000Z","updated":"2022-09-25T14:14:00.031Z","comments":true,"path":"2022/09/22/网络编程-CS-APP-第十一章/","link":"","permalink":"https://cfla1638.github.io/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/","excerpt":"","text":"网络编程 - CS:APP 第十一章客户端和服务器都是进程，而不是机器或主机。 IP地址IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中 struct in_addr &#123; uint32_t s_addr; // 32位IP地址，使用网络字节顺序（大端法）&#125; 由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。 字节顺序和主机顺序的转换： #include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong); // host to netuint16_t htons(uint16_t hostshort); // host to netuint32_t ntohl(uint32_t netlong); // net to hostuint16_t ntohs(uint16_t netshort); // net to host 点分IP地址与32位IP地址的转换： #include &lt;arpa/inet.h&gt;// 点分十进制转换成32位地址/*得到的32位地址也要转换成本地顺序返回：若成功返回1，串非法返回0，错误返回-1*/int inet_pton(AF_INET, const char *src, void *dst);// 32位地址转换成点分十进制/*在使用该函数之前，要将32位IP地址转换成网络顺序把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中返回：若成功返回指向点分十进制地址的指针，出错返回NULL*/int char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size); 附 1. // 将十六进制字符串转换成十进制数：使用sscanf(str, &quot;%x&quot;, &amp;num) 使用32位IP地址时，可以直接使用in_addr结构而不是in_addr结构里的s_addr 套接字是一组绝大多数操作系统都定义的函数，可以实现网络应用。 套接字地址结构 // 这两个结构体所占字节数相同，可以互相转换struct sockaddr_in &#123; uint16_t sin_family; // 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6) uint16_t sin_port; // 端口号，使用网络字节顺序 struct in_addr sin_addr; // IP地址结构 unsigned char sin_zero[8]; // 填充0，为了满足struct sockaddr的大小&#125;; // 这个结构体一共占16个字节struct sockaddr &#123; uint16_t sa_family; char sa_data[14];&#125;typedef struct sockaddr SA; socket() 通用#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);/*使套接字称为一个连接的结点返回一个还不能用于读写的描述符*/// 使称为一个连接点clientfd = socket(AF_INET, SOCK_STREAM, 0); connect() 客户端#include &lt;sys/socket.h&gt;int connect(int clientfd, const struct sockaddr * addr, socklen_t addrlen);/*客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ bind() 服务器#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);/*将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)成功返回0， 出错返回-1*/ listen() 服务器#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);/*该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024成功返回0， 出错返回-1*/ accept() 服务器#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen);/*成功返回非负连接描述符， 出错返回-1*/ 建立连接服务器： 调用socket()，创建连接结点 调用bind() 成为一个服务器套接字 调用listen() 转换成监听描述符 调用accept() ，阻塞程序，等待客户端连接，返回连接描述符 客户端： 调用socket()，创建连接结点 调用connect()， 连接服务器 套接字地址和主机名服务名的转换首先了解，域名和IP地址是等价的，服务名和端口号是等价的 例如localhost和127.0.0.1是等价的，http和80是等价的 从 字符串主机名服务名信息 到 二进制套接字地址信息 为什么要使用这个函数？ 域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。 #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;/*host: 域名或点分十进制IP地址service: 服务名或端口号hints: 可选 传递设置result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构*/int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);// 释放返回的链表void freeaddrinfo(struct addrinfo, *result);// 将错误代码转换成错误信息const char *gai_strerror(int errcode); getaddrinfo 使用的结构 struct addrinfo &#123; int ai_flags; int ai_family; int ai_socktype; int ai_protocol; char *ai_canonname; size_t ai_addrlen; struct sockaddr *ai_addr; struct addrinfo *ai_next;&#125; 从 二进制套接字地址信息 到 字符串主机名服务名信息#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *service, size_t servlen, int flags); 辅助简化函数int open_clientfd(char *hostname, char *port) &#123; int clientfd, rc; struct addrinfo hints, *listp, *p; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Open a connection */ hints.ai_flags = AI_NUMERICSERV; /* ... using a numeric port arg. */ hints.ai_flags |= AI_ADDRCONFIG; /* Recommended for connections */ if ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (%s:%s): %s\\n&quot;, hostname, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can successfully connect to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Connect to the server */ if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -1) break; /* Success */ if (close(clientfd) &lt; 0) &#123; /* Connect failed, try another */ //line:netp:openclientfd:closefd fprintf(stderr, &quot;open_clientfd: close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* All connects failed */ return -1; else /* The last connect succeeded */ return clientfd;&#125; int open_listenfd(char *port) &#123; struct addrinfo hints, *listp, *p; int listenfd, rc, optval=1; /* Get a list of potential server addresses */ memset(&amp;hints, 0, sizeof(struct addrinfo)); hints.ai_socktype = SOCK_STREAM; /* Accept connections */ hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */ hints.ai_flags |= AI_NUMERICSERV; /* ... using port number */ if ((rc = getaddrinfo(NULL, port, &amp;hints, &amp;listp)) != 0) &#123; fprintf(stderr, &quot;getaddrinfo failed (port %s): %s\\n&quot;, port, gai_strerror(rc)); return -2; &#125; /* Walk the list for one that we can bind to */ for (p = listp; p; p = p-&gt;ai_next) &#123; /* Create a socket descriptor */ if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; 0) continue; /* Socket failed, try the next */ /* Eliminates &quot;Address already in use&quot; error from bind */ setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, //line:netp:csapp:setsockopt (const void *)&amp;optval , sizeof(int)); /* Bind the descriptor to the address */ if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0) break; /* Success */ if (close(listenfd) &lt; 0) &#123; /* Bind failed, try the next */ fprintf(stderr, &quot;open_listenfd close failed: %s\\n&quot;, strerror(errno)); return -1; &#125; &#125; /* Clean up */ freeaddrinfo(listp); if (!p) /* No address worked */ return -1; /* Make it a listening socket ready to accept connection requests */ if (listen(listenfd, LISTENQ) &lt; 0) &#123; close(listenfd); return -1; &#125; return listenfd;&#125; 例子// echoclient.c#include &lt;csapp.h&gt;int main(int argc, char *argv[])&#123; int clientfd; char *host, *port, buf[MAXLINE]; rio_t rio; if (argc != 3) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; host = argv[1]; port = argv[2]; clientfd = Open_clientfd(host, port); Rio_readinitb(&amp;rio, clientfd); while (Fgets(buf, MAXLINE, stdin) != NULL) &#123; Rio_writen(clientfd, buf, strlen(buf)); Rio_readlineb(&amp;rio, buf, MAXLINE); Fputs(buf, stdout); &#125; Close(clientfd); exit(0);&#125; // echoserver.c#include &lt;csapp.h&gt;void echo(int connfd)&#123; size_t n; char buf[MAXLINE]; rio_t rio; Rio_readinitb(&amp;rio, connfd); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123; printf(&quot;server received %d bytes\\n&quot;, (int)n); printf(&quot;Received:%s\\n&quot;, buf); Rio_writen(connfd, buf, n); &#125;&#125;int main(int argc, char **argv)&#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; char client_hostname[MAXLINE], client_port[MAXLINE]; if (argc != 2) &#123; fprintf(stderr, &quot;argument error\\n&quot;); exit(0); &#125; listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, 0); printf(&quot;connected to (%s, %s)\\n&quot;, client_hostname, client_port); echo(connfd); Close(connfd); &#125; exit(0);&#125; 术语索引protocol family 协议簇：一组相关联的协议","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"系统级I/O - CS:APP 第十章","slug":"系统级I-O-CS-APP-第十章","date":"2022-09-20T07:18:55.000Z","updated":"2022-09-25T14:15:11.726Z","comments":true,"path":"2022/09/20/系统级I-O-CS-APP-第十章/","link":"","permalink":"https://cfla1638.github.io/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"系统级I&#x2F;O - CS:APP 第十章Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。 在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。 文件描述符 定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。 Linux Shell 创建的进程会打开三个文件： 0：标准输入；也可以使用定义在unistd.h 中的STDIN_FILENO 来显示表述 1：标准输出；STDOUT_FILENO 2：标准错误；STDERR_FILENO EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;&#x3D; m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。 文件类型 普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。 目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是. 和.. 分别代表自己和上层目录。 套接字 socket ：用来和其他进程进行跨网络通信的文件。 系统级IO函数#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;// 打开和关闭文件int open(char * filename, int flags, mode_t mode);/*flags: 文件的打开方式O_RDONLY 只读O_WRONLY 只写O_RDWR 可读可写O_CREAT 如果文件不存在，创建O_TRUNC 如果文件已存在，截断它（即覆盖原文件）O_APPEND 添加到文件末尾不同的flag可以使用管道符| 连接使用 mode:一般为0*/int close(int fd);// 读写ssize_t read(int fd, void *buf, size_t n);// 返回值：若成功返回-1，EOF返回0，出错返回-1ssize_t write(int fd, const void *buf, size_t n);// 返回值：若成功返回写的字节数，出错返回-1 ssize_t ：signed size type read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n 可能会返回不足值得情况： 读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。 从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。 读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。 RIO包函数RIO(Robust I&#x2F;O)：用于网络编程中，会自动处理不足值的情况。 总览：// 不带缓冲区的版本ssize_t rio_readn(int fd, void *usrbuf, size_t n); // 代替readssize_t rio_writen(int fd, void *usrbuf, size_t n); // 代替write// 带缓冲区的版本void rio_readinitb(rio_t *rp, int fd);ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n); // 带缓冲区的rio_readn 带缓冲区和不带缓冲区的优劣： 带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。 不带缓冲区：比较快速，方便在网络上进行数据传输（臆断） 不带缓冲区的函数rio_readn()用来代替read 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。 ssize_t rio_readn(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被读取的字节 ssize_t nread; // 单次调用read 函数所读取的字节 char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; // read 函数发生错误 if (errno == EINTR) // interrupted by a sig handler return nread = 0; // call read again else return -1; // unknown error &#125; else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft; // 这个程序读取的所有字节&#125; rio_writen()用来代替write 的函数，无缓冲区，绝对不可能返回不足值 ssize_t rio_writen(int fd, void *usrbuf, size_t n)&#123; size_t nleft = n; // 整个程序中，还没有被写入的字节 ssize_t nwritten; // 单词write函数写入的字节 char *bufp = usrbuf; // 下一个将被写入的位置 while (nleft &gt; 0) &#123; if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) &#123; if (errno == EINTR) // 被一个信号处理程序返回打断 nwritten = 0; else return -1; // 未知错误 &#125; nleft -= nwritten; bufp += nwritten; &#125; return n;&#125; 带缓冲区的函数缓冲区的代码 #define RIO_BUFSIZE 8192 // 缓冲区的大小typedef struct&#123; int rio_fd; // 与缓冲区关联的文件描述符 int rio_cnt; // 缓冲区中的未读字节数 char *rio_bufptr; // 下一个未读字节地址 char rio_buf[RIO_BUFSIZE]; // 缓冲区&#125;rio_t; 初始化缓冲区 void rio_ rio_read()带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数 该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。 该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。 static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)&#123; int cnt; // 本次调用函数读取的字节数 while (rp-&gt;rio_cnt &lt;= 0) &#123; // 如果缓冲区为空，重新填满缓冲区 rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf)); if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno != EINTR) // 被信号打断，自动重启 return -1; // 未知错误 &#125; else if (rp-&gt;rio_cnt == 0) return 0; // EOF else rp-&gt;rio_bufptr = rp-&gt;rio_buf; // 重置bufptr &#125; cnt = n; if (rp-&gt;rio_cnt &lt; n) // 缓冲区字节数不够 cnt = rp-&gt;rio_cnt; // 返回不足值 memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125; rio_readlineb()读取一行，最多读取maxlen-1个字节，最后一个字节要填充&#39;\\0&#39; ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)&#123; int n, rc; // n 程序读取字节数， rc 单次rio_read 的返回值 char c, *bufp = usrbuf; // c一个临时变量，用于逐个读取，测试是否为换行 for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = rio_read(rp, &amp;c, 1)) == 1) &#123; // 正常 *bufp++ = c; if (c == &#x27;\\n&#x27;) &#123; n++; break; &#125; &#125; else if (rc == 0) &#123; // 返回不足值 if (n == 1) return 0; // EOF，什么字节也没读取，直接返回0 else break; // EOF, 但已经读取了一些字节，需要处理后返回 &#125; else return -1; // 未知错误 &#125; *bufp = 0; // 最后一位用 &#x27;\\0&#x27; 填充 return n - 1;&#125; rio_readnb()rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同 ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)&#123; size_t nleft = n; // bytes that has not been read ssize_t nread; // read() func had read nread bytes char *bufp = usrbuf; // nleft != 0 while (nleft &gt; 0) &#123; if ((nread = rio_read(rp, bufp, nleft)) &lt; 0) // someting wrong return -1; // unknown error else if (nread == 0) break; // EOF nleft -= nread; usrbuf += nread; &#125; return n - nleft;&#125; 读取文件元数据#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *filename, struct stat *buf);int fstat(int fd, struct stat *buf); stat() 函数以文件名作为输入，填写struct stat *buf 我们只对struct stat 的一些条目感兴趣： buf-&gt;st_size 文件的大小 buf-&gt;st_mode 使用在sys/stat.h 的三个宏可以判断文件类型： S_ISREG(mode) 这是一个普通文件吗？ S_ISDIR(mode) 这是一个目录文件吗？ S_ISSOCK(mode) 这是一个网络套接字吗？ 读取目录#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);#include &lt;dirent.h&gt;struct dirent * readdir(DIR *dirp);struct dirent &#123; ino_t d_ino; // inode number 文件位置 char d_name[256]; // Filename 文件名&#125; IO重定位#include &lt;unistd.h&gt;int dup2(int oldfd, int newfd);/*复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd*/","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章","slug":"虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章","date":"2022-09-17T03:03:22.000Z","updated":"2022-09-17T03:27:16.949Z","comments":true,"path":"2022/09/17/虚拟内存视角下的Linux进程-动态内存分配-CS-APP-第九章/","link":"","permalink":"https://cfla1638.github.io/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"虚拟内存视角下的Linux进程 &amp; 动态内存分配Linux的虚拟内存系统Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分： 进程虚拟内存部分 内核虚拟内存部分 进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是： 用户栈 %rsp → 共享库的内存映射区域 brk → 运行时的堆（通过malloc分配的） 未初始化的数据(.bss) 已初始化的数据(.data) 0x400000 → 代码(.text) 内核虚拟内存可分为两部分： 内核中的代码和数据及数据结构 被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置） 与进程相关的数据结构（页表、task和mm结构、内核栈） 每个进程都不相同 物理内存 每个进程都相同 内核代码和数据 每个进程都相同 Linux如何组织虚拟内存Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段 这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap） 用户级内存映射Linux 可以使用mmap函数来创建新的虚拟内存，并将对象映射到这些区域中 #include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);/*将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域prot:PROT_EXEC 该页面的区域可以被执行PROT_READ 该页面区域可读PROT_WRITE ... 可写PROT_NONE ... 不能被访问flags:MAP_ANON 被映射的对象是一个匿名对象MAP_PRIVATE 是一个私有对象，使用写时复制机制MAP_SHARE 是一个共享对象*/int munmap(void *start, size_t length); // 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误 例子：将任意磁盘文件赋值到stdout #include &lt;csapp.h&gt;void mmapcopy(int fd, int size)&#123; char *bufp; // load to virtual memory bufp = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0); Write(STDOUT_FILENO, bufp, size); // write to stdout return ;&#125;int main(int argc, char *argv[])&#123; struct stat stat; int fd; if (argc != 2) &#123; printf(&quot;usage: %s &lt;filename&gt;\\n&quot;, argv[0]); exit(0); &#125; // open file fd = Open(argv[1], O_RDONLY, 0); fstat(fd, &amp;stat); // get detailed message of file mmapcopy(fd, stat.st_size); // call mmapcopy exit(0);&#125;","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"异常控制流 - CS:APP 第8章","slug":"异常控制流-CS-APP-第8章","date":"2022-09-12T01:48:49.000Z","updated":"2022-09-25T14:15:19.214Z","comments":true,"path":"2022/09/12/异常控制流-CS-APP-第8章/","link":"","permalink":"https://cfla1638.github.io/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/","excerpt":"","text":"异常控制流 - CS:APP 第8章 这一章更多的是实践，理论的部分实在不多 本文将介绍： 常见的异常 (Linux)部分并发编程 一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。 异常及其分类 中断 (interrupt) : 异步发生，是来自处理器外部I&#x2F;O设备的信号的结果 陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过syscall 指令，造成一个到异常处理程序的陷阱。 系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式 故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页 终止 (abort)：不可恢复的错误。 Linux 进程进程的定义：一个执行中的程序实例 进程提供给程序两个抽象的概念： 一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。 区分并发和并行： 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 获取进程id #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 在linux上，pid_t 被定义为 intpid_t getpid(void); // 获取当前进程pidpid_t getppid(void); // 获得父进程pid 进程只有三种状态： 运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。 暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。) 终止。进程永远地停止了。进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程 从主程序返回 调用exit函数。 创建进程： #include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);/*该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）子进程与父进程的虚拟地址空间相同，文件描述符相同该函数返回两次：在父进程中返回创建子进程的pid在子进程中返回0可以依此区分两个进程*/ 回收僵死进程: #include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *statusp, int options);/*pid 等待集合 pid &gt; 0 一个单独的子进程 pid = -1 父进程的所有子进程 statusp 导致返回的状态信息options 选项return :成功回收：回收进程的pidWNOHANG 返回0其他错误 -1 (例如没有子进程)：如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR典型用法：waitpid(-1, NULL, 0);挂起该进程，等待该进程的子进程终止，回收该僵死进程*/pid_t wait(int *statusp); // 等价于waitpid(-1, &amp;statusp, 0); 让进程休眠： #include &lt;unistd.h&gt;unsigned int sleep(unsigned int secs); // 挂起进程secs秒，如果因为信号中断则会提前返回int pause(void); // 挂起进程，因为进程中断会提前返回 加载并运行程序 #include &lt;unistd.h&gt;// filename 可执行文件路径，argv参数列表，envp环境变量int execve(const char *filename, const char *argv[], const char *envp[]);/*execve调用一次，从不返回，除非找不到可执行文件文件argv/envp 指向以NULL结尾的指针数组特别强调：通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码*/ 信号信号是一种软件层次的异常 发送信号的两个原因： 内核检测到一个系统事件，如子进程终止，发送SIGCHLD 一个进程显式地调用了kill函数，向某个进程发送了信号 一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此： 当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。 为了能方便向大量进程发送信号，Linux提供了进程组这个概念。 进程组相关： #include &lt;unistd.h&gt;pid_t getpgrp(void); // 获取当前进程的进程组int setpgid(pid_t pid, pid_t pgid); // 设置pid的进程组/*如果pid为0，则设置当前的进程如果pgid为0，则用pid指定的PID作为进程组idsetpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID*/ 发送信号 /bin/kill 程序可以手动发送信号 在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。 kill函数 alarm函数 #include &lt;unistd.h&gt;unsigned int alarm(unsigned int secs);// secs秒后，发送一个SIGALRM信号给调用进程 接受处理信号： #include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler handler);/*signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：1. 如果handler是SG_IGN,那么忽略类型为signum的信号。2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。*/ 阻塞 &amp; 解除阻塞信号： #include &lt;signal.h&gt;int sigprocmask(int how, sigset_t *set, sigset *oldset);int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int setdelset(sigset_t *set, int signum);int sigismember(const sigset_t *set, int signum);/*对于sigprocmask的how，有三个选项：SIG_BLOCK 将set中的信号添加到阻塞集合SIG_UNBLOCK 将set中的信号从阻塞信号中删除SIG_SETMASK 将block = set*/ 非本地跳转 #include &lt;setjmp.h&gt;int setjmp(jmp_buf env);int sigsetjmp(sigjmp_buf env, int savesigs);void longjmp(jmp_buf env, int retval);void siglongjmp(sigjmp_buf env, int retrval); 附：Linux 配置CSAPP库 参考： https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435 https://zhuanlan.zhihu.com/p/76930507 https://blog.csdn.net/jakejohn/article/details/79825086 第三版CSAPP库 代码下载：http://csapp.cs.cmu.edu/3e/code.html 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 术语索引抢占(preempted) 暂时挂起 并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合 并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大 并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上 挂起(suspended) 阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"模电课程 - 大学课程","slug":"模电课程-大学课程","date":"2022-09-10T04:17:18.000Z","updated":"2022-11-19T11:20:27.832Z","comments":true,"path":"2022/09/10/模电课程-大学课程/","link":"","permalink":"https://cfla1638.github.io/2022/09/10/%E6%A8%A1%E7%94%B5%E8%AF%BE%E7%A8%8B-%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"电工学基础知识基尔霍夫电压定理 基尔霍夫电流定理 结点电压法：第1章-直流电路分析理论-1.12结点电压法 - 知乎 (zhihu.com) 回路电流法： 叠加定理：电学基础理论之叠加定理 (baidu.com) 戴维南等效电路 二极管： 正向压降 ： 正向通过后，电压的减小量。 二极管的功能： 钳位 钳位二极管_百度百科 (baidu.com) 隔离 稳压 ： 见下面稳压二极管视频 稳压二极管： 详见视频： https://www.bilibili.com/video/BV1qY4y1t7sc 详见P15页笔记 绪论 电压源 理想的电压源内阻为0，输出电压U = E - IR0, R0 &#x3D; 0，因此输出电压恒定不变。当内阻远小于外电阻时，可近似看作理想电压源。 电流源 理想电流源的内阻为无穷大，因此输出的电流I &#x3D; IS - U &#x2F; R ，恒定不变。 第十四章 半导体器件二极管 导通电压： 硅管：0.5V 锗管：0.1V 正向压降 硅管：0.6 ~ 0.8 V 锗管：0.2 ~ 0.3 V 主要参数 最大整流电流 IOM : 长时间使用所允许通过的最大正向平均电流 反向工作峰值电压 URWM : 保证二极管不被击穿而给出的反向峰值电压，一般是反向击穿电压的1&#x2F;2或2&#x2F;3。 反向峰值电流 IRM ：在URWM 下的电流 作用 整流 限伏&#x2F;钳位 隔离：两个二极管并联，某个二极管的电压高，则它优先导通。因而电压低的那一个二极管被隔离了。 稳压二极管 使用稳压二极管时一定要有限流电阻R，不然二极管必定会被烧坏。 稳压二极管的工作原理：当电源电压升高，使得稳压二极管两侧电压有升高的趋势时，此时稳压二极管的电阻升高，电流增大，引起干路限流电阻的电流增加，限流电阻的电阻不变，因此限流电阻的分压增大，抵消了电源增加的电压。 在分析使用稳压二极管之前，假设二极管尚未反向导通，先判断二极管两侧的电压，只有二极管反向击穿时，才能有稳压的效果。 三极管","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"链接 - CS:APP 第七章","slug":"链接-CS-APP-第七章","date":"2022-09-07T11:47:36.000Z","updated":"2022-09-23T04:37:32.473Z","comments":true,"path":"2022/09/07/链接-CS-APP-第七章/","link":"","permalink":"https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"链接本文将介绍： 编译的过程 三种目标文件 三种链接和链接的过程 1 编译的过程 源文件（.c &#x2F;.cpp）经过翻译，形成可重定位目标文件（.o） 具体过程： 预处理 cpp main.c -o main.i 或 gcc -E -o main.c main.c 编译器 ：翻译成汇编语言 cc1 或 cc main.i -o main.s 或 gcc -S -o main.s main.c 汇编器 ：形成可重定位目标文件 as [args] -o main.o 这中间参数很多， 如果向直接到这一步可以使用 gcc -c -o main.o main.c 链接器 链接形成可执行目标文件 ld -o prog main.o other.o 或 gcc -o prog main.o other.o 如果想要一步一步生成.i .s .o 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。 除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 -E -S -c 参数进行编译。 顺带一提，在bash中，可以通过 echo $? 来展示上一次程序退出的返回值 2 三种目标文件首先，什么是目标文件？ 计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。 ——360百科 目标文件可以分为三类： 可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。 可执行目标文件 ： 可以被复制到内存中执行。 共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接 window系统使用PE portable Executable 格式 Linux使用 Executable and Linkable Format, ELF格式 2.1 可重定位目标文件格式 可重定位目标文件 以ELF头开始，通过readelf -a main.o 我们可以看到ELF头的内容 ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12 可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。 我倾向于认为这是节头部表的内容： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1 在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。 一个典型的ELF可重定位目标文件包含下面的节： .text : 已编译的机器代码 .rodata : read only data 只读数据，如printf的格式字符串 .data : 已初始化的全局和静态变量 .bss : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节） .symtab ：符号表 rel.text ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量 .rel.data .debug ：调试信息 .line ：调试时的行号 strtab ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字 2.1.1 符号表符号表的条目格式是这样的 typedef struct &#123; int name; // 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c char type:4, // 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ... binding:4; // 全局变量还是本地变量 GLOBAL OR LOCAL char reserved; // 保留的，未使用 short section; // 在ubuntu 上的名字是Ndx,指明该符号是在那个section的 long value; // 距离节section 起始位置的字节偏移 long size; // 该符号最小的大小&#125; Elf64_Symbol; 对于section 字段，在ubuntu 的readelf 命令中，显示为 Ndx。 该字段有三个伪节，他们分别是 UNDEF COMMON ABS 。 ABS ：代表不改被重定位的符号 UNDEF ：代表未定义的符号，即在本模块引用却在其他模块定义的符号 COMMON ：还未被分配位置的未初始化的数据目标 COMMON 和 .bss 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到COMMON 和.bss COMMON ：未初始化的全局变量 .bss ：未初始化的静态变量，以及初始化为0的全局或静态变量 下面我们通过一个程序来展示以下ubuntu 中的符号表 int sum(int * a, int n);int array[2] = &#123;1, 3&#125;;int global_not_init;int global_init = 1;int global_init_zero = 0;int main()&#123; static int stat_not_init; static int stat_init_zero = 0; static int stat_init = 1; int val = sum(array, 2); return val;&#125; 下面我们生成可重定位的目标文件gcc -c main.c 接着使用readelf -a main.o 读取elf，即可查看符号表 cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.ccfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.oELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 1040 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 12节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000025 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000358 0000000000000030 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 00000068 0000000000000010 0000000000000000 WA 0 0 8 [ 4] .bss NOBITS 0000000000000000 00000078 000000000000000c 0000000000000000 WA 0 0 4 [ 5] .comment PROGBITS 0000000000000000 00000078 000000000000002c 0000000000000001 MS 0 0 1 [ 6] .note.GNU-stack PROGBITS 0000000000000000 000000a4 0000000000000000 0000000000000000 0 0 1 [ 7] .note.gnu.propert NOTE 0000000000000000 000000a8 0000000000000020 0000000000000000 A 0 0 8 [ 8] .eh_frame PROGBITS 0000000000000000 000000c8 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000388 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000100 00000000000001c8 0000000000000018 11 12 8 [11] .strtab STRTAB 0000000000000000 000002c8 0000000000000090 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 000003a0 000000000000006c 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific)There are no section groups in this file.本文件中没有程序头。There is no dynamic section in this file.重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries: 偏移量 信息 类型 符号值 符号名称 + 加数000000000014 000c00000002 R_X86_64_PC32 0000000000000000 array - 4000000000019 001200000004 R_X86_64_PLT32 0000000000000000 sum - 4重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.Symbol table &#x27;.symtab&#x27; contains 19 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 000000000000000c 4 OBJECT LOCAL DEFAULT 3 stat_init.1921 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 0 SECTION LOCAL DEFAULT 7 10: 0000000000000000 0 SECTION LOCAL DEFAULT 8 11: 0000000000000000 0 SECTION LOCAL DEFAULT 5 12: 0000000000000000 8 OBJECT GLOBAL DEFAULT 3 array 13: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_not_init 14: 0000000000000008 4 OBJECT GLOBAL DEFAULT 3 global_init 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero 16: 0000000000000000 37 FUNC GLOBAL DEFAULT 1 main 17: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 18: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND sumNo version information found in this file.Displaying notes found in: .note.gnu.property 所有者 Data size Description GNU 0x00000010 NT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK 符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量global_not_init 在COMMON 伪节，已经初始化了的全局变量global_init和静态变量stat_init都在.data 节，而初始化为0的全局变量global_init_zero 和没有初始化的静态变量stat_not_init 和初始化为0的静态变量stat_init_zero 在.bss 节 根据这三行的value 字段我们还可以看到这三个变量在.bss 节的存储顺序 15: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 global_init_zero6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 4 stat_init_zero.1920 7: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 stat_not_init.1919 注意观察两个静态变量多了两个后辍 这样做其实是为了区分在同一个模块中同名的两个静态变量 如下面程序的这个例子 int func_1(int n)&#123; static int x = n + 1; return x;&#125;int func_2(int n)&#123; static int x = n + 2; return x;&#125; 这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。 2.2 可执行目标文件格式下面是典型的ELF 可执行目标文件 在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过readelf 来看一下这个段头部表 LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000498 0x0000000000000498 R 0x1000LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x0000000000000205 0x0000000000000205 R E 0x1000LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x0000000000000120 0x0000000000000120 R 0x1000LOAD 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x00000000000001e0 0x00000000000001e8 RW 0x1000 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。 ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。 加载可执行文件： 在shell中输入 ./prog 后： shell调用fork() 函数，创建子进程 子进程调用execve()，execve调用加载器，加载prog程序 加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址) _start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数 2.3 可共享目标文件格式3 三种链接和链接的过程三种链接： 静态链接 动态链接库 程序运行时链接共享库 3.1 静态链接静态链接的两个过程 符号解析 重定位 3.1.1 符号解析链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。 对于局部符号，它不会出现在符号表中。 对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。 唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。 对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。 而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。 强符号：函数和已初始化的全局变量 弱符号：未初始化的全局变量 (在COMMON伪节) 接着使用以下规则来处理这些符号： 不允许有多个同名的强符号 如果一个强符号与多个弱符号同名，选择强符号 若有多个弱符号同名，从这些弱符号中任选一个。 这三个规则很容易造成一些不易察觉的运行时错误。 为什么会有.COMMON伪节？ 如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。 而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节 以上讲的是几个.o 文件的链接，他们都是目标文件 接下来我们讲与静态库的链接，其中会有存档文件 这个概念，注意区别 静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是 .a 在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。 生成静态库： 首先编译：gcc -c addvec.c multvec.c 接着生成静态库：ar rcs libvector.a addvec.o multvec.o 得到静态库 libvector.a，存档文件 (重要) 链接器如何使用静态库来解析引用： 链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。 对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。 注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。 因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。 但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的 如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B 假如有这样的依赖关系： 我们要写成 gcc A.o B.a C.a B.a -o prog 因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。 3.1.2 重定位《深入理解计算机系统》原书第三版 P 478 7.7 3.2 动态链接库静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。 所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。 创建动态库 gcc -shared -fpic -o libvector.so addvec.c multvec.c 与动态库链接： gcc -o prog main.c ./libvector.so 与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。 下面是动态链接库的过程： 一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章) 我们将csapp.c 库编译成动态库 使用gcc -shared -fpic csapp.c -o libcsapp.so -lphread 得到 libcsapp.so 将它移动到/lib 接着将csapp.h 移动到 /usr/local/include 编译问使用CSAPP动态库时，只需要使用 gcc main.c -o prog -lcsapp 其中编译选项-lxxx 代表告诉GCC去&#x2F;lib等文件夹下寻找 libxxx.so 与其链接 我们在编译csapp.c的时候，用的编译选项，-lphread 就是告诉编译器与libphread.so库链接，这个库存放与线程相关的代码 以后打包静态库时，我们也要记住，动态库的命名规则是libxxx.so 3.3 程序运行时链接共享库可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序： // 7.11 load and link shared library from an application// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int x[2] = &#123;1, 2&#125;;int y[2] = &#123;3, 4&#125;;int z[2];int main(void)&#123; void * handle; // shared lib handle void (*addvec)(int *, int *, int *, int); // point to a function void (*multvec)(int *, int *, int *, int); // point to a function char * error; // point to error massages string // load shared library handle = dlopen(&quot;./libvector.so&quot;, RTLD_LAZY); if (!handle) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; // search the symbol &quot;multvec&quot; from the shared library multvec = dlsym(handle, &quot;multvec&quot;); if ((error = (dlerror())) != NULL) &#123; fprintf(stderr, &quot;%s\\n&quot;, error); exit(1); &#125; // execute the function multvec(x, y, z, 2); printf(&quot;z = [%d %d]\\n&quot;, z[0], z[1]); // unload the shared library if (dlclose(handle) &lt; 0) &#123; fprintf(stderr, &quot;%s\\n&quot;, dlerror()); exit(1); &#125; return 0;&#125; 名词索引ELF-64 目标文件格式 PIC(Position-Independent Code) 位置无关代码","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"动态数组,二维数组,指针","slug":"动态数组-二维数组-指针","date":"2022-09-06T12:45:24.000Z","updated":"2022-09-06T12:46:41.480Z","comments":true,"path":"2022/09/06/动态数组-二维数组-指针/","link":"","permalink":"https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/","excerpt":"","text":"动态数组、二维数组、指针本文会讲： 二维数组的存储形式 数组类型为什么会退化？ 二维数组的动态分配 1 二维数组的存储形式以下这个程序可以很好的说明二维数组的存储形式 #include &lt;stdio.h&gt;int main(void)&#123; int a[4][2]; // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = i * 10 + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); return 0;&#125; 这个程序的运行结果是这样的 sizeof(int): 4sizeof(a): 32 sizeof(a[0]): 8 a: 000000000064FDD0&amp;a: 000000000064FDD0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 000000000064FDD0a[1]: 000000000064FDD8a[2]: 000000000064FDE0a[3]: 000000000064FDE8*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 000000000064FDD0&amp;a[1]: 000000000064FDD8&amp;a[2]: 000000000064FDE0&amp;a[3]: 000000000064FDE8&amp;a[0][0]: 000000000064FDD0&amp;a[0][1]: 000000000064FDD4&amp;a[1][0]: 000000000064FDD8&amp;a[1][1]: 000000000064FDDC&amp;a[2][0]: 000000000064FDE0&amp;a[2][1]: 000000000064FDE4&amp;a[3][0]: 000000000064FDE8&amp;a[3][1]: 000000000064FDEC 可以看出，二维数组是连续储存的，有&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0] ，以此类推。 我们可以这样表示二维数组 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 2 数组类型为什么会退化？有的时候会出现这种情况： 在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？ 详见：https://www.zhihu.com/question/464844221/answer/1940453834 3 动态分配二维数组3.1 第一种方法先申请一维数组，在将该一维数组强制转换成二维数组 前置知识： 一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息 二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型， 即int q[][4] 和int (*q)[4] 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于q += 2 * 4 * sizeof(int) 直接贴代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int *a = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) a[i] = i; int (*b)[4] = (int (*)[4])a; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, b[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。 我们用int (*b)[4] 声明了一个指向 四个元素的数组 的指针。 然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。 这样动态分配的指针和直接int b[2][4] 是一样的。 下面我们使用 1 中的方法对这个数组进行仔细检查 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; // 初始化数组 int *b = (int *)malloc(2 * 4 * sizeof(int)); for (int i = 0; i &lt; 8; i++) b[i] = i; int (*a)[2] = (int (*)[2])b; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]);&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8 sizeof(a[0]): 8 a: 00000000009C1420&amp;a: 000000000064FDF0a[0][0]: 00 a[0][1]: 01 a[1][0]: 02a[1][1]: 03a[2][0]: 04a[2][1]: 05a[3][0]: 06a[3][1]: 07a[0]: 00000000009C1420a[1]: 00000000009C1428a[2]: 00000000009C1430a[3]: 00000000009C1438*a[0]: 0*a[1]: 2*a[2]: 4*a[3]: 6&amp;a[0]: 00000000009C1420&amp;a[1]: 00000000009C1428&amp;a[2]: 00000000009C1430&amp;a[3]: 00000000009C1438&amp;a[0][0]: 00000000009C1420&amp;a[0][1]: 00000000009C1424&amp;a[1][0]: 00000000009C1428&amp;a[1][1]: 00000000009C142C&amp;a[2][0]: 00000000009C1430&amp;a[2][1]: 00000000009C1434&amp;a[3][0]: 00000000009C1438&amp;a[3][1]: 00000000009C143C 可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。 这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 3.2 第二种方法： 参考: https://blog.csdn.net/morewindows/article/details/7664479# 我这里将原文的int 替换成了size_t //C语言中动态的申请二维数组 malloc free#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//动态申请二维数组template &lt;typename T&gt;T** malloc_Array2D(int row, int col)&#123; int size = sizeof(T); int point_size = sizeof(T*); //先申请内存，其中point_size * row表示存放row个行指针 T **arr = (T **) malloc(point_size * row + size * row * col); if (arr != NULL) &#123; memset(arr, 0, point_size * row + size * row * col); T *head = (T*)((size_t)arr + point_size * row); // 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好 while (row--) arr[row] = (T*)((size_t)head + row * col * size); &#125; return (T**)arr;&#125;//释放二维数组void free_Aarray2D(void **arr)&#123; if (arr != NULL) free(arr);&#125;int main()&#123; printf(&quot; C语言中动态的申请二维数组 malloc free\\n&quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\\n\\n&quot;); printf(&quot;请输入行列(以空格分开): &quot;); int nRow, nCol; scanf(&quot;%d %d&quot;, &amp;nRow, &amp;nCol); //动态申请连续的二维数组 int **p = malloc_Array2D&lt;int&gt;(nRow, nCol); //为二维数组赋值 int i, j; for (i = 0; i &lt; nRow; i++) for (j = 0; j &lt; nCol; j++) p[i][j] = i + j; //输出二维数组 for (i = 0; i &lt; nRow; i++) &#123; for (j = 0; j &lt; nCol; j++) printf(&quot;%4d &quot;, p[i][j]); putchar(&#x27;\\n&#x27;); &#125; free_Aarray2D((void**)p); return 0;&#125; 这里，原作者对指针的操作让我叹为观止。 但是，用这种方法创作出来的二维数组和直接int b[2][4] 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。 它的具体结构我将在下一小节介绍 3.3 第三种方法 参考：https://blog.csdn.net/houqd2012/article/details/8146070 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(2, 4); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 4; j++) a[i][j] = 10 * i + j; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 4; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; free_array2D(a); return 0;&#125; 乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。 我们使用 1 中的程序对这个数组进行详细的检查。代码如下 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int **make_array2D(int row, int col)&#123; int **arr = (int **)malloc(row * sizeof(int *)); arr[0] = (int *)malloc(row * col * sizeof(int)); for (int i = 1; i &lt; row; i++) arr[i] = arr[i - 1] + col; return arr;&#125;void free_array2D(int **arr)&#123; free(arr[0]); free(arr);&#125;int main(void)&#123; int **a = make_array2D(4, 2); // 初始化 for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) a[i][j] = 10 * i + j; printf(&quot;sizeof(int):\\t%llu\\n&quot;, sizeof(int)); printf(&quot;sizeof(a):\\t%llu\\n&quot;, sizeof(a)); printf(&quot;sizeof(a[0]):\\t%llu\\n&quot;, sizeof(a[0])); printf(&quot;\\n&quot;); printf(&quot;a:\\t%p\\n&quot;, a); printf(&quot;&amp;a:\\t%p\\n&quot;, &amp;a); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;a[%d][%d]:\\t%02d\\n&quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;a[%d]:\\t%p\\n&quot;, i, a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;*a[%d]:\\t%d\\n&quot;, i, *a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) printf(&quot;&amp;a[%d]:\\t%p\\n&quot;, i, &amp;a[i]); printf(&quot;\\n&quot;); for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 2; j++) printf(&quot;&amp;a[%d][%d]:\\t%p\\n&quot;, i, j, &amp;a[i][j]); free_array2D(a); return 0;&#125; 运行结果如下 sizeof(int): 4sizeof(a): 8sizeof(a[0]): 8a: 0000000000701420&amp;a: 000000000064FDF0a[0][0]: 00a[0][1]: 01a[1][0]: 10a[1][1]: 11a[2][0]: 20a[2][1]: 21a[3][0]: 30a[3][1]: 31a[0]: 0000000000701450a[1]: 0000000000701458a[2]: 0000000000701460a[3]: 0000000000701468*a[0]: 0*a[1]: 10*a[2]: 20*a[3]: 30&amp;a[0]: 0000000000701420&amp;a[1]: 0000000000701428&amp;a[2]: 0000000000701430&amp;a[3]: 0000000000701438&amp;a[0][0]: 0000000000701450&amp;a[0][1]: 0000000000701454&amp;a[1][0]: 0000000000701458&amp;a[1][1]: 000000000070145C&amp;a[2][0]: 0000000000701460&amp;a[2][1]: 0000000000701464&amp;a[3][0]: 0000000000701468&amp;a[3][1]: 000000000070146C 从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接int b[2][4] 得到的二维数组，还是不一样的。 它的具体结构我将在下一小节介绍 3.4 总结 ： 下标运算符首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。 下标运算符是左结合的，我们引用二维数组，通常是这样的 arr[i][j] 但其实也可以这样 (arr[i])[j] 这两种形式是等价的。 下面我们详细地描述下标运算符 ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType)) 可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型int **, 也可以是数组类型 int (*)[]，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。 首先我们来看内置的数组类型 a a[0] a[1] a[2] a[3] a[0] [0] a[0] [1] a[1] [0] a[1] [1] a[2] [0] a[2] [1] a[3] [0] a[3] [1] 一个内置数组类型表示为int a[5][5] ，但拎出来a，他的类型是 int (*)[5] 所以arr[1] 其实是指a[1][0] 这个位置。a[1] 的类型是int * 所以(a[1])[1] 的类型就是int 接下来我们看动态分配二维数组的第一种方法： 这种方法一开始申请了一个一维数组int *a = (int *)malloc(2 * 4 * sizeof(int)) a的类型是int * 接下来我们使用强制类型转换，将a由int * 转换为int (*)[4] ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。 接下类我们看动态分配二维数组的第二种方法： 首先我们将这种方法分配的图画出来 设行数为row，列数为col，假设二维数组存储的类型为 int 第二种方法申请了 row * sizeof(int *) + row * col * sizeof(int) 字节的空间。 这个表达式的前一项row * sizeof(int *) 代表a[0] a[1] a[2] 的空间，后一项row * col * sizeof(int) 指的是连续的二维数组的存储空间。 这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。 需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是int ** 而不是int (*)[col] ，也决不能是int (*)[col] 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？ 首先a的类型时int ** ，a[1]，代表a之后一个指针大小位置的内容，即 *((size_t)a + 1 * sizeof(int *))，就是a[1] [0]的地址，而(a[1])[0] 就是a[1] [0]的内容。 为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是int ** 第三种二维数组的分析与第二种类似，这里我们给出它的表示 4 指针我们使用一个程序来展示 int (*)[col] 类型 #include &lt;stdio.h&gt;void func_1(int a[][8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_2(int (*a)[8], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 8; j++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); &#125;&#125;void func_3(int (*a)[8]) // 指向数组的指针&#123; for (int i = 0; i &lt; 8; i++) printf(&quot;%d &quot;, (*a)[i]);&#125;int main(void)&#123; int q[4][8]; for (int i = 0; i &lt; 4; i++) for (int j = 0; j &lt; 8; j++) q[i][j] = 10 * i + j; func_1(q, 4); printf(&quot;\\n&quot;); func_2(q, 4); printf(&quot;\\n&quot;); int p[8] = &#123;0, 1, 2, 3, 4, 5, 6, 7&#125;; func_3(&amp;p); // 因为是指向数组的指针，p必须要取地址&#125; 贴一篇文章 ：https://blog.csdn.net/soonfly/article/details/51131141 这篇文章里对指针类型的分析很好 int p; //这是一个普通的整型变量int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.","categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"}]},{"title":"存储器层次结构 - CS:APP 第六章","slug":"存储器层次结构-CS-APP-第六章","date":"2022-09-04T03:28:41.000Z","updated":"2022-09-25T14:13:47.752Z","comments":true,"path":"2022/09/04/存储器层次结构-CS-APP-第六章/","link":"","permalink":"https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"存储器层次结构 - CS:APP 第六章本章的主要内容有四： 介绍存储技术 介绍存储器的层次结构思想 特别介绍高速缓存的原理和细节 使用局部性优化程序的性能 本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。 1 存储器的层次结构根据我们的经验观察，读取速度越快的存储器&#x2F;存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。 因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。 但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 L0 寄存器L1 L1高速缓存 SRAML2 L2高速缓存 SRAML3 L3高速缓存 SRAML4 主存 DRAML5 本地二级存储（本地磁盘）L6 远程二级缓存（分布式文件系统、二级服务器） 下面我们介绍它们的存在基础，存储技术。 2 存储技术我们要介绍的存储技术如下 随机存储器RAM SRAM DRAM 非易失性存储器 ROM PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） SSD （基于闪存，固态硬盘就是使用SSD技术） 磁盘 2.1 随机访问存储器随机存储器分为两种材类：SRAM和DRAM SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。 DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。 2.1.1 DRAM &#x2F; 内存的工作原理内存由若干个DRAM芯片构成，被称作内存模块(memory module) 每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。 每个超单元内存储若干个位，一般是一字节八位。 内存/主存||- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片|- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片 首先介绍DRAM 芯片： DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c &#x3D; d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。 我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。 接下来看一下工作流程： 首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。 接着介绍内存模块： 一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 2.2 磁盘 &amp; ROMROM可分为 PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） 我们不多介绍，只需要知道他们的名字和依赖关系即可 磁盘：通常指的是机械硬盘，也不过多介绍。 3 高速缓存首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍： 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。 而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。 数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。 以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。 令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。 这句话暂且悬置。 当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。 但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。 3.1 高速缓存的结构 一个计算机存储器的地址有m位，他被分为三部分： 高t位是标记位 中间s位是组索引位 低b位是组偏移位。 高速缓存被组织为这样的结构： 高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1 每个组中最多有2^t^ 个高速缓存行 每个高速缓存行也由三部分组成 一位有效位，标记着这个高速缓存行是否有效 t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行 2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用 3.2 高速缓存的工作原理当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。 确定是否命中有三个步骤： 组选择 行匹配 字抽取 组选择 回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。 行匹配 如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。 如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。 补充 : 我们先回忆一下地址的构成 标记位 t + 索引位 s + 偏移位b 假设有一个四位的地址，t &#x3D; 1，s &#x3D; 2，b &#x3D; 1 这四位地址的所有组合如下： 我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。 我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。 这样我们较低层的 0、4 映射到了较高层的0组， 1、5映射到了1， 2、6映射到了2， 3、7映射到了3 一个组中可以有最多2^t^ 行，如果我们一组中只有一行。 如果我们首先引用了块0，那么块0每放在较高层的组0， 接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。 通过上面的例子，我想说明两点 一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。 二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？ 注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。 其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。 字抽取 只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。 4 虚拟内存从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。 虚拟内存提供三个重要的能力： 它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。 它位每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。 虚拟内存的存在基础： 同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。 4.1 虚拟内存原理首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。 我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。 4.2 虚拟内存的结构在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。 页表：每个进程都有一个页表，页表将虚拟页映射到物理页。 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。 4.3 虚拟内存的地址翻译下面简单概括以下虚拟内存的地址翻译： 处理器产生一个虚拟地址，并将它传送给MMU MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3 由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4 现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。 下面我们介绍虚拟地址翻译中的一些细节： 什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？ 要解答这个问题，首先我们要介绍虚拟地址的格式。 虚拟页号 VPN 虚拟页偏移 VPO 页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。 PTE 是什么，它的结构是什么？ PTE 是页表条目，他的结构是这样的 SUP 有效位 READ 有效位 WRITE 有效位 PPN 物理页号 (Physical Page Number) 前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。 PPN 物理页号是什么呢？ 让我们回忆以下我们在介绍高速缓存时用到的物理地址 如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。 而标记位和组索引合起来就是PPN。 而块偏移和虚拟地址的虚拟页偏移VPO是一样的 因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。 快表TLB的工作原理是什么？ 快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址： 虚拟地址由VPN和VPO组成 虚拟页号 VPN 虚拟页偏移 VPO 而虚拟页号VPN又可以分为两部分： VPN VPN VPO TLB标记(TLBT) TLB索引(TLBI) VPO TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。 接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。 5 高速缓存系统和虚拟内存系统的对比高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统 虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统 存储在某个存储层，在存储层之间传输的单元叫做块(block) 在高速缓存SRAM中，它叫做高速缓存行，或者行 在主存DRAM中，它叫做块(block) 在虚拟内存系统中，它叫做页(page) 调度策略 高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小 DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大 6 技术总结在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。 有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。 我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。 B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n &#x3D; m + o。 现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。 由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？ 我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t &#x3D; m - i 位来作为标记，区分一组中的不同块。 通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 为什么使用中间位作为索引？ 如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。 接下来我们概括一下内存系统： 一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。 如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。 7 术语索引主存储器(main memory 主存) : 即通常理解的使用DRAM内存。 块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block) VM (Virtual Memory) 虚拟内存 VA(Virtual Address) 虚拟地址 MMU(Memory Management Unit)：内存管理单元，一种硬件 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 页表 ：一个数据类型位PTE的数组 PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型 页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging) 缺页：DRAM缓存不命中称为page fault 内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"CS:APP 读后感","slug":"CS-APP-读后感","date":"2022-09-02T06:23:07.000Z","updated":"2022-09-03T15:05:12.432Z","comments":true,"path":"2022/09/02/CS-APP-读后感/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"CS:APP 读后感这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的） 接下来会陆续更新各章的详细笔记 … 介绍目录： 第1章 计算机系统漫游--- 程序结构和执行第2章 信息的表示和处理第3章 程序的机械级表示第4章 处理器体系结构第5章 优化程序性能第6章 存储器的层次结构--- 在系统上运行程序第7章 链接第8章 异常控制流第9章 虚拟内存--- 程序间的交互和通信第10章 系统及I/O第11章 网络编程第12章 并发编程 本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。 剩下的十一章是本书的正式部分，我认为本书的核心在第 79 章，26章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。 分章介绍第二章 信息的表示和处理 这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。 2.1.3 寻址和字节顺序： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。 2.16 布尔代数介绍 ： 可以使用位向量来表示有限集合。 2.2 整数表示 ： 介绍了整数原码和补码的表示，以及他们之间的转换。 2.3 整数运算 ： 介绍了整数运算可能出现的错误，以及来源。 2.4 ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。 第三章 程序的机器级表示 相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。 这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。 从这一张开始到最后，才是一口气看完的。 3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了objdump 的使用 3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。 3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。 3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法 第四章 处理器体系结构 这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。 第五章 优化程序性能 呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。 客观一点就是 普通人日常写代码小技巧 第六章 存储器层次结构 没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。 第七章 链接 含金量高的来了 这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld 7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位 7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表 7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接 7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方 动态链接：与加载的时候链接的类型 库打桩机制 第八章 异常控制流 最重要的一章之一，介绍了并发编程的基础——异常控制流 介绍了进程，简单带领读者入门了并发编程 讲了信号，有助于以后学习事件驱动的GUI编程 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 8.2 异常 8.3 进程 8.4 用C语言操作进程：fork execve 8.5 信号 SIGINT … 第九章 虚拟内存 最重要的一章之一 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 本章可以分为三部分 第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的 第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve 第三部分介绍了一个内存分配器的实现( malloc() ) 第十章 系统级 I&#x2F;O 这一章读起来很简单，没有什么要理解的东西 首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。 然后着介绍了RIO包，即包装后的IO函数。 本章完 第十一章 网络编程 这一章需要理解的地方不多，只有介绍网络编程的部分 第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。 首先介绍了网络编程 接着介绍了Linux的套接字函数 最后实现了一个小web服务器 11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议 第十二章 并发编程 和上一章差不多的感觉 本章也分为三部分 首先介绍了实现并发编程的三种方法 进程 IO多路复用 线程 之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。 最后介绍了并发编程容易出现的问题：死锁、访问共享变量 …","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"ubuntu 配置","slug":"ubuntu-配置","date":"2022-09-02T02:49:51.000Z","updated":"2022-09-07T06:20:54.963Z","comments":true,"path":"2022/09/02/ubuntu-配置/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 配置2022&#x2F;9&#x2F;1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。 VScode 下载和配置下载的方法见官网，配置C&#x2F;C++的方法网上的博客也很好搜到 Linux系统VsCode 配置C&#x2F;C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境 接下来使将Open With Code 添加到右键菜单 这部分参考 ubuntu中为vscode添加右键菜单–网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com) 其中修改了一点命令，将visual-studio-code 改成了code 去$HOME/.local/share/nautilus/script/ 目录下新建一个文件，文件名就是显示在右键菜单上的名字。 接着将以下内容复制到新建的文件中 #!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&#x27;s directory if it&#x27;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &#x27;s/^file://////&#x27;`&quot;fi# It&#x27;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec code &quot;$destination&quot; 最后运行命令chmod +x 刚才创建的文件名 对文件或文件夹右键就可以看到刚才添加的右键菜单了。 下拉式终端Yakuka在这里 找到 Ubuntu 根据提示安装。 如果安装失败可能要换清华源，如下： 更换清华源 参考：https://blog.csdn.net/weixin_49700990/article/details/122005001 首先使用lsb_release -a 查看自己的Ubuntu版本 我们要更改的文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list， 首先使用命令对这个文件进行备份 sudo cp /etc/apt/sources.list /etc/apt/sources_save.list 接着 进入清华源网站 ，找到Ubuntu的源 ，选择合适的版本，根据提示手动替换即可。 设置应用开机启动在Ubuntu自带的 “启动应用程序” 里配置 更改磁盘大小 参考 https://blog.csdn.net/Shine_Su/article/details/124630751 首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。 将虚拟机的内容复制到虚拟机外 参考：https://blog.csdn.net/u013554213/article/details/124061526 依次执行以下命令，最后重启Ubuntu # 删除原来安装过的文件sudo apt autoremove open-vm-tools# 输入安装命令：sudo apt install open-vm-toolssudo apt install open-vm-tools-desktop 截图软件 https://zhuanlan.zhihu.com/p/415011610 sudo apt install flameshot 查看安装路径 which flameshot 在设置中，添加键盘快捷键 命令是/usr/bin/flameshot gui","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"}]},{"title":"数据结构课程","slug":"数据结构课程","date":"2022-08-23T03:50:55.000Z","updated":"2022-10-28T02:49:29.057Z","comments":true,"path":"2022/08/23/数据结构课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数据结构TODO： 初步：写好面向对象 要实现的数据结构： 顺序表 栈 队列 链表 循环链表 双向链表 游标实现 树 二叉树 AVL树 红黑树 堆 二叉堆 左式堆 二项队列 哈希表 高级数据结构 红黑树 … 隐式数据共享 想做到： 写成模板形式，可以尽可能向STL靠近，打包成静态库 树1.1 二叉树的性质 二叉树的第i层至多有2^i-1^ 个结点 深度为k的二叉树至多有2^k^ -1个结点 对任何一棵二叉树，若它含有n0 个叶子结点、n2 个度（出度）为 2 的结点，则必存在关系式：n0 &#x3D; n2+1。 推论：适用于Huffman树 对于有n0 个结点的Huffman树，它的总结点数为n0 + n2 &#x3D; 2n0 -1 具有n个结点的完全二叉树的深度为 floor(log2 n) + 1 cell()向上取整，floor向下取整 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：(1) 若 i&#x3D;1，则该结点是二叉树的根，无双亲， 否则，编号为floor(i/2) 的结点为其双亲结点； (2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点； (3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。 1.2 线索化：可以以线性的方式访问二叉树结构 1.2.1 中序线索树 对于中序线索树，我们约定： 它有两个存储左右子树标记的域，如果左子树的标记为0，那么它存储的是其左孩子，如果左子树的标记为1，那么它存储的是其中序遍历时的直接前驱. 如果右子树的标记为0，它存储的是其右孩子。如果右子树的标记为1，那么它存储的是中序遍历时的直接后继。 求中序线索树的前驱： 如果 左标记为1: 直接返回其左孩子否则: 返回其左子树的最右下的结点 求中序线索树的后继： 如果 右标记为1: 返回其右孩子否则: 返回其右子树的最左下的孩子 建立中序线索树 void InThreading(BiTree&amp; T)&#123; if(T) &#123; InThreading(T-&gt;lchild); if(!T-&gt;lchild) &#123; T-&gt;LTag=1; T-&gt;lchild=Pre; &#125; else T-&gt;LTag=0; if(!Pre-&gt;rchild) &#123; Pre-&gt;RTag=1; Pre-&gt;rchild=T; &#125; else Pre-&gt;RTag=0; Pre=T; InThreading(T-&gt;rchild); &#125;&#125; 1.3 一般的树和森林的表示：三种表示法： 父亲表示法（并查集的实现方法） 孩子表示法 孩子表示法（将一般的树或森林转换成二叉树） 让二叉树结点的左孩子指向这个一般的树的第一个孩子，右孩子指向下一个兄弟 1.4 一般的树和森林的遍历：树的遍历： 先根遍历（二叉树的先序遍历） 后根遍历（二叉树的中序遍历） 层次遍历","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"数字逻辑课程","slug":"数字逻辑课程","date":"2022-08-23T03:44:02.000Z","updated":"2022-11-09T08:05:53.414Z","comments":true,"path":"2022/08/23/数字逻辑课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数字逻辑课程进行中，持续更新 … 第一章 逻辑代数基础1.1 布尔代数也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。 · + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。 虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。 · 即合取，可以像乘号一样省略。 逻辑代数公理： 0 - 1 律 A + 0 = AA + 1 = 1A · 0 = 0A · 1 = A 重叠律 A + A = AA · A = A 互补律 A + ┐A = 1A · ┐A = 0 对合律 ┐┐A = A 交换律 结合律 分配律 A · (B + C) = AB + AC 与对或的分配A + BC = (A + B)(A + C) 或对与的分配 1.2 逻辑函数定义: 从n个逻辑变量到01的映射。记为F &#x3D; f(A1, A2, A3 … ) 逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式） 1.2.1 三种表示法： 逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成 真值表 卡诺图 用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。 挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。 1.2.2 两种标准形式最小项表达式：也叫积之和范式 或 主析取范式 最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。 最小项的表示： 对于n个变量而言，可以构成2的n次方个最小项。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。 对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 mi 来表示这个最小项表达式。 Q：为什么要使用1代表原变量，用0代表反变量？ A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi &#x3D; 1，而且这是唯一的。 例如m6 &#x3D; AB┐C，其顺序为110B &#x3D; 6D，令对应的逻辑变量为1或0，则m6 &#x3D; 1 · 1 · (┐0) &#x3D; 1 例如，最小项表达式 AB, 转换成二进制即11，表示为m3。 最小项表达式A┐B，转换成二进制即10，表示为m2。 最小项的性质： 对于任意一个最小项，只有一组变量取值可以使其值为1 任意两个最小项之积为0 n个变量的所有2^n^ 个最小项之和为1 将任意表达式转换为最小项表达式： 利用公式A = A(B + ┐B) 最小项表达式的性质： 性质1：若mi是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi&#x3D;1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。 性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F&#x3D;F1+F2 将包括 F1 和 F2 中的所有最小项， G&#x3D;F1·F2 将包括 F1 和 F2 中的公有最小项。 性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成 思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式 使用归谬法证明 第一次课到此结束 最大项表达式： 也叫和之积范式或主合取范式 定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。 举例： 二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B) 三变量最大项表达式： 最大项表达式的三条性质类似最小项表达式的三条性质： 对于任意一个最大项，只有一组变量取值可使其值为0。 任意两个最大项 Mi 和 Mj 之和必为1。 n 变量的所有2^n^ 个最大项之积必为0。 最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。 任意逻辑表达式转换成最大项表达式： 先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。 类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。 AB + A┐B, 而这种表达式被称为 “与 - 或”表达式 最大项表达式的性质也与最小项表达式类似： 性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi&#x3D;0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F&#x3D;F1+F2将包括F1和F2中的公有最大项， G&#x3D;F1·F2将包括F1和F2中的所有最大项。 性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。 1.2.3 逻辑函数的三种表示法的关系用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。 同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。 从上一节的学习，我们知道逻辑函数有三种表示法： 逻辑表达式 真值表 卡诺图 首先，逻辑表达式形式都可以化成标准形式。 接着我们来看真值表与逻辑表达式的关系（最大&#x2F;小项表达式也是逻辑表达式）： 还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。 最大项表达式与最小项表达式恰恰相反： 最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。 最后我们来看一下卡诺图与真值表的关系： 卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合： ——————————————A B | F——————————————0 0 | 00 1 | 11 0 | 11 1 | 0—————————————— 它是一维的 线性的。 而卡诺图则二维的： 将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。 将项的组合换成数字的组合，我们得到卡诺图的简化形式 需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。 下面给出一个逻辑函数的卡诺图表示的例子： 补充：格雷码 https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 1位格雷码有两个码字 (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 2位格雷码 3位格雷码 4位格雷码 4位自然二进制码 00 000 0000 0000 01 001 0001 0001 11 011 0011 0010 10 010 0010 0011 110 0110 0100 111 0111 0101 101 0101 0110 100 0100 0111 1100 1000 1101 1001 1111 1010 1110 1011 1010 1100 1011 1101 1001 1110 1000 1111 第二次课结束 1.3 主要定理 &amp; 常用公式1.3.1个主要定理德摩根律： 当变量个数较少的时候，可以使用真值表法证明。 当变量较多的时候，使用数学归纳法证明。 香农定理： 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。 注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。 对偶定理: 对偶函数的定义： 将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数 设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) 则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) &#x3D; f (x1, x2, … , xn, 1, 0, ·, 1) 对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。 两个推论： 原函数与其对偶函数互为对偶函数。 两个相等的函数（f &#x3D; g）的对偶函数必定相等（f ‘ &#x3D; g ‘） 自对偶函数：一个函数的对偶函数等于它自己。 展开定理： 两个推理： 展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16 1.3.2 5个常用公式 AB + A┐B &#x3D; A 在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。 A + AB &#x3D; A 在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。 还可以写成ABC + ABCDE &#x3D; ABC A + ┐AB &#x3D; A + B 在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。 ┐C + CE &#x3D; ┐C + E AB + ┐AC + BC &#x3D; AB + ┐AC 包含律 在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。 AB + ┐AC + BCDE &#x3D; AB + ┐AC ┐(A┐B + ┐AB) &#x3D; ┐A┐B + AB 两个变量的异或的反 是 两个变量的同或 上面5个公式的对偶形式也是成立的 1.3.3 异或的性质A ⊕A &#x3D; 0 A⊕┐A &#x3D; 1 A⊕0 &#x3D; A A⊕1 &#x3D; ┐ A 重要 A⊕┐ B &#x3D; A ⊙ B &#x3D; A⊕B⊕1 A⊕B &#x3D; B⊕A 交换律 A⊕(B⊕C) &#x3D; （A⊕B) ⊕C 结合律 A(B⊕C) &#x3D; AB⊕AC 分配律 第三次课到此结束 1.3.4 应用一、转化称其他形式（详见P20） “与或” 表达式转 “或与”表达式 法一：分配律 法二：展开定理 “与或” 表达式 转 “与非 - 与非” 表达式 “与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式 或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可 因此我们的步骤是：两次取反，内层非用德摩根律断开 “与或” 表达式 转 “或非 - 或非” 表达式 “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 二、最大项表达式和最小项表达式的关系 ┐mi &#x3D; Mi 或 mi &#x3D; ┐Mi mi’ &#x3D; Mj，且i + j &#x3D; 2 ** n - 1 原函数 ​ – 变换 –&gt; 最小项表达式 ​ – 一次取反 –&gt; 符号错开，但保持最小项表达式，反函数的最小项表达式 或 或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式 ​ – 二次取反 –&gt; 原函数的最大项表达式（和原函数最小项表达式符号错开） 将最大项表达式或最小项表达式变成对偶函数： 首先将最大项变成最小项，或最小项变成最大项 其次将序号变成互补的序号 1.4 逻辑函数的化简 逻辑函数最简式的定义： 该式中乘积项最少 该式中的乘积项不能再用变量更少的乘积项代替 化简方法: 代数方法 卡诺图法 列表化简法 1.4.1 卡诺图法第四次课到此结束 基本原理：ABC + ┐ABC &#x3D; (A + ┐A)BC &#x3D; BC 反映在卡诺图上，就是相邻的两个格可以构成一个圈。 n变量的卡诺图，任何2^m^ 个标1的相邻单元可以形成一个圈，改圈所代表的乘积项由n-m个变量组成，可以消去m个变量。 名词解释： 蕴含项：最小项，以及2^m^ 个相邻单元所形成的圈组成的项。 素项：不是其他蕴含项子集的蕴含项。 实质素项：包含某一最小项，该最小项只被该素项包含。 化简方法： 作出卡诺图，找出全部素项 找出全部实质素项 若有未被覆盖的最小项，找出一个可以包含该最小项的蕴含项，将其添加到实质素项集合中。 得到的集合，写成代数形式，即是化简结果。 第二章 组合电路的分析2.1 各种门电路或门 与门 非门 与非门 或非门 与或非门 异或门 三态门 三态门真值表： E A F 0 0 0 0 1 1 1 任意 高阻抗 第五次课结束 2.2 门电路的主要参数以及组合电路的分析方法门电路的主要参数： 标称逻辑电平：表示逻辑值01的理想电平 扇入系数：门电路允许的输入端数目 若使用的输入端数目比扇入系数小，则多余的输入端再不改变电路逻辑功能的情况下接高电平或低电平 扇出系数：一个门电路输出端所连接的下一级输入端的个数 平均时延 组合电路的分析方法： 给定组合线路 列写逻辑表达式 列真值表 指出线路的逻辑功能 对线路进行评价和改进 2.3 全加器符号表示： A 被加数 B 加数 Ci-1 低位向高位的进位 S 和 全加器的逻辑符号： S &#x3D; A⊕B⊕Ci-1 ​ &#x3D; ∑(1, 2, 4, 7) C &#x3D; AB+(A⊕B)Ci-1 &#x3D; AB+(A+B)Ci-1 ​ &#x3D; ∑(3, 5, 6, 7) 2.4 译码器几种常见的十进制数在二进制下的编码： 8421码：顾名思义，就是十进制数转直接转换成二进制数（范围是0000-1001） 格雷码：相邻的格雷码只有一个位不同 8421转格雷码：Gi&#x3D;B⊕Bi+1 (i &lt;&#x3D; n-1); Gi &#x3D; Bi (i &#x3D; n) 余三码：8421码+3得到余三码（范围是0011-1100） 十进制数 8421 格雷码 余三码 0 0000 0000 0011 1 0001 0001 0100 2 0010 0011 0101 3 0011 0010 0110 4 0100 0110 0111 5 0101 0111 1000 6 0110 0101 1001 7 0111 0100 1010 8 1000 1100 1011 9 1001 1101 1100 第五次课结束 不同的译码器： 三位译八位译码器（多一译码）：从三位二进制数中，翻译出他们的最小项表达式。 高电平译重：翻译出来的那个最小项的电平是高电平 低电平译重：翻译出来的最小项的电平是低电平 如果使用与非门实现译码器，使用低电平译重可以节省非门 2.5.格雷码转8421码：利用异或的性质，一个逻辑表达式异或同一个逻辑表达式两次，等于原逻辑表达式 已知从8421码到格雷码的转换有： G0 &#x3D; B0 ⊕ B1 G1 &#x3D; B1 ⊕ B2 G2 &#x3D; B2 ⊕ B3 G3 &#x3D; B3 则根据异或的性质 B3 &#x3D; G3 已知 G2 &#x3D; B2 ⊕ B3 已知 G2 &#x3D; B2 ⊕ G3 （2） G3 ⊕ G2 &#x3D; B2 ⊕ G3 ⊕ G3 两边同时异或G3 B2 &#x3D; G2 ⊕ G3 异或的性质，消去两个G3 于是我们有： 从格雷码到8421码： B3 &#x3D; G3 B2 &#x3D; G2 ⊕ G3 B1 &#x3D; G1 ⊕ G2 ⊕ G3 B0 &#x3D; G0 ⊕ G1 ⊕ G2 ⊕ G3 2.6 奇偶校验器分为奇校验和偶校验： 我们有一个n位二进制数和一个校验位p 奇校验：n位二进制数和p中，1的个数是奇数 偶校验：n位二进制数和p中，1的个数是偶数 奇偶校验的原理： n个二进制数异或，如果他们中1的数目是奇数，则结果为1 这个原理可以使用数学归纳法证明 一个逻辑变量异或1等于它的非 一个逻辑变量异或0等于它本身 下面以奇校验为例： 生成校验位: p &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ 1 校验 is_valid &#x3D; B8 ⊕ B4 ⊕ B2 ⊕ B1 ⊕ P 偶校验 p &#x3D; B8 ⊕B4 ⊕B2 ⊕B1 校验 is_valid &#x3D; B8 ⊕B4 ⊕B2 ⊕B1⊕p⊕1 第三章 组合线路的设计设计流程： 确定逻辑功能 列真值表（也就得到了最小项表达式） 根据卡诺图化简逻辑表达式 按照设计要求变换逻辑表达式 考虑工程问题 3.1 逻辑函数的变换与或变与非： 两次取反，中间DM断开 对F的反函数，三次取反（可以理解为四次取反，怎样好用用那个） 与或非： 两次取反，不断开 对反函数一次取反 或非 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 对F两次求对偶函数 第六次课结束 3.2 利用任意项的线路设计任意项定义：是的约束方程推的逻辑值为0的最小项，也称无关项。 任意项再当前约束条件下的逻辑值必定为0，因此我们将任意项和原函数进行或运算，不影响原函数的取值。 任意项在卡诺图或真值表中，用φ表示，将它在卡诺图中画出来可以方便形成更大的圈，从而简化得到的逻辑表达式。但我们使用真值表化简带有任意项的逻辑函数时，不必考虑任意项是否被圈全部包含，只需要考虑逻辑函数的最小项。 3.3 多输出函数的线路设计（需要考虑共享项）当我们有多个逻辑函数，共享输入时，我们需要从全局出发考虑，看是否有可以共享的项目，从而减少要使用的逻辑器件。 考虑共享项的最小覆盖修改原则： 若Fi的一个素项Bk也是Fj的一个素项，则Bk不作修改，除非修改后能减少总圈数。 若Bi、Bj分别是Fi、Fj的素项，且Bi、Bj都包含一个蕴涵项Bk,在选取Bk后，Bi、Bj中余下的最小项均分别包含在Fi、Fj其它素项中，则在Fi、Fj中改选Bk 示例： Fi的一个素项Bi，中的一些最小项分别被Fj, Fj+1, … , Fj+m中的素项Bj, Bj+1 , … , Bj+m覆盖，且Bj, Bj+1, … , Bj+m ⊆ B, 若在Fi中选取Bj,Bj+1, …, Bj+m 后，Bi中余下的最小项均包含在的其它素项中，则将Bi改选为Bj, Bj+1, …, Bj+m 示例： 第七次课到此结束 3.4 应用MSI功能块的组合线路设计SSI：小规模集成电路 MSI：中规模集成电路 利用数据多路选择器进行设计 首先要知道数据多路选择器的原理 f &#x3D; a0┐x0┐x1 + a1┐x0x1 + a2x0┐x1 + a3x0x1 设计步骤： 首先，对于给定n变量的逻辑函数，我们选择N &#x3D; 2^n-1^ 路数据选择器 选定n-1个变量作为地址输入，作为数据选择器的控制端，根据选择的地址输入，确定数据选择器输入端的各表达式输入 对于如何确定数据选择器输入端的各表达式，我们可以使用代数方法得到，也可以使用卡诺图方法得到。 利用译码器进行线路设计 将对应逻辑表达式转换为最小项表达式，直接将译码出来的最小项用或门连接（高电平译中）或用与非门连接（低电平译中），输出即可。 第八次课到此结束 第四章 时序电路的分析4.1 触发器的外特性4.1.1 基本触发器基本触发器通过其电路的设计，可以具有存储二进制位的功能，其电路就是存储器，而不是有单独的存储器。 基本触发器有两个稳态，分别表示0和1。当基本触发器（RD ，SD）输入 1，1时，基本触发器里存储的位被保持输出，当输入0，1时，基本触发器被置零，当输入1，0时，基本触发器被置一，当输入0，0时不能确定输出的是当前存储的状态，还是其他状态。因此不能输入0。 基本触发器的RD 和SD 端都是低电平有效，R端是Reset重置，置零端，S端是Set，置一端。 基本触发器的特征表达式 ┐RD┐ SD &#x3D; 0 (RD 和SD 不能同时为0) Q^n+1^ &#x3D; ┐SD + RD Q 4.1.2 RS触发器 电位触发，高电位时触发 五个输入端，RD , SD ，R, S, CP CP只有在为1时才有效，CP为0时保持。 特征方程： Q^n+1^ &#x3D; S + ┐RQ 4.1.3 D 触发器 边缘触发器，正跳变触发 关于电位触发和边缘触发： 边缘触发：输出不能迟于触发信号到达，但触发信号已到达，输入信号就可以撤下来 电位触发：输入信号可以迟于触发电位到达，但在触发电位变回非触发电位前，输入信号不能改变 Q^n+1^ &#x3D; D 4.1.4 JK 触发器 边缘触发器，负跳变触发 Q^n+1^ &#x3D; J ┐Q^n^ + ┐K Q^n^ 当J，K同为0时，输出Q 当J，K同为1时，输出┐Q 当J，K相异时，输出 J 4.1.5 T触发器 边缘触发器，负跳变触发 Q^n+1^ &#x3D; T┐Q^n^ + ┐TQ^n^ 当T为0时，输出Q 当T为1时，输出┐Q 第九次课到此结束 4.2 时序电路的分析方法 列些输出函数和控制函数表达式 输出函数：线路的外输出函数（z） 控制函数：向存储元件的输入 建立次态表达式及状态转移表 建立状态表及状态图 画波形图（optional） 说明时序线路的功能 异步电路分析： 写出输出函数和控制函数和每个触发器的CP端 建立次态表达式，次态表达式要将CP写进去，注意，不同触发器CP为一的条件不同 建立状态转移，如果输入信号是脉冲信号，那么输入信号为一代表打一个脉冲，而非输入信号恒唯一。 建立状态表和状态图 画波形图 说明时序电路功能 第十&amp;十一次课到此结束 4.3 同步时序电路的设计同步时序电路设计的一般步骤： 根据问题的描述，建立原始的状态表 使用隐含表法（下三角矩阵）化简原始状态表 对最简状态表进行编码，建立编码状态表 画出真值表（包括外部输入，现态，次态，控制函数，输出） 根据真值表写出触发器的控制函数 设计组合线路，考虑工程问题 4.3.1 关于状态的化简两个状态可以合并的条件： 在所有不同的输入下，输出均相同且满足以下条件 两个次态完全相同 两个次态为其现态的交错 两个次态的某一后续状态对可以合并 两个次态为状态对封闭链中的一个状态对。 本课程结束","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"BallMove:基于Qt的GUI小项目","slug":"BallMove-基于Qt的GUI小项目","date":"2022-08-21T11:46:01.000Z","updated":"2022-09-29T10:22:02.774Z","comments":true,"path":"2022/08/21/BallMove-基于Qt的GUI小项目/","link":"","permalink":"https://cfla1638.github.io/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"BallMove:基于Qt的GUI小项目简介在暑假学科目二的时候，看着 Qt学习之路2 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。 今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。 这个项目基于QGraphicsScene + QGraphicsItem + QGraphicsView， 模拟了一个小球在现实世界中的运动。 项目地址：cfla1638&#x2F;BallMove 设定功能：实现了实心球的运动。 考虑的因素有： 用户给予的加速度 重力 摩擦力 空气阻力 细节： 该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg &#x2F; m^3^ 。 重力加速度为 9.8 m&#x2F;s^2^ 。 静摩擦系数为 0.3。 空气阻力使用公式：F &#x3D; 1&#x2F;2 * CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 * 0.04^2^ 。 尺寸换算：1m &#x3D; 250px。 基础知识 Qt的绘制系统由QGraphicsScene + QGraphicsItem + QGraphicsView 相互配合使用。 QGraphicsScene 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。 QGraphicsItem 是在QGraphicsScene 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到QGraphicsScene，进行显示和管理。 QGraphicsView 提供了一个观察的视角，配合QGraphicsScene 进行显示。这个类可以被设为QMainWindow 的CentralWidget。 只有QObject 的子类可以使用信号槽的机制 QTimer类提供计时器功能，使用timer.start(sec) 功能开始计时，这里timer是一个QTimer类的一个对象，每经过sec时间后，timer就会发出一个timeout() 信号。 想要实现物体的运动，就要让物体的位置在每一帧里进行改变&#x2F;刷新（本程序的帧率是120），而QGraphicsScene 提供一个advance() 函数，该函数会调用所有在场景里的QGraphicsItem 对象的advance() 函数，因此我们只要每经过 1000 &#x2F; 120 毫秒 就调用一次QGraphicsScene::advance() 函数，就可以进行场景刷新，从而实现物体的运动。 每个QGraphicsItem::advance(int phase) 都会被一个QGraphicsScene::advance() 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase &#x3D; 0。第二次QGraphicsScene::advance() 将phase &#x3D; 1 传入函数并调用。 基于此，我们只需要在phase &#x3D; 1是进行处理，phase &#x3D; 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。 Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在QGraphicsScene 中的全局坐标系，它记录了每个QGraphicsItem 的位置。第二个是每个QGraphicsItem 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。 每个继承了QGraphicsItem 的类都要重载以下四个函数。 QRectF boundingRect() const;QPainterPath shape() const;void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);void advance(int phase); boundingRect() 返回一个包裹住QGraphicsItem 对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。 shape() 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) 该函数一般由QGraphicsScene 自动调用，绘制该项目。 这个函数一般这样写 void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); // 保存画笔状态 //设置新的画笔状态 painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); // 绘制图型 painter-&gt;restore(); // 还原画笔状态&#125; 我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。 painter-&gt;fillPath(shape(), Qt::blue); 这一行绘制我们在shape() 中返回的图型，在此之前我们可以设置画笔的状态。 编写头文件的建议 如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。 为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。 即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。 项目设计首先来看一下运行效果： 在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象另外，这棵树也为我们展示了本项目的设计思路。└─MainWindow ├─Controller │ ├─Ball │ ├─Balldata │ ├─Ground │ └─QGraphicsScene - Reference ├─QGraphicsScene └─QGraphicsView 自下而上，首先来看Controller下的三个类， Controller下有三个类，分别是Ball, Balldata, Ground，他们都是QGraphicsItem 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。 这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。 值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。 接着是Controller类。 顾名思义，Controller类是我们程序的控制器。 Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。 最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。 当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的QMainWindow::show() 和 QApplication :: exec() 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。 项目实现文件结构首先看一下我们的文件结构 BallMove - BallMove.pro Headers - ball.h - balldata.h - constants.h - controller.h - ground.h - mainwindow.h Sources - ball.cpp - balldata.cpp - controller.cpp - ground.cpp - main.cpp - mainwindow.cpp Ball类的实现首先看一下ball类的实现 class Ball : public QGraphicsItem&#123;public: Ball(qreal x, qreal y); QRectF boundingRect() const; QPainterPath shape() const; void advance(int phase); QPointF getPos()&#123;return pos();&#125; int forceCount = 4; qreal a[2][4]; qreal vx = 0; qreal vy = 0;protected: void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);&#125;; 首先我们来看Ball类的私有变量： 由于我们运动的平面是二维的，因此我们使用一个二维数组qreal a[2][4] 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即a[xAxis][AirResistance] 。如果想要引用y方向的重力加速度，就使用a[yAxis][Gravity] 。 qreal vx, vy 即小球的x方向速度，和y方向的速度。 int forceCount 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。 接着我们来看一下Ball类中声明的函数: 第一个函数getPos()很好理解，即返回小球在全局坐标系中的坐标。 接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：paint() shape() advance() boundingRect() boundingRect : QRectF Ball::boundingRect() const&#123; return QRectF(-BALL_SIZE * 2, -BALL_SIZE * 2, BALL_SIZE * 4, BALL_SIZE * 4); &#125; QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。 BALL_SIZE 定义在constants.h 代表小球的直径。 shape() : QPainterPath Ball::shape() const&#123; QPainterPath path; path.addEllipse(QPointF(0, 0), BALL_SIZE / 2, BALL_SIZE / 2); return path;&#125; 这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。 paint() ： void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); painter-&gt;restore();&#125; 在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。 advance() ： void Ball::advance(int phase)&#123; // 只有phase为1时进行处理 if (!phase) return ; // 计算合力 qreal sumAx = 0, sumAy = 0; for (int i = 0; i &lt; forceCount; i++) &#123; sumAx += a[xAxis][i]; sumAy += a[yAxis][i]; &#125; if (sumAx) vx += (sumAx / FRAME_RATE); if (sumAy) vy += (sumAy / FRAME_RATE); qreal x = fmod(pos().rx() + vx / FRAME_RATE, 1000), y = fmod(pos().ry() + vy / FRAME_RATE, 1000); // 处理小球越界 if (x &lt; 0) x += 1000; if (y &lt; BALL_SIZE / 2) y = BALL_SIZE / 2; // 设置新位置 setPos(QPointF(x, y)); update(); // 更新显示小球&#125; 由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。 在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。 需要注意，一、因为我们的速度、加速度定义为m&#x2F;s和m&#x2F;s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。 二、在设置了小球的位置之后，需要使用update() 函数更新小球的位置。 constants.h 参数存储文件constants.h 文件中存放了项目的各种参数 const int FRAME_RATE = 120; // 帧率：120帧 帧率过低时碰撞会穿透地面const int BALL_SIZE = 20; // 球的直径：20px// 400 对应 112 重力// 3000 对应 2450 重力const int X_SPEED = 1500; // 左右键给球的加速度const int Y_SPEED = 3000; // 上下键给球的加速度const int FRICTION = 735; // 摩擦力大小const int FRICTION_SENSITIVITY = 2; // 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力// 112 对应1.75 米的人// 2450 对应 8cm 的实心球const int GRAVITY = 2450; // 重力大小const double M = 2.1038; // 小球质量enum Directions&#123;xAxis, yAxis&#125;; // x, y轴方向enum Force&#123;User, Gravity, Friction, AirResistance&#125;; // 力的四个维度，用户给出的力，重力，摩擦力，空气阻力 需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。 Balldata &amp; ground这两个类都继承了QGraphicsItem 和Ball类类似，因此我们不在赘述。 Controller类首先看一下Controller类的定义 class Controller : QObject&#123; Q_OBJECTpublic: Controller(QGraphicsScene &amp; scene, QObject * parent = 0); void track(bool); void gravity();public slots: void drawLineOfTrack(); void resume(); void pause(); void advance();protected: bool eventFilter(QObject *atched, QEvent *event);private: void handleKeyPressed(QKeyEvent * event); void handleKeyReleased(QKeyEvent * event); QTimer timer; Ball * ball; QGraphicsScene &amp; scene; Ground * ground; ballData * data;&#125;; Controller类有以下几点功能： 处理键盘事件：如上下左右移动，打开&#x2F;关闭 轨迹显示，清屏。 相关地函数有： bool eventFilter(QObject *atched, QEvent *event);void handleKeyPressed(QKeyEvent * event);void handleKeyReleased(QKeyEvent * event); 控制程序的开始与结束 相关地函数有： void resume();void pause(); 控制程序的一步步地推进，即让小球动起来。 相关地函数有： void advance(); 其他功能 相关地函数有： void track(bool);void gravity();void drawLineOfTrack(); 在这里我们只介绍advance() 函数 void Controller::advance()&#123; scene.advance(); // 首先调用场景的advance() // 获取碰撞信息 static bool lastStatus = false; // 上一帧是否碰撞 static bool nowStatus = false; // 当前是否处于碰撞 nowStatus = ball-&gt;collidesWithItem(ground); //处理碰撞 if (nowStatus == true &amp;&amp; lastStatus == false) &#123; ball-&gt;a[yAxis][Gravity] = 0; // 碰撞时重力与支持力抵消 ball-&gt;vy = -(ball-&gt;vy * 0.667); // 回弹 2/3 的速度 ball-&gt;a[yAxis][User] = 0; // 竖直方向速度为0 &#125; // 处理摩擦力 if (nowStatus) &#123; if (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION; else if (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION; else ball-&gt;a[xAxis][Friction] = 0; &#125; // 没有碰撞的时候 if (!nowStatus) &#123; // 摩擦力置零 ball-&gt;a[xAxis][Friction] = 0; ball-&gt;a[yAxis][Gravity] = GRAVITY; &#125; // 处理空气阻力 qreal sumV = pow(ball-&gt;vx, 2) + pow(ball-&gt;vy, 2); if (fabs(sumV) &gt; 10) &#123; qreal airSum = 0.0009744 * sumV / 250; if (sumV == 0) sumV = 1; ball-&gt;a[xAxis][AirResistance] = (fabs(ball-&gt;vx) / (sqrt(sumV))) * airSum; ball-&gt;a[yAxis][AirResistance] = (fabs(ball-&gt;vy) / (sqrt(sumV))) * airSum; // 将力换算成加速度 ball-&gt;a[xAxis][AirResistance] /= M; ball-&gt;a[yAxis][AirResistance] /= M; if (ball-&gt;vx &gt; 5) ball-&gt;a[xAxis][AirResistance] *= -1; else if (ball -&gt; vx &lt; 10) ; else ball-&gt;a[xAxis][AirResistance] = 0; if (ball-&gt;vy &gt; 5) ball-&gt;a[yAxis][AirResistance] *= -1; else if (ball -&gt; vy &lt; 10) ; else ball-&gt;a[yAxis][AirResistance] = 0; &#125; lastStatus = nowStatus; data-&gt;update(); // 更新数据显示&#125; 由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。 等运动结束之后，我们使用Qt地碰撞检测函数collidesWithItem()看小球是否接触地面。 接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。 其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。 MainWindow 类MainWindow类的代码如下 class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void adjustViewSize();private: void initScene(); QGraphicsView * view; QGraphicsScene * scene; Controller * controller;&#125;; 唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), scene(new QGraphicsScene(this)), view(new QGraphicsView(scene, this)), controller(new Controller(*scene, this))&#123; setCentralWidget(view); resize(750, 750); initScene(); QTimer::singleShot(0, this, SLOT(adjustViewSize()));&#125; 在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的centralWidget 并调整了窗口大小。 在倒数第二步，调用initScene 对scene进行调整。 以上的这些步骤都不会有什么问题，只有最后一步令人困惑： QTimer::singleShot(0, this, SLOT(adjustViewSize())); 首先解释singleShot() 函数，这个函数的声明如下 void QTimer::singleShot(int msec, const QObject *receiver, const char *member) 它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。 那么为什么要使用这个功能呢？ 这里有两个解释 那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数。这就是为什么我们需要用QTimer而不是直接调用adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的callLater()函数。 这个解释来自《Qt学习之路2》 但我并不清楚这里的 “下一次事件循环” 的意思。 依我的理解，应该是这个意思：某个QObject 发出 paintEvent() 事件，但对这个事件的处理比较耗时，如果此时直接调用adjustViewSize() ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用adjustViewSize() ，我们会发现视图小小的挤在屏幕的中间。 后来我又在网上发现了这篇博客：QTimer::singleShot(0, this, slot函数)； ，意思和我理解的大概相似。 但还是挖个坑，等我以后学精了一定回来解释清楚。 参考C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范 Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World","categories":[{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]},{"title":"配置博客","slug":"配置博客","date":"2022-08-20T14:58:00.000Z","updated":"2022-08-21T12:05:04.405Z","comments":true,"path":"2022/08/20/配置博客/","link":"","permalink":"https://cfla1638.github.io/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"博客配置 &amp; 使用教程简介该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。 本文章记录了配置博客和使用博客的一些细节，供以后的我参考。 持续更新中 …… 工作原理在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。 基本命令 调试： hexo server --debug 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面 修改&#x2F;发布博客 进行更新： hexo clean 清理缓存和public文件夹 hexo g generate，生成静态页面，该操作之后即可在本地预览。 hexo d deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。 发布博客 hexo new [layout] [title] 使用layout，在_post&#x2F;title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。 配置文件 可以在 _config.yml 里配置Hexo，在 _config.nexmoe.yml 里配置nexmoe主题。 _config.yml : 配置 网站的标题、副标题、关键词、作者、语言、时区 部署设置，其中repository可以填ssh的链接（执行git clone 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。 _config.nexmoe.yml： 网站的默认头图，头像，图标等均在这里配置。 如果要使用本地相对路径，./ 的绝对路径即博客根目录下的source文件夹。 front-matter在这里可以配置文件的变量。 hexo 的文档：Front-matter | Hexo nexmoe 的私有 front-matter 文档：Front-matter | Hexo Theme Nexmoe 如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900 --title: &lt;title&gt;others...cover: 图片链接--- 配置分类和标签要像这样配置： categories:- Diarytags:- PS3- Games 其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见这里 widgets 关于 “文件归档”：归档页面 | Hexo Theme Nexmoe 关于 “关于博客”：是./ 目录下的一个markdown文件，与其他博文相同。 其他部件可以在_config.nexmoe.yml 里配置 评论系统nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 Valine ，使用方法非常简单，按照Valine的官方手册一步步操作即可。 资源iconfont-阿里巴巴矢量图标库 参考文档Hexo参考文档 Nexmoe 参考文档 nexmoe GitHub地址 从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"琐碎记录","slug":"琐碎记录","permalink":"https://cfla1638.github.io/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"},{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://cfla1638.github.io/tags/C-C/"},{"name":"cmake","slug":"cmake","permalink":"https://cfla1638.github.io/tags/cmake/"},{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]}