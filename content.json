{"meta":{"title":"cfla's blog","subtitle":"","description":"","author":"cfla","url":"https://cfla1638.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-08-20T23:36:33.219Z","updated":"2022-08-20T14:43:28.978Z","comments":true,"path":"Archives.html","permalink":"https://cfla1638.github.io/Archives.html","excerpt":"","text":""},{"title":"关于博客","date":"2022-08-20T16:00:00.000Z","updated":"2022-09-02T05:08:53.737Z","comments":true,"path":"about.html","permalink":"https://cfla1638.github.io/about.html","excerpt":"","text":"关于博客建站日期：2022 年 8 月 20 日 About Blog建立一个自己的博客站，最主要的目的是记录自己在计算机这条路上学到的知识。 写下这些内容的时候是大二，在大一时，我看了好多本计算机专业的书，比如《C++ Primer》，《C Primer Plus》。 暑假的时候我学了Qt，用到 C++ 的 OOP 时，我才意识到自己之前学到的知识是不牢固的。刚看完的书，没有经过实践，就是不能变成自己的东西。但我又不能将所有的内容都去实践。因此我决定为看过的计算机类的书籍都写读书笔记，内容主要是看完这本书的感受，学到的东西。就像操作系统切换进程需要保存上下文一样，将对这本书印象最深时的 “上下文” 保存下来，等以后需要的时候能够快速开始。 同样的道理，也适用于刚做完的项目，刚配置好的系统 … 因此，我的博客将记录自己在计算机领域学到过的、实践过的知识 以及 解决问题的经验。 About me 计算机科学与技术专业 内向的、焦虑的、热爱学习、向往未来的 OTAKU"}],"posts":[{"title":"存储器层次结构 - CS:APP 第六章","slug":"存储器层次结构-CS-APP-第六章","date":"2022-09-04T03:28:41.000Z","updated":"2022-09-05T14:27:05.518Z","comments":true,"path":"2022/09/04/存储器层次结构-CS-APP-第六章/","link":"","permalink":"https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"存储器层次结构本章的主要内容有四： 介绍存储技术 介绍存储器的层次结构思想 特别介绍高速缓存的原理和细节 使用局部性优化程序的性能 本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。 1 存储器的层次结构根据我们的经验观察，读取速度越快的存储器&#x2F;存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。 因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。 但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。 存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。 L0 寄存器L1 L1高速缓存 SRAML2 L2高速缓存 SRAML3 L3高速缓存 SRAML4 主存 DRAML5 本地二级存储（本地磁盘）L6 远程二级缓存（分布式文件系统、二级服务器） 下面我们介绍它们的存在基础，存储技术。 2 存储技术我们要介绍的存储技术如下 随机存储器RAM SRAM DRAM 非易失性存储器 ROM PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） SSD （基于闪存，固态硬盘就是使用SSD技术） 磁盘 2.1 随机访问存储器随机存储器分为两种材类：SRAM和DRAM SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。 DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。 2.1.1 DRAM &#x2F; 内存的工作原理内存由若干个DRAM芯片构成，被称作内存模块(memory module) 每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。 每个超单元内存储若干个位，一般是一字节八位。 内存/主存||- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片|- 内存模块| |- DRAM 芯片| |- DRAM 芯片| |- DRAM 芯片 首先介绍DRAM 芯片： DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c &#x3D; d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。 我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。 接下来看一下工作流程： 首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。 接着介绍内存模块： 一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 2.2 磁盘 &amp; ROMROM可分为 PROM 可编程ROM EPRROM 可擦可写可编程ROM flash memory 闪存（基于EPRROM） 我们不多介绍，只需要知道他们的名字和依赖关系即可 磁盘：通常指的是机械硬盘，也不过多介绍。 3 高速缓存首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍： 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。 而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。 数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。 以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。 令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。 这句话暂且悬置。 当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。 但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。 3.1 高速缓存的结构 一个计算机存储器的地址有m位，他被分为三部分： 高t位是标记位 中间s位是组索引位 低b位是组偏移位。 高速缓存被组织为这样的结构： 高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1 每个组中最多有2^t^ 个高速缓存行 每个高速缓存行也由三部分组成 一位有效位，标记着这个高速缓存行是否有效 t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行 2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用 3.2 高速缓存的工作原理当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。 确定是否命中有三个步骤： 组选择 行匹配 字抽取 组选择 回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。 行匹配 如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。 如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。 补充 : 我们先回忆一下地址的构成 标记位 t + 索引位 s + 偏移位b 假设有一个四位的地址，t &#x3D; 1，s &#x3D; 2，b &#x3D; 1 这四位地址的所有组合如下： 我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。 我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。 这样我们较低层的 0、4 映射到了较高层的0组， 1、5映射到了1， 2、6映射到了2， 3、7映射到了3 一个组中可以有最多2^t^ 行，如果我们一组中只有一行。 如果我们首先引用了块0，那么块0每放在较高层的组0， 接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。 通过上面的例子，我想说明两点 一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。 二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？ 注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。 其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。 字抽取 只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。 4 虚拟内存从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。 虚拟内存提供三个重要的能力： 它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。 它位每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。 虚拟内存的存在基础： 同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。 4.1 虚拟内存原理首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。 我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。 4.2 虚拟内存的结构在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。 页表：每个进程都有一个页表，页表将虚拟页映射到物理页。 快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。 4.3 虚拟内存的地址翻译下面简单概括以下虚拟内存的地址翻译： 处理器产生一个虚拟地址，并将它传送给MMU MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3 由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4 现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。 下面我们介绍虚拟地址翻译中的一些细节： 什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？ 要解答这个问题，首先我们要介绍虚拟地址的格式。 虚拟页号 VPN 虚拟页偏移 VPO 页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。 PTE 是什么，它的结构是什么？ PTE 是页表条目，他的结构是这样的 SUP 有效位 READ 有效位 WRITE 有效位 PPN 物理页号 (Physical Page Number) 前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。 PPN 物理页号是什么呢？ 让我们回忆以下我们在介绍高速缓存时用到的物理地址 如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。 而标记位和组索引合起来就是PPN。 而块偏移和虚拟地址的虚拟页偏移VPO是一样的 因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。 快表TLB的工作原理是什么？ 快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址： 虚拟地址由VPN和VPO组成 虚拟页号 VPN 虚拟页偏移 VPO 而虚拟页号VPN又可以分为两部分： VPN VPN VPO TLB标记(TLBT) TLB索引(TLBI) VPO TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。 接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。 5 高速缓存系统和虚拟内存系统的对比高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统 虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统 存储在某个存储层，在存储层之间传输的单元叫做块(block) 在高速缓存SRAM中，它叫做高速缓存行，或者行 在主存DRAM中，它叫做块(block) 在虚拟内存系统中，它叫做页(page) 调度策略 高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小 DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大 6 技术总结在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。 有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。 我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。 B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n &#x3D; m + o。 现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。 由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？ 我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t &#x3D; m - i 位来作为标记，区分一组中的不同块。 通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 7 术语索引主存储器(main memory 主存) : 即通常理解的使用DRAM内存。 块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block) VM (Virtual Memory) 虚拟内存 VA(Virtual Address) 虚拟地址 MMU(Memory Management Unit)：内存管理单元，一种硬件 VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块 PP(Physical page) 物理页 : 在磁盘和主存之间传输的块 页表 ：一个数据类型位PTE的数组 PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型 页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging) 缺页：DRAM缓存不命中称为page fault 内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[]},{"title":"CS:APP 读后感","slug":"CS-APP-读后感","date":"2022-09-02T06:23:07.000Z","updated":"2022-09-03T15:05:12.432Z","comments":true,"path":"2022/09/02/CS-APP-读后感/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"","text":"CS:APP 读后感这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的） 接下来会陆续更新各章的详细笔记 … 介绍目录： 第1章 计算机系统漫游--- 程序结构和执行第2章 信息的表示和处理第3章 程序的机械级表示第4章 处理器体系结构第5章 优化程序性能第6章 存储器的层次结构--- 在系统上运行程序第7章 链接第8章 异常控制流第9章 虚拟内存--- 程序间的交互和通信第10章 系统及I/O第11章 网络编程第12章 并发编程 本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。 剩下的十一章是本书的正式部分，我认为本书的核心在第 79 章，26章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。 分章介绍第二章 信息的表示和处理 这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。 2.1.3 寻址和字节顺序： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。 2.16 布尔代数介绍 ： 可以使用位向量来表示有限集合。 2.2 整数表示 ： 介绍了整数原码和补码的表示，以及他们之间的转换。 2.3 整数运算 ： 介绍了整数运算可能出现的错误，以及来源。 2.4 ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。 第三章 程序的机器级表示 相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。 这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。 从这一张开始到最后，才是一口气看完的。 3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了objdump 的使用 3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。 3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。 3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法 第四章 处理器体系结构 这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。 第五章 优化程序性能 呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。 客观一点就是 普通人日常写代码小技巧 第六章 存储器层次结构 没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。 第七章 链接 含金量高的来了 这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld 7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位 7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表 7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接 7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方 动态链接：与加载的时候链接的类型 库打桩机制 第八章 异常控制流 最重要的一章之一，介绍了并发编程的基础——异常控制流 介绍了进程，简单带领读者入门了并发编程 讲了信号，有助于以后学习事件驱动的GUI编程 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 8.2 异常 8.3 进程 8.4 用C语言操作进程：fork execve 8.5 信号 SIGINT … 第九章 虚拟内存 最重要的一章之一 这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点 本章可以分为三部分 第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的 第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve 第三部分介绍了一个内存分配器的实现( malloc() ) 第十章 系统级 I&#x2F;O 这一章读起来很简单，没有什么要理解的东西 首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。 然后着介绍了RIO包，即包装后的IO函数。 本章完 第十一章 网络编程 这一章需要理解的地方不多，只有介绍网络编程的部分 第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。 首先介绍了网络编程 接着介绍了Linux的套接字函数 最后实现了一个小web服务器 11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议 第十二章 并发编程 和上一章差不多的感觉 本章也分为三部分 首先介绍了实现并发编程的三种方法 进程 IO多路复用 线程 之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。 最后介绍了并发编程容易出现的问题：死锁、访问共享变量 …","categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"ubuntu 配置","slug":"ubuntu-配置","date":"2022-09-02T02:49:51.000Z","updated":"2022-09-02T04:36:41.841Z","comments":true,"path":"2022/09/02/ubuntu-配置/","link":"","permalink":"https://cfla1638.github.io/2022/09/02/ubuntu-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 配置2022&#x2F;9&#x2F;1 配置了Ubuntu，用来学习《CSAPP》上面需要实践的代码。这篇博客是为了记住我究竟配置了什么，也为了方便下次在其他设备上配置Ubuntu。 VScode 下载和配置下载的方法见官网，配置C&#x2F;C++的方法网上的博客也很好搜到 Linux系统VsCode 配置C&#x2F;C++环境_ZERO_pan的博客-CSDN博客_linuxvscode配置c++环境 接下来使将Open With Code 添加到右键菜单 这部分参考 ubuntu中为vscode添加右键菜单–网上没有—就自己做了个 - 洪豆豆的记录 - 博客园 (cnblogs.com) 其中修改了一点命令，将visual-studio-code 改成了code 去$HOME/.local/share/nautilus/script/ 目录下新建一个文件，文件名就是显示在右键菜单上的名字。 接着将以下内容复制到新建的文件中 #!/bin/bash## This script opens a gnome-terminal in the directory you select.## Distributed under the terms of GNU GPL version 2 or later## Install in ~/.gnome2/nautilus-scripts or ~/Nautilus/scripts# You need to be running Nautilus 1.0.3+ to use scripts.# When a directory is selected, go there. Otherwise go to current# directory. If more than one directory is selected, show error.if [ -n &quot;$NAUTILUS_SCRIPT_SELECTED_FILE_PATHS&quot; ]; thenset $NAUTILUS_SCRIPT_SELECTED_FILE_PATHSif [ $# -eq 1 ]; thendestination=&quot;$1&quot;# Go to file&#x27;s directory if it&#x27;s a fileif [ ! -d &quot;$destination&quot; ]; thendestination=&quot;`dirname &quot;$destination&quot;`&quot;fielsezenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;You can only select one directory.&quot;exit 1fielsedestination=&quot;`echo &quot;$NAUTILUS_SCRIPT_CURRENT_URI&quot; | sed &#x27;s/^file://////&#x27;`&quot;fi# It&#x27;s only possible to go to local directoriesif [ -n &quot;`echo &quot;$destination&quot; | grep &#x27;^[a-zA-Z0-9]/+:&#x27;`&quot; ]; thenzenity --error --title=&quot;Error - Open terminal here&quot; /--text=&quot;Only local directories can be used.&quot;exit 1ficd &quot;$destination&quot;exec code &quot;$destination&quot; 最后运行命令chmod +x 刚才创建的文件名 对文件或文件夹右键就可以看到刚才添加的右键菜单了。 下拉式终端Yakuka在这里 找到 Ubuntu 根据提示安装。 如果安装失败可能要换清华源，如下： 更换清华源 参考：https://blog.csdn.net/weixin_49700990/article/details/122005001 首先使用lsb_release -a 查看自己的Ubuntu版本 我们要更改的文件是 &#x2F;etc&#x2F;apt&#x2F;sources.list， 首先使用命令对这个文件进行备份 sudo cp /etc/apt/sources.list /etc/apt/sources_save.list 接着 进入清华源网站 ，找到Ubuntu的源 ，选择合适的版本，根据提示手动替换即可。 设置应用开机启动在Ubuntu自带的 “启动应用程序” 里配置 更改磁盘大小 参考 https://blog.csdn.net/Shine_Su/article/details/124630751 首先在VMware里扩容，接着根据上面的博客，在Ubuntu里手动配置。 将虚拟机的内容复制到虚拟机外 参考：https://blog.csdn.net/u013554213/article/details/124061526 依次执行以下命令，最后重启Ubuntu # 删除原来安装过的文件sudo apt autoremove open-vm-tools# 输入安装命令：sudo apt install open-vm-toolssudo apt install open-vm-tools-desktop","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"}]},{"title":"数据结构课程","slug":"数据结构课程","date":"2022-08-23T03:50:55.000Z","updated":"2022-08-23T03:56:14.161Z","comments":true,"path":"2022/08/23/数据结构课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数据结构课程进行中，持续更新 …","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"数字逻辑课程","slug":"数字逻辑课程","date":"2022-08-23T03:44:02.000Z","updated":"2022-08-29T15:15:11.740Z","comments":true,"path":"2022/08/23/数字逻辑课程/","link":"","permalink":"https://cfla1638.github.io/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"数字逻辑课程进行中，持续更新 … 第一章 逻辑代数基础1.1 布尔代数也叫逻辑代数，开关代数，以后不作区分。是一种定义在{0，1}上的代数系统，表示为(K, +, ·, -, 0, 1)。 · + - 分别对应 ∧∨ ┐，与或非，合取、析取、非。 虽然课本上这样写，但我觉得根据离散数学里学的代数系统的知识，代数系统是 非空集合 加上定义在集合上的运算，所以应该写成 ({0, 1}, +, ·, -) 。 · 即合取，可以像乘号一样省略。 逻辑代数公理： 0 - 1 律 A + 0 = AA + 1 = 1A · 0 = 0A · 1 = A 重叠律 A + A = AA · A = A 互补律 A + ┐A = 1A · ┐A = 0 对合律 ┐┐A = A 交换律 结合律 分配律 A · (B + C) = AB + AC 与对或的分配A + BC = (A + B)(A + C) 或对与的分配 1.2 逻辑函数定义: 从n个逻辑变量到01的映射。记为F &#x3D; f(A1, A2, A3 … ) 逻辑函数有三种表示法和两种标准形式（最小项表达式和最大项表达式） 三种表示法： 逻辑表达式：类似数学表达式，由逻辑变量和运算符按一定规律组合而成 真值表 卡诺图 用图形表示逻辑函数的方法，在使函数值为1的变量组合所对应的小方格上标记1。 挖坑 卡诺图应该和最小项表达式有关，等学了再填坑。 1.2.3 两种标准形式最小项表达式：也叫积之和范式 或 主析取范式 最小项的定义：由若干项乘积之和组成，其中每个乘积项包含该函数的全部逻辑变量，或以原变量的形式出现，或以反变量的形式出现，且每个变量在一个乘积项中只出现一次。 最小项的表示： 对于n个变量而言，可以构成2的n次方个最小项表达式。这个性质类似与n位二进制数有2的n次方种组合，因此我们可以对最小项表达式作出规定，以便方便的表示他们。 对于一个n变量的最小项表达式，当各个变量按一定次序排好后，用1代表原变量，用0代表反变量，这样一个最小项表达式可以被转化为2进制数，我们用 mi 来表示这个最小项表达式。 Q：为什么要使用1代表原变量，用0代表反变量？ A：如果有一个最小项mi，如果令原变量为1，反变量为0，一定能使mi &#x3D; 1，而且这是唯一的。 例如m6 &#x3D; AB┐C，其顺序为110B &#x3D; 6D，令对应的逻辑变量为1或0，则m6 &#x3D; 1 · 1 · (┐0) &#x3D; 1 例如，最小项表达式 AB, 转换成二进制即11，表示为m3。 最小项表达式A┐B，转换成二进制即10，表示为m2。 最小项的性质： 对于任意一个最小项，只有一组变量取值可以使其值为1 任意两个最小项之积为0 n个变量的所有2^n^ 个最小项之和为1 将任意表达式转换为最小项表达式： 利用公式A = A(B + ┐B) 最小项表达式的性质： 性质1：若mi是逻辑函数 F(A1 ,A2 ,…,An ) 的一个最小项，则使mi&#x3D;1的一组变量取值 (a1 ,a2 ,…,an ) 必定使 F 值为 l 。 性质2：若 F1 和 F2 都是 A1 ,A2 ,…,An 的函数，则 F&#x3D;F1+F2 将包括 F1 和 F2 中的所有最小项， G&#x3D;F1·F2 将包括 F1 和 F2 中的公有最小项。 性质3：若 F 是 ┐F 的反函数，则F必定由F所包含 的最小项之外的全部最小项所组成 思考题：任何n变量的逻辑函数都有且仅有一个最小项表达式 使用归谬法证明 第一次课到此结束 最大项表达式： 也叫和之积范式或主合取范式 定义：设n个逻辑变量，他们所组成的和项（“或”项）中，每个变量或以原变量或以反变量形式出现，且仅出现一次，这个和项称为n变量的最大项。 举例： 二变量最大项表达式：（A + B），（A + ┐B）, (┐A + B), (┐A + ┐B) 三变量最大项表达式： 最大项表达式的三条性质类似最小项表达式的三条性质： 对于任意一个最大项，只有一组变量取值可使其值为0。 任意两个最大项 Mi 和 Mj 之和必为1。 n 变量的所有2^n^ 个最大项之积必为0。 最大项表达式以 + 连接，因此绝大多数的最大想表达式的值为1，但是对于任意一个最大项，只有一组变量取值可使其值为0。 任意逻辑表达式转换成最大项表达式： 先用“或对与的分配”（就是普通加减乘除代数没有的那种分配律），将给定逻辑表达式展开为 “或 - 与” 表达式，然后对每一个或项“或”上 （加上） 所缺变量x的 x┐x。 类似(A + B)(A + ┐B) ，先在括号里进行或运算，再在括号外进行与运算的表达式，被称为“或 - 与” 表达式。 AB + A┐B, 而这种表达式被称为 “与 - 或”表达式 最大项表达式的性质也与最小项表达式类似： 性质1：若Mi是逻辑函数F(A1 ,A2 ,…,An )的一个 最大项，则使Mi&#x3D;0的一组变量取值(a1 ,a2 ,…,an ) 必定使F值为0。 性质2：若F1和F2都是A1 , A2 , …, An的函数，则 F&#x3D;F1+F2将包括F1和F2中的公有最大项， G&#x3D;F1·F2将包括F1和F2中的所有最大项。 性质3：若F是F的反函数，则F必定由F所包含的最大项之外的全部最大项所组成。 1.2.4 逻辑函数的三种表示法的关系用最小项表达式表示的逻辑函数，我们将原变量用1表示，反变量用0表示。这样我们把每个最小项都放进一个集合A里。那么，逻辑函数可以说是这个集合的特征函数。 同样的，用最大项表达式表示的逻辑函数，我们将原变量用0表示，反变量用1表示。这样我们把每个最大项都放进一个集合B里。那么，逻辑函数可以说是这个集合的特征函数。 从上一节的学习，我们直到逻辑函数有三种表示法： 逻辑表达式 真值表 卡诺图 首先，逻辑表达式形式都可以化成标准形式。 接着我们来看真值表与逻辑表达式的关系（最大&#x2F;小项表达式也是逻辑表达式）： 还记得我们说最小项表达式可以看成是集合A的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是1，不在这个集合里的逻辑变量值的组合都是0。 最大项表达式与最小项表达式恰恰相反： 最大项表达式可以看成是集合B的特征函数。而只要是在这个集合里的逻辑变量值的组合，其在真是表中的值都是0，不在这个集合里的逻辑变量值的组合都是1。 最后我们来看一下卡诺图与真值表的关系： 卡诺图其实是真值表的变形，真值表按照二进制顺序来排放逻辑变量值得组合： ——————————————A B | F——————————————0 0 | 00 1 | 11 0 | 11 1 | 0—————————————— 它是一维的 线性的。 而卡诺图则二维的： 将逻辑变量值得组合放在二维表格得行或列，每个行或列 填上不同的组合，这样每个格子就可以表示由这些变量所组成的所有最小项。 将项的组合换成数字的组合，我们得到卡诺图的简化形式 需要注意的是，如上图所示：边框外的二进制数的排列数序并不是随意的，而是必须按照格雷码的顺序排列。 下面给出一个逻辑函数的卡诺图表示的例子： 补充：格雷码 https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 1位格雷码有两个码字 (n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1 [4] n+1位格雷码的集合 &#x3D; n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 2位格雷码 3位格雷码 4位格雷码 4位自然二进制码 00 000 0000 0000 01 001 0001 0001 11 011 0011 0010 10 010 0010 0011 110 0110 0100 111 0111 0101 101 0101 0110 100 0100 0111 1100 1000 1101 1001 1111 1010 1110 1011 1010 1100 1011 1101 1001 1110 1000 1111 第二次课结束 1.3 主要定理 &amp; 常用公式4个主要定理德摩根律： 当变量个数较少的时候，可以使用真值表法证明。 当变量较多的时候，使用数学归纳法证明。 香农定理： 任何函数的反函数，可通过对该函数的所有变量取反，并将1换成0，0换成1，· 换成 + ，+换成 · 运算得到。 注意：我们使用香农定理是不能改变运算的顺序，而+ 和 ·的优先级不一样，因此如有必要需要加括号。 对偶定理: 对偶函数的定义： 将逻辑函数中的 · +互换 ，01互换，但变量不变，则函数变为原来的对偶函数 设原函数表示为 f (x1, x2, … , xn, 0, 1, +, · ) 则其对偶函数为 f ‘ (x1, x2, … , xn, 0, 1, +, · ) &#x3D; f (x1, x2, … , xn, 1, 0, ·, 1) 对偶定理表述为：对于任何函数的对偶函数，可以通过原函数的所有变量取反，并再对整个函数求反函数得到。 两个推论： 原函数与其对偶函数互为对偶函数。 两个相等的函数（f &#x3D; g）的对偶函数必定相等（f ‘ &#x3D; g ‘） 自对偶函数：一个函数的对偶函数等于它自己。 展开定理： 两个推理： 展开定理可以用于将逻辑函数展开成 与或式 or 或与式。详见 P16 5个常用公式 AB + A┐B &#x3D; A 在一个积之和表达式中，若有一个变量，他在一个乘积项中为原变量，在另一个乘积项中为反变量，且这两个乘积项的其余因子相同，则此变量是多余的。 A + AB &#x3D; A 在一个积之和表达式中，若有一个乘积项是另一个乘积项的因子，则包含这个乘积项的乘积项是多余的。 还可以写成ABC + ABCDE &#x3D; ABC A + ┐AB &#x3D; A + B 在一个积之和表达式中，若有一个乘积项的“非”是另一个乘积项的因子，则在该乘积项中，这个因子是多余的。 ┐C + CE &#x3D; ┐C + E AB + ┐AC + BC &#x3D; AB + ┐AC 包含律 在一个积之和表达式中，若有两个乘积项，其中一个包含原变量x另一个包含反变量┐x 且这两个乘积项的其余因子都是另一个乘积项的因子，则另一个乘积项是多余的。 AB + ┐AC + BCDE &#x3D; AB + ┐AC ┐(A┐B + ┐AB) &#x3D; ┐A┐B + AB 两个变量的异或的反 是 两个变量的同或 上面5个公式的对偶形式也是成立的 异或的性质A ⊕A &#x3D; 0 A⊕┐A &#x3D; 1 A⊕0 &#x3D; A A⊕1 &#x3D; ┐ A 重要 A⊕┐ B &#x3D; A ⊙ B &#x3D; A⊕B⊕1 A⊕B &#x3D; B⊕A 交换律 A⊕(B⊕C) &#x3D; （A⊕B) ⊕C 结合律 A(B⊕C) &#x3D; AB⊕AC 分配律 第三次课到此结束 应用一、转化称其他形式（详见P20） “与或” 表达式转 “或与”表达式 法一：分配律 法二：展开定理 “与或” 表达式 转 “与非 - 与非” 表达式 “与非 - 与非” 表达式 ：若干个“与非”项进行“与非”得到的逻辑表达式 或与表达式是中间由 + 即或连接的，我们只要利用德摩根律将这个或变为与即可 因此我们的步骤是：两次取反，内层非用德摩根律断开 “与或” 表达式 转 “或非 - 或非” 表达式 “或非 - 或非” 表达式: 若干个“或非”项进行“或非”得到的逻辑表达式 首先将 “与或” 转换为 “或与”，再两次取反，内层非用德摩根律断开 二、最大项表达式和最小项表达式的关系 ┐mi &#x3D; Mi 或 mi &#x3D; ┐Mi mi’ &#x3D; Mj，且i + j &#x3D; 2 ** n - 1 原函数 ​ – 变换 –&gt; 最小项表达式 ​ – 一次取反 –&gt; 符号错开，但保持最小项表达式，反函数的最小项表达式 或 或符号不错开，变成最大项表达式形式，得到反函数的最大项表达式形式 ​ – 二次取反 –&gt; 原函数的最大项表达式（和原函数最小项表达式符号错开） 将最大项表达式或最小项表达式变成对偶函数： 首先将最大项变成最小项，或最小项变成最大项 其次将序号变成互补的序号 1.4 逻辑函数的化简 逻辑函数最简式的定义： 该式中乘积项最少 该式中的乘积项不能再用变量更少的乘积项代替 化简方法: 代数方法 卡诺图法 列表化简法 卡诺图法第四次课到此结束","categories":[{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"}],"tags":[]},{"title":"BallMove:基于Qt的GUI小项目","slug":"BallMove-基于Qt的GUI小项目","date":"2022-08-21T11:46:01.000Z","updated":"2022-08-23T12:44:32.474Z","comments":true,"path":"2022/08/21/BallMove-基于Qt的GUI小项目/","link":"","permalink":"https://cfla1638.github.io/2022/08/21/BallMove-%E5%9F%BA%E4%BA%8EQt%E7%9A%84GUI%E5%B0%8F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"BallMove:基于Qt的GUI小项目简介在暑假学科目二的时候，看着 Qt学习之路2 学了Qt的绘制系统，做这个项目的初心就是用来巩固学到的Qt绘制系统。 今天写下这篇博客，是为了记录下自己在这个项目中学到的东西，方便自己以后使用Qt的时候能够快速上手。 这个项目基于QGraphicsScene + QGraphicsItem + QGraphicsView， 模拟了一个小球在现实世界中的运动。 项目地址：cfla1638&#x2F;BallMove 设定功能：实现了实心球的运动。 考虑的因素有： 用户给予的加速度 重力 摩擦力 空气阻力 细节： 该项目模拟了一个半径0.04米的实心钢铁球，其密度为 7850 kg &#x2F; m^3^ 。 重力加速度为 9.8 m&#x2F;s^2^ 。 静摩擦系数为 0.3。 空气阻力使用公式：F &#x3D; 1&#x2F;2 * CρSv^2^ ，其中C取0.3，ρ取1.293，S取 3.14 * 0.04^2^ 。 尺寸换算：1m &#x3D; 250px。 基础知识 Qt的绘制系统由QGraphicsScene + QGraphicsItem + QGraphicsView 相互配合使用。 QGraphicsScene 提供一个场景(Scene)，所有要显示的实体都可以放到这个场景中。 QGraphicsItem 是在QGraphicsScene 中实体对象类的父类，在本项目中的实体类都要继承这个类。继承这个类的实体可以被添加到QGraphicsScene，进行显示和管理。 QGraphicsView 提供了一个观察的视角，配合QGraphicsScene 进行显示。这个类可以被设为QMainWindow 的CentralWidget。 只有QObject 的子类可以使用信号槽的机制 QTimer类提供计时器功能，使用timer.start(sec) 功能开始计时，这里timer是一个QTimer类的一个对象，每经过sec时间后，timer就会发出一个timeout() 信号。 想要实现物体的运动，就要让物体的位置在每一帧里进行改变&#x2F;刷新（本程序的帧率是120），而QGraphicsScene 提供一个advance() 函数，该函数会调用所有在场景里的QGraphicsItem 对象的advance() 函数，因此我们只要每经过 1000 &#x2F; 120 毫秒 就调用一次QGraphicsScene::advance() 函数，就可以进行场景刷新，从而实现物体的运动。 每个QGraphicsItem::advance(int phase) 都会被一个QGraphicsScene::advance() 调用两次。在第一次时，Item已经准备好刷新，此时传入的phase &#x3D; 0。第二次QGraphicsScene::advance() 将phase &#x3D; 1 传入函数并调用。 基于此，我们只需要在phase &#x3D; 1是进行处理，phase &#x3D; 0 是我们什么也不做。否则我们程序的帧率会变成原来的二倍。 Qt 的坐标系统。在本程序中，我们用到了Qt的两套坐标。第一个是在QGraphicsScene 中的全局坐标系，它记录了每个QGraphicsItem 的位置。第二个是每个QGraphicsItem 对象都会有的本地坐标系。在我们绘制每个部件时，我们就会基于本地坐标系绘制。 每个继承了QGraphicsItem 的类都要重载以下四个函数。 QRectF boundingRect() const;QPainterPath shape() const;void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);void advance(int phase); boundingRect() 返回一个包裹住QGraphicsItem 对象的矩形（比对象大一点或很多）。这个矩形使用的是全局坐标系，用于碰撞检测等功能。 shape() 返回图型的准确形状。如对于我们的小球来说，这个函数返回一个圆轨迹。 void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) 该函数一般由QGraphicsScene 自动调用，绘制该项目。 这个函数一般这样写 void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); // 保存画笔状态 //设置新的画笔状态 painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); // 绘制图型 painter-&gt;restore(); // 还原画笔状态&#125; 我们要保证该函数调用过之后，画笔的状态不被改变，因此使用save和restore。 painter-&gt;fillPath(shape(), Qt::blue); 这一行绘制我们在shape() 中返回的图型，在此之前我们可以设置画笔的状态。 编写头文件的建议 如果我们在头文件中#include 了另一个文件，那么我们的这个头文件就依赖另一个文件。如果我们依赖的文件发生改变，本文件也要重新编译。 为了减少编译时间，我们要减少头文件的依赖。为此我们使用前置声明法。 即，在头文件中，我们尽量使用需要使用到的类的指针，并将此类的声明写在头文件前，这样我们就不需要在头文件中include 这个类，也就减少了头文件的依赖。 项目设计首先来看一下运行效果： 在这颗树中，一个类是另一个类的子树，就表示这个类是另一个类的私有对象另外，这棵树也为我们展示了本项目的设计思路。└─MainWindow ├─Controller │ ├─Ball │ ├─Balldata │ ├─Ground │ └─QGraphicsScene - Reference ├─QGraphicsScene └─QGraphicsView 自下而上，首先来看Controller下的三个类， Controller下有三个类，分别是Ball, Balldata, Ground，他们都是QGraphicsItem 的子类，分别对应运行结果中的蓝色小球，上面绿色的信息显示和下面黑色的地面。 这三个类定义了自身的形状和他们的运动逻辑。以Ball为例，Ball类有四个上述提到的函数，用来绘制他的形状，还有记录它自身加速度和速度的私有类型。 值得一提的是，Controller类有一个引用，QGraphicsScene - Reference，它其实是MainWindow的私有对象，但由于Controller类需要经常使用这个对象，为了方便，我们就将它的引用放在了Controller类中。 接着是Controller类。 顾名思义，Controller类是我们程序的控制器。 Controller类可以控制程序的开始结束，控制界面的刷新，对Qt的时间进行处理。 最后我们看一下最外层的MainWindow类，他是程序的主窗口。它下面的QGraphicsScene和QGraphicsView 分别是画布和观察窗口。 当程序开始执行时，首先执行MainWindow类的构造函数，分别构造QGraphicsScene，QGraphicsView和Controller。在Controller类进行构造时，Controller下的物体就被添加到了Scene中，程序也就开始运行了。当MainWindow下的对象都构造完成时。main.cpp 的QMainWindow::show() 和 QApplication :: exec() 函数分别将程序主窗口显示，并且开始程序的事件循环，接受事件，交给Controller进行处理。 项目实现文件结构首先看一下我们的文件结构 BallMove - BallMove.pro Headers - ball.h - balldata.h - constants.h - controller.h - ground.h - mainwindow.h Sources - ball.cpp - balldata.cpp - controller.cpp - ground.cpp - main.cpp - mainwindow.cpp Ball类的实现首先看一下ball类的实现 class Ball : public QGraphicsItem&#123;public: Ball(qreal x, qreal y); QRectF boundingRect() const; QPainterPath shape() const; void advance(int phase); QPointF getPos()&#123;return pos();&#125; int forceCount = 4; qreal a[2][4]; qreal vx = 0; qreal vy = 0;protected: void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr);&#125;; 首先我们来看Ball类的私有变量： 由于我们运动的平面是二维的，因此我们使用一个二维数组qreal a[2][4] 来存储加速度。其中qreal就是double类型。如果我们想要访问小球x方向的空气阻力产生的加速度，我们可以使用在constants.h 中定义的枚举类型，即a[xAxis][AirResistance] 。如果想要引用y方向的重力加速度，就使用a[yAxis][Gravity] 。 qreal vx, vy 即小球的x方向速度，和y方向的速度。 int forceCount 即我们考虑的力的数目，这个变量用于将这些力合成的时候进行计数。 接着我们来看一下Ball类中声明的函数: 第一个函数getPos()很好理解，即返回小球在全局坐标系中的坐标。 接着我们仔细考察一下之前我们在基础知识部分介绍的四个函数：paint() shape() advance() boundingRect() boundingRect : QRectF Ball::boundingRect() const&#123; return QRectF(-BALL_SIZE * 2, -BALL_SIZE * 2, BALL_SIZE * 4, BALL_SIZE * 4); &#125; QRectF类即矩形类，这个函数返回了一个包裹小球矩形。需要注意的是，这个矩形的坐标是在本地坐标系的坐标。 BALL_SIZE 定义在constants.h 代表小球的直径。 shape() : QPainterPath Ball::shape() const&#123; QPainterPath path; path.addEllipse(QPointF(0, 0), BALL_SIZE / 2, BALL_SIZE / 2); return path;&#125; 这个函数返回了一个绘画轨迹类QPainterPath，并在里面添加了一个圆形轨迹。需要注意的是，这个坐标也是在小球本地坐标系中的。 paint() ： void Ball::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)&#123; painter-&gt;save(); painter-&gt;setRenderHint(QPainter::Antialiasing); // 设置反走线（抗锯齿） painter-&gt;fillPath(shape(), Qt::blue); painter-&gt;restore();&#125; 在第五行设置了画笔的抗锯齿，紧接着下一行绘制了小球的准确形状。 advance() ： void Ball::advance(int phase)&#123; // 只有phase为1时进行处理 if (!phase) return ; // 计算合力 qreal sumAx = 0, sumAy = 0; for (int i = 0; i &lt; forceCount; i++) &#123; sumAx += a[xAxis][i]; sumAy += a[yAxis][i]; &#125; if (sumAx) vx += (sumAx / FRAME_RATE); if (sumAy) vy += (sumAy / FRAME_RATE); qreal x = fmod(pos().rx() + vx / FRAME_RATE, 1000), y = fmod(pos().ry() + vy / FRAME_RATE, 1000); // 处理小球越界 if (x &lt; 0) x += 1000; if (y &lt; BALL_SIZE / 2) y = BALL_SIZE / 2; // 设置新位置 setPos(QPointF(x, y)); update(); // 更新显示小球&#125; 由于我们设置了帧率为120帧，因此这个函数在每秒钟会被调用120次。 在这个函数里，我们依次计算了小球受到的合力，改变了小球的速度，根据小球的速度对小球进行了移动。 需要注意，一、因为我们的速度、加速度定义为m&#x2F;s和m&#x2F;s^2^。 因此我们在更新速度和位置时，要将速度和加速度除以帧率，这样经过120次调用，速度和加速度才改变了1s的量。 二、在设置了小球的位置之后，需要使用update() 函数更新小球的位置。 constants.h 参数存储文件constants.h 文件中存放了项目的各种参数 const int FRAME_RATE = 120; // 帧率：120帧 帧率过低时碰撞会穿透地面const int BALL_SIZE = 20; // 球的直径：20px// 400 对应 112 重力// 3000 对应 2450 重力const int X_SPEED = 1500; // 左右键给球的加速度const int Y_SPEED = 3000; // 上下键给球的加速度const int FRICTION = 735; // 摩擦力大小const int FRICTION_SENSITIVITY = 2; // 摩擦力敏感度，当速度的值大于此值时，小球受摩擦力// 112 对应1.75 米的人// 2450 对应 8cm 的实心球const int GRAVITY = 2450; // 重力大小const double M = 2.1038; // 小球质量enum Directions&#123;xAxis, yAxis&#125;; // x, y轴方向enum Force&#123;User, Gravity, Friction, AirResistance&#125;; // 力的四个维度，用户给出的力，重力，摩擦力，空气阻力 需要注意是两个枚举类型，通过定义枚举类型，可以使用枚举变量引用数组元素，可读性更好。 Balldata &amp; ground这两个类都继承了QGraphicsItem 和Ball类类似，因此我们不在赘述。 Controller类首先看一下Controller类的定义 class Controller : QObject&#123; Q_OBJECTpublic: Controller(QGraphicsScene &amp; scene, QObject * parent = 0); void track(bool); void gravity();public slots: void drawLineOfTrack(); void resume(); void pause(); void advance();protected: bool eventFilter(QObject *atched, QEvent *event);private: void handleKeyPressed(QKeyEvent * event); void handleKeyReleased(QKeyEvent * event); QTimer timer; Ball * ball; QGraphicsScene &amp; scene; Ground * ground; ballData * data;&#125;; Controller类有以下几点功能： 处理键盘事件：如上下左右移动，打开&#x2F;关闭 轨迹显示，清屏。 相关地函数有： bool eventFilter(QObject *atched, QEvent *event);void handleKeyPressed(QKeyEvent * event);void handleKeyReleased(QKeyEvent * event); 控制程序的开始与结束 相关地函数有： void resume();void pause(); 控制程序的一步步地推进，即让小球动起来。 相关地函数有： void advance(); 其他功能 相关地函数有： void track(bool);void gravity();void drawLineOfTrack(); 在这里我们只介绍advance() 函数 void Controller::advance()&#123; scene.advance(); // 首先调用场景的advance() // 获取碰撞信息 static bool lastStatus = false; // 上一帧是否碰撞 static bool nowStatus = false; // 当前是否处于碰撞 nowStatus = ball-&gt;collidesWithItem(ground); //处理碰撞 if (nowStatus == true &amp;&amp; lastStatus == false) &#123; ball-&gt;a[yAxis][Gravity] = 0; // 碰撞时重力与支持力抵消 ball-&gt;vy = -(ball-&gt;vy * 0.667); // 回弹 2/3 的速度 ball-&gt;a[yAxis][User] = 0; // 竖直方向速度为0 &#125; // 处理摩擦力 if (nowStatus) &#123; if (ball-&gt;vx &gt; FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = -FRICTION; else if (ball-&gt;vx &lt; -FRICTION_SENSITIVITY) ball-&gt;a[xAxis][Friction] = FRICTION; else ball-&gt;a[xAxis][Friction] = 0; &#125; // 没有碰撞的时候 if (!nowStatus) &#123; // 摩擦力置零 ball-&gt;a[xAxis][Friction] = 0; ball-&gt;a[yAxis][Gravity] = GRAVITY; &#125; // 处理空气阻力 qreal sumV = pow(ball-&gt;vx, 2) + pow(ball-&gt;vy, 2); if (fabs(sumV) &gt; 10) &#123; qreal airSum = 0.0009744 * sumV / 250; if (sumV == 0) sumV = 1; ball-&gt;a[xAxis][AirResistance] = (fabs(ball-&gt;vx) / (sqrt(sumV))) * airSum; ball-&gt;a[yAxis][AirResistance] = (fabs(ball-&gt;vy) / (sqrt(sumV))) * airSum; // 将力换算成加速度 ball-&gt;a[xAxis][AirResistance] /= M; ball-&gt;a[yAxis][AirResistance] /= M; if (ball-&gt;vx &gt; 5) ball-&gt;a[xAxis][AirResistance] *= -1; else if (ball -&gt; vx &lt; 10) ; else ball-&gt;a[xAxis][AirResistance] = 0; if (ball-&gt;vy &gt; 5) ball-&gt;a[yAxis][AirResistance] *= -1; else if (ball -&gt; vy &lt; 10) ; else ball-&gt;a[yAxis][AirResistance] = 0; &#125; lastStatus = nowStatus; data-&gt;update(); // 更新数据显示&#125; 由于每次更新，我们都要对碰撞进行检测，因此我们首先调用场景地advance函数。 等运动结束之后，我们使用Qt地碰撞检测函数collidesWithItem()看小球是否接触地面。 接着我们根据碰撞检测地结果，依次处理摩擦力和空气阻力。 其实我们还可以将处理各种力地程序写到小球地advance()中，但为了让我们地程序更符合controller控的概念，我们为controller也添加了advance()函数，由它调用scene的advance()函数。 MainWindow 类MainWindow类的代码如下 class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private slots: void adjustViewSize();private: void initScene(); QGraphicsView * view; QGraphicsScene * scene; Controller * controller;&#125;; 唯一需要解释的函数是它的构造函数，其他的函数都会在构造函数里被调用。 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; scene = new QGraphicsScene(this); view = new QGraphicsView(scene, this); controller = new Controller(*scene, this); setCentralWidget(view); resize(750, 750); initScene(); QTimer::singleShot(0, this, SLOT(adjustViewSize()));&#125; 在构造函数中，我们首先初始化了scene、view和controller，紧接着我们将view设为了窗口的centralWidget 并调整了窗口大小。 在倒数第二步，调用initScene 对scene进行调整。 以上的这些步骤都不会有什么问题，只有最后一步令人困惑： QTimer::singleShot(0, this, SLOT(adjustViewSize())); 首先解释singleShot() 函数，这个函数的声明如下 void QTimer::singleShot(int msec, const QObject *receiver, const char *member) 它的含义是在msec 毫秒后调用receiver的槽函数member，这是一个很方便的函数，这样你就可以在不去手动计时的情况下达到同样的效果。 那么为什么要使用这个功能呢？ 这里有两个解释 那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数。在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数。这就是为什么我们需要用QTimer而不是直接调用adjustViewSize()。如果熟悉 flash，这相当于 flash 里面的callLater()函数。 这个解释来自《Qt学习之路2》 但我并不清楚这里的 “下一次事件循环” 的意思。 依我的理解，应该是这个意思：某个QObject 发出 paintEvent() 事件，但对这个事件的处理比较耗时，如果此时直接调用adjustViewSize() ，视图还没有绘制完成，自然就不能起到调节视图的效果。事实也是这样，如果直接调用adjustViewSize() ，我们会发现视图小小的挤在屏幕的中间。 后来我又在网上发现了这篇博客：QTimer::singleShot(0, this, slot函数)； ，意思和我理解的大概相似。 但还是挖个坑，等我以后学精了一定回来解释清楚。 参考C++ 头文件使用规范建议_恋喵大鲤鱼的博客-CSDN博客_c++头文件规范 Qt 学习之路 2（31）：贪吃蛇游戏（1） - DevBean Tech World","categories":[{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]},{"title":"配置博客","slug":"配置博客","date":"2022-08-20T14:58:00.000Z","updated":"2022-08-21T12:05:04.405Z","comments":true,"path":"2022/08/20/配置博客/","link":"","permalink":"https://cfla1638.github.io/2022/08/20/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"博客配置 &amp; 使用教程简介该博客使用Hexo框架，部署在GitHub Pages上，使用的主题为nexmoe。 本文章记录了配置博客和使用博客的一些细节，供以后的我参考。 持续更新中 …… 工作原理在本地书写博客，使用hexo生成静态网页，部署到GitHub上，即可使用GitHub访问生成的静态网页。即我们看到的博客。 基本命令 调试： hexo server --debug 在本地运行服务器程序，并将目录输出在shell中。该命令可用于在本地预览页面 修改&#x2F;发布博客 进行更新： hexo clean 清理缓存和public文件夹 hexo g generate，生成静态页面，该操作之后即可在本地预览。 hexo d deploy，部署，即部署到GitHub上，该操作之后可以使用浏览器访问。 发布博客 hexo new [layout] [title] 使用layout，在_post&#x2F;title.md 的文件。使用这个命令而不是直接在文件夹里新建文件，是因为这样新建的文件有初始化的布局。 配置文件 可以在 _config.yml 里配置Hexo，在 _config.nexmoe.yml 里配置nexmoe主题。 _config.yml : 配置 网站的标题、副标题、关键词、作者、语言、时区 部署设置，其中repository可以填ssh的链接（执行git clone 的链接），也可以填https的链接，https的链接在国内特别慢，一定要使用ssh的链接。 _config.nexmoe.yml： 网站的默认头图，头像，图标等均在这里配置。 如果要使用本地相对路径，./ 的绝对路径即博客根目录下的source文件夹。 front-matter在这里可以配置文件的变量。 hexo 的文档：Front-matter | Hexo nexmoe 的私有 front-matter 文档：Front-matter | Hexo Theme Nexmoe 如果需要配置文章头图，可以在markdown文件开始加上以下代码，图片大小为1600 * 900 --title: &lt;title&gt;others...cover: 图片链接--- 配置分类和标签要像这样配置： categories:- Diarytags:- PS3- Games 其中分类categories最好明确且只有一个，而标签tags可以有多个且没有顺序，详情请见这里 widgets 关于 “文件归档”：归档页面 | Hexo Theme Nexmoe 关于 “关于博客”：是./ 目录下的一个markdown文件，与其他博文相同。 其他部件可以在_config.nexmoe.yml 里配置 评论系统nexmoe 支持几种评论系统，其中利用GitHub issue的gitment和gitalk，都因为墙的问题无法使用，所以本博客使用 Valine ，使用方法非常简单，按照Valine的官方手册一步步操作即可。 资源iconfont-阿里巴巴矢量图标库 参考文档Hexo参考文档 Nexmoe 参考文档 nexmoe GitHub地址 从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)","categories":[{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"CS:APP","slug":"CS-APP","permalink":"https://cfla1638.github.io/categories/CS-APP/"},{"name":"使用教程","slug":"使用教程","permalink":"https://cfla1638.github.io/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"name":"大学课程","slug":"大学课程","permalink":"https://cfla1638.github.io/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://cfla1638.github.io/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"https://cfla1638.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Linux","slug":"Linux","permalink":"https://cfla1638.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://cfla1638.github.io/tags/Qt/"}]}