<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|jetbrains mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cfla1638.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cfla&#39;s blog">
<meta property="og:url" content="https://cfla1638.github.io/default-index/page/2/index.html">
<meta property="og:site_name" content="cfla&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cfla">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cfla1638.github.io/default-index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cfla's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cfla's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">const 和 constexpr 的详解和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 15:40:53" itemprop="dateCreated datePublished" datetime="2022-09-26T15:40:53+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-29 15:45:33" itemprop="dateModified" datetime="2022-09-29T15:45:33+08:00">2022-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">琐碎记录</span></a>
                </span>
            </span>

          
            <span id="/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/" class="post-meta-item leancloud_visitors" data-flag-title="const 和 constexpr 的详解和区别" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/26/const-%E5%92%8C-constexpr-%E7%9A%84%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="const和constexpr"><a href="#const和constexpr" class="headerlink" title="const和constexpr"></a><code>const</code>和<code>constexpr</code></h1><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p>常量表达式：是指值不会改变且在编译期间就可以计算处结果的表达式</p>
<p>常量表达式是由</p>
<ul>
<li>数据类型</li>
<li>数据初始值</li>
</ul>
<p>决定的。</p>
<p><code>int a = 1</code> a 不是一个常量表达式，因为它的数据类型不是常量</p>
<p><code>const int b = get_val()</code> b不是一个常量表达式，因为它的初始值不是常量</p>
<p>由于使用<code>const</code> 不能确定一个表达式是不是常量，因此C++11使用<code>constexpr</code> 修饰符，可以让编译器在编译期间检查一个表达式是不是常量。</p>
<p>下面这个程序是不正确的，因为a虽然被<code>const</code> 修饰，但它并不是常量表达式，它引用了非常量表达式，因此在编译期间就可以确定它不是常量表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> i = a;</span><br><span class="line">    <span class="type">int</span> arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而只要将<code>a = b</code> 改为 <code>a = 1</code> 程序就不会报错了，因为此时a的确是一个常量表达式</p>
<h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h3><p>普通的函数不是常量表达式，但我们可以定义<code>constexpr</code> 类型的函数，它可以作为常量表达式，但这个函数必须简单到可以在编译期间被确定</p>
<h3 id="constexpr-指针-amp-引用"><a href="#constexpr-指针-amp-引用" class="headerlink" title="constexpr 指针 &amp; 引用"></a><code>constexpr</code> 指针 &amp; 引用</h3><p><code>constexpr</code> 指向的位置必须是全局变量，静态变量，或者字面值等放在<code>.bss</code> 节<code>.data</code> 位置的数据，而不能是放在栈上的本地变量，因为他们必须在运行时才能确定位置，而不能在编译时确定位置。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h2><p><code>const</code>用来修饰变量，根据<code>const</code> 出现的位置，可以分为两种<code>const</code> ：顶层<code>const</code> 和底层<code>const</code> </p>
<p>顶层<code>const</code> 可以表示任意的对象是常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;    <span class="comment">// a不能改变，是顶层const</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;    <span class="comment">// p不能改变指向，是顶层const</span></span><br></pre></td></tr></table></figure>
<p>低层<code>const</code> 与指针和引用有关，表示，不能通过这个途径修改他们指向或者引用的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;    <span class="comment">// 指向a的指针，不能通过这个指针修改a的值，是底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref = a;    <span class="comment">// a的引用，不能通过这种方式修改a, 是底层const</span></span><br></pre></td></tr></table></figure>
<h3 id="const-与参数传递"><a href="#const-与参数传递" class="headerlink" title="const 与参数传递"></a><code>const</code> 与参数传递</h3><ul>
<li><p>在参数传递时，顶层<code>const</code>会被忽略掉，因此下面这两个函数不能重载，因为他们忽略掉顶层<code>const</code> 后没有区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用非常量初始化底层<code>const</code> ，但不能使用常量去初始化非底层<code>const</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_1 = a;  <span class="comment">// 可以， 可以使用非常量初始化底层const</span></span><br><span class="line"><span class="type">int</span> &amp;ret_2 = b;      <span class="comment">// 不可以， 不能使用常量去初始化非底层const</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非常量的引用必须是左值，常量的引用可以是左值，也可以是右值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">1</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span> &amp;b = <span class="number">2</span>;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>因此<strong>尽量将不会改变形参的函数的形参定义成底层<code>const</code></strong> ，因为这样定义我们可以使用字面量（rvalue）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">并发编程 - CS:APP 第十二章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-25 22:10:57" itemprop="dateCreated datePublished" datetime="2022-09-25T22:10:57+08:00">2022-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-26 14:38:29" itemprop="dateModified" datetime="2022-09-26T14:38:29+08:00">2022-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="并发编程 - CS:APP 第十二章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发编程-CS-APP-第十二章"><a href="#并发编程-CS-APP-第十二章" class="headerlink" title="并发编程 - CS:APP 第十二章"></a>并发编程 - CS:APP 第十二章</h1><p>本章主要内容：</p>
<ul>
<li>实现并发程序的三种方法：<ol>
<li>fork() 进程</li>
<li>I/O 多路复用</li>
<li>使用线程</li>
</ol>
</li>
<li>使用信号量同步线程</li>
<li>线程安全问题</li>
</ul>
<h2 id="使用进程进行并发编程"><a href="#使用进程进行并发编程" class="headerlink" title="使用进程进行并发编程"></a>使用进程进行并发编程</h2><p><code>fork()</code> &amp; <code>execve</code> </p>
<p>优点：进程模型清晰，有独立的地址空间</p>
<p>缺点：不方便进程之间共享信息</p>
<p>基于进程的并发echo服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;args error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d connected\n&quot;</span>, getpid());</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            echo(connfd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process:%d close connection\n&quot;</span>, getpid());</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>可以使用<code>select()</code> 函数显示等待一个进程有一个IO事件发生。</p>
<p>例如我们有一个监听描述符和很多链接描述符，如果有一个描述符准备好读，我们就相应它，这样也可以实现并发。</p>
<p>只要有一个IO事件发生，程序的逻辑流就会改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果fdset中的描述符准备好读或者写，就返回</span></span><br><span class="line"><span class="comment">返回值：返回已准备好的描述符数目，若出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(fd_set *fdset);</span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    fd_set read_set;</span><br><span class="line">    fd_set ready_set;</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="type">int</span> maxi;</span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];</span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE];</span><br><span class="line">&#125;pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pool.nready);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set)) &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(connfd &gt; p-&gt;maxfd)</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi) </span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready) &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set))) &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：编码特别复杂</p>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>线程是运行在进程上下文中的逻辑流</p>
<p>运行在同一个进程里的线程共享</p>
<ul>
<li>虚拟地址空间</li>
</ul>
<p>有自己独立的</p>
<ul>
<li>栈、栈指针、PC、通用目的寄存器和条件码</li>
</ul>
<p>线程之间是对等的，没有和进程一样有父子之分</p>
<p>进程有两种状态：可结合的和分离的</p>
<ul>
<li>可结合的：能被其他线程回收和杀死，但它的内存资源需要被显示回收</li>
<li>分离的：不能被其他线程杀死，内存资源结束时由系统自动释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> * attr, func *f, <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自己的tid</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程会显示的终止，如果主调线程是主线程，那么他会等待其他对等线程终止，然后终止这个进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止 tid</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞，等待tid终止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当这个线程第一次被调用时，执行 init_routine()，用于初始化</span></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>如果两个线程交错地调用某个共享变量，如果第一个线程还没有将新值更新，第二个线程就已经取出了共享变量的值，就可能会造成错误</p>
<blockquote>
<p>对于线程i，操作共享变量的指令，构成了一个关于共享变量的临界区，这个临界区不应该和其他程序的临界区交错执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量互斥的访问。</p>
</blockquote>
<p>想要实现互斥的访问，我们可以使用信号量机制</p>
<p>信号量：</p>
<p>信号量s是具有非负整数值的全局变量，只能通过两种操作来改变它：</p>
<ul>
<li>P(s) : 如果s是非零的，那么P将s减1，并且立即返回。如果s为零，那么就挂起进程，直到s变为非零，并且该进程被一个V操作重启。在重启之后，P操作将s减1，并将控制返回给调用者。</li>
<li>V(S) : V操作将s加1。如果有任何进程阻塞在P操作等待s变成非零，那么V操作会重启这些进程中的一个，然后该进程将s减1，完成它的P操作。</li>
</ul>
<p>P中测试和加一的操作是不可分割的</p>
<p>V中测试和加以的操作也是不可分割的</p>
<p>如果s的值只能是0或者1，我们就将这个信号量成为互斥锁，它可以提供对共享变量互斥的访问。</p>
<p>互斥锁的使用：当一个线程要使用共享变量时，它对S进行P操作，互斥锁加锁，S变为0，当另一个线程想要使用共享变量时，他也对s进行P操作，因为P已经变为了0，所以这个线程被挂起，等待一个其他线程的V操作将它激活。当第一个线程使用完共享变量，它执行V操作，互斥锁解锁，第二个线程被激活。</p>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><blockquote>
<p>生产者线程反复地生成新的项目(item),并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费它们。</p>
<p>因为插入和取出项目都包括更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位)，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个可用的项目。</p>
</blockquote>
<p>基于生产者消费者的sbuf包：</p>
<p><code>sbuf.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H_SBUF</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">int</span> n;    <span class="comment">// 缓冲区长度</span></span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 队列头</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;  <span class="comment">// 对缓冲区的互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> slots;  <span class="comment">// 控制生产者的信号量</span></span><br><span class="line">    <span class="type">sem_t</span> items;  <span class="comment">// 控制消费者的信号量</span></span><br><span class="line">&#125;<span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>sbuf.c</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n);</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放缓冲区空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区插入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);  <span class="comment">// 如果缓冲区已满，想要插入的线程会阻塞在这里</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁加锁</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;    <span class="comment">// 因为信号量的机制，我们不用担心插入的数据大小超过缓冲区大小</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);  <span class="comment">// 互斥锁解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);  <span class="comment">// 如果有线程因为缓冲区为空而阻塞在这里，这个操作会激活它们</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);  <span class="comment">// 如果缓冲区为空，想要取出的线程会阻塞</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % sp-&gt;n];    <span class="comment">// 因为信号量的机制，我们不用担心从空缓冲区里取出数据</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);</span><br><span class="line">    V(&amp;sp-&gt;slots);  <span class="comment">// 如果有线程因为缓冲区已满而阻塞在这里，这个操作会通知激活他们</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于预线程化的并发服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt;</span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        echo_cnt(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="四个种不安全的函数"><a href="#四个种不安全的函数" class="headerlink" title="四个种不安全的函数"></a>四个种不安全的函数</h3><ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数（依赖前次调用结果的函数）</li>
<li>返回指向静态变量指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入的函数"><a href="#可重入的函数" class="headerlink" title="可重入的函数"></a>可重入的函数</h3><p>通常与线程安全的函数相混淆，但其实可重入的函数是线程安全函数的子集</p>
<p>定义：当它被多个线程使用时，不会引用任何共享数据</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它控制流种的x点时，就会发生竞争</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>deadlock：一个程序被阻塞了，等待一个永远也不会为真的条件</p>
<p>给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁，并以相反的顺序释放，那么这个程序是无死锁的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">网络编程 - CS:APP 第十一章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-22 17:53:11" itemprop="dateCreated datePublished" datetime="2022-09-22T17:53:11+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:14:00" itemprop="dateModified" datetime="2022-09-25T22:14:00+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="网络编程 - CS:APP 第十一章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-CS-APP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络编程-CS-APP-第十一章"><a href="#网络编程-CS-APP-第十一章" class="headerlink" title="网络编程 - CS:APP 第十一章"></a>网络编程 - CS:APP 第十一章</h1><p>客户端和服务器都是进程，而不是机器或主机。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址结构：由于早期的一些原因，存放IP地址的32位无符号整数被放到了一个结构中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;  <span class="comment">// 32位IP地址，使用网络字节顺序（大端法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不同的设备，使用的字节顺序不同。因此，在网络上进行传输时，会首先把字节转换成网络字节顺序，接受时，会再转换回本地字节顺序。</p>
<p>字节顺序和主机顺序的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to net</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// host to net</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// net to host</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;  <span class="comment">// net to host</span></span><br></pre></td></tr></table></figure>
<p>点分IP地址与32位IP地址的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 点分十进制转换成32位地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">得到的32位地址也要转换成本地顺序</span></span><br><span class="line"><span class="comment">返回：若成功返回1，串非法返回0，错误返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位地址转换成点分十进制</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用该函数之前，要将32位IP地址转换成网络顺序</span></span><br><span class="line"><span class="comment">把指向src的32位IP地址转换成点分十进制地址，并把得到的以NULL结尾的字符串的做多size个字符赋值到dst中</span></span><br><span class="line"><span class="comment">返回：若成功返回指向点分十进制地址的指针，出错返回NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>附</p>
<ol>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将十六进制字符串转换成十进制数：</span></span><br><span class="line">使用<span class="built_in">sscanf</span>(str, <span class="string">&quot;%x&quot;</span>, &amp;num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用32位IP地址时，可以直接使用<code>in_addr</code>结构而不是<code>in_addr</code>结构里的<code>s_addr</code></p>
</li>
</ol>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>是一组绝大多数操作系统都定义的函数，可以实现网络应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209231151155.png" alt="image-20220923115128790"></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个结构体所占字节数相同，可以互相转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;  <span class="comment">// 协议簇类型，通常是 AF_INET(ipv4, ipv6是AF_INET6)</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;    <span class="comment">// 端口号，使用网络字节顺序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IP地址结构</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];   <span class="comment">// 填充0，为了满足struct sockaddr的大小</span></span><br><span class="line">&#125;;    <span class="comment">// 这个结构体一共占16个字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="socket-通用"><a href="#socket-通用" class="headerlink" title="socket() 通用"></a>socket() 通用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使套接字称为一个连接的结点</span></span><br><span class="line"><span class="comment">返回一个还不能用于读写的描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使称为一个连接点</span></span><br><span class="line">clientfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="connect-客户端"><a href="#connect-客户端" class="headerlink" title="connect() 客户端"></a>connect() 客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">客户端clientfd试图与addr建立连接， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="bind-服务器"><a href="#bind-服务器" class="headerlink" title="bind()  服务器"></a>bind()  服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将addr中的服务器地址与套接字描述符sockfd连接起来， addrlen是sizeof(sockaddr_in)</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="listen-服务器"><a href="#listen-服务器" class="headerlink" title="listen() 服务器"></a>listen() 服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数使sockfd变成一个监听套接字，backlog是最大连接数，一般为1024</span></span><br><span class="line"><span class="comment">成功返回0， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="accept-服务器"><a href="#accept-服务器" class="headerlink" title="accept() 服务器"></a>accept() 服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功返回非负连接描述符， 出错返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>服务器：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>bind()</code> 成为一个服务器套接字</li>
<li>调用<code>listen()</code> 转换成监听描述符</li>
<li>调用<code>accept()</code> ，阻塞程序，等待客户端连接，返回连接描述符</li>
</ol>
<p>客户端：</p>
<ol>
<li>调用<code>socket()</code>，创建连接结点</li>
<li>调用<code>connect()</code>， 连接服务器</li>
</ol>
<h3 id="套接字地址和主机名服务名的转换"><a href="#套接字地址和主机名服务名的转换" class="headerlink" title="套接字地址和主机名服务名的转换"></a>套接字地址和主机名服务名的转换</h3><p>首先了解，域名和IP地址是等价的，服务名和端口号是等价的</p>
<p>例如localhost和127.0.0.1是等价的，http和80是等价的</p>
<h4 id="从-字符串主机名服务名信息-到-二进制套接字地址信息"><a href="#从-字符串主机名服务名信息-到-二进制套接字地址信息" class="headerlink" title="从 字符串主机名服务名信息 到 二进制套接字地址信息"></a>从 字符串主机名服务名信息 到 二进制套接字地址信息</h4><blockquote>
<p>为什么要使用这个函数？</p>
<p>域名和IP地址是多对多的，一个域名可能对应多个IP地址，因此此函数返回的链表很有帮助。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">host: 域名或点分十进制IP地址</span></span><br><span class="line"><span class="comment">service: 服务名或端口号</span></span><br><span class="line"><span class="comment">hints: 可选 传递设置</span></span><br><span class="line"><span class="comment">result: 指向一个addrinfo 结构链表，每个结构指向一个对应host和service的套接字地址结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放返回的链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo, *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将错误代码转换成错误信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getaddrinfo</code> 使用的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;</span><br><span class="line">    <span class="type">int</span> ai_family;</span><br><span class="line">    <span class="type">int</span> ai_socktype;</span><br><span class="line">    <span class="type">int</span> ai_protocol;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *ai_canonname;</span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从-二进制套接字地址信息-到-字符串主机名服务名信息"><a href="#从-二进制套接字地址信息-到-字符串主机名服务名信息" class="headerlink" title="从 二进制套接字地址信息 到 字符串主机名服务名信息"></a>从 二进制套接字地址信息 到 字符串主机名服务名信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen,</span></span><br><span class="line"><span class="params">               <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, </span></span><br><span class="line"><span class="params">               <span class="type">char</span> *service, <span class="type">size_t</span> servlen,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="辅助简化函数"><a href="#辅助简化函数" class="headerlink" title="辅助简化函数"></a>辅助简化函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> clientfd, rc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;  <span class="comment">/* Open a connection */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV;  <span class="comment">/* ... using a numeric port arg. */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;  <span class="comment">/* Recommended for connections */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(hostname, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (%s:%s): %s\n&quot;</span>, hostname, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Walk the list for one that we can successfully connect to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Connect to the server */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(clientfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Connect failed, try another */</span>  <span class="comment">//line:netp:openclientfd:closefd</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_clientfd: close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* All connects failed */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">/* The last connect succeeded */</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, rc, optval=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a list of potential server addresses */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* Accept connections */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* ... on any IP address */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* ... using port number */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Walk the list for one that we can bind to */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="comment">/* Create a socket descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">/* Socket failed, try the next */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span></span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="comment">//line:netp:csapp:setsockopt</span></span><br><span class="line">                   (<span class="type">const</span> <span class="type">void</span> *)&amp;optval , <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind the descriptor to the address */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* Success */</span></span><br><span class="line">        <span class="keyword">if</span> (close(listenfd) &lt; <span class="number">0</span>) &#123; <span class="comment">/* Bind failed, try the next */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* No address worked */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make it a listening socket ready to accept connection requests */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoclient.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echoserver.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received:%s\n&quot;</span>, buf);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argument error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, client_hostname, MAXLINE,</span><br><span class="line">        client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>protocol family 协议簇：一组相关联的协议</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">系统级I/O - CS:APP 第十章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-20 15:18:55" itemprop="dateCreated datePublished" datetime="2022-09-20T15:18:55+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:15:11" itemprop="dateModified" datetime="2022-09-25T22:15:11+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="系统级I/O - CS:APP 第十章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/20/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O-CS-APP-%E7%AC%AC%E5%8D%81%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统级I-O-CS-APP-第十章"><a href="#系统级I-O-CS-APP-第十章" class="headerlink" title="系统级I/O - CS:APP 第十章"></a>系统级I/O - CS:APP 第十章</h1><p>Linux 所有的IO设备都被模型化为文件，所有的输入输出都被抽象成文件的读写。这种将设备映射成文件的方式，允许内核提供一些低级的函数接口还读写，被称为Unix IO。</p>
<p>在Linux中，较高级的IO函数（C标准库IO）是由内核提供的系统级Unix IO来实现的。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul>
<li><p>定义：一个应用程序要通过内核打开文件，内核返回一个非负小整数，叫做文件描述符，应用程序要操作文件，只需要知道文件描述符即可。</p>
</li>
<li><p>Linux Shell 创建的进程会打开三个文件：</p>
<p>0：标准输入；也可以使用定义在<code>unistd.h</code> 中的<code>STDIN_FILENO</code> 来显示表述</p>
<p>1：标准输出；<code>STDOUT_FILENO</code></p>
<p>2：标准错误；<code>STDERR_FILENO</code> </p>
</li>
<li><p>EOF：如果一个字节数为m的文件，一个读操作，读到k字节处。如果k &gt;= m，则触发一个End of file条件，应用程序可以检测这个条件，但文件末尾并不是真的有EOF符号。</p>
</li>
</ul>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul>
<li>普通文件 regular file ： 包含任意数据，系统并不会区分二进制文件或者文本文件，那时应用程序需要区分的。</li>
<li>目录 directory ：是一个包含一组连接的文件，每个链接都映射到一个文件。有两个特殊的链接，每个目录文件一定会有，他们是<code>.</code> 和<code>..</code> 分别代表自己和上层目录。</li>
<li>套接字 socket ：用来和其他进程进行跨网络通信的文件。</li>
</ul>
<h2 id="系统级IO函数"><a href="#系统级IO函数" class="headerlink" title="系统级IO函数"></a>系统级IO函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开和关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> * filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flags: 文件的打开方式</span></span><br><span class="line"><span class="comment">O_RDONLY   只读</span></span><br><span class="line"><span class="comment">O_WRONLY  只写</span></span><br><span class="line"><span class="comment">O_RDWR    可读可写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">O_CREAT   如果文件不存在，创建</span></span><br><span class="line"><span class="comment">O_TRUNC    如果文件已存在，截断它（即覆盖原文件）</span></span><br><span class="line"><span class="comment">O_APPEND  添加到文件末尾</span></span><br><span class="line"><span class="comment">不同的flag可以使用管道符| 连接使用 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mode:</span></span><br><span class="line"><span class="comment">一般为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回-1，EOF返回0，出错返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值：若成功返回写的字节数，出错返回-1</span></span><br></pre></td></tr></table></figure>
<p><code>ssize_t</code> ：signed size type</p>
<p>read 函数会返回不足值(short count) ，即返回的数目并不是要求的size_t n</p>
<p>可能会返回不足值得情况：</p>
<ul>
<li>读时遇到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的组块(chunk)进行读取。这样一来，下一个read返回的不足值为20，此后的read将通过返回O发出EOF信号。</li>
<li>从终端读文本行。如果打开文件是与终端相关联的（例如，键盘和显示器），那么每个rad函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li>
<li>读和写网络套接字(socket)。如果打开的文件对应于网络套接字（12.3.3节)，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Unix管道(pipe)调用read和wte,也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。</li>
</ul>
<h2 id="RIO包函数"><a href="#RIO包函数" class="headerlink" title="RIO包函数"></a>RIO包函数</h2><p>RIO(Robust I/O)：用于网络编程中，会自动处理不足值的情况。</p>
<h3 id="总览："><a href="#总览：" class="headerlink" title="总览："></a>总览：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带缓冲区的版本</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替read</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;    <span class="comment">// 代替write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带缓冲区的版本</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span>;  <span class="comment">// 带缓冲区的rio_readn</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>带缓冲区和不带缓冲区的优劣：</p>
<p>带缓冲区：由于每次调用read都要进入内核模式进行系统调用，会比较浪费时间，因此带缓冲区可以在缓冲区为空的时候填满缓冲区，等下次调用的时候直接在缓冲区中取出数据，这样会节省减少不必要的系统调用。</p>
<p>不带缓冲区：比较快速，方便在网络上进行数据传输（臆断）</p>
</blockquote>
<h3 id="不带缓冲区的函数"><a href="#不带缓冲区的函数" class="headerlink" title="不带缓冲区的函数"></a>不带缓冲区的函数</h3><h3 id="rio-readn"><a href="#rio-readn" class="headerlink" title="rio_readn()"></a>rio_readn()</h3><p>用来代替<code>read</code> 的RIO函数，无缓冲区，这个函数只有在遇到EOF时，才会返回不足值，其他情况下，绝不会返回不足值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// 整个程序中，还没有被读取的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// 单次调用read 函数所读取的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// read 函数发生错误</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)     <span class="comment">// interrupted by a sig handler return</span></span><br><span class="line">                nread = <span class="number">0</span>;      <span class="comment">// call read again</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;      <span class="comment">// 这个程序读取的所有字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-writen"><a href="#rio-writen" class="headerlink" title="rio_writen()"></a>rio_writen()</h3><p>用来代替<code>write</code> 的函数，无缓冲区，绝对不可能返回不足值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;    <span class="comment">// 整个程序中，还没有被写入的字节</span></span><br><span class="line">    <span class="type">ssize_t</span> nwritten;    <span class="comment">// 单词write函数写入的字节</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;  <span class="comment">// 下一个将被写入的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)    <span class="comment">// 被一个信号处理程序返回打断</span></span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带缓冲区的函数"><a href="#带缓冲区的函数" class="headerlink" title="带缓冲区的函数"></a>带缓冲区的函数</h3><p>缓冲区的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192  <span class="comment">// 缓冲区的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;        <span class="comment">// 与缓冲区关联的文件描述符</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;      <span class="comment">// 缓冲区中的未读字节数</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;    <span class="comment">// 下一个未读字节地址</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];    <span class="comment">// 缓冲区</span></span><br><span class="line">&#125;<span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>
<p>初始化缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rio_</span><br></pre></td></tr></table></figure>
<h3 id="rio-read"><a href="#rio-read" class="headerlink" title="rio_read()"></a>rio_read()</h3><p>带缓冲区的rio_read() 遇到错误返回-1，遇到EOF返回0，否则返回成功读取的字节数</p>
<p>该函数会返回不足值，除了上述几种不足值，当缓冲区的字节数小于要求的字节数时，也会返回不足值，我们其他的带缓冲区的rio函数都是基于这个函数。</p>
<p>该函数会首先调用read填满缓冲区，如果缓冲区内还有字节则会直接读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;  <span class="comment">// 本次调用函数读取的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 如果缓冲区为空，重新填满缓冲区</span></span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)    <span class="comment">// 被信号打断，自动重启</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未知错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// EOF</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">// 重置bufptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)    <span class="comment">// 缓冲区字节数不够</span></span><br><span class="line">        cnt = rp-&gt;rio_cnt;      <span class="comment">// 返回不足值</span></span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readlineb"><a href="#rio-readlineb" class="headerlink" title="rio_readlineb()"></a>rio_readlineb()</h3><p>读取一行，最多读取maxlen-1个字节，最后一个字节要填充<code>&#39;\0&#39;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, rc;    <span class="comment">// n 程序读取字节数， rc 单次rio_read 的返回值</span></span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;    <span class="comment">// c一个临时变量，用于逐个读取，测试是否为换行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;  <span class="comment">// 正常</span></span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;  <span class="comment">// 返回不足值</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// EOF，什么字节也没读取，直接返回0</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">// EOF, 但已经读取了一些字节，需要处理后返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未知错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *bufp = <span class="number">0</span>;      <span class="comment">// 最后一位用 &#x27;\0&#x27; 填充</span></span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rio-readnb"><a href="#rio-readnb" class="headerlink" title="rio_readnb()"></a>rio_readnb()</h3><p>rio_readn的带缓冲区版本，代码结构与rio_readn 基本相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;   <span class="comment">// bytes that has not been read</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;      <span class="comment">// read() func had read nread bytes</span></span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nleft != 0</span></span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)   <span class="comment">// someting wrong</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// unknown error</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;              <span class="comment">// EOF</span></span><br><span class="line">        nleft -= nread;</span><br><span class="line">        usrbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>stat()</code> 函数以文件名作为输入，填写<code>struct stat *buf</code>  </p>
<p>我们只对<code>struct stat</code> 的一些条目感兴趣：</p>
<ul>
<li><p><code>buf-&gt;st_size</code> 文件的大小</p>
</li>
<li><p><code>buf-&gt;st_mode</code> 使用在<code>sys/stat.h</code> 的三个宏可以判断文件类型：</p>
<p><code>S_ISREG(mode)</code> 这是一个普通文件吗？</p>
<p><code>S_ISDIR(mode)</code> 这是一个目录文件吗？</p>
<p><code>S_ISSOCK(mode)</code> 这是一个网络套接字吗？</p>
</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent * <span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;      <span class="comment">// inode number 文件位置</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>];    <span class="comment">// Filename		文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO重定位"><a href="#IO重定位" class="headerlink" title="IO重定位"></a>IO重定位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制oldfd 到newfd,如果newfd 已经打开，dup2会在复制之前关闭newfd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-title-link" itemprop="url">虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 11:03:22 / 修改时间：11:27:16" itemprop="dateCreated datePublished" datetime="2022-09-17T11:03:22+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="虚拟内存视角下的Linux进程 & 动态内存分配 - CS:APP 第九章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/17/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84Linux%E8%BF%9B%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-CS-APP-%E7%AC%AC%E4%B9%9D%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚拟内存视角下的Linux进程-amp-动态内存分配"><a href="#虚拟内存视角下的Linux进程-amp-动态内存分配" class="headerlink" title="虚拟内存视角下的Linux进程 &amp; 动态内存分配"></a>虚拟内存视角下的Linux进程 &amp; 动态内存分配</h1><h2 id="Linux的虚拟内存系统"><a href="#Linux的虚拟内存系统" class="headerlink" title="Linux的虚拟内存系统"></a>Linux的虚拟内存系统</h2><p>Linux为每个进程提供了一个虚拟地址空间。而这些地址空间被分为两部分：</p>
<ul>
<li>进程虚拟内存部分</li>
<li>内核虚拟内存部分</li>
</ul>
<p>进程虚拟内存部分我们已经很熟悉了，按照地址从低到高，他们分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>用户栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rsp →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>共享库的内存映射区域</td>
</tr>
<tr>
<td>brk →</td>
<td></td>
</tr>
<tr>
<td></td>
<td>运行时的堆（通过malloc分配的）</td>
</tr>
<tr>
<td></td>
<td>未初始化的数据(.bss)</td>
</tr>
<tr>
<td></td>
<td>已初始化的数据(.data)</td>
</tr>
<tr>
<td>0x400000 →</td>
<td>代码(.text)</td>
</tr>
</tbody>
</table>
</div>
<p>内核虚拟内存可分为两部分：</p>
<ul>
<li>内核中的代码和数据及数据结构</li>
<li>被映射到此的物理内存（Linux将一组连续的虚拟内存（大小等于系统DRAM总量）映射到物理内存，为内核提供一种便利的方法来访问物理内存中的任何位置）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>与进程相关的数据结构（页表、task和mm结构、内核栈）</th>
<th>每个进程都不相同</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理内存</td>
<td>每个进程都相同</td>
</tr>
<tr>
<td>内核代码和数据</td>
<td>每个进程都相同</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171118039.png" alt="image-20220917111815524"></p>
<h2 id="Linux如何组织虚拟内存"><a href="#Linux如何组织虚拟内存" class="headerlink" title="Linux如何组织虚拟内存"></a>Linux如何组织虚拟内存</h2><p>Linux将虚拟内存组成成一些区域的集合。一个区域就是已分配的虚拟内存片段</p>
<p>这些片段通过一个结构链表被组织起来。（task_struct-&gt;mm_struct-&gt;mmap）</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209171117123.png" alt="image-20220917111745313"></p>
<h2 id="用户级内存映射"><a href="#用户级内存映射" class="headerlink" title="用户级内存映射"></a>用户级内存映射</h2><p>Linux 可以使用<code>mmap</code>函数来创建新的虚拟内存，并将对象映射到这些区域中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将文件描述符fd所表示的文件，从offset处开始的length字节大小的数据，以prot的访问权限和flags的方式，映射到最好再虚拟内存start处开始的区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">prot:</span></span><br><span class="line"><span class="comment">PROT_EXEC  该页面的区域可以被执行</span></span><br><span class="line"><span class="comment">PROT_READ  该页面区域可读</span></span><br><span class="line"><span class="comment">PROT_WRITE  ... 可写</span></span><br><span class="line"><span class="comment">PROT_NONE  ... 不能被访问</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">flags:</span></span><br><span class="line"><span class="comment">MAP_ANON    被映射的对象是一个匿名对象</span></span><br><span class="line"><span class="comment">MAP_PRIVATE    是一个私有对象，使用写时复制机制</span></span><br><span class="line"><span class="comment">MAP_SHARE    是一个共享对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">// 删除从虚拟地址start开始处的length字节，接下来对这些地址的引用将会导致段错误</span></span><br></pre></td></tr></table></figure>
<p>例子：将任意磁盘文件赋值到<code>stdout</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmapcopy</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bufp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load to virtual memory</span></span><br><span class="line">    bufp = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    Write(STDOUT_FILENO, bufp, size);   <span class="comment">// write to stdout</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open file </span></span><br><span class="line">    fd = Open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    fstat(fd, &amp;stat);   <span class="comment">// get detailed message of file</span></span><br><span class="line">    mmapcopy(fd, stat.st_size);     <span class="comment">// call mmapcopy</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">异常控制流 - CS:APP 第8章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-12 09:48:49" itemprop="dateCreated datePublished" datetime="2022-09-12T09:48:49+08:00">2022-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:15:19" itemprop="dateModified" datetime="2022-09-25T22:15:19+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="异常控制流 - CS:APP 第8章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/12/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-CS-APP-%E7%AC%AC8%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常控制流-CS-APP-第8章"><a href="#异常控制流-CS-APP-第8章" class="headerlink" title="异常控制流 - CS:APP 第8章"></a>异常控制流 - CS:APP 第8章</h1><blockquote>
<p>这一章更多的是实践，理论的部分实在不多</p>
</blockquote>
<p>本文将介绍：</p>
<ol>
<li>常见的异常</li>
<li>(Linux)部分并发编程</li>
</ol>
<p>一系列的指令组成的流叫做控制流，现在的操作系统通过使控制流突变来对异常情况作出反应，这种突变就叫做异常控制流。</p>
<h2 id="异常及其分类"><a href="#异常及其分类" class="headerlink" title="异常及其分类"></a>异常及其分类</h2><ol>
<li><p>中断 (interrupt) : 异步发生，是来自处理器外部I/O设备的信号的结果</p>
</li>
<li><p>陷阱 (trap) ： 同步发生，是故意造成的异常，最重要的用途是实现用户程序的系统调用。用户程序通过<code>syscall</code> 指令，造成一个到异常处理程序的陷阱。</p>
<p>系统调用和普通函数调用的区别：普通函数调用运行在用户模式，系统调用发生在内核模式</p>
</li>
<li><p>故障 (fault)：可能被处理程序修复的异常，比如内存不命中导致的缺页</p>
</li>
<li><p>终止 (abort)：不可恢复的错误。</p>
</li>
</ol>
<h2 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h2><p>进程的定义：一个执行中的程序实例</p>
<p>进程提供给程序两个抽象的概念：</p>
<ol>
<li>一个独立的逻辑控制流，它提供一个假象，使我们觉得我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，使我们觉得我们的程序独占地使用存储器系统。</li>
</ol>
<p>区分并发和并行：</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>获取进程id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在linux上，pid_t 被定义为 int</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程pid</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 获得父进程pid</span></span><br></pre></td></tr></table></figure>
<p>进程只有三种状态：</p>
<ol>
<li>运行。进程要么在CPU上执行，要么在等待被执行且最终会被调度。</li>
<li>暂停。进程的执行被挂起(suspended),且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN或者SIGTTOU信号时，进程就暂停，并且保持暂停直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在8.5节中给予描述。)</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：<ol>
<li>收到一个信号，该信号的默认行为是终止进程</li>
<li>从主程序返回</li>
<li>调用exit函数。</li>
</ol>
</li>
</ol>
<p>创建进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数创建一个进程，子进程和父进程的进程组相同（如果不可以改变）</span></span><br><span class="line"><span class="comment">子进程与父进程的虚拟地址空间相同，文件描述符相同</span></span><br><span class="line"><span class="comment">该函数返回两次：</span></span><br><span class="line"><span class="comment">在父进程中返回创建子进程的pid</span></span><br><span class="line"><span class="comment">在子进程中返回0</span></span><br><span class="line"><span class="comment">可以依此区分两个进程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>回收僵死进程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pid 等待集合</span></span><br><span class="line"><span class="comment">  pid &gt; 0 一个单独的子进程</span></span><br><span class="line"><span class="comment">  pid = -1 父进程的所有子进程</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">statusp 导致返回的状态信息</span></span><br><span class="line"><span class="comment">options 选项</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return :</span></span><br><span class="line"><span class="comment">成功回收：回收进程的pid</span></span><br><span class="line"><span class="comment">WNOHANG 返回0</span></span><br><span class="line"><span class="comment">其他错误 -1 (例如没有子进程)：</span></span><br><span class="line"><span class="comment">如果没有子进程，该函数返回-1，并设置全局变量errno为ECHILD</span></span><br><span class="line"><span class="comment">如果挂起的进程被信号中断（经过我测试，当信号到达，转到处理程序时，waitpid并不会返回）:返回-1， 设置errno为EINTR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">典型用法：waitpid(-1, NULL, 0);</span></span><br><span class="line"><span class="comment">挂起该进程，等待该进程的子进程终止，回收该僵死进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">// 等价于waitpid(-1, &amp;statusp, 0);</span></span><br></pre></td></tr></table></figure>
<p>让进程休眠：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;    <span class="comment">// 挂起进程secs秒，如果因为信号中断则会提前返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;      <span class="comment">// 挂起进程，因为进程中断会提前返回</span></span><br></pre></td></tr></table></figure>
<p>加载并运行程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename 可执行文件路径，argv参数列表，envp环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">execve调用一次，从不返回，除非找不到可执行文件文件</span></span><br><span class="line"><span class="comment">argv/envp 指向以NULL结尾的指针数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特别强调：</span></span><br><span class="line"><span class="comment">通过fork创建的子进程将会继承父进程处置(disposition)的副本，在执行execve时，所有信号的处置将会重置为默认值，但是对于是否阻塞信号不会修改，因为在执行execve时将保留信号掩码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种软件层次的异常</p>
<p>发送信号的两个原因：</p>
<ol>
<li>内核检测到一个系统事件，如子进程终止，发送SIGCHLD</li>
<li>一个进程显式地调用了kill函数，向某个进程发送了信号</li>
</ol>
<p>一个进程接受到的信号，被放在一个位向量里，当收到一个信号，该位被设置为1，如果再收到一个信号，由于该位已经被设置为1，因此，这个信号会被简单地丢弃。因此：</p>
<blockquote>
<p>当我们设计信号处理程序时，我们必须假设，再该信号之前，已经有不止一个该类型的信号已经到达，我们必须处理尽可能处理多的信号。</p>
</blockquote>
<p>为了能方便向大量进程发送信号，Linux提供了进程组这个概念。</p>
<p>进程组相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 获取当前进程的进程组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;    <span class="comment">// 设置pid的进程组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果pid为0，则设置当前的进程</span></span><br><span class="line"><span class="comment">如果pgid为0，则用pid指定的PID作为进程组id</span></span><br><span class="line"><span class="comment">setpgid(0, 0); 即使当前进程独立出原进程组，使用当前的PID作为进程组ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>发送信号</p>
<ol>
<li><p><code>/bin/kill</code> 程序可以手动发送信号</p>
</li>
<li><p>在键盘上输入ctrl-c,发送SIGINT信号到shell。.shell捕获该信号（参见8.5.3节），然后发送SGT信号到这个前台进程组中的每个进程。在默认情况中，结果是终止前台作业。类似地，输入ctrl-z会发送一个SIGTSTP信号到shell,shell捕获这个信号，并发送SIGTSTP信号给前台进程组中的每个进程。在默认情况下，结果是暂停（挂起）前台作业。</p>
</li>
<li>kill函数</li>
<li>alarm函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// secs秒后，发送一个SIGALRM信号给调用进程</span></span><br></pre></td></tr></table></figure>
<p>接受处理信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, sighandler handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：</span></span><br><span class="line"><span class="comment">1. 如果handler是SG_IGN,那么忽略类型为signum的信号。</span></span><br><span class="line"><span class="comment">2. 如果handler是SIG_DF凡L,那么类型为signum的信号行为恢复为默认行为。</span></span><br><span class="line"><span class="comment">3. 否则，handler就是用户定义的函数的地址，称为信号处理程序(signal handler),只要进程接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序。信号处理程序的调用被称为捕捉信号。信号处理程序的执行被称为处理信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>阻塞 &amp; 解除阻塞信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, sigset *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于sigprocmask的how，有三个选项：</span></span><br><span class="line"><span class="comment">SIG_BLOCK    将set中的信号添加到阻塞集合</span></span><br><span class="line"><span class="comment">SIG_UNBLOCK    将set中的信号从阻塞信号中删除</span></span><br><span class="line"><span class="comment">SIG_SETMASK    将block = set</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>非本地跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retrval)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="附：Linux-配置CSAPP库"><a href="#附：Linux-配置CSAPP库" class="headerlink" title="附：Linux 配置CSAPP库"></a>附：Linux 配置CSAPP库</h2><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435">https://blog.csdn.net/ustc_sse_shenzhang/article/details/105744435</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76930507">https://zhuanlan.zhihu.com/p/76930507</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jakejohn/article/details/79825086">https://blog.csdn.net/jakejohn/article/details/79825086</a></p>
<p>第三版CSAPP库 代码下载：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/code.html">http://csapp.cs.cmu.edu/3e/code.html</a></p>
</blockquote>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到     <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
<h2 id="术语索引"><a href="#术语索引" class="headerlink" title="术语索引"></a>术语索引</h2><p>抢占(preempted) 暂时挂起</p>
<p>并发流(concurrency flow)：一个逻辑流的执行在时间是与另一个逻辑流重合</p>
<p>并发(concurrency)：多个逻辑流并发地执行，它是一种思想，包括的范围更大</p>
<p>并行流(parallel flow)：两个逻辑流并发地运行在两个处理器或计算机上</p>
<p>挂起(suspended) </p>
<p>阻塞信号：信号被阻塞不等于信号被丢弃，只是没有被处理</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-title-link" itemprop="url">链接 - CS:APP 第七章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 19:47:36" itemprop="dateCreated datePublished" datetime="2022-09-07T19:47:36+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-23 12:37:32" itemprop="dateModified" datetime="2022-09-23T12:37:32+08:00">2022-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="链接 - CS:APP 第七章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/07/%E9%93%BE%E6%8E%A5-CS-APP-%E7%AC%AC%E4%B8%83%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>本文将介绍：</p>
<ul>
<li>编译的过程</li>
<li>三种目标文件</li>
<li>三种链接和链接的过程</li>
</ul>
<h2 id="1-编译的过程"><a href="#1-编译的过程" class="headerlink" title="1 编译的过程"></a>1 编译的过程</h2><ol>
<li><p>源文件（.c /.cpp）经过翻译，形成可重定位目标文件（.o）</p>
<p>具体过程：</p>
<p>预处理</p>
<p><code>cpp main.c -o main.i</code> 或 <code>gcc -E -o main.c main.c</code> </p>
<p>编译器 ：翻译成汇编语言</p>
<p><code>cc1 或 cc main.i -o main.s</code> 或 <code>gcc -S -o main.s main.c</code></p>
<p>汇编器 ：形成可重定位目标文件</p>
<p><code>as [args] -o main.o</code> 这中间参数很多，</p>
<p>如果向直接到这一步可以使用 <code>gcc -c -o main.o main.c</code> </p>
</li>
<li><p>链接器 链接形成可执行目标文件</p>
<p><code>ld -o prog main.o other.o</code> 或 <code>gcc -o prog main.o other.o</code> </p>
</li>
</ol>
<p>如果想要一步一步生成<code>.i</code> <code>.s</code> <code>.o</code> 文件，建议使用gcc 加参数，而不是使用cpp cc1 as ld，这里面水很深，你把握不住。</p>
<p>除了以上的方法，你也可以在使用gcc是，加上-v参数，让gcc显示编译过程。不过，它显示的信息实在太多了，不如一步一步使用 <code>-E</code> <code>-S</code> <code>-c</code> 参数进行编译。</p>
<blockquote>
<p>顺带一提，在bash中，可以通过 <code>echo $?</code> 来展示上一次程序退出的返回值</p>
</blockquote>
<h2 id="2-三种目标文件"><a href="#2-三种目标文件" class="headerlink" title="2 三种目标文件"></a>2 三种目标文件</h2><p>首先，什么是目标文件？</p>
<blockquote>
<p>计算机科学中存放目标代码的计算机文件,包含着机器代码，代码在运行时使用的数据，调试信息等，是从源代码文件产生程序文件这一过程的中间产物。</p>
<p>——360百科</p>
</blockquote>
<p>目标文件可以分为三类：</p>
<ol>
<li>可重定位目标文件 ：包含二进制数据和代码，可以在链接时与其他目标文件合并成可执行目标文件。</li>
<li>可执行目标文件 ： 可以被复制到内存中执行。</li>
<li>共享目标文件 ：特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接</li>
</ol>
<p>window系统使用<code>PE portable Executable</code> 格式</p>
<p>Linux使用 <code>Executable and Linkable Format, ELF</code>格式  </p>
<h3 id="2-1-可重定位目标文件格式"><a href="#2-1-可重定位目标文件格式" class="headerlink" title="2.1 可重定位目标文件格式"></a>2.1 可重定位目标文件格式</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209091204533.png" alt="image-20220909120357886"> </p>
<p>可重定位目标文件 以ELF头开始，通过<code>readelf -a main.o</code> 我们可以看到ELF头的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              <span class="number">2</span> 补码，小端序 (little endian)</span><br><span class="line">  Version:                           <span class="number">1</span> (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          <span class="number">0</span></span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86<span class="number">-64</span></span><br><span class="line">  版本:                              <span class="number">0x1</span></span><br><span class="line">  入口点地址：               <span class="number">0x0</span></span><br><span class="line">  程序头起点：          <span class="number">0</span> (bytes into file)</span><br><span class="line">  Start of section headers:          <span class="number">1040</span> (bytes into file)</span><br><span class="line">  标志：             <span class="number">0x0</span></span><br><span class="line">  Size of this header:               <span class="number">64</span> (bytes)</span><br><span class="line">  Size of program headers:           <span class="number">0</span> (bytes)</span><br><span class="line">  Number of program headers:         <span class="number">0</span></span><br><span class="line">  Size of section headers:           <span class="number">64</span> (bytes)</span><br><span class="line">  Number of section headers:         <span class="number">13</span></span><br><span class="line">  Section header <span class="built_in">string</span> table index: <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>可重定位目标文件的末尾是节头部表，它描述不同节的位置和大小。</p>
<p>我倾向于认为这是节头部表的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span></span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000040</span></span><br><span class="line">       <span class="number">0000000000000025</span>  <span class="number">0000000000000000</span>  AX       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rela.text        RELA             <span class="number">0000000000000000</span>  <span class="number">00000358</span></span><br><span class="line">       <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000068</span></span><br><span class="line">       <span class="number">0000000000000010</span>  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS           <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000000</span>c  <span class="number">0000000000000000</span>  WA       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS         <span class="number">0000000000000000</span>  <span class="number">00000078</span></span><br><span class="line">       <span class="number">000000000000002</span>c  <span class="number">0000000000000001</span>  MS       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>a4</span><br><span class="line">       <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .note.gnu.propert NOTE             <span class="number">0000000000000000</span>  <span class="number">000000</span>a8</span><br><span class="line">       <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">8</span>] .eh_frame         PROGBITS         <span class="number">0000000000000000</span>  <span class="number">000000</span>c8</span><br><span class="line">       <span class="number">0000000000000038</span>  <span class="number">0000000000000000</span>   A       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  [ <span class="number">9</span>] .rela.eh_frame    RELA             <span class="number">0000000000000000</span>  <span class="number">00000388</span></span><br><span class="line">       <span class="number">0000000000000018</span>  <span class="number">0000000000000018</span>   I      <span class="number">10</span>     <span class="number">8</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB           <span class="number">0000000000000000</span>  <span class="number">00000100</span></span><br><span class="line">       <span class="number">00000000000001</span>c8  <span class="number">0000000000000018</span>          <span class="number">11</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB           <span class="number">0000000000000000</span>  <span class="number">000002</span>c8</span><br><span class="line">       <span class="number">0000000000000090</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  [<span class="number">12</span>] .shstrtab         STRTAB           <span class="number">0000000000000000</span>  <span class="number">000003</span>a0</span><br><span class="line">       <span class="number">000000000000006</span>c  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在ELF头和节头部表之间的是节，在上面的节头部表中我们也可以看到那些节。</p>
<p>一个典型的ELF可重定位目标文件包含下面的节：</p>
<p><code>.text</code> : 已编译的机器代码</p>
<p><code>.rodata</code> : read only data 只读数据，如printf的格式字符串</p>
<p><code>.data</code> : 已初始化的全局和静态变量</p>
<p><code>.bss</code> : 未初始化的静态变量，以及所有被初始化为0的全局或静态变量。这个节只是一个占位符，实际不占空间。（未初始化的全局变量分配到COMMON伪节）</p>
<p><code>.symtab</code> ：符号表</p>
<p><code>rel.text</code> ：.text 节中的位置列表，存放当链接器把这个目标文件和其他文件组合在一起时需要修改的位置。通俗讲就是.text中引用的外部函数或全局变量</p>
<p><code>.rel.data</code></p>
<p><code>.debug</code> ：调试信息</p>
<p><code>.line</code> ：调试时的行号</p>
<p><code>strtab</code> ：字符串表，包含符号表中的符号，.debug节的符号表以及节头部表中的节的名字</p>
<h4 id="2-1-1-符号表"><a href="#2-1-1-符号表" class="headerlink" title="2.1.1 符号表"></a>2.1.1 符号表</h4><p>符号表的条目格式是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;    <span class="comment">// 字符串表的字节偏移，指向null结尾的字符串，具体的内容就是变量的名字，函数的名词，文件的名字等 main or main.c</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>,  <span class="comment">// 该符号条目的类型，函数数据或者节 NOTYPE OR OBJECT OR FUNC ...</span></span><br><span class="line">       binding:<span class="number">4</span>;	<span class="comment">// 全局变量还是本地变量 GLOBAL OR LOCAL</span></span><br><span class="line">    <span class="type">char</span> reserved;  <span class="comment">// 保留的，未使用</span></span><br><span class="line">    <span class="type">short</span> section;  <span class="comment">// 在ubuntu 上的名字是Ndx,指明该符号是在那个section的</span></span><br><span class="line">    <span class="type">long</span> value;    <span class="comment">// 距离节section 起始位置的字节偏移</span></span><br><span class="line">    <span class="type">long</span> size;    <span class="comment">// 该符号最小的大小</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure>
<p>对于section 字段，在<code>ubuntu</code> 的<code>readelf</code> 命令中，显示为 Ndx。</p>
<p>该字段有三个伪节，他们分别是 <code>UNDEF</code> <code>COMMON</code> <code>ABS</code> 。</p>
<p><code>ABS</code> ：代表不改被重定位的符号</p>
<p><code>UNDEF</code> ：代表未定义的符号，即在本模块引用却在其他模块定义的符号</p>
<p><code>COMMON</code> ：还未被分配位置的未初始化的数据目标</p>
<p><code>COMMON</code> 和 <code>.bss</code> 的区别很细微，现在GCC 根据以下规则来讲可重定位目标文件的符号分配到<code>COMMON</code> 和<code>.bss</code></p>
<p><code>COMMON</code> ：未初始化的全局变量</p>
<p><code>.bss</code> ：未初始化的静态变量，以及初始化为0的全局或静态变量</p>
<p>下面我们通过一个程序来展示以下ubuntu 中的符号表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_not_init;</span><br><span class="line"><span class="type">int</span> global_init = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> global_init_zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_not_init;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init_zero = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stat_init = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们生成可重定位的目标文件<code>gcc -c main.c</code> </p>
<p>接着使用<code>readelf -a main.o</code> 读取elf，即可查看符号表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ gcc -c main.c</span><br><span class="line">cfla@cfla-virtual-machine:~/code/CSAPP/ch_7$ readelf -a main.o</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x0</span><br><span class="line">  程序头起点：          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1040 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000025  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000358</span><br><span class="line">       0000000000000030  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000068</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000078</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  00000078</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a4</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .note.gnu.propert NOTE             0000000000000000  000000a8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000388</span><br><span class="line">       0000000000000018  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000100</span><br><span class="line">       00000000000001c8  0000000000000018          11    12     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  000002c8</span><br><span class="line">       0000000000000090  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  000003a0</span><br><span class="line">       000000000000006c  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in this file.</span><br><span class="line"></span><br><span class="line">本文件中没有程序头。</span><br><span class="line"></span><br><span class="line">There is no dynamic section in this file.</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.text&#x27; at offset 0x358 contains 2 entries:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000014  000c00000002 R_X86_64_PC32     0000000000000000 array - 4</span><br><span class="line">000000000019  001200000004 R_X86_64_PLT32    0000000000000000 sum - 4</span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rela.eh_frame&#x27; at offset 0x388 contains 1 entry:</span><br><span class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class="line"></span><br><span class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 19 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    3 stat_init.1921</span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">     7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">    12: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_not_init</span><br><span class="line">    14: 0000000000000008     4 OBJECT  GLOBAL DEFAULT    3 global_init</span><br><span class="line">    15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">    16: 0000000000000000    37 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    18: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum</span><br><span class="line"></span><br><span class="line">No version information found in this file.</span><br><span class="line"></span><br><span class="line">Displaying notes found in: .note.gnu.property</span><br><span class="line">  所有者            Data size   Description</span><br><span class="line">  GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0</span><br><span class="line">      Properties: x86 feature: IBT, SHSTK</span><br></pre></td></tr></table></figure>
<p>符号表中的Ndx代表section字段，我们可以看到，只有未初始化的全局变量<code>global_not_init</code> 在COMMON 伪节，已经初始化了的全局变量<code>global_init</code>和静态变量<code>stat_init</code>都在<code>.data</code> 节，而初始化为0的全局变量<code>global_init_zero</code> 和没有初始化的静态变量<code>stat_not_init</code> 和初始化为0的静态变量<code>stat_init_zero</code> 在<code>.bss</code> 节</p>
<p>根据这三行的<code>value</code> 字段我们还可以看到这三个变量在<code>.bss</code> 节的存储顺序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  15: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_init_zero</span><br><span class="line">6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 stat_init_zero.1920</span><br><span class="line">   7: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 stat_not_init.1919</span><br></pre></td></tr></table></figure>
<p>另外我们还看到了一个有趣的现象，对于这个模块，编译器在所有静态变量的名称后面都加上了后辍，而全局变量则没有。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>: <span class="number">0000000000000004</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_init_zero<span class="number">.1920</span></span><br><span class="line">   <span class="number">7</span>: <span class="number">0000000000000008</span>     <span class="number">4</span> OBJECT  LOCAL  DEFAULT    <span class="number">4</span> stat_not_init<span class="number">.1919</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意观察两个静态变量多了两个后辍</p>
</blockquote>
<p>这样做其实是为了区分在同一个模块中同名的两个静态变量</p>
<p>如下面程序的这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个静态变量虽然都是x，但显然他们不是同一个变量，因此编译器会在符号表中通过加上一个后辍的形式来区分他们。</p>
<h3 id="2-2-可执行目标文件格式"><a href="#2-2-可执行目标文件格式" class="headerlink" title="2.2 可执行目标文件格式"></a>2.2 可执行目标文件格式</h3><p>下面是典型的ELF 可执行目标文件</p>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220910192419982.png" alt="image-20220910192419982"></p>
<p>在ELF 头和节之间，有一个特殊的段头部表，接下来我们通过<code>readelf</code> 来看一下这个段头部表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOAD           <span class="number">0x0000000000000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span></span><br><span class="line">               <span class="number">0x0000000000000498</span> <span class="number">0x0000000000000498</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000001000</span> <span class="number">0x0000000000401000</span> <span class="number">0x0000000000401000</span></span><br><span class="line">               <span class="number">0x0000000000000205</span> <span class="number">0x0000000000000205</span>  R E    <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002000</span> <span class="number">0x0000000000402000</span> <span class="number">0x0000000000402000</span></span><br><span class="line">               <span class="number">0x0000000000000120</span> <span class="number">0x0000000000000120</span>  R      <span class="number">0x1000</span></span><br><span class="line">LOAD           <span class="number">0x0000000000002e50</span> <span class="number">0x0000000000403e50</span> <span class="number">0x0000000000403e50</span></span><br><span class="line">               <span class="number">0x00000000000001e0</span> <span class="number">0x00000000000001e8</span>  RW     <span class="number">0x1000</span> </span><br></pre></td></tr></table></figure>
<p> 我们知道，程序的代码从0x0000000000400000开始，从上面这个程序头部表中我们看到它将文件中0x00000000000000000处的内容映射到了虚拟内存0x0000000000400000处，这正是程序开始运行的地方。</p>
<blockquote>
<p>ELF可执行文件被设计为很容易加载到存储器，连续的可执行文件的组块(cuks)被映射到连续的存储器段。段头表(segment header table)描述了这种映射关系。</p>
</blockquote>
<p>加载可执行文件：</p>
<p>在shell中输入 <code>./prog</code> 后：</p>
<ol>
<li>shell调用fork() 函数，创建子进程</li>
<li>子进程调用execve()，execve调用加载器，加载prog程序</li>
<li>加载器讲可执行文件加载到内存后(在段头部表的引导下)，跳转到程序的入口点(_start函数地址)</li>
<li>_start 调用系统函数 __libc_start_main，初始化执行环境，调用用户层的main函数</li>
</ol>
<h3 id="2-3-可共享目标文件格式"><a href="#2-3-可共享目标文件格式" class="headerlink" title="2.3 可共享目标文件格式"></a>2.3 可共享目标文件格式</h3><h2 id="3-三种链接和链接的过程"><a href="#3-三种链接和链接的过程" class="headerlink" title="3 三种链接和链接的过程"></a>3 三种链接和链接的过程</h2><p>三种链接：</p>
<ol>
<li>静态链接</li>
<li>动态链接库</li>
<li>程序运行时链接共享库</li>
</ol>
<h3 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1 静态链接"></a>3.1 静态链接</h3><p>静态链接的两个过程</p>
<ol>
<li>符号解析</li>
<li>重定位</li>
</ol>
<h4 id="3-1-1-符号解析"><a href="#3-1-1-符号解析" class="headerlink" title="3.1.1 符号解析"></a>3.1.1 符号解析</h4><p>链接器解析符号引用的方法是，讲每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p>
<p>对于局部符号，它不会出现在符号表中。</p>
<p>对于本地静态变量，编译器会确保它们有唯一的名字 （回忆一下，编译器会通过给名称相同的静态变量加后缀来区分他们），因此也很好解析。</p>
<p>唯一难处理的是对全局符号（全局变量，非static 的函数声明）的引用。</p>
<p>对于一个不在当前模块定义的符号，编译器会假定它定义在其他模块，并生成一条符号表条目，将它交给链接器处理。</p>
<p>而编译器向链接器输出的这些符号，都会被划分为强符号或弱符号。</p>
<p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量 (在COMMON伪节)</p>
<p>接着使用以下规则来处理这些符号：</p>
<ol>
<li>不允许有多个同名的强符号</li>
<li>如果一个强符号与多个弱符号同名，选择强符号</li>
<li>若有多个弱符号同名，从这些弱符号中任选一个。</li>
</ol>
<blockquote>
<p>这三个规则很容易造成一些不易察觉的运行时错误。</p>
<p>为什么会有.COMMON伪节？</p>
<p>如果有一个未初始化的全局变量x，编译器不知道这是一个extern 声明还是一个定义，不知道其他模块是否还有一个x，因此它把这个决定权留给链接器。</p>
<p>而如果是一个初始化为0的全局变量，根据强符号的规则，它是唯一的，因此编译器可以把他放到.bss节</p>
</blockquote>
<p>以上讲的是几个.o 文件的链接，他们都是<code>目标文件</code> </p>
<p>接下来我们讲与静态库的链接，其中会有<code>存档文件</code> 这个概念，注意区别</p>
<blockquote>
<p>静态库，封装了很多函数编译出来的目标文件的文件，一般是一个一个的函数。静态库即存档文件，后辍是  .a</p>
<p>在链接时，链接器指挥复制静态库里被使用的存档文件，从而节省空间。</p>
</blockquote>
<p>生成静态库：</p>
<p>首先编译：<code>gcc -c addvec.c multvec.c</code></p>
<p>接着生成静态库：<code>ar rcs libvector.a addvec.o multvec.o</code> </p>
<p>得到静态库 <code>libvector.a</code>，存档文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101743742.png" alt="image-20220910174348618"> </p>
<p>(重要) 链接器如何使用静态库来解析引用：</p>
<blockquote>
<p>链接器维持一个可重定位目标文件的集合E,这个集合中的文件会被合并起来形成可执行文件，和一个未解析的符号（也就是，引用了但是尚未定义的符号)集合U,以及一个在前面输入文件中已定义的符号集合D。初始地，E、U和D都是空的。</p>
<ul>
<li>对于命令行上的每个输入文件f，链接器会判断 f 是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E,修改U和D来反映 f 中的符号定义和引用，并继续下一个输入文件。</li>
<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义<br>的符号。如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m<br>加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成<br>员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E<br>中的成员目标文件都被丢弃，而链接器将继续到下一个输入文件。</li>
<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错<br>误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>
</ul>
</blockquote>
<p>注意：链接器对待存档文件和目标文件是有区别的，对于目标文件，他会解析所有的符号，而对待存档文件，如果U中没有这个符号，该存档文件就会被抛弃。</p>
<p>因此，如果有几个相互依赖的目标文件，他们在命令行中出现的顺序是无关紧要的。</p>
<p>但如果几个存档文件相互依赖，那么他们在命令行中出现的顺序就是需要特别关注的</p>
<p>如果文件A的符号定义在文件B中，我们就说文件A依赖文件B A→B</p>
<p>假如有这样的依赖关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209101815751.png" alt="image-20220910181532038"></p>
<p>我们要写成<code>gcc A.o B.a C.a B.a -o prog</code>  因为A.o 是目标文件，它的所有符号都被解析了，所以它只需要出现一次，而B.a则需要出现两次。</p>
<h4 id="3-1-2-重定位"><a href="#3-1-2-重定位" class="headerlink" title="3.1.2 重定位"></a>3.1.2 重定位</h4><p>《深入理解计算机系统》原书第三版 P 478 7.7</p>
<h3 id="3-2-动态链接库"><a href="#3-2-动态链接库" class="headerlink" title="3.2 动态链接库"></a>3.2 动态链接库</h3><p>静态库的代码被嵌入到链接的程序，如果一个静态库被几乎所有的程序使用，就会造成大量的空间浪费，因此出现了动态库。</p>
<p>所有引用一个动态库的可执行目标文件共享一个动态库，而不是像静态库一样，代码被嵌入进程序中。</p>
<p>创建动态库 <code>gcc -shared -fpic -o libvector.so addvec.c multvec.c</code> </p>
<p>与动态库链接：</p>
<p><code>gcc -o prog main.c ./libvector.so</code></p>
<p>与动态库链接的时候，只会讲重定位和符号表信息复制到可执行文件中，而不会嵌入其他数据。</p>
<p>下面是动态链接库的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209112059039.png" alt="image-20220911205952800"> </p>
<blockquote>
<p>一个使用动态库的例子：(详见异常控制流 - CS:APP 第八章)</p>
<p>我们将<code>csapp.c</code> 库编译成动态库</p>
<p>使用<code>gcc -shared -fpic csapp.c -o libcsapp.so -lphread</code> </p>
<p>得到 <code>libcsapp.so</code> 将它移动到<code>/lib</code> </p>
<p>接着将<code>csapp.h</code> 移动到 <code>/usr/local/include</code> </p>
<p>编译问使用CSAPP动态库时，只需要使用    <code>gcc main.c -o prog -lcsapp</code> </p>
<p>其中编译选项<code>-lxxx</code> 代表告诉GCC去/lib等文件夹下寻找 libxxx.so 与其链接</p>
<p>我们在编译<code>csapp.c</code>的时候，用的编译选项，<code>-lphread</code> 就是告诉编译器与<code>libphread.so</code>库链接，这个库存放与线程相关的代码</p>
<p>以后打包静态库时，我们也要记住，动态库的命名规则是<code>libxxx.so</code> </p>
</blockquote>
<h3 id="3-3-程序运行时链接共享库"><a href="#3-3-程序运行时链接共享库" class="headerlink" title="3.3 程序运行时链接共享库"></a>3.3 程序运行时链接共享库</h3><p>可以在运行时，从动态库中寻找该符号，动态加载到程序中。示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7.11 load and link shared library from an application</span></span><br><span class="line"><span class="comment">// to compile this file : &quot;gcc -rdynamic -o prog_runtime_load dll.c -ldl&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * handle;  <span class="comment">// shared lib handle</span></span><br><span class="line">    <span class="type">void</span> (*addvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">void</span> (*multvec)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">// point to a function</span></span><br><span class="line">    <span class="type">char</span> * error;   <span class="comment">// point to error massages string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load shared library</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search the symbol &quot;multvec&quot; from the shared library</span></span><br><span class="line">    multvec = dlsym(handle, <span class="string">&quot;multvec&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = (dlerror())) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute the function</span></span><br><span class="line">    multvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unload the shared library</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="名词索引"><a href="#名词索引" class="headerlink" title="名词索引"></a>名词索引</h2><p>ELF-64 目标文件格式</p>
<p>PIC(Position-Independent Code) 位置无关代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">动态数组,二维数组,指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-06 20:45:24 / 修改时间：20:46:41" itemprop="dateCreated datePublished" datetime="2022-09-06T20:45:24+08:00">2022-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%90%E7%A2%8E%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">琐碎记录</span></a>
                </span>
            </span>

          
            <span id="/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/" class="post-meta-item leancloud_visitors" data-flag-title="动态数组,二维数组,指针" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/06/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%87%E9%92%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态数组、二维数组、指针"><a href="#动态数组、二维数组、指针" class="headerlink" title="动态数组、二维数组、指针"></a>动态数组、二维数组、指针</h1><p>本文会讲：</p>
<ul>
<li>二维数组的存储形式</li>
<li>数组类型为什么会退化？</li>
<li>二维数组的动态分配</li>
</ul>
<h2 id="1-二维数组的存储形式"><a href="#1-二维数组的存储形式" class="headerlink" title="1 二维数组的存储形式"></a>1 二维数组的存储形式</h2><p>以下这个程序可以很好的说明二维数组的存储形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = i * <span class="number">10</span> + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="built_in">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的运行结果是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">32</span>      </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DD0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">000000000064F</span>DD0</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">000000000064F</span>DD8</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">000000000064F</span>DE0</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">000000000064F</span>DE8</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD0</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DD4</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DD8</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DDC</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE0</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DE4</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">000000000064F</span>DE8</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000064F</span>DEC</span><br></pre></td></tr></table></figure>
<p>可以看出，二维数组是连续储存的，有<code>&amp;a = a = &amp;a[0] = a[0] = &amp;a[0][0]</code> ，以此类推。</p>
<p>我们可以这样表示二维数组</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-数组类型为什么会退化？"><a href="#2-数组类型为什么会退化？" class="headerlink" title="2 数组类型为什么会退化？"></a>2 数组类型为什么会退化？</h2><p>有的时候会出现这种情况：</p>
<p>在主函数里声明了一个二维数组，使用sizeof 会得到它的大小，但传到函数里，却只能得到指针的大小，这是为什么呢？</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/464844221/answer/1940453834">https://www.zhihu.com/question/464844221/answer/1940453834</a></p>
<h2 id="3-动态分配二维数组"><a href="#3-动态分配二维数组" class="headerlink" title="3 动态分配二维数组"></a>3 动态分配二维数组</h2><h3 id="3-1-第一种方法"><a href="#3-1-第一种方法" class="headerlink" title="3.1 第一种方法"></a>3.1 第一种方法</h3><p>先申请一维数组，在将该一维数组强制转换成二维数组</p>
<p>前置知识：</p>
<p>一维数组的数组名是：一个指向数据类型的指针，如int *，初次之外没有任何多余的信息</p>
<p>二维数组的数组名是：一个【指向一维数组的指针】，在这里，一维数组就相当于数据类型，</p>
<p>即<code>int q[][4]</code> 和<code>int (*q)[4]</code> 是等价的，两者都是指向一维数组的指针，当对这个指针 + 2时，就等价于<code>q += 2 * 4 * sizeof(int)</code></p>
<p>直接贴代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="type">int</span> (*b)[<span class="number">4</span>] = (<span class="type">int</span> (*)[<span class="number">4</span>])a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建了一个一维数组，这个数组存储了8个连续的整数类型。</p>
<p>我们用<code>int (*b)[4]</code> 声明了一个指向 四个元素的数组 的指针。</p>
<p>然后对数组a进行强制类型转换，将它转换成了一个指向4个元素数组的指针。</p>
<p>这样动态分配的指针和直接<code>int b[2][4]</code> 是一样的。</p>
<p>下面我们使用 1 中的方法对这个数组进行仔细检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        b[i] = i;</span><br><span class="line">    <span class="type">int</span> (*a)[<span class="number">2</span>] = (<span class="type">int</span> (*)[<span class="number">2</span>])b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span>       </span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span>       </span><br><span class="line"></span><br><span class="line">a:      <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span>      </span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span>      </span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">02</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">03</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">04</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">05</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">06</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">07</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">00000000009</span>C1420</span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">00000000009</span>C1428</span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">00000000009</span>C1430</span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">2</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">4</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">00000000009</span>C1438</span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1420</span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1424</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1428</span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C142C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1430</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C1434</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">00000000009</span>C1438</span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">00000000009</span>C143C</span><br></pre></td></tr></table></figure>
<p>可以看到除了小部分细节（sizeof(a) 、&amp;a）与我们直接声明二维数组表现得不一样，其他的行为与直接声明二维数组是一模一样的。</p>
<p>这种方法得到的二维数组虽然和原生的二维数组一样，但它也有缺点，就是它不能动态分配行的长度，即列的大小。因此只能说是半个动态数组。而且，更令人烦恼的是，指向数组的指针，int (*)[len] 这个类型也无法作为函数的返回值，或者使用typedef来取别名，不方便我们对它进行包装。 </p>
<h3 id="3-2-第二种方法："><a href="#3-2-第二种方法：" class="headerlink" title="3.2 第二种方法："></a>3.2 第二种方法：</h3><blockquote>
<p>参考: <a target="_blank" rel="noopener" href="https://blog.csdn.net/morewindows/article/details/7664479#">https://blog.csdn.net/morewindows/article/details/7664479#</a> 我这里将原文的int 替换成了size_t</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言中动态的申请二维数组 malloc free</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//动态申请二维数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T** <span class="title">malloc_Array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="built_in">sizeof</span>(T);</span><br><span class="line">  <span class="type">int</span> point_size = <span class="built_in">sizeof</span>(T*);</span><br><span class="line">  <span class="comment">//先申请内存，其中point_size * row表示存放row个行指针</span></span><br><span class="line">  T **arr = (T **) <span class="built_in">malloc</span>(point_size * row + size * row * col);</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;	</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, point_size * row + size * row * col);</span><br><span class="line">    T *head = (T*)((<span class="type">size_t</span>)arr + point_size * row);    <span class="comment">// 这里将arr转换成int型是为了直接进行算数相加，但我觉得还是转换成size_t好</span></span><br><span class="line">    <span class="keyword">while</span> (row--)</span><br><span class="line">      arr[row] = (T*)((<span class="type">size_t</span>)head + row * col * size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T**)arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_Aarray2D</span><span class="params">(<span class="type">void</span> **arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  C语言中动态的申请二维数组 malloc free\n&quot;</span>);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入行列(以空格分开): &quot;</span>);</span><br><span class="line">  <span class="type">int</span> nRow, nCol;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;nRow, &amp;nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//动态申请连续的二维数组</span></span><br><span class="line">  <span class="type">int</span> **p = <span class="built_in">malloc_Array2D</span>&lt;<span class="type">int</span>&gt;(nRow, nCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//为二维数组赋值	</span></span><br><span class="line">  <span class="type">int</span> i, j;	</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      p[i][j] = i + j;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//输出二维数组	</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRow; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCol; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, p[i][j]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">free_Aarray2D</span>((<span class="type">void</span>**)p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，原作者对指针的操作让我叹为观止。</p>
<p>但是，用这种方法创作出来的二维数组和直接<code>int b[2][4]</code> 得到的二维数组，结构显然是不一样的，这里我们不在进行仔细地检查。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-3-第三种方法"><a href="#3-3-第三种方法" class="headerlink" title="3.3 第三种方法"></a>3.3 第三种方法</h3><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/houqd2012/article/details/8146070">https://blog.csdn.net/houqd2012/article/details/8146070</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，这种方法生成地数组，其地址是连续地，应该和原生的二维数组是一样的(包括这种方法的原作者也是这样认为的)，但如果我们仔细检查，我们会发现它其实和原生的二维数组是不一样的。</p>
<p>我们使用 1 中的程序对这个数组进行详细的检查。代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **<span class="title function_">make_array2D</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(row * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(row * col * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + col;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array2D</span><span class="params">(<span class="type">int</span> **arr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> **a = make_array2D(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]):\t%llu\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:\t%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a:\t%p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]:\t%02d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]:\t%p\n&quot;</span>, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*a[%d]:\t%d\n&quot;</span>, i, *a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d]:\t%p\n&quot;</span>, i, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[%d][%d]:\t%p\n&quot;</span>, i, j, &amp;a[i][j]);</span><br><span class="line">    free_array2D(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>):    <span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a):      <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]):   <span class="number">8</span></span><br><span class="line"></span><br><span class="line">a:      <span class="number">0000000000701420</span></span><br><span class="line">&amp;a:     <span class="number">000000000064F</span>DF0</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:        <span class="number">00</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]:        <span class="number">01</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:        <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:        <span class="number">11</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]:        <span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>]:        <span class="number">21</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]:        <span class="number">30</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">1</span>]:        <span class="number">31</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]:   <span class="number">0000000000701450</span></span><br><span class="line">a[<span class="number">1</span>]:   <span class="number">0000000000701458</span></span><br><span class="line">a[<span class="number">2</span>]:   <span class="number">0000000000701460</span></span><br><span class="line">a[<span class="number">3</span>]:   <span class="number">0000000000701468</span></span><br><span class="line"></span><br><span class="line">*a[<span class="number">0</span>]:  <span class="number">0</span></span><br><span class="line">*a[<span class="number">1</span>]:  <span class="number">10</span></span><br><span class="line">*a[<span class="number">2</span>]:  <span class="number">20</span></span><br><span class="line">*a[<span class="number">3</span>]:  <span class="number">30</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>]:  <span class="number">0000000000701420</span></span><br><span class="line">&amp;a[<span class="number">1</span>]:  <span class="number">0000000000701428</span></span><br><span class="line">&amp;a[<span class="number">2</span>]:  <span class="number">0000000000701430</span></span><br><span class="line">&amp;a[<span class="number">3</span>]:  <span class="number">0000000000701438</span></span><br><span class="line"></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">0</span>]:       <span class="number">0000000000701450</span></span><br><span class="line">&amp;a[<span class="number">0</span>][<span class="number">1</span>]:       <span class="number">0000000000701454</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">0</span>]:       <span class="number">0000000000701458</span></span><br><span class="line">&amp;a[<span class="number">1</span>][<span class="number">1</span>]:       <span class="number">000000000070145</span>C</span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">0</span>]:       <span class="number">0000000000701460</span></span><br><span class="line">&amp;a[<span class="number">2</span>][<span class="number">1</span>]:       <span class="number">0000000000701464</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">0</span>]:       <span class="number">0000000000701468</span></span><br><span class="line">&amp;a[<span class="number">3</span>][<span class="number">1</span>]:       <span class="number">000000000070146</span>C</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出，这种方法生成的二维数组，虽然地址是连续的，但它的结构和直接<code>int b[2][4]</code> 得到的二维数组，还是不一样的。</p>
<p>它的具体结构我将在下一小节介绍</p>
<h3 id="3-4-总结-：-下标运算符"><a href="#3-4-总结-：-下标运算符" class="headerlink" title="3.4 总结 ： 下标运算符"></a>3.4 总结 ： 下标运算符</h3><p>首先我们介绍下标运算符，上面的三种动态分配二维数组的方法，其原理都是基于下标运算符。</p>
<p>下标运算符是左结合的，我们引用二维数组，通常是这样的    <code>arr[i][j]</code> 但其实也可以这样 <code>(arr[i])[j]</code> 这两种形式是等价的。</p>
<p>下面我们详细地描述下标运算符 </p>
<p><code>ElementType[i] = *((size_t)ElementType + i * sizeof(ElementType))</code></p>
<p>可见下标运算符最重要的就是ElementType，这个ElementType 可以是内置类型 int，可以是指针类型<code>int **</code>, 也可以是数组类型 <code>int (*)[]</code>，在使用下标运算符时，我们要尤其注意ElementType，尤其是在我们接下来分析二维数组时。</p>
<p>首先我们来看内置的数组类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a[0]</td>
<td></td>
<td>a[1]</td>
<td></td>
<td>a[2]</td>
<td></td>
<td>a[3]</td>
<td></td>
</tr>
<tr>
<td>a[0] [0]</td>
<td>a[0] [1]</td>
<td>a[1] [0]</td>
<td>a[1] [1]</td>
<td>a[2] [0]</td>
<td>a[2] [1]</td>
<td>a[3] [0]</td>
<td>a[3] [1]</td>
</tr>
</tbody>
</table>
</div>
<p>一个内置数组类型表示为<code>int a[5][5]</code> ，但拎出来a，他的类型是 <code>int (*)[5]</code> 所以<code>arr[1]</code> 其实是指<code>a[1][0]</code> 这个位置。<code>a[1]</code> 的类型是<code>int *</code> 所以<code>(a[1])[1]</code> 的类型就是<code>int</code></p>
<p>接下来我们看动态分配二维数组的第一种方法：</p>
<p>这种方法一开始申请了一个一维数组<code>int *a = (int *)malloc(2 * 4 * sizeof(int))</code> a的类型是<code>int *</code></p>
<p>接下来我们使用强制类型转换，将a由<code>int *</code> 转换为<code>int (*)[4]</code> ，这样它就和内置的二维数组一样了。也可以使用两个下标运算符进行访问。</p>
<p>接下类我们看动态分配二维数组的第二种方法：</p>
<p>首先我们将这种方法分配的图画出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209061948605.png" alt="image-20220906194800829">  </p>
<p>设行数为row，列数为col，假设二维数组存储的类型为 int</p>
<p>第二种方法申请了 <code>row * sizeof(int *) + row * col * sizeof(int)</code> 字节的空间。</p>
<p>这个表达式的前一项<code>row * sizeof(int *)</code> 代表a[0] a[1] a[2] 的空间，后一项<code>row * col * sizeof(int)</code> 指的是连续的二维数组的存储空间。</p>
<p>这个程序做的就是让a[0]指向a[0] [0]，让a[1] 指向 a[1] [0]，依此类推。</p>
<p>需要注意的是这个二维数组的类型，虽然这个二维数组可以使用两个下标运算符引用，但原理却和内置的二维数组完全不同。第二种二维数组的类型是<code>int **</code> 而不是<code>int (*)[col]</code> ，也决不能是<code>int (*)[col]</code> 。要理解这个，我们看一下在使用下标运算符时究竟发生了什么？</p>
<p>首先a的类型时<code>int **</code> ，a[1]，代表a之后一个指针大小位置的内容，即</p>
<p><code>*((size_t)a + 1 * sizeof(int *))</code>，就是a[1] [0]的地址，而<code>(a[1])[0]</code> 就是a[1] [0]的内容。</p>
<p>为了保证我们第一个下表运算符能够得到a[1] [0] 的地址，我们必须保证这个二维数组的类型是<code>int **</code> </p>
<p>第三种二维数组的分析与第二种类似，这里我们给出它的表示</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209062002932.png" alt="image-20220906200208361"> </p>
<h2 id="4-指针"><a href="#4-指针" class="headerlink" title="4 指针"></a>4 指针</h2><p>我们使用一个程序来展示 <code>int (*)[col]</code> 类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> a[][<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_3</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">8</span>])</span>  <span class="comment">// 指向数组的指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (*a)[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> q[<span class="number">4</span>][<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">      q[i][j] = <span class="number">10</span> * i + j;</span><br><span class="line"></span><br><span class="line">  func_1(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  func_2(q, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> p[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  func_3(&amp;p);		<span class="comment">// 因为是指向数组的指针，p必须要取地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一篇文章 ：<a target="_blank" rel="noopener" href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></p>
<p>这篇文章里对指针类型的分析很好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span></span><br><span class="line"><span class="type">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line">Int (*p)(<span class="type">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span></span><br><span class="line"><span class="type">int</span> *(*p(<span class="type">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">存储器层次结构 - CS:APP 第六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-04 11:28:41" itemprop="dateCreated datePublished" datetime="2022-09-04T11:28:41+08:00">2022-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 22:13:47" itemprop="dateModified" datetime="2022-09-25T22:13:47+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-meta-item leancloud_visitors" data-flag-title="存储器层次结构 - CS:APP 第六章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/04/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-CS-APP-%E7%AC%AC%E5%85%AD%E7%AB%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储器层次结构-CS-APP-第六章"><a href="#存储器层次结构-CS-APP-第六章" class="headerlink" title="存储器层次结构 - CS:APP 第六章"></a>存储器层次结构 - CS:APP 第六章</h1><p>本章的主要内容有四：</p>
<ol>
<li>介绍存储技术 </li>
<li>介绍存储器的层次结构思想</li>
<li>特别介绍高速缓存的原理和细节</li>
<li>使用局部性优化程序的性能</li>
</ol>
<p>本文主要介绍前三条内容，第四条内容可以说是优化程序性能的一部分，所以本文暂不深入。另外，本章和第九章虚拟内存密切相关，因此本文也会介绍第九章的虚拟内存，来完整的总结计算机的存储系统。</p>
<h2 id="1-存储器的层次结构"><a href="#1-存储器的层次结构" class="headerlink" title="1 存储器的层次结构"></a>1 存储器的层次结构</h2><p>根据我们的经验观察，读取速度越快的存储器/存储技术，成本越高，容量越小，读取速度越慢的存储器，成本越低，容量越大。</p>
<p>因此我们可以将大量的数据都存放在成本低，速度慢的存储器上。</p>
<p>但随着技术的发展，CPU的时钟周期越来越快，如果让CPU直接和这些慢速存储器交互会浪费大量的性能，因此我们可以上速度快的存储器缓存低速存储器的内容，与CPU交互，这就是存储器层次结构的思想。</p>
<blockquote>
<p>存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L0  寄存器</span><br><span class="line">L1  L1高速缓存 SRAM</span><br><span class="line">L2  L2高速缓存 SRAM</span><br><span class="line">L3  L3高速缓存 SRAM</span><br><span class="line">L4  主存 DRAM</span><br><span class="line">L5  本地二级存储（本地磁盘）</span><br><span class="line">L6  远程二级缓存（分布式文件系统、二级服务器）</span><br></pre></td></tr></table></figure>
<p>下面我们介绍它们的存在基础，存储技术。</p>
<h2 id="2-存储技术"><a href="#2-存储技术" class="headerlink" title="2 存储技术"></a>2 存储技术</h2><p>我们要介绍的存储技术如下</p>
<ul>
<li>随机存储器RAM<ul>
<li>SRAM</li>
<li>DRAM</li>
</ul>
</li>
<li>非易失性存储器 ROM<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
<li>SSD （基于闪存，固态硬盘就是使用SSD技术）</li>
</ul>
</li>
<li>磁盘</li>
</ul>
<h3 id="2-1-随机访问存储器"><a href="#2-1-随机访问存储器" class="headerlink" title="2.1 随机访问存储器"></a>2.1 随机访问存储器</h3><p>随机存储器分为两种材类：SRAM和DRAM</p>
<p>SRAM 静态随机存储器，通电之后，数据就是稳定的，因此被称为静态随机存储器。速度最快，造价高，一般计算机的高速缓存是SRAM。</p>
<p>DRAM 动态随机存储器，其原理是电容充电，DRAM上的单元在10 ~ 100ms 内就会放电，所以要定期刷新以保持数据，因此被称为动态随机存储器。速度相对SRAM慢，造价相对低，一般用于计算机的内存 或叫做主存。</p>
<h4 id="2-1-1-DRAM-内存的工作原理"><a href="#2-1-1-DRAM-内存的工作原理" class="headerlink" title="2.1.1 DRAM / 内存的工作原理"></a>2.1.1 DRAM / 内存的工作原理</h4><p>内存由若干个DRAM芯片构成，被称作内存模块(memory module)</p>
<p>每个DRAM芯片由超单元矩阵、内部行缓冲区、内存控制器构成，DRAM芯片上还有由于信息输入输出的脚针。</p>
<p>每个超单元内存储若干个位，一般是一字节八位。　</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内存/主存</span><br><span class="line">|</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|- 内存模块</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br><span class="line">|  |- DRAM 芯片</span><br></pre></td></tr></table></figure>
<p>首先介绍DRAM 芯片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041151521.png" alt="image-20220904115118409"> </p>
<p>DRAM 芯片由超单元矩阵、内部行缓冲区、内存控制器构成。一个DRAM芯片中由d个超单元，这些超单元被组织成 r 行 c 列的长方形矩阵(r * c = d)，每个超单元内存储w位，我们称这是一个d×w的DRAM芯片。</p>
<p>我们可以看到两个引脚，一个addr引脚向内部输送行列信息，一个data引脚向外输送存储在一个超单元上的位。一个超单元有多少位，data引脚就有多少位。</p>
<p>接下来看一下工作流程：</p>
<p>首先内存控制器在addr引脚上发送行地址，DRAM将相应的一行放到内部行缓冲区上作为相应，接着内存控制器在addr引脚上发送列地址，DRAM将内部行缓冲区上的列放到data引脚上传输出去 作为相应。</p>
<p>接着介绍内存模块：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209041158562.png" alt="image-20220904115757187"> </p>
<p>一个内存模块由若干个DRAM芯片构成，当内存控制器给内存模块发送一个行列信息(i, j) 时，内存模块会将它所有的DRAM芯片上（i, j）位置的超单元的位 取下来，将所有的这些字节拼成一个字，再传输出去，如上图所示。 </p>
<h3 id="2-2-磁盘-amp-ROM"><a href="#2-2-磁盘-amp-ROM" class="headerlink" title="2.2 磁盘 &amp; ROM"></a>2.2 磁盘 &amp; ROM</h3><p>ROM可分为</p>
<ul>
<li>PROM 可编程ROM</li>
<li>EPRROM 可擦可写可编程ROM</li>
<li>flash memory 闪存（基于EPRROM）</li>
</ul>
<p>我们不多介绍，只需要知道他们的名字和依赖关系即可</p>
<p>磁盘：通常指的是机械硬盘，也不过多介绍。</p>
<h2 id="3-高速缓存"><a href="#3-高速缓存" class="headerlink" title="3 高速缓存"></a>3 高速缓存</h2><p>首先我们补充存储器层次结构方面的知识，由于这部分知识和本节密切相关，因此我们放到这里介绍：</p>
<blockquote>
<ul>
<li><p>对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)，块的大小通常是固定的。</p>
</li>
<li><p>而第k层的存储器被划分为较少的块的集合，每个块的大小与k+1层的块的大小是一样的，在任意时刻，第k层的缓存包含第k+1层块的一个子集的副本。</p>
</li>
<li>数据总是以块大小为传送单元，在第k层和第k+1层之间来回复制，虽然在层次结构中的任意一对相邻的层次之间块大小是固定的，但是其他层次对之间可以有不同块大小。</li>
</ul>
</blockquote>
<p>以上是书上的原话，他们介绍了一个重要的概念——块。你要记住在层次之间传送的是块。</p>
<p>令人迷惑的是第三句话，相邻层次的块大小是相同的，但隔层之间的块可以是不同的。如果相邻层之间的块，大小是相同的，那么所有层次的块，大小都应该是相同的。</p>
<p>这句话暂且悬置。</p>
<p>当然，硬要解释也是可以的，你可以理解为，相邻块之间总是传输大小相同的单元，但下层块一旦到了上层，就会被划分为更小的块，用于与上层交互。</p>
<p>但最好还是理解成所有块的大小都是相同的，方便理解下面的内容。</p>
<h3 id="3-1-高速缓存的结构"><a href="#3-1-高速缓存的结构" class="headerlink" title="3.1 高速缓存的结构"></a>3.1 高速缓存的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042138819.png" alt="image-20220904213832532"> </p>
<p>一个计算机存储器的地址有m位，他被分为三部分：</p>
<ul>
<li>高t位是标记位</li>
<li>中间s位是组索引位</li>
<li>低b位是组偏移位。</li>
</ul>
<p>高速缓存被组织为这样的结构：</p>
<ul>
<li><p>高速缓存有2^s^ 组，每组被编号位0，1，2，…，2^s^ - 1</p>
</li>
<li><p>每个组中最多有2^t^ 个高速缓存行</p>
</li>
<li>每个高速缓存行也由三部分组成<ul>
<li>一位有效位，标记着这个高速缓存行是否有效</li>
<li>t个标记位，用于与该组中的其他高速缓存行区分，因此每组只能由2^t^ 个高速缓存行</li>
<li>2^b^ 大小的数据，存储的是在下一层复制上来的块(block)，一行就存储了一个块的内容，有时候，“行” 和 “块” 这两个术语可以交替使用</li>
</ul>
</li>
</ul>
<h3 id="3-2-高速缓存的工作原理"><a href="#3-2-高速缓存的工作原理" class="headerlink" title="3.2 高速缓存的工作原理"></a>3.2 高速缓存的工作原理</h3><p>当CPU向高速缓存发起读指令时，高速缓存首先确定缓存是否命中，如果命中，直接发送给CPU的寄存器。如果不命中就向主存取，等待数据到达某个高速缓存行，接着发送给CPU的寄存器。</p>
<p>确定是否命中有三个步骤：</p>
<ol>
<li>组选择</li>
<li>行匹配</li>
<li>字抽取</li>
</ol>
<ol>
<li><p>组选择</p>
<p>回忆我们的地址的中间s位是组索引，所以我们只要抽取组索引就可以找到对应的组，而且由于一共有2^s^ 个组，所以，组一定会命中。</p>
</li>
<li><p>行匹配</p>
<p>如果一个组里的某一行，改行的有效位被设置，且标记位等于地址的标记位，则行匹配成功。</p>
<p>如果行不命中，就要牺牲某一行，将它驱逐，相应的块从低层次的存储层次中取上来。</p>
</li>
</ol>
<p>   补充 : </p>
<p>   我们先回忆一下地址的构成</p>
<p>   标记位 t + 索引位 s + 偏移位b</p>
<p>   假设有一个四位的地址，t = 1，s = 2，b = 1</p>
<p>   这四位地址的所有组合如下：</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209042239062.png" alt="image-20220904223950779"> </p>
<p>   我们把目光投向一对缓存层，由于地址的限制，较低层有8块，而较高层有4组（这里的4组是我们规定的）。</p>
<p>   我们的低层有8块，高层有4组，对于低层块如何在高层放置，我们做出如下规定：对于低层的块i，它必须存放在高层的 i mod 4 组上。</p>
<p>   这样我们较低层的 0、4 映射到了较高层的0组，</p>
<p>   1、5映射到了1，</p>
<p>   2、6映射到了2，</p>
<p>   3、7映射到了3</p>
<p>   一个组中可以有最多2^t^ 行，如果我们一组中只有一行。</p>
<p>   如果我们首先引用了块0，那么块0每放在较高层的组0，</p>
<p>   接下来我们再引用块4的时候，由于我们规定一组只有一行，这时就出现了一个冲突，我们必须选择一个牺牲行，来放置块4，在这里毫无疑问我们将选择唯一的一行。我们将块4放到了组0的唯一一行。</p>
<p>   通过上面的例子，我想说明两点</p>
<p>   一、并不是所有组都只有1行，如果一个组有多行，如果出现上述情况，我们只能使用严格复杂的策略去选择牺牲行，或者直接随机选择一个牺牲行。</p>
<p>   二、如果我们获得了一个地址，这个地址的组索引是0组，但该组里并没有一个有效的标记与我们地址的标记匹配，这是我们要怎样在下层存储中找到我们要得到的块呢？</p>
<p>   注意到，将地址的标记位（1位）和组索引位（2位），合起来（3位），刚好是块在较低存储层的编号。这样就可以快速在较低层定位块。</p>
<p>   其实，将地址分成标记位和索引位，并不能扩充地址空间的大小，但可以增快寻址速度，这一点就是利用了这个原理。</p>
<ol>
<li>字抽取</li>
</ol>
<p>只要根据地址中的块偏移定位到行的某个位置，就可以取出在此之后的任意长度的位。</p>
<h2 id="4-虚拟内存"><a href="#4-虚拟内存" class="headerlink" title="4 虚拟内存"></a>4 虚拟内存</h2><p>从上面的叙述我们可以看出，计算机的存储系统是复杂的。为了简化内存管理，现代系统提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供一个大的、一致的私有地址空间。</p>
<blockquote>
<p>虚拟内存提供三个重要的能力：</p>
<ol>
<li>它将主存堪称是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它搞笑地利用了主存。</li>
<li>它位每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol>
</blockquote>
<p>从上面的原文我们可以看出，虚拟内存是对磁盘的抽象，它管理的是磁盘上的块，按需要将磁盘上的块传送到主存DRAM中。同时我们要知道，虚拟内存将磁盘上的N个连续的字节大小的单元组织成数组，每个单元都有唯一的地址。</p>
<p>虚拟内存的存在基础：</p>
<p>同一个数据对象，它在不同的地址空间里可以有不同的地址，主存中的每一个字节都可以有一个选自虚拟地址空间的地址和一个选自物理地址空间的地址。</p>
<h3 id="4-1-虚拟内存原理"><a href="#4-1-虚拟内存原理" class="headerlink" title="4.1 虚拟内存原理"></a>4.1 虚拟内存原理</h3><p>首先介绍两个概念，我们知道，在两个相邻的存储层次，他们传输的是块(block)，而在磁盘和主存中传输的块被称为页: </p>
<blockquote>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
</blockquote>
<p>真正的页就是物理页，而虚拟内存管理的页就是虚拟页，虚拟页和物理页是一一对应的，大小相等的。</p>
<p>我们知道，主存的容量远小于磁盘，而我们的虚拟内存是对磁盘空间的映射，所以，主存有时并不能放下某个进程的全部虚拟内存。而且，计算机要同时运行多个程序，不能只在主存中存放某个进程的虚拟内存。因此我们只能将某个进程暂时用到的虚拟内存的某部分存放到主存中。</p>
<h3 id="4-2-虚拟内存的结构"><a href="#4-2-虚拟内存的结构" class="headerlink" title="4.2 虚拟内存的结构"></a>4.2 虚拟内存的结构</h3><p>在CPU上有一个名叫内存管理单元(Memory Management Unit)的硬件，利用存放在主存中的页表来动态翻译虚拟地址。</p>
<p>页表：每个进程都有一个页表，页表将虚拟页映射到物理页。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209051937453.png" alt="image-20220905193713696"> </p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>
<h3 id="4-3-虚拟内存的地址翻译"><a href="#4-3-虚拟内存的地址翻译" class="headerlink" title="4.3 虚拟内存的地址翻译"></a>4.3 虚拟内存的地址翻译</h3><p>下面简单概括以下虚拟内存的地址翻译：</p>
<ol>
<li>处理器产生一个虚拟地址，并将它传送给MMU</li>
<li>MMU生成一个页表条目地址(Page Table Entry Address, PTEA)，首先在快表中搜索该PTEA，如果快表命中，我们得到页表条目(Page Table Entry, PTE)转4，否则在页表中寻找该页表条目地址，转3</li>
<li>由于快表没有命中PTEA，所以我们在高速缓存的页表中寻找该PTEA，如果命中，那么我们得到页表条目转4，如果高速缓存中的页表没有命中，那么我们要向主存请求页表，再从新的页表中搜寻PTEA，然后得到PTE，转4</li>
<li>现在我们已经得到了PTE，PTE在MMU中被翻译成物理地址，如果该物理地址在高速缓存中命中，那么我们直接将数据发送给处理器。如果高速缓存没有命中，我们就要在主存中请求该物理地址。</li>
</ol>
<p><img src="C:\Users\cfla\AppData\Roaming\Typora\typora-user-images\image-20220905200451112.png" alt="image-20220905200451112"> </p>
<p>下面我们介绍虚拟地址翻译中的一些细节：</p>
<ol>
<li><p>什么是页表条目地址(Page Table Entry Address, PTEA)，它是怎样被生成的？</p>
<p>要解答这个问题，首先我们要介绍虚拟地址的格式。</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>页表条目地址PTEA和虚拟页号VPN其实是同一个东西，两者没有区别。例如，VPN 0 选择PTE 0，VPN 1选择 PTE 1。</p>
</li>
<li><p>PTE 是什么，它的结构是什么？</p>
<p>PTE 是页表条目，他的结构是这样的</p>
<p>| SUP 有效位 | READ 有效位 | WRITE 有效位 | PPN 物理页号 (Physical Page Number) |<br>| ————— | —————- | —————— | —————————————————- |</p>
<p>前三段是有效位，如果SUP有效位设置为1表示该页只能在超级用户（内核模式）下才能被访问，READ有效位设置为1表示该页可读，WRITE有效位设置为1，表示该页可写。</p>
<p>PPN 物理页号是什么呢？</p>
<p>让我们回忆以下我们在介绍高速缓存时用到的物理地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052139387.png" alt="image-20220905213937545"> </p>
<p>如图所示，物理地址是由高t位的标记位，中间s位的组索引和低b位的快偏移 组成的。</p>
<p>而标记位和组索引合起来就是PPN。</p>
<p>而块偏移和虚拟地址的虚拟页偏移VPO是一样的</p>
<p>因此，地址翻译的时候，只需要将PTE中的PPN取出来，和VPO拼接起来就得到了物理地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052144414.png" alt="image-20220905214401855"> </p>
<ol>
<li><p>快表TLB的工作原理是什么？</p>
<p>快表和高速缓存的原理是类似的，我们首先重新审视一下虚拟地址：</p>
<p>虚拟地址由VPN和VPO组成</p>
<p>| 虚拟页号 VPN | 虚拟页偏移 VPO |<br>| —————— | ——————— |</p>
<p>而虚拟页号VPN又可以分为两部分：</p>
<p>| VPN           | VPN           | VPO  |<br>| ——————- | ——————- | —— |<br>| TLB标记(TLBT) | TLB索引(TLBI) | VPO  |</p>
<p>TLB首先进行组选择，即使用TLBI来匹配TLB内的组，这是一定可以命中的，原因详见高速缓存。</p>
<p>接着进行行匹配，即匹配TLB组内标记和TLBT相同的行。这一步就不一定会命中。如果按照我们之前的模型，由许多个页表条目PTE，只要他们的TLB索引相同（或者说VPN对2^S^ 取模，得到的值相同。PS: 其实这和组索引相同 是同一的，因为对2^s^ 取模就是取TLB索引，在这里，s指TLBI的位数），他们就会被映射到同一个组。如果没有命中，那么我们只能去高速缓存里继续从页表里翻找页表条目PTE了。</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-高速缓存系统和虚拟内存系统的对比"><a href="#5-高速缓存系统和虚拟内存系统的对比" class="headerlink" title="5 高速缓存系统和虚拟内存系统的对比"></a>5 高速缓存系统和虚拟内存系统的对比</h2><p>高速缓存系统 是在主存DRAM 和高速缓存SRAM 之间调度的系统</p>
<p>虚拟内存系统 是在磁盘(机械硬盘 或 SSD) 和主存DRAM 之间调度的系统</p>
<p>存储在某个存储层，在存储层之间传输的单元叫做块(block)</p>
<p>在高速缓存SRAM中，它叫做高速缓存行，或者行</p>
<p>在主存DRAM中，它叫做块(block)</p>
<p>在虚拟内存系统中，它叫做页(page)</p>
<p>调度策略</p>
<p>高速缓存不命中，替换策略往往很简单，因为不命中的惩罚很小</p>
<p>DRAM不命中，替换策略往往很复杂，因为DRAM与磁盘的速度相差很大，不命中的惩罚很大</p>
<h2 id="6-技术总结"><a href="#6-技术总结" class="headerlink" title="6 技术总结"></a>6 技术总结</h2><p>在介绍3.2 高速缓存工作原理时，我们看到了索引位和标记位的使用。同样我们在4.3 虚拟地址的翻译中也看到了TLBT和TLBI的使用。在这里我们对这种技术进行抽象和总结。</p>
<p>有两个存储层次，较下层的存储层次容量大，速度慢，我们称之为B层，较上层的存储层次容量小，速度快，我们称之为A层，我们要使用A层来缓存B层的内容。</p>
<p>我们将B层想象成一个数组，我们用n位的地址来表示这个数组的每个位。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052218205.png" alt="image-20220905221756883"> </p>
<p>B层可以容纳 2^n^ 大小的位。我们将B层划分为 2^m^ 块，其中每块的大小为 2^o^ ，这样数组的前2^o^ 位为第一个块，接着2^o^ 位是第二个块，依此类推。而这些块一共有2^m^ 个。我们有n = m + o。</p>
<p>现在我们通过巧妙地在地址中间花了一道线，不改变地址本身的结构，将线性的地址划分成了一个又一个的块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052220108.png" alt="image-20220905222017878"> </p>
<p>由于A层的空间有限，我们只能将B层的2^i^ 块映射到A层，我们要怎么去映射呢？</p>
<p>我们的方法是取出我们地址的前m位，去这m位的低i位，这低i位相同的块映射到同一组，而我们使用这m位的高t = m - i 位来作为标记，区分一组中的不同块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/cfla1638/Img/202209052224081.png" alt="image-20220905222457743"></p>
<p>通过这种方式，我们就实现了将B层的块映射到A层，通过这种映射，只要我们知道某数据对象位于B层的地址，我们就能很方便的在A层找到它。 </p>
<p>为什么使用中间位作为索引？</p>
<p>如果使用高位作为索引，连续的块可能会被映射到同一组，这样不能利用程序的局部性，造成比较大的损失。</p>
<p>接下来我们概括一下内存系统：</p>
<p>一个进程有自己的私有虚拟内存，它可以通过虚拟内存引用程序里的数据，io设备等。</p>
<p>如果他要引用一个数据，它生成一个虚拟地址，虚拟地址被CPU上的MMU转换成物理地址，然后依次开始在高速缓存、主存、磁盘 … 上寻址。</p>
<h2 id="7-术语索引"><a href="#7-术语索引" class="headerlink" title="7 术语索引"></a>7 术语索引</h2><p>主存储器(main memory 主存) : 即通常理解的使用DRAM内存。</p>
<p>块（block）: 对于存储器层次的k+1层，该层的存储器被分为连续的数据对象组块(chunk)，称为块(block)</p>
<p>VM (Virtual Memory) 虚拟内存</p>
<p>VA(Virtual Address) 虚拟地址</p>
<p>MMU(Memory Management Unit)：内存管理单元，一种硬件</p>
<p>VP (virtual page ) 虚拟页 : 在虚拟内存系统中与物理页对应的块</p>
<p>PP(Physical page) 物理页 : 在磁盘和主存之间传输的块</p>
<p>页表 ：一个数据类型位PTE的数组</p>
<p>PTE(Page Table Entry) 页表条目：存放在页表数组的每个元素的类型</p>
<p>页 : 在虚拟内存的习惯说法中，块(block) 被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping) 或页面调度(paging)</p>
<p>缺页：DRAM缓存不命中称为page fault</p>
<p>内存映射：将一组连续的虚拟页映射到任意文件中的任意位置的表示法称作内存映射(memory mapping)。P566</p>
<p>快表 (Translation Lookaside Buffer，TLB)：在MMU中的对页表的缓存，因为页表存储在主存中，所以与同为主存的高速缓存一样，快表的结构也是组加行，寻址时，首先进行组选择，接着进行行匹配，最后字抽取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cfla1638.github.io/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cfla">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cfla's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/" class="post-title-link" itemprop="url">CS:APP 读后感</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-02 14:23:07" itemprop="dateCreated datePublished" datetime="2022-09-02T14:23:07+08:00">2022-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-03 23:05:12" itemprop="dateModified" datetime="2022-09-03T23:05:12+08:00">2022-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-APP/" itemprop="url" rel="index"><span itemprop="name">CS:APP</span></a>
                </span>
            </span>

          
            <span id="/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/" class="post-meta-item leancloud_visitors" data-flag-title="CS:APP 读后感" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/02/CS-APP-%E8%AF%BB%E5%90%8E%E6%84%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS-APP-读后感"><a href="#CS-APP-读后感" class="headerlink" title="CS:APP 读后感"></a>CS:APP 读后感</h1><p>这本书，给了我 一个在Linux下运行的程序 的直观印象。下面是每一章让我产生 “惊讶” 的内容，这些内容是我在这本书中新接触到的内容。（以下内容是在阅读完第一遍之后，第二遍之前写的）</p>
<p>接下来会陆续更新各章的详细笔记 … </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目录：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第1章    计算机系统漫游</span><br><span class="line">--- 程序结构和执行</span><br><span class="line">第2章    信息的表示和处理</span><br><span class="line">第3章    程序的机械级表示</span><br><span class="line">第4章    处理器体系结构</span><br><span class="line">第5章    优化程序性能</span><br><span class="line">第6章    存储器的层次结构</span><br><span class="line">--- 在系统上运行程序</span><br><span class="line">第7章    链接</span><br><span class="line">第8章    异常控制流</span><br><span class="line">第9章    虚拟内存</span><br><span class="line">--- 程序间的交互和通信</span><br><span class="line">第10章  系统及I/O</span><br><span class="line">第11章  网络编程</span><br><span class="line">第12章  并发编程</span><br></pre></td></tr></table></figure>
<p>本书一共分为12章，第一章可以说是对全书的介绍，简单介绍了本书的所有内容。</p>
<p>剩下的十一章是本书的正式部分，我认为本书的核心在第 7~9 章，2~6章的内容可以说是为读者补充了前置知识，例如，第六章的内容就和第九章密切相关。而 10 ~ 12 章则主要以实践为主，第十章IO和第十一章网络编程，在介绍他们本来内容的同时，也是为在第十二章建立一个并发网络服务器构建基础。</p>
<h2 id="分章介绍"><a href="#分章介绍" class="headerlink" title="分章介绍"></a>分章介绍</h2><h3 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h3><blockquote>
<p>这一章读起来很抽象，特别是2.2 2.3 介绍原码和补码以及他们之间的互相转换，看的人头疼，第一次读的时候放弃了一次，第二次才一口气读完的。2.4 介绍浮点数表示，虽然也很抽象，但相比整数的部分，浮点数有趣很多，IEEE的表示方法真的很奇妙，它看起来很丝滑，随着表示位数的增加，能表示的最小数增加的很自然，有种“天选”，“本来就应该是这样子” 的感觉。</p>
</blockquote>
<p><strong>2.1.3 寻址和字节顺序</strong>： 介绍了在计算机硬件上存储字节的两种不同顺序：大端法和小段法。明白了这个，才能知道网络协议做了什么，他们将不同硬件上的字节顺序转换成了网络字节顺序，便于传输。</p>
<p><strong>2.16 布尔代数介绍</strong> ： 可以使用位向量来表示有限集合。</p>
<p><strong>2.2 整数表示</strong> ： 介绍了整数原码和补码的表示，以及他们之间的转换。</p>
<p><strong>2.3 整数运算</strong> ： 介绍了整数运算可能出现的错误，以及来源。</p>
<p><strong>2.4</strong> ：介绍了浮点数的IEEE表示方法，具体规则。以及使用IEEE浮点数运算可能导致的错误。</p>
<h3 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h3><blockquote>
<p>相比于上一章的枯燥，这一章可以说让我开眼了，介绍汇编语言的可能有点难懂，但绝不枯燥，更加深刻的理解了c语言。</p>
<p>这一章之前的内容是上个学期考试周之前看的，具体内容不如这一章记得清楚。</p>
<p>从这一张开始到最后，才是一口气看完的。</p>
</blockquote>
<p>3.2 ：介绍了程序从c语言到汇编语言的过程，介绍了<code>objdump</code> 的使用</p>
<p>3.4 3.5 3.6 3.7：介绍了x86-64的寄存器，以及汇编语言的指令，通过阅读这部分，你可以看懂汇编语言。从hello world 到函数递归的汇编语言都介绍的很详细。</p>
<p>3.9 ：介绍了异质的数据结构 结构体 联合 的存储方式，介绍了数据对齐的概念。</p>
<p>3.10.4 ：介绍了几种对抗缓冲区溢出攻击的方法</p>
<h3 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章 处理器体系结构"></a>第四章 处理器体系结构</h3><blockquote>
<p>这一章我看懂的部分不必我在计算机导论大作业里懂得更多，这一章确实抽象，我只看了一般就看不下去了，等我学完数字逻辑再来看吧。</p>
</blockquote>
<h3 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h3><blockquote>
<p>呃呃 感觉含金量不是很高，没啥看了之后让我感觉很厉害的东西。</p>
</blockquote>
<p>客观一点就是 普通人日常写代码小技巧</p>
<h3 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h3><blockquote>
<p>没留下很深刻的印象，只记得和虚拟内存那一章有关，等我再看一遍吧。</p>
</blockquote>
<h3 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h3><blockquote>
<p>含金量高的来了</p>
<p>这一章基本全都是“惊讶” ，学习c语言时都了解过，但不知道细节。读这一章就像揭开了一层面纱一样。</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>7.1 编译器驱动程序： 详细介绍了编译的过程： c预处理器cpp -&gt; 编译器ccl -&gt; 汇编器as -&gt; 链接器 ld</p>
<p>7.2 静态链接 ： 介绍了静态链接的流程：符号解析 重定位</p>
<p>7.3 7.4 7.5：介绍了讲静态链接的前置知识：目标文件、符号和符号表</p>
<p>7.6.2 ： 介绍了如何打包生成静态库以及与静态库链接</p>
<p>7.6.3 ：很重要！介绍了静态链接的细节，以及容易出错的地方</p>
<p>动态链接：与加载的时候链接的类型</p>
<p>库打桩机制</p>
<h3 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h3><blockquote>
<p>最重要的一章之一，介绍了并发编程的基础——异常控制流</p>
<p>介绍了进程，简单带领读者入门了并发编程</p>
<p>讲了信号，有助于以后学习事件驱动的GUI编程</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>8.2 异常</p>
<p>8.3 进程</p>
<p>8.4 用C语言操作进程：fork execve</p>
<p>8.5 信号  SIGINT … </p>
<h3 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h3><blockquote>
<p>最重要的一章之一</p>
<p>这一章基本全都是之前没学过的内容，以至于我只要把本章的目录简单偷过来，就是本章的重点</p>
</blockquote>
<p>本章可以分为三部分</p>
<p>第一部分介绍了虚拟内存的工作机制，在9.6 详细介绍了虚拟地址是如何被翻译成物理地址的</p>
<p>第二部分介绍了Linux上的虚拟内存，并在这个角度观察了上一章讲的 fork 和execve</p>
<p>第三部分介绍了一个内存分配器的实现( malloc() )</p>
<h3 id="第十章-系统级-I-O"><a href="#第十章-系统级-I-O" class="headerlink" title="第十章 系统级 I/O"></a>第十章 系统级 I/O</h3><blockquote>
<p>这一章读起来很简单，没有什么要理解的东西</p>
</blockquote>
<p>首先介绍了Linux的文件，即每个IO设备都被抽象成了文件，每个文件都有一个文件描述符，通过这个描述符 加上 操作文件的函数，可以对IO设备进行访。</p>
<p>然后着介绍了RIO包，即包装后的IO函数。</p>
<p>本章完</p>
<h3 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h3><blockquote>
<p>这一章需要理解的地方不多，只有介绍网络编程的部分</p>
<p>第二和第三部分，如果不好好实践一番，光靠眼睛看，是很难理解的。</p>
</blockquote>
<p>首先介绍了网络编程</p>
<p>接着介绍了Linux的套接字函数</p>
<p>最后实现了一个小web服务器</p>
<p>11.5.3 HTTP事务 介绍了在命令行的HTTP协议使用，有助于更深刻地理解HTTP协议</p>
<h3 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h3><blockquote>
<p>和上一章差不多的感觉</p>
</blockquote>
<p>本章也分为三部分</p>
<p>首先介绍了实现并发编程的三种方法</p>
<ol>
<li>进程</li>
<li>IO多路复用</li>
<li>线程</li>
</ol>
<p>之后 介绍了用信号量同步线程的方法，同时实现了一个并发服务器。</p>
<p>最后介绍了并发编程容易出现的问题：死锁、访问共享变量 … </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/default-index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span><a class="page-number" href="/default-index/page/3/">3</a><a class="extend next" rel="next" href="/default-index/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cfla</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cfla</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '04Cb1hKhS46C40AAoWX7DdEw-gzGzoHsz',
      appKey     : 'qp0Ojo0wkFhB7QKVLOS13J5m',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-Hans' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
